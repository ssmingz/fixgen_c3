[[{"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.6\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.6\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT\";\n}"}], [{"methodBefore": "private MaxCore(File storedResults) {\n    fHistory = MaxHistory.locallyStored(storedResults);\n}", "methodAfter": "private MaxCore(File storedResults) {\n    fHistory = MaxHistory.forFolder(storedResults);\n}"}, {"methodBefore": "private MaxCore(File storedResults) {\n    fHistory = MaxHistory.locallyStored(storedResults);\n}", "methodAfter": "private MaxCore(File storedResults) {\n    fHistory = MaxHistory.forFolder(storedResults);\n}"}], [{"methodBefore": "public AssumptionViolatedException(Object value, Matcher<?> matcher) {\n    this(null, true, value, matcher);\n}", "methodAfter": "@Deprecated\npublic AssumptionViolatedException(Object value, Matcher<?> matcher) {\n    this(null, true, value, matcher);\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}, {"methodBefore": "public AssumptionViolatedException(String assumption) {\n    this(assumption, false, null, null);\n}", "methodAfter": "@Deprecated\npublic AssumptionViolatedException(String assumption) {\n    this(assumption, false, null, null);\n}"}, {"methodBefore": "protected Description(final String displayName) {\n    fDisplayName = displayName;\n}", "methodAfter": "@Deprecated\nprotected Description(final String displayName) {\n    fDisplayName = displayName;\n}"}, {"methodBefore": "protected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}, {"methodBefore": "public void testRunStarted(Description description) throws Exception {\n}", "methodAfter": "@Deprecated\npublic void testRunStarted(Description description) throws Exception {\n}"}, {"methodBefore": "public void expectCause(Matcher<? extends Throwable> expectedCause) {\n    expect(hasCause(expectedCause));\n}", "methodAfter": "@Deprecated\npublic void expectCause(Matcher<? extends Throwable> expectedCause) {\n    expect(hasCause(expectedCause));\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}, {"methodBefore": "public void expect(Matcher<?> matcher) {\n    matcherBuilder.add(matcher);\n}", "methodAfter": "@Deprecated\npublic void expect(Matcher<?> matcher) {\n    matcherBuilder.add(matcher);\n}"}, {"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}"}, {"methodBefore": "public void expectMessage(Matcher<String> matcher) {\n    expect(hasMessage(matcher));\n}", "methodAfter": "@Deprecated\npublic void expectMessage(Matcher<String> matcher) {\n    expect(hasMessage(matcher));\n}"}, {"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}"}, {"methodBefore": "public AssumptionViolatedException(String assumption, Object value, Matcher<?> matcher) {\n    this(assumption, true, value, matcher);\n}", "methodAfter": "@Deprecated\npublic AssumptionViolatedException(String assumption, Object value, Matcher<?> matcher) {\n    this(assumption, true, value, matcher);\n}"}, {"methodBefore": "protected void validateInstanceMethods(List<Throwable> errors) {\n    validatePublicVoidNoArgMethods(After.class, false, errors);\n    validatePublicVoidNoArgMethods(Before.class, false, errors);\n    validateTestMethods(errors);\n    if (computeTestMethods().size() == 0) {\n        errors.add(new Exception(\"No runnable methods\"));\n    }\n}", "methodAfter": "@Deprecated\nprotected void validateInstanceMethods(List<Throwable> errors) {\n    validatePublicVoidNoArgMethods(After.class, false, errors);\n    validatePublicVoidNoArgMethods(Before.class, false, errors);\n    validateTestMethods(errors);\n    if (computeTestMethods().size() == 0) {\n        errors.add(new Exception(\"No runnable methods\"));\n    }\n}"}, {"methodBefore": "public static void assertEquals(double expected, double actual) {\n    assertEquals(null, expected, actual);\n}", "methodAfter": "@Deprecated\npublic static void assertEquals(double expected, double actual) {\n    assertEquals(null, expected, actual);\n}"}, {"methodBefore": "public static Request errorReport(Class<?> klass, Throwable cause) {\n    return runner(new ErrorReportingRunner(klass, cause));\n}", "methodAfter": "@Deprecated\npublic static Request errorReport(Class<?> klass, Throwable cause) {\n    return runner(new ErrorReportingRunner(klass, cause));\n}"}, {"methodBefore": "public ArrayList<Description> getChildren() {\n    return fChildren;\n}", "methodAfter": "@Deprecated\npublic ArrayList<Description> getChildren() {\n    return fChildren;\n}"}, {"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}"}, {"methodBefore": "public static void assertEquals(String message, double expected, double actual) {\n    fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n}", "methodAfter": "@Deprecated\npublic static void assertEquals(String message, double expected, double actual) {\n    fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n}"}, {"methodBefore": "protected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}"}, {"methodBefore": "protected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}"}, {"methodBefore": "protected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}"}], [{"methodBefore": "public void success() {\n}", "methodAfter": "public void runTest() {\n}"}, {"methodBefore": "public void success() {\n}", "methodAfter": "public void runTest() {\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory();\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec(FilterFactoryFactoryTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec(FilterFactoryFactoryTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFilter() throws Exception {\n    FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory();\n    Filter filter = filterFactoryFactory.createFilter(FilterFactoryFactoryTest.FilterFactoryStub.class, new NoFilterFactoryParams());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilter() throws Exception {\n    Filter filter = filterFactoryFactory.createFilter(FilterFactoryFactoryTest.FilterFactoryStub.class, new NoFilterFactoryParams());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFilterWithArguments() throws Exception {\n    FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory();\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec((ExcludeCategories.class.getName() + \"=\") + FilterFactoryFactoryTest.DummyCategory.class.getName());\n    assertThat(filter.describe(), startsWith(\"excludes \"));\n}", "methodAfter": "@Test\npublic void shouldCreateFilterWithArguments() throws Exception {\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec((ExcludeCategories.class.getName() + \"=\") + FilterFactoryFactoryTest.DummyCategory.class.getName());\n    assertThat(filter.describe(), startsWith(\"excludes \"));\n}"}], [{"methodBefore": "@Test\npublic void one() {\n    fExample1One = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1One = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void one() {\n    fExample1One = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1One = Thread.currentThread();\n}"}], [{"methodBefore": "public Result run(Request request, JUnitCore core) {\n    core.addListener(new RememberingListener());\n    try {\n        return core.run(sortRequest(request).getRunner());\n    } finally {\n        try {\n            save();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "public Result run(Request request, JUnitCore core) {\n    core.addListener(fHistory.listener());\n    try {\n        return core.run(sortRequest(request).getRunner());\n    } finally {\n        try {\n            fHistory.save();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "public Result run(Request request, JUnitCore core) {\n    core.addListener(new RememberingListener());\n    try {\n        return core.run(sortRequest(request).getRunner());\n    } finally {\n        try {\n            save();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "public Result run(Request request, JUnitCore core) {\n    core.addListener(fHistory.listener());\n    try {\n        return core.run(sortRequest(request).getRunner());\n    } finally {\n        try {\n            fHistory.save();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "@Override\npublic Description getDescription() {\n    return new EmptyDescription();\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    return Description.EMPTY;\n}"}, {"methodBefore": "@Override\npublic Description getDescription() {\n    return new EmptyDescription();\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    return Description.EMPTY;\n}"}, {"methodBefore": "@Override\npublic Description getDescription() {\n    return new EmptyDescription();\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    return Description.EMPTY;\n}"}], [{"methodBefore": "@Override\npublic void runChild(final T child, final RunNotifier notifier) {\n    fResults.add(fService.submit(new Callable<Object>() {\n        public Object call() throws Exception {\n            fDelegate.internalRunChild(child, notifier);\n            return null;\n        }\n    }));\n}", "methodAfter": "public void runChild(final SafeStatement statement) {\n    fResults.add(fService.submit(new Callable<Object>() {\n        public Object call() throws Exception {\n            statement.execute();\n            return null;\n        }\n    }));\n}"}, {"methodBefore": "@Override\npublic void runChild(final T child, final RunNotifier notifier) {\n    fResults.add(fService.submit(new Callable<Object>() {\n        public Object call() throws Exception {\n            fDelegate.internalRunChild(child, notifier);\n            return null;\n        }\n    }));\n}", "methodAfter": "public void runChild(final SafeStatement statement) {\n    fResults.add(fService.submit(new Callable<Object>() {\n        public Object call() throws Exception {\n            statement.execute();\n            return null;\n        }\n    }));\n}"}], [{"methodBefore": "public void sort(Sorter sorter) {\n    synchronized(fLock) {\n        for (T each : getFilteredChildren()) {\n            sorter.apply(each);\n        }\n        List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n        Collections.sort(sortedChildren, comparator(sorter));\n        fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n    }\n}", "methodAfter": "public void sort(Sorter sorter) {\n    synchronized(fChildrenLock) {\n        for (T each : getFilteredChildren()) {\n            sorter.apply(each);\n        }\n        List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());\n        Collections.sort(sortedChildren, comparator(sorter));\n        fFilteredChildren = Collections.unmodifiableCollection(sortedChildren);\n    }\n}"}, {"methodBefore": "private Collection<T> getFilteredChildren() {\n    if (fFilteredChildren == null) {\n        synchronized(fLock) {\n            if (fFilteredChildren == null) {\n                fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n            }\n        }\n    }\n    return fFilteredChildren;\n}", "methodAfter": "private Collection<T> getFilteredChildren() {\n    if (fFilteredChildren == null) {\n        synchronized(fChildrenLock) {\n            if (fFilteredChildren == null) {\n                fFilteredChildren = Collections.unmodifiableCollection(getChildren());\n            }\n        }\n    }\n    return fFilteredChildren;\n}"}], [{"methodBefore": "private String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}", "methodAfter": "private String parseMethod() {\n    Matcher matcher = methodStringMatcher();\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}"}, {"methodBefore": "private String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}", "methodAfter": "private String parseMethod() {\n    Matcher matcher = methodStringMatcher();\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}"}], [{"methodBefore": "protected Statement classBlock(final RunNotifier notifier) {\n    Statement statement = childrenInvoker(notifier);\n    statement = withBeforeClasses(statement);\n    statement = withAfterClasses(statement);\n    return statement;\n}", "methodAfter": "protected Statement classBlock(final RunNotifier notifier) {\n    Statement statement = childrenInvoker(notifier);\n    statement = withBeforeClasses(statement);\n    statement = withAfterClasses(statement);\n    statement = withClassRules(statement);\n    return statement;\n}"}, {"methodBefore": "protected Statement classBlock(final RunNotifier notifier) {\n    Statement statement = childrenInvoker(notifier);\n    statement = withBeforeClasses(statement);\n    statement = withAfterClasses(statement);\n    return statement;\n}", "methodAfter": "protected Statement classBlock(final RunNotifier notifier) {\n    Statement statement = childrenInvoker(notifier);\n    statement = withBeforeClasses(statement);\n    statement = withAfterClasses(statement);\n    statement = withClassRules(statement);\n    return statement;\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}"}], [{"methodBefore": "public ArrayList<Description> getChildren() {\n    return fChildren;\n}", "methodAfter": "@Deprecated\npublic ArrayList<Description> getChildren() {\n    return fChildren;\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}], [{"methodBefore": "public void testMoneyBagEquals() {\n    assertTrue(!fMB1.equals(null));\n    assertEquals(fMB1, fMB1);\n    MoneyBag equal = new MoneyBag(new Money(12, \"CHF\"), new Money(7, \"USD\"));\n    assertTrue(fMB1.equals(equal));\n    assertTrue(!fMB1.equals(f12CHF));\n    assertTrue(!f12CHF.equals(fMB1));\n    assertTrue(!fMB1.equals(fMB2));\n}", "methodAfter": "public void testMoneyBagEquals() {\n    assertTrue(!fMB1.equals(null));\n    assertEquals(fMB1, fMB1);\n    IMoney equal = MoneyBag.create(new Money(12, \"CHF\"), new Money(7, \"USD\"));\n    assertTrue(fMB1.equals(equal));\n    assertTrue(!fMB1.equals(f12CHF));\n    assertTrue(!f12CHF.equals(fMB1));\n    assertTrue(!fMB1.equals(fMB2));\n}"}, {"methodBefore": "public void testMoneyBagHash() {\n    MoneyBag equal = new MoneyBag(new Money(12, \"CHF\"), new Money(7, \"USD\"));\n    assertEquals(fMB1.hashCode(), equal.hashCode());\n}", "methodAfter": "public void testMoneyBagHash() {\n    IMoney equal = MoneyBag.create(new Money(12, \"CHF\"), new Money(7, \"USD\"));\n    assertEquals(fMB1.hashCode(), equal.hashCode());\n}"}], [{"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}], [{"methodBefore": "public synchronized void runSuite() {\n    if (fRunner != null) {\n        fTestResult.stop();\n    } else {\n        if (!setUseLoadingRunner()) {\n            return;\n        }\n        reset();\n        showInfo(\"Load Test Case...\");\n        final String suiteName = getSuiteText();\n        final Test testSuite = getTest(suiteName);\n        if (testSuite != null) {\n            addToHistory(suiteName);\n            doRunTest(testSuite);\n        }\n    }\n}", "methodAfter": "public synchronized void runSuite() {\n    if (fRunner != null) {\n        fTestResult.stop();\n    } else {\n        setLoading(shouldReload());\n        reset();\n        showInfo(\"Load Test Case...\");\n        final String suiteName = getSuiteText();\n        final Test testSuite = getTest(suiteName);\n        if (testSuite != null) {\n            addToHistory(suiteName);\n            doRunTest(testSuite);\n        }\n    }\n}"}, {"methodBefore": "public synchronized void runSuite() {\n    if (fRunner != null) {\n        fTestResult.stop();\n    } else {\n        if (!setUseLoadingRunner()) {\n            return;\n        }\n        fRun.setLabel(\"Stop\");\n        showInfo(\"Initializing...\");\n        reset();\n        showInfo(\"Load Test Case...\");\n        final Test testSuite = getTest(fSuiteField.getText());\n        if (testSuite != null) {\n            fRunner = new Thread() {\n                public void run() {\n                    fTestResult = createTestResult();\n                    fTestResult.addListener(TestRunner.this);\n                    fProgressIndicator.start(testSuite.countTestCases());\n                    showInfo(\"Running...\");\n                    long startTime = System.currentTimeMillis();\n                    testSuite.run(fTestResult);\n                    if (fTestResult.shouldStop()) {\n                        showStatus(\"Stopped\");\n                    } else {\n                        long endTime = System.currentTimeMillis();\n                        long runTime = endTime - startTime;\n                        showInfo((\"Finished: \" + elapsedTimeAsString(runTime)) + \" seconds\");\n                    }\n                    fTestResult = null;\n                    fRun.setLabel(\"Run\");\n                    fRunner = null;\n                    System.gc();\n                }\n            };\n            fRunner.start();\n        }\n    }\n}", "methodAfter": "public synchronized void runSuite() {\n    if (fRunner != null) {\n        fTestResult.stop();\n    } else {\n        setLoading(shouldReload());\n        fRun.setLabel(\"Stop\");\n        showInfo(\"Initializing...\");\n        reset();\n        showInfo(\"Load Test Case...\");\n        final Test testSuite = getTest(fSuiteField.getText());\n        if (testSuite != null) {\n            fRunner = new Thread() {\n                public void run() {\n                    fTestResult = createTestResult();\n                    fTestResult.addListener(TestRunner.this);\n                    fProgressIndicator.start(testSuite.countTestCases());\n                    showInfo(\"Running...\");\n                    long startTime = System.currentTimeMillis();\n                    testSuite.run(fTestResult);\n                    if (fTestResult.shouldStop()) {\n                        showStatus(\"Stopped\");\n                    } else {\n                        long endTime = System.currentTimeMillis();\n                        long runTime = endTime - startTime;\n                        showInfo((\"Finished: \" + elapsedTimeAsString(runTime)) + \" seconds\");\n                    }\n                    fTestResult = null;\n                    fRun.setLabel(\"Run\");\n                    fRunner = null;\n                    System.gc();\n                }\n            };\n            fRunner.start();\n        }\n    }\n}"}], [{"methodBefore": "@Test\npublic void bothPasses() {\n    assertThat(3, both(is(Integer.class)).and(is(3)));\n}", "methodAfter": "@Test\npublic void bothPasses() {\n    assertThat(3, both(isA(Integer.class)).and(is(3)));\n}"}, {"methodBefore": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(is(Integer.class)).and(is(3)));\n}", "methodAfter": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(isA(Integer.class)).and(is(3)));\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090504-1327\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090428-1600\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090504-1327\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090428-1600\";\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090428-1600\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090507-1339\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090428-1600\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090507-1339\";\n}"}], [{"methodBefore": "public void testAssertPosInfinityNotEquals() {\n    try {\n        assertEquals(Double.POSITIVE_INFINITY, 1.23, 0.0);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertPosInfinityNotEquals() {\n    try {\n        assertEquals(Double.POSITIVE_INFINITY, 1.23, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertPosInfinityNotEqualsNegInfinity() {\n    try {\n        assertEquals(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0.0);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertPosInfinityNotEqualsNegInfinity() {\n    try {\n        assertEquals(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}], [{"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<T> iter = getCachedChildren().iterator(); iter.hasNext();) {\n        T each = iter.next();\n        if (!filter.shouldRun(describeChild(each))) {\n            iter.remove();\n        } else {\n            try {\n                filter.apply(each);\n            } catch (NoTestsRemainException e) {\n                iter.remove();\n            }\n        }\n    }\n    fDescription = null;\n    if (getCachedChildren().isEmpty()) {\n        throw new NoTestsRemainException();\n    }\n}", "methodAfter": "public void filter(Filter filter) throws NoTestsRemainException {\n    fFilter = filter;\n    for (T each : getChildren()) {\n        if (shouldRun(each)) {\n            return;\n        }\n    }\n    throw new NoTestsRemainException();\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<T> iter = getCachedChildren().iterator(); iter.hasNext();) {\n        T each = iter.next();\n        if (!filter.shouldRun(describeChild(each))) {\n            iter.remove();\n        } else {\n            try {\n                filter.apply(each);\n            } catch (NoTestsRemainException e) {\n                iter.remove();\n            }\n        }\n    }\n    fDescription = null;\n    if (getCachedChildren().isEmpty()) {\n        throw new NoTestsRemainException();\n    }\n}", "methodAfter": "public void filter(Filter filter) throws NoTestsRemainException {\n    fFilter = filter;\n    for (T each : getChildren()) {\n        if (shouldRun(each)) {\n            return;\n        }\n    }\n    throw new NoTestsRemainException();\n}"}], [{"methodBefore": "public Statement apply(Statement base, Description description) {\n    return statement(base);\n}", "methodAfter": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return statement(base);\n}"}, {"methodBefore": "public Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}", "methodAfter": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}"}, {"methodBefore": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}"}, {"methodBefore": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}, {"methodBefore": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "private void runChild(Runner each, final RunNotifier notifier) {\n    each.run(notifier);\n}", "methodAfter": "@Override\nprotected void runChild(Runner each, final RunNotifier notifier) {\n    each.run(notifier);\n}"}, {"methodBefore": "public Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}", "methodAfter": "@Override\nprotected Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}"}, {"methodBefore": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "@Test\npublic void categoriesOnSuiteTrickleDown() {\n    assertThat(testResult(CategoryTest.ParentSuite.class), isSuccessful());\n    Result result = new JUnitCore().run(CategoryTest.ParentSuite.class);\n    assertEquals(1, result.getRunCount());\n    assertEquals(0, result.getFailureCount());\n}", "methodAfter": "@Ignore\n@Test\npublic void categoriesOnSuiteTrickleDown() {\n    assertThat(testResult(CategoryTest.ParentSuite.class), isSuccessful());\n    Result result = new JUnitCore().run(CategoryTest.ParentSuite.class);\n    assertEquals(1, result.getRunCount());\n    assertEquals(0, result.getFailureCount());\n}"}, {"methodBefore": "@Theory\npublic void showFailedAssumptionsWhenNoParametersFound(int data, Matcher<Integer> matcher) throws Exception {\n    assumeThat(data, not(matcher));\n    AssumptionsFail.DATA = data;\n    AssumptionsFail.MATCHER = matcher;\n    String result = testResult(WhenNoParametersMatch.AssumptionsFail.class).toString();\n    assertThat(result, containsString(matcher.toString()));\n    assertThat(result, containsString(\"\" + data));\n    assertThat(result, containsString(\"invalid assumption:\"));\n}", "methodAfter": "@Ignore\n@Theory\npublic void showFailedAssumptionsWhenNoParametersFound(int data, Matcher<Integer> matcher) throws Exception {\n    assumeThat(data, not(matcher));\n    AssumptionsFail.DATA = data;\n    AssumptionsFail.MATCHER = matcher;\n    String result = testResult(WhenNoParametersMatch.AssumptionsFail.class).toString();\n    assertThat(result, containsString(matcher.toString()));\n    assertThat(result, containsString(\"\" + data));\n    assertThat(result, containsString(\"invalid assumption:\"));\n}"}], [{"methodBefore": "@After\npublic void forgetMax() {\n    fMax.fHistory.forget();\n}", "methodAfter": "@After\npublic void forgetMax() {\n    fMaxFile.delete();\n}"}, {"methodBefore": "@After\npublic void forgetMax() {\n    fMax.fHistory.forget();\n}", "methodAfter": "@After\npublic void forgetMax() {\n    fMaxFile.delete();\n}"}], [{"methodBefore": "@After\npublic void forgetMax() {\n    fMax.forget();\n}", "methodAfter": "@After\npublic void forgetMax() {\n    MaxHistory history = fMax.fHistory;\n    history.forget();\n}"}, {"methodBefore": "@After\npublic void forgetMax() {\n    fMax.forget();\n}", "methodAfter": "@After\npublic void forgetMax() {\n    MaxHistory history = fMax.fHistory;\n    history.forget();\n}"}], [{"methodBefore": "public JUnit4TestAdapter(final Class<?> newTestClass, JUnit4TestAdapterCache cache) {\n    fCache = cache;\n    fNewTestClass = newTestClass;\n    fRunner = Request.classWithoutSuiteMethod(newTestClass).filterWith(removeIgnored()).getRunner();\n}", "methodAfter": "public JUnit4TestAdapter(final Class<?> newTestClass, JUnit4TestAdapterCache cache) {\n    fCache = cache;\n    fNewTestClass = newTestClass;\n    fRunner = Request.classWithoutSuiteMethod(newTestClass).getRunner();\n}"}, {"methodBefore": "public JUnit4TestAdapter(final Class<?> newTestClass, JUnit4TestAdapterCache cache) {\n    fCache = cache;\n    fNewTestClass = newTestClass;\n    fRunner = Request.classWithoutSuiteMethod(newTestClass).filterWith(removeIgnored()).getRunner();\n}", "methodAfter": "public JUnit4TestAdapter(final Class<?> newTestClass, JUnit4TestAdapterCache cache) {\n    fCache = cache;\n    fNewTestClass = newTestClass;\n    fRunner = Request.classWithoutSuiteMethod(newTestClass).getRunner();\n}"}], [{"methodBefore": "@Test\npublic void preferNewTestsOverTestsThatFailed() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    MaxCore max = MaxCore.createFresh();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sort(two);\n    Description succeed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"succeed\");\n    assertEquals(succeed, things.get(0));\n    assertEquals(2, things.size());\n}", "methodAfter": "@Test\npublic void preferNewTestsOverTestsThatFailed() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    MaxCore max = MaxCore.createFresh();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sortedLeavesForTest(two);\n    Description succeed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"succeed\");\n    assertEquals(succeed, things.get(0));\n    assertEquals(2, things.size());\n}"}, {"methodBefore": "@Test\npublic void preferNewTests() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"succeed\");\n    MaxCore max = MaxCore.createFresh();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sort(two);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, things.get(0));\n    assertEquals(2, things.size());\n}", "methodAfter": "@Test\npublic void preferNewTests() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"succeed\");\n    MaxCore max = MaxCore.createFresh();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sortedLeavesForTest(two);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, things.get(0));\n    assertEquals(2, things.size());\n}"}], [{"methodBefore": "public boolean isShadowedBy(FrameworkField otherMember) {\n    return false;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkField otherMember) {\n    return otherMember.getField().getName().equals(getField().getName());\n}"}, {"methodBefore": "public boolean isShadowedBy(FrameworkField otherMember) {\n    return false;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkField otherMember) {\n    return otherMember.getField().getName().equals(getField().getName());\n}"}], [{"methodBefore": "protected List<MethodRule> rules(Object test) {\n    List<MethodRule> results = new ArrayList<MethodRule>();\n    for (FrameworkField each : ruleFields()) {\n        results.add(createRule(test, each));\n    }\n    return results;\n}", "methodAfter": "protected List<MethodRule> rules(Object test) {\n    List<MethodRule> results = new ArrayList<MethodRule>();\n    for (FrameworkField each : ruleFields()) {\n        if (MethodRule.class.isAssignableFrom(each.getField().getType())) {\n            results.add(createRule(test, each));\n        }\n    }\n    return results;\n}"}, {"methodBefore": "protected List<MethodRule> rules(Object test) {\n    List<MethodRule> results = new ArrayList<MethodRule>();\n    for (FrameworkField each : ruleFields()) {\n        results.add(createRule(test, each));\n    }\n    return results;\n}", "methodAfter": "protected List<MethodRule> rules(Object test) {\n    List<MethodRule> results = new ArrayList<MethodRule>();\n    for (FrameworkField each : ruleFields()) {\n        if (MethodRule.class.isAssignableFrom(each.getField().getType())) {\n            results.add(createRule(test, each));\n        }\n    }\n    return results;\n}"}], [{"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getDescription(), results);\n    return results;\n}"}], [{"methodBefore": "public Statement intercept(Statement base, FrameworkMethod method, Object target) {\n    return new ExpectedExceptionStatement(base);\n}", "methodAfter": "public Statement apply(Statement base, FrameworkMethod method, Object target) {\n    return new ExpectedExceptionStatement(base);\n}"}, {"methodBefore": "public Statement intercept(Statement base, FrameworkMethod method, Object target) {\n    return new ExpectedExceptionStatement(base);\n}", "methodAfter": "public Statement apply(Statement base, FrameworkMethod method, Object target) {\n    return new ExpectedExceptionStatement(base);\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.6-RC1\";\n}", "methodAfter": "public static String id() {\n    return \"4.6\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.6-RC1\";\n}", "methodAfter": "public static String id() {\n    return \"4.6\";\n}"}], [{"methodBefore": "public String trace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    thrownException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}", "methodAfter": "public String trace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    thrownException().printStackTrace(writer);\n    return stringWriter.toString();\n}"}, {"methodBefore": "public String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}", "methodAfter": "public String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    return stringWriter.toString();\n}"}], [{"methodBefore": "@Parameters\npublic static Collection<Object[]> getParameters() {\n    return Collections.singletonList(new Object[]{ \"a\" });\n}", "methodAfter": "@Parameters\npublic static Iterable<String> getParameters() {\n    return Arrays.asList(\"first\", \"second\");\n}"}, {"methodBefore": "@Parameters\npublic static Collection<Object[]> getParameters() {\n    return Collections.singletonList(new Object[]{ \"a\" });\n}", "methodAfter": "@Parameters\npublic static Iterable<String> getParameters() {\n    return Arrays.asList(\"first\", \"second\");\n}"}, {"methodBefore": "@Parameters\npublic static Collection<Object[]> getParameters() {\n    return Collections.singletonList(new Object[]{ \"a\" });\n}", "methodAfter": "@Parameters\npublic static Iterable<String> getParameters() {\n    return Arrays.asList(\"first\", \"second\");\n}"}], [{"methodBefore": "@Test\npublic void fieldsOnSubclassesShadowSuperclasses() {\n    assertThat(new TestClass(TestClassTest.SubclassWithField.class).getAnnotatedFields(Interceptor.class).size(), is(1));\n}", "methodAfter": "@Test\npublic void fieldsOnSubclassesShadowSuperclasses() {\n    assertThat(new TestClass(TestClassTest.SubclassWithField.class).getAnnotatedFields(Rule.class).size(), is(1));\n}"}, {"methodBefore": "@Test\npublic void fieldsOnSubclassesShadowSuperclasses() {\n    assertThat(new TestClass(TestClassTest.SubclassWithField.class).getAnnotatedFields(Interceptor.class).size(), is(1));\n}", "methodAfter": "@Test\npublic void fieldsOnSubclassesShadowSuperclasses() {\n    assertThat(new TestClass(TestClassTest.SubclassWithField.class).getAnnotatedFields(Rule.class).size(), is(1));\n}"}], [{"methodBefore": "public void testExceptionTest() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assert result.wasSuccessful();\n}", "methodAfter": "public void testExceptionTest() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assertTrue(result.wasSuccessful());\n}"}, {"methodBefore": "public void testExceptionSubclass() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assert result.wasSuccessful();\n}", "methodAfter": "public void testExceptionSubclass() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assertTrue(result.wasSuccessful());\n}"}], [{"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "@Override\npublic void run(final RunNotifier notifier) {\n    new ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {\n        public void run() {\n            runChildren(notifier);\n        }\n    }).runProtected();\n}", "methodAfter": "@Override\npublic void run(final RunNotifier notifier) {\n    fTestClass.runProtected(notifier, getDescription(), new Runnable() {\n        public void run() {\n            runChildren(notifier);\n        }\n    });\n}"}, {"methodBefore": "@Override\npublic void run(final RunNotifier notifier) {\n    new ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {\n        public void run() {\n            runChildren(notifier);\n        }\n    }).runProtected();\n}", "methodAfter": "@Override\npublic void run(final RunNotifier notifier) {\n    fTestClass.runProtected(notifier, getDescription(), new Runnable() {\n        public void run() {\n            runChildren(notifier);\n        }\n    });\n}"}, {"methodBefore": "@Override\npublic void run(final RunNotifier notifier) {\n    new ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {\n        public void run() {\n            runMethods(notifier);\n        }\n    }).runProtected();\n}", "methodAfter": "@Override\npublic void run(final RunNotifier notifier) {\n    fTestClass.runProtected(notifier, getDescription(), new Runnable() {\n        public void run() {\n            runMethods(notifier);\n        }\n    });\n}"}], [{"methodBefore": "@Override\npublic void run(final Roadie context) {\n    context.runProtected(this, new Runnable() {\n        public void run() {\n            try {\n                fNext.run(context);\n            } catch (Throwable e) {\n                context.addFailure(e);\n            }\n        }\n    });\n}", "methodAfter": "@Override\npublic void run(final Roadie context) throws Throwable {\n    try {\n        if (context.runBefores(this)) {\n            fNext.run(context);\n        }\n    } finally {\n        context.runAfters(this);\n    }\n}"}, {"methodBefore": "@Override\npublic void run(final Roadie context) {\n    context.runProtected(this, new Runnable() {\n        public void run() {\n            try {\n                fNext.run(context);\n            } catch (Throwable e) {\n                context.addFailure(e);\n            }\n        }\n    });\n}", "methodAfter": "@Override\npublic void run(final Roadie context) throws Throwable {\n    try {\n        if (context.runBefores(this)) {\n            fNext.run(context);\n        }\n    } finally {\n        context.runAfters(this);\n    }\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090507-1339\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090511-2347\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090507-1339\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090511-2347\";\n}"}], [{"methodBefore": "public void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}"}, {"methodBefore": "protected void setUp() {\n    fResult = new TestResult();\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fResult = new TestResult();\n}"}], [{"methodBefore": "@Test\npublic void nullMessageDisappearsWithStringAssertEquals() {\n    try {\n        assertEquals(null, \"a\", \"b\");\n    } catch (ComparisonFailure e) {\n        assertEquals(\"expected:<[a]> but was:<[b]>\", e.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void nullMessageDisappearsWithStringAssertEquals() {\n    try {\n        assertEquals(null, \"a\", \"b\");\n        fail();\n    } catch (ComparisonFailure e) {\n        assertEquals(\"expected:<[a]> but was:<[b]>\", e.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void sameNullMessage() {\n    try {\n        assertSame(\"hello\", \"good-bye\");\n    } catch (AssertionError exception) {\n        assertEquals(\"expected same:<hello> was not:<good-bye>\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void sameNullMessage() {\n    try {\n        assertSame(\"hello\", \"good-bye\");\n        fail();\n    } catch (AssertionError exception) {\n        assertEquals(\"expected same:<hello> was not:<good-bye>\", exception.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void sameWithMessage() {\n    try {\n        assertSame(\"not same\", \"hello\", \"good-bye\");\n    } catch (AssertionError exception) {\n        assertEquals(\"not same expected same:<hello> was not:<good-bye>\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void sameWithMessage() {\n    try {\n        assertSame(\"not same\", \"hello\", \"good-bye\");\n        fail();\n    } catch (AssertionError exception) {\n        assertEquals(\"not same expected same:<hello> was not:<good-bye>\", exception.getMessage());\n    }\n}"}], [{"methodBefore": "@Override\nprotected void assertElementsEqual(Object expected, Object actual) {\n    if (expected instanceof Double) {\n        Assert.assertEquals(((Double) (expected)), ((Double) (actual)), fDelta);\n    } else {\n        Assert.assertEquals(((Float) (expected)), ((Float) (actual)), fDelta);\n    }\n}", "methodAfter": "@Override\nprotected void assertElementsEqual(Object expected, Object actual) {\n    if (expected instanceof Double) {\n        Assert.assertEquals(((Double) (expected)), ((Double) (actual)), ((Double) (fDelta)));\n    } else {\n        Assert.assertEquals(((Float) (expected)), ((Float) (actual)), ((Float) (fDelta)));\n    }\n}"}, {"methodBefore": "@Override\nprotected void assertElementsEqual(Object expected, Object actual) {\n    if (expected instanceof Double) {\n        Assert.assertEquals(((Double) (expected)), ((Double) (actual)), fDelta);\n    } else {\n        Assert.assertEquals(((Float) (expected)), ((Float) (actual)), fDelta);\n    }\n}", "methodAfter": "@Override\nprotected void assertElementsEqual(Object expected, Object actual) {\n    if (expected instanceof Double) {\n        Assert.assertEquals(((Double) (expected)), ((Double) (actual)), ((Double) (fDelta)));\n    } else {\n        Assert.assertEquals(((Float) (expected)), ((Float) (actual)), ((Float) (fDelta)));\n    }\n}"}], [{"methodBefore": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    Description description = Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n    description.setParent(getDescription());\n    return description;\n}", "methodAfter": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n}"}, {"methodBefore": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    Description description = Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n    description.setParent(getDescription());\n    return description;\n}", "methodAfter": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n}"}, {"methodBefore": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n}", "methodAfter": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    Description description = Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n    description.setParent(getDescription());\n    return description;\n}"}], [{"methodBefore": "public int countTestCases() {\n    return super.countTestCases() * fTimesRepeat;\n}", "methodAfter": "@Override\npublic int countTestCases() {\n    return super.countTestCases() * fTimesRepeat;\n}"}, {"methodBefore": "public void run(TestResult result) {\n    fActiveTestDeathCount = 0;\n    super.run(result);\n    waitUntilFinished();\n}", "methodAfter": "@Override\npublic void run(TestResult result) {\n    fActiveTestDeathCount = 0;\n    super.run(result);\n    waitUntilFinished();\n}"}], [{"methodBefore": "public void testOneTestCase() {\n    Test t = new TestSuite(OneTestCase.class);\n    t.run(fResult);\n    assertTrue(fResult.runCount() == 1);\n    assertTrue(fResult.failureCount() == 0);\n    assertTrue(fResult.errorCount() == 0);\n    assertTrue(fResult.wasSuccessful());\n}", "methodAfter": "public void testOneTestCase() {\n    TestSuite t = new TestSuite(OneTestCase.class);\n    t.run(fResult);\n    assertTrue(fResult.runCount() == 1);\n    assertTrue(fResult.failureCount() == 0);\n    assertTrue(fResult.errorCount() == 0);\n    assertTrue(fResult.wasSuccessful());\n}"}, {"methodBefore": "public void testOneTestCase() {\n    Test t = new TestSuite(OneTestCase.class);\n    t.run(fResult);\n    assertTrue(fResult.runCount() == 1);\n    assertTrue(fResult.failureCount() == 0);\n    assertTrue(fResult.errorCount() == 0);\n    assertTrue(fResult.wasSuccessful());\n}", "methodAfter": "public void testOneTestCase() {\n    TestSuite t = new TestSuite(OneTestCase.class);\n    t.run(fResult);\n    assertTrue(fResult.runCount() == 1);\n    assertTrue(fResult.failureCount() == 0);\n    assertTrue(fResult.errorCount() == 0);\n    assertTrue(fResult.wasSuccessful());\n}"}, {"methodBefore": "public void testOneTestCase() {\n    Test t = new TestSuite(OneTestCase.class);\n    t.run(fResult);\n    assertTrue(fResult.runCount() == 1);\n    assertTrue(fResult.failureCount() == 0);\n    assertTrue(fResult.errorCount() == 0);\n    assertTrue(fResult.wasSuccessful());\n}", "methodAfter": "public void testOneTestCase() {\n    TestSuite t = new TestSuite(OneTestCase.class);\n    t.run(fResult);\n    assertTrue(fResult.runCount() == 1);\n    assertTrue(fResult.failureCount() == 0);\n    assertTrue(fResult.errorCount() == 0);\n    assertTrue(fResult.wasSuccessful());\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090527-0039\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090529-1159\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090527-0039\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090529-1159\";\n}"}], [{"methodBefore": "@Test\npublic void categoryFilterRejectsIncompatibleCategory() throws InitializationError, NoTestsRemainException {\n    CategoryFilter filter = CategoryFilter.include(CategoryTest.SlowTests.class);\n    BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner(CategoryTest.AllFastTests.class);\n    filter.apply(runner);\n    assertEquals(1, runner.testCount());\n}", "methodAfter": "@Test\npublic void categoryFilterRejectsIncompatibleCategory() throws InitializationError, NoTestsRemainException {\n    CategoryFilter filter = CategoryFilter.include(CategoryTest.SlowTests.class);\n    BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner(CategoryTest.OneFastOneSlow.class);\n    filter.apply(runner);\n    assertEquals(1, runner.testCount());\n}"}, {"methodBefore": "@Test\npublic void categoryFilterRejectsIncompatibleCategory() throws InitializationError, NoTestsRemainException {\n    CategoryFilter filter = CategoryFilter.include(CategoryTest.SlowTests.class);\n    BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner(CategoryTest.AllFastTests.class);\n    filter.apply(runner);\n    assertEquals(1, runner.testCount());\n}", "methodAfter": "@Test\npublic void categoryFilterRejectsIncompatibleCategory() throws InitializationError, NoTestsRemainException {\n    CategoryFilter filter = CategoryFilter.include(CategoryTest.SlowTests.class);\n    BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner(CategoryTest.OneFastOneSlow.class);\n    filter.apply(runner);\n    assertEquals(1, runner.testCount());\n}"}], [{"methodBefore": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : eachClass.getDeclaredMethods()) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod));\n        }\n    }\n}", "methodAfter": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : eachClass.getDeclaredMethods()) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod), fMethodsForAnnotations);\n        }\n        for (Field eachField : eachClass.getDeclaredFields()) {\n            addToAnnotationLists(new FrameworkField(eachField), fFieldsForAnnotations);\n        }\n    }\n}"}, {"methodBefore": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : eachClass.getDeclaredMethods()) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod));\n        }\n    }\n}", "methodAfter": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : eachClass.getDeclaredMethods()) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod), fMethodsForAnnotations);\n        }\n        for (Field eachField : eachClass.getDeclaredFields()) {\n            addToAnnotationLists(new FrameworkField(eachField), fFieldsForAnnotations);\n        }\n    }\n}"}], [{"methodBefore": "@Test\npublic void ignoreRunner() {\n    JUnitCore runner = new JUnitCore();\n    Result result = runner.run(TestMethodTest.IgnoredTest.class);\n    assertEquals(2, result.getIgnoreCount());\n}", "methodAfter": "@Test\npublic void ignoreRunner() {\n    JUnitCore runner = new JUnitCore();\n    Result result = runner.run(TestMethodTest.IgnoredTest.class);\n    assertEquals(2, result.getIgnoreCount());\n    assertEquals(1, result.getRunCount());\n}"}, {"methodBefore": "@Test\npublic void ignoreRunner() {\n    JUnitCore runner = new JUnitCore();\n    Result result = runner.run(TestMethodTest.IgnoredTest.class);\n    assertEquals(2, result.getIgnoreCount());\n}", "methodAfter": "@Test\npublic void ignoreRunner() {\n    JUnitCore runner = new JUnitCore();\n    Result result = runner.run(TestMethodTest.IgnoredTest.class);\n    assertEquals(2, result.getIgnoreCount());\n    assertEquals(1, result.getRunCount());\n}"}, {"methodBefore": "@Test\npublic void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(CategoryTest.SlowTests.class);\n    Request baseRequest = Request.aClass(CategoryTest.TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}", "methodAfter": "@Test\npublic void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(CategoryTest.SlowTests.class);\n    Request baseRequest = Request.aClass(CategoryTest.TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n    assertEquals(2, result.getRunCount());\n}"}], [{"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<FrameworkMethod> iter = fTestMethods.iterator(); iter.hasNext();) {\n        FrameworkMethod method = iter.next();\n        if (!filter.shouldRun(describeChild(method))) {\n            iter.remove();\n        }\n    }\n    if (fTestMethods.isEmpty()) {\n        throw new NoTestsRemainException();\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<FrameworkMethod> iter = fTestMethods.iterator(); iter.hasNext();) {\n        FrameworkMethod method = iter.next();\n        if (!filter.shouldRun(describeChild(method))) {\n            iter.remove();\n        }\n    }\n    if (fTestMethods.isEmpty()) {\n        throw new NoTestsRemainException();\n    }\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(describeChild(runner))) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(describeChild(runner))) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}"}, {"methodBefore": "public void run(final TestResult result) {\n    Protectable p = new Protectable() {\n        public void protect() throws Exception {\n            setUp();\n            basicRun(result);\n            tearDown();\n        }\n    };\n    result.runProtected(this, p);\n}", "methodAfter": "@Override\npublic void run(final TestResult result) {\n    Protectable p = new Protectable() {\n        public void protect() throws Exception {\n            setUp();\n            basicRun(result);\n            tearDown();\n        }\n    };\n    result.runProtected(this, p);\n}"}, {"methodBefore": "public void run(TestResult result) {\n    for (int i = 0; i < fTimesRepeat; i++) {\n        if (result.shouldStop()) {\n            break;\n        }\n        super.run(result);\n    }\n}", "methodAfter": "@Override\npublic void run(TestResult result) {\n    for (int i = 0; i < fTimesRepeat; i++) {\n        if (result.shouldStop()) {\n            break;\n        }\n        super.run(result);\n    }\n}"}], [{"methodBefore": "@Test\npublic void bothPasses() {\n    assertThat(3, both(is(3)).and(matches(is(Integer.class))));\n}", "methodAfter": "@Test\npublic void bothPasses() {\n    assertThat(3, both(is(3)).and(matches(is(Integer.class))));\n    assertThat(\"ab\", both(containsString(\"a\")).and(containsString(\"b\")));\n}"}, {"methodBefore": "@Test\npublic void bothPasses() {\n    assertThat(3, both(is(3)).and(matches(is(Integer.class))));\n}", "methodAfter": "@Test\npublic void bothPasses() {\n    assertThat(3, both(is(3)).and(matches(is(Integer.class))));\n    assertThat(\"ab\", both(containsString(\"a\")).and(containsString(\"b\")));\n}"}], [{"methodBefore": "public Suite getSuite(final RunnerBuilder builder, Class<?>[] classes) throws InitializationError {\n    return new Suite(new RunnerBuilder() {\n        @Override\n        public Runner runnerForClass(Class<?> testClass) throws Throwable {\n            return getRunner(builder, testClass);\n        }\n    }, classes);\n}", "methodAfter": "public Runner getSuite(final RunnerBuilder builder, Class<?>[] classes) throws InitializationError {\n    return new Suite(new RunnerBuilder() {\n        @Override\n        public Runner runnerForClass(Class<?> testClass) throws Throwable {\n            return getRunner(builder, testClass);\n        }\n    }, classes);\n}"}, {"methodBefore": "public Suite getSuite(final RunnerBuilder builder, Class<?>[] classes) throws InitializationError {\n    return new Suite(new RunnerBuilder() {\n        @Override\n        public Runner runnerForClass(Class<?> testClass) throws Throwable {\n            return getRunner(builder, testClass);\n        }\n    }, classes);\n}", "methodAfter": "public Runner getSuite(final RunnerBuilder builder, Class<?>[] classes) throws InitializationError {\n    return new Suite(new RunnerBuilder() {\n        @Override\n        public Runner runnerForClass(Class<?> testClass) throws Throwable {\n            return getRunner(builder, testClass);\n        }\n    }, classes);\n}"}], [{"methodBefore": "public Description getDescription() {\n    return fRunner.getDescription();\n}", "methodAfter": "public Description getDescription() {\n    Description description = fRunner.getDescription();\n    return removeIgnored(description);\n}"}, {"methodBefore": "public Description getDescription() {\n    return fRunner.getDescription();\n}", "methodAfter": "public Description getDescription() {\n    Description description = fRunner.getDescription();\n    return removeIgnored(description);\n}"}, {"methodBefore": "public Description getDescription() {\n    return fRunner.getDescription();\n}", "methodAfter": "public Description getDescription() {\n    Description description = fRunner.getDescription();\n    return removeIgnored(description);\n}"}], [{"methodBefore": "@Test\npublic void wrongMessageFails() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.HasWrongMessage.class), hasSingleFailureContaining(\"Unexpected exception message, expected<expectedMessage> but was<actualMessage>\"));\n}", "methodAfter": "@Test\npublic void wrongMessageFails() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.HasWrongMessage.class), hasSingleFailureContaining(\"\\\"expectedMessage\\\"\\n     but: getMessage() was \\\"actualMessage\\\"\"));\n}"}, {"methodBefore": "@Test\npublic void wrongMessageFails() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.HasWrongMessage.class), hasSingleFailureContaining(\"Unexpected exception message, expected<expectedMessage> but was<actualMessage>\"));\n}", "methodAfter": "@Test\npublic void wrongMessageFails() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.HasWrongMessage.class), hasSingleFailureContaining(\"\\\"expectedMessage\\\"\\n     but: getMessage() was \\\"actualMessage\\\"\"));\n}"}], [{"methodBefore": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1Two = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fExample1Two = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1One = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fExample1One = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1One = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fExample1One = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fTwo = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fTwo = Thread.currentThread();\n}"}], [{"methodBefore": "@Override\nprotected Object createTest() throws Exception {\n    return fConstructor.newInstance(fParameters);\n}", "methodAfter": "@Override\npublic Object createTest() throws Exception {\n    return fConstructor.newInstance(fParameters);\n}"}, {"methodBefore": "protected Object createTest() throws Exception {\n    return fTestClass.getConstructor().newInstance();\n}", "methodAfter": "public Object createTest() throws Exception {\n    return fTestClass.getConstructor().newInstance();\n}"}], [{"methodBefore": "@Override\npublic String getDescription() throws CouldNotGenerateValueException {\n    return fMethod.getName();\n}", "methodAfter": "@Override\npublic String getDescription() throws CouldNotGenerateValueException {\n    return method.getName();\n}"}, {"methodBefore": "@Override\npublic String getName() {\n    return fMethod.getName();\n}", "methodAfter": "@Override\npublic String getName() {\n    return method.getName();\n}"}], [{"methodBefore": "public static void failSame(String message) {\n    String formatted = \"\";\n    if (message != null) {\n        formatted = message + \" \";\n    }\n    fail(formatted + \"expected not same\");\n}", "methodAfter": "public static void failSame(String message) {\n    String formatted = (message != null) ? message + \" \" : \"\";\n    fail(formatted + \"expected not same\");\n}"}, {"methodBefore": "public static void failNotSame(String message, Object expected, Object actual) {\n    String formatted = \"\";\n    if (message != null) {\n        formatted = message + \" \";\n    }\n    fail(((((formatted + \"expected same:<\") + expected) + \"> was not:<\") + actual) + \">\");\n}", "methodAfter": "public static void failNotSame(String message, Object expected, Object actual) {\n    String formatted = (message != null) ? message + \" \" : \"\";\n    fail(((((formatted + \"expected same:<\") + expected) + \"> was not:<\") + actual) + \">\");\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.5\";\n}", "methodAfter": "public static String id() {\n    return \"4.6-RC1\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.5\";\n}", "methodAfter": "public static String id() {\n    return \"4.6-RC1\";\n}"}], [{"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}], [{"methodBefore": "@Test\npublic void testInfiniteLoop() {\n    log += \"ran\";\n    for (; ;) {\n    }\n}", "methodAfter": "@Test\npublic void testInfiniteLoop1() {\n    log += \"ran1\";\n    for (; ;) {\n    }\n}"}, {"methodBefore": "@Test\npublic void testInfiniteLoop() {\n    log += \"ran\";\n    for (; ;) {\n    }\n}", "methodAfter": "@Test\npublic void testInfiniteLoop1() {\n    log += \"ran1\";\n    for (; ;) {\n    }\n}"}], [{"methodBefore": "@Override\npublic Description getDescription() {\n    return null;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    return new EmptyDescription();\n}"}, {"methodBefore": "@Override\npublic Description getDescription() {\n    return null;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    return new EmptyDescription();\n}"}, {"methodBefore": "@Override\npublic Description getDescription() {\n    return null;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    return new EmptyDescription();\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testOneTestCaseEclipseSeesSameStructureAs381\"));\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testOneTestCaseEclipseSeesSameStructureAs381\"));\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}"}], [{"methodBefore": "@Override\nprotected TheoryAnchor anchor(TestMethod method) {\n    return new TheoryAnchor(method);\n}", "methodAfter": "@Override\nprotected TheoryAnchor invoke(TestMethod method) {\n    return new TheoryAnchor(method);\n}"}, {"methodBefore": "@Override\nprotected TheoryAnchor anchor(TestMethod method) {\n    return new StubbedTheoryAnchor(method);\n}", "methodAfter": "@Override\nprotected TheoryAnchor invoke(TestMethod method) {\n    return new StubbedTheoryAnchor(method);\n}"}], [{"methodBefore": "@Override\npublic void evaluate() throws Throwable {\n    try {\n        fNext.evaluate();\n    } catch (Throwable e) {\n        if (fMatcher == null) {\n            throw e;\n        }\n        Assert.assertThat(e, fMatcher);\n        return;\n    }\n    if (fMatcher != null) {\n        throw new AssertionError(\"Expected test to throw \" + StringDescription.toString(fMatcher));\n    }\n}", "methodAfter": "@Override\npublic void evaluate() throws Throwable {\n    try {\n        fNext.evaluate();\n    } catch (Throwable e) {\n        if (fMatcher == null) {\n            throw e;\n        }\n        try {\n            Assert.assertThat(e, fMatcher);\n        } catch (AssertionError ae) {\n            ae.initCause(e);\n            throw ae;\n        }\n        return;\n    }\n    if (fMatcher != null) {\n        throw new AssertionError(\"Expected test to throw \" + StringDescription.toString(fMatcher));\n    }\n}"}, {"methodBefore": "@Override\npublic void evaluate() throws Throwable {\n    try {\n        fNext.evaluate();\n    } catch (Throwable e) {\n        if (fMatcher == null) {\n            throw e;\n        }\n        Assert.assertThat(e, fMatcher);\n        return;\n    }\n    if (fMatcher != null) {\n        throw new AssertionError(\"Expected test to throw \" + StringDescription.toString(fMatcher));\n    }\n}", "methodAfter": "@Override\npublic void evaluate() throws Throwable {\n    try {\n        fNext.evaluate();\n    } catch (Throwable e) {\n        if (fMatcher == null) {\n            throw e;\n        }\n        try {\n            Assert.assertThat(e, fMatcher);\n        } catch (AssertionError ae) {\n            ae.initCause(e);\n            throw ae;\n        }\n        return;\n    }\n    if (fMatcher != null) {\n        throw new AssertionError(\"Expected test to throw \" + StringDescription.toString(fMatcher));\n    }\n}"}], [{"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFailureUponUnknownOption() throws Exception {\n    String unknownOption = \"--unknown-option\";\n    jUnitCommandLineParser.parseOptions(new String[]{ unknownOption });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnknownOption() throws Exception {\n    String unknownOption = \"--unknown-option\";\n    jUnitCommandLineParser.parseOptions(new String[]{ unknownOption });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponUncreatedFilter() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + JUnitCommandLineParserTest.FilterFactoryStub.class.getName() });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUncreatedFilter() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + JUnitCommandLineParserTest.FilterFactoryStub.class.getName() });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}], [{"methodBefore": "public Description getDescription() {\n    Description description = fRunner.getDescription();\n    return removeIgnored(description);\n}", "methodAfter": "public Description getDescription() {\n    return fRunner.getDescription();\n}"}, {"methodBefore": "public Description getDescription() {\n    Description description = fRunner.getDescription();\n    return removeIgnored(description);\n}", "methodAfter": "public Description getDescription() {\n    return fRunner.getDescription();\n}"}], [{"methodBefore": "public static String id() {\n    return \"3.7\";\n}", "methodAfter": "public static String id() {\n    return \"@version@\";\n}"}, {"methodBefore": "public static String id() {\n    return \"3.7\";\n}", "methodAfter": "public static String id() {\n    return \"@version@\";\n}"}], [{"methodBefore": "private MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}", "methodAfter": "private MaxHistory(File storedResults) {\n    fHistoryStore = storedResults;\n}"}, {"methodBefore": "private MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}", "methodAfter": "private MaxHistory(File storedResults) {\n    fHistoryStore = storedResults;\n}"}], [{"methodBefore": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    statement = new RunBefores(statement, befores, null);\n    return statement;\n}", "methodAfter": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}"}, {"methodBefore": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    statement = new RunBefores(statement, befores, null);\n    return statement;\n}", "methodAfter": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}"}], [{"methodBefore": "public List<FrameworkField> getAnnotatedFields(Class<? extends Annotation> annotationClass) {\n    ensureKey(fFieldsForAnnotations, annotationClass);\n    return fFieldsForAnnotations.get(annotationClass);\n}", "methodAfter": "public List<FrameworkField> getAnnotatedFields(Class<? extends Annotation> annotationClass) {\n    return getAnnotatedMembers(fFieldsForAnnotations, annotationClass);\n}"}, {"methodBefore": "public List<FrameworkField> getAnnotatedFields(Class<? extends Annotation> annotationClass) {\n    ensureKey(fFieldsForAnnotations, annotationClass);\n    return fFieldsForAnnotations.get(annotationClass);\n}", "methodAfter": "public List<FrameworkField> getAnnotatedFields(Class<? extends Annotation> annotationClass) {\n    return getAnnotatedMembers(fFieldsForAnnotations, annotationClass);\n}"}], [{"methodBefore": "List<Method> getAfters() {\n    return getAnnotatedMethods(AfterClass.class);\n}", "methodAfter": "@Override\nprotected List<Method> getAfters() {\n    return getAnnotatedMethods(AfterClass.class);\n}"}, {"methodBefore": "List<Method> getAfters() {\n    return fTestClass.getAnnotatedMethods(After.class);\n}", "methodAfter": "@Override\nprotected List<Method> getAfters() {\n    return fTestClass.getAnnotatedMethods(After.class);\n}"}], [{"methodBefore": "public void testEnded(String testName) {\n}", "methodAfter": "@Override\npublic void testEnded(String testName) {\n}"}, {"methodBefore": "public String toString() {\n    return super.toString() + \"(repeated)\";\n}", "methodAfter": "@Override\npublic String toString() {\n    return super.toString() + \"(repeated)\";\n}"}, {"methodBefore": "public String toString() {\n    return ((getName() + \"(\") + getClass().getName()) + \")\";\n}", "methodAfter": "@Override\npublic String toString() {\n    return ((getName() + \"(\") + getClass().getName()) + \")\";\n}"}, {"methodBefore": "protected void setUp() {\n    f12CHF = new Money(12, \"CHF\");\n    f14CHF = new Money(14, \"CHF\");\n    f7USD = new Money(7, \"USD\");\n    f21USD = new Money(21, \"USD\");\n    fMB1 = MoneyBag.create(f12CHF, f7USD);\n    fMB2 = MoneyBag.create(f14CHF, f21USD);\n}", "methodAfter": "@Override\nprotected void setUp() {\n    f12CHF = new Money(12, \"CHF\");\n    f14CHF = new Money(14, \"CHF\");\n    f7USD = new Money(7, \"USD\");\n    f21USD = new Money(21, \"USD\");\n    fMB1 = MoneyBag.create(f12CHF, f7USD);\n    fMB2 = MoneyBag.create(f14CHF, f21USD);\n}"}], [{"methodBefore": "public JUnit4TestAdapter(final Class<?> newTestClass, JUnit4TestAdapterCache cache) {\n    fCache = cache;\n    fNewTestClass = newTestClass;\n    fRunner = Request.classWithoutSuiteMethod(newTestClass).filterWith(removeIgnored()).getRunner();\n}", "methodAfter": "public JUnit4TestAdapter(final Class<?> newTestClass, JUnit4TestAdapterCache cache) {\n    fCache = cache;\n    fNewTestClass = newTestClass;\n    fRunner = Request.classWithoutSuiteMethod(newTestClass).getRunner();\n}"}, {"methodBefore": "public JUnit4TestAdapter(final Class<?> newTestClass, JUnit4TestAdapterCache cache) {\n    fCache = cache;\n    fNewTestClass = newTestClass;\n    fRunner = Request.classWithoutSuiteMethod(newTestClass).filterWith(removeIgnored()).getRunner();\n}", "methodAfter": "public JUnit4TestAdapter(final Class<?> newTestClass, JUnit4TestAdapterCache cache) {\n    fCache = cache;\n    fNewTestClass = newTestClass;\n    fRunner = Request.classWithoutSuiteMethod(newTestClass).getRunner();\n}"}], [{"methodBefore": "public void testExceptionSubclass() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assert result.wasSuccessful();\n}", "methodAfter": "public void testExceptionSubclass() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assertTrue(result.wasSuccessful());\n}"}, {"methodBefore": "public void testExceptionTest() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assert result.wasSuccessful();\n}", "methodAfter": "public void testExceptionTest() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assertTrue(result.wasSuccessful());\n}"}, {"methodBefore": "public void testInheritedTests() {\n    TestSuite suite = new TestSuite(InheritedTestCase.class);\n    suite.run(fResult);\n    assert fResult.wasSuccessful();\n    assertEquals(2, fResult.runCount());\n}", "methodAfter": "public void testInheritedTests() {\n    TestSuite suite = new TestSuite(InheritedTestCase.class);\n    suite.run(fResult);\n    assertTrue(fResult.wasSuccessful());\n    assertEquals(2, fResult.runCount());\n}"}], [{"methodBefore": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        return Suite.emptySuite();\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        return Suite.emptySuite();\n    }\n    if (each.toString().startsWith(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX)) {\n        return new JUnit38ClassRunner(new TestSuite(getMalformedTestClass(each)));\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}, {"methodBefore": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        return Suite.emptySuite();\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        return Suite.emptySuite();\n    }\n    if (each.toString().startsWith(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX)) {\n        return new JUnit38ClassRunner(new TestSuite(getMalformedTestClass(each)));\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}], [{"methodBefore": "private List<FrameworkField> interceptorFields() {\n    return getTestClass().getAnnotatedFields(Interceptor.class);\n}", "methodAfter": "private List<FrameworkField> ruleFields() {\n    return getTestClass().getAnnotatedFields(Rule.class);\n}"}, {"methodBefore": "private List<FrameworkField> interceptorFields() {\n    return getTestClass().getAnnotatedFields(Interceptor.class);\n}", "methodAfter": "private List<FrameworkField> ruleFields() {\n    return getTestClass().getAnnotatedFields(Rule.class);\n}"}], [{"methodBefore": "@Override\npublic boolean shouldRun(Description description) {\n    if (isExcluded(description)) {\n        return false;\n    }\n    if (description.isSuite()) {\n        return true;\n    }\n    return isIncludedMethod(description);\n}", "methodAfter": "@Override\npublic boolean shouldRun(Description description) {\n    if (hasCorrectCategoryAnnotation(description)) {\n        return true;\n    }\n    for (Description each : description.getChildren()) {\n        if (shouldRun(each)) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "@Override\npublic boolean shouldRun(Description description) {\n    if (isExcluded(description)) {\n        return false;\n    }\n    if (description.isSuite()) {\n        return true;\n    }\n    return isIncludedMethod(description);\n}", "methodAfter": "@Override\npublic boolean shouldRun(Description description) {\n    if (hasCorrectCategoryAnnotation(description)) {\n        return true;\n    }\n    for (Description each : description.getChildren()) {\n        if (shouldRun(each)) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "public static Runner emptySuite() {\n    try {\n        return new Suite(((RunnerBuilder) (null)), new Class<?>[0]);\n    } catch (InitializationError e) {\n        throw new RuntimeException(\"This shouldn't be possible\");\n    }\n}", "methodAfter": "public static Runner emptySuite() {\n    try {\n        return new Suite(((Class<?>) (null)), new Class<?>[0]);\n    } catch (InitializationError e) {\n        throw new RuntimeException(\"This shouldn't be possible\");\n    }\n}"}, {"methodBefore": "public static Runner emptySuite() {\n    try {\n        return new Suite(((RunnerBuilder) (null)), new Class<?>[0]);\n    } catch (InitializationError e) {\n        throw new RuntimeException(\"This shouldn't be possible\");\n    }\n}", "methodAfter": "public static Runner emptySuite() {\n    try {\n        return new Suite(((Class<?>) (null)), new Class<?>[0]);\n    } catch (InitializationError e) {\n        throw new RuntimeException(\"This shouldn't be possible\");\n    }\n}"}], [{"methodBefore": "public RememberingListener listener() {\n    return new RememberingListener();\n}", "methodAfter": "public RunListener listener() {\n    return new RememberingListener();\n}"}, {"methodBefore": "public RememberingListener listener() {\n    return new RememberingListener();\n}", "methodAfter": "public RunListener listener() {\n    return new RememberingListener();\n}"}], [{"methodBefore": "public void testJarClassLoading() throws Exception {\n    URL url = getClass().getResource(\"test.jar\");\n    if (url == null) {\n        return;\n    }\n    String path = url.getFile();\n    TestCaseClassLoader loader = new TestCaseClassLoader(path);\n    Class loadedClass = loader.loadClass(\"junit.tests.runner.LoadedFromJar\", true);\n    Object o = loadedClass.newInstance();\n    Method method = loadedClass.getDeclaredMethod(\"verify\", new Class[0]);\n    method.invoke(o, new Class[0]);\n}", "methodAfter": "public void testJarClassLoading() throws Exception {\n    URL url = getClass().getResource(\"test.jar\");\n    if (url == null) {\n        return;\n    }\n    String path = url.getFile();\n    TestCaseClassLoader loader = new TestCaseClassLoader(path);\n    Class loadedClass = loader.loadClass(\"junit.tests.runner.LoadedFromJar\", true);\n    Object o = loadedClass.newInstance();\n    Method method = loadedClass.getDeclaredMethod(\"verify\", new Class[0]);\n    method.invoke(o, ((Object[]) (new Class[0])));\n}"}, {"methodBefore": "public void testClassLoading() throws Exception {\n    TestCaseClassLoader loader = new TestCaseClassLoader();\n    Class loadedClass = loader.loadClass(\"junit.tests.runner.ClassLoaderTest\", true);\n    Object o = loadedClass.newInstance();\n    Method method = loadedClass.getDeclaredMethod(\"verify\", new Class[0]);\n    method.invoke(o, new Class[0]);\n}", "methodAfter": "public void testClassLoading() throws Exception {\n    TestCaseClassLoader loader = new TestCaseClassLoader();\n    Class loadedClass = loader.loadClass(\"junit.tests.runner.ClassLoaderTest\", true);\n    Object o = loadedClass.newInstance();\n    Method method = loadedClass.getDeclaredMethod(\"verify\", new Class[0]);\n    method.invoke(o, ((Object[]) (new Class[0])));\n}"}], [{"methodBefore": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new TestClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}", "methodAfter": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new JUnit4ClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}"}, {"methodBefore": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new TestClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}", "methodAfter": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new JUnit4ClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}"}], [{"methodBefore": "@Test\npublic void failsWithNullExceptionMessage() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.ExpectsSubstringNullMessage.class), hasSingleFailureContaining(\"Unexpected exception message, expected<anything!> but was<>\"));\n}", "methodAfter": "@Test\npublic void failsWithNullExceptionMessage() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.ExpectsSubstringNullMessage.class), hasSingleFailureContaining(\"but: getMessage() was null\"));\n}"}, {"methodBefore": "@Test\npublic void failsWithNullExceptionMessage() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.ExpectsSubstringNullMessage.class), hasSingleFailureContaining(\"Unexpected exception message, expected<anything!> but was<>\"));\n}", "methodAfter": "@Test\npublic void failsWithNullExceptionMessage() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.ExpectsSubstringNullMessage.class), hasSingleFailureContaining(\"but: getMessage() was null\"));\n}"}], [{"methodBefore": "public List<Throwable> getCauses() {\n    return errors;\n}", "methodAfter": "public List<Throwable> getCauses() {\n    return fErrors;\n}"}, {"methodBefore": "public List<Throwable> getCauses() {\n    return errors;\n}", "methodAfter": "public List<Throwable> getCauses() {\n    return fErrors;\n}"}], [{"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}], [{"methodBefore": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n    for (T child : getFilteredChildren()) {\n        description.addChild(describeChild(child));\n    }\n    return description;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n    for (T child : getCachedChildren()) {\n        description.addChild(describeChild(child));\n    }\n    return description;\n}"}, {"methodBefore": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n    for (T child : getFilteredChildren()) {\n        description.addChild(describeChild(child));\n    }\n    return description;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n    for (T child : getCachedChildren()) {\n        description.addChild(describeChild(child));\n    }\n    return description;\n}"}], [{"methodBefore": "public void assertEmptyRethrowsSingleRuntimeException() throws Exception {\n    Throwable exception = new ExpectedException(\"pesto\");\n    List<Throwable> errors = Collections.singletonList(exception);\n    try {\n        MultipleFailureException.assertEmpty(errors);\n        fail();\n    } catch (ExpectedException e) {\n        assertSame(e, exception);\n    }\n}", "methodAfter": "@Test\npublic void assertEmptyRethrowsSingleRuntimeException() throws Exception {\n    Throwable exception = new ExpectedException(\"pesto\");\n    List<Throwable> errors = Collections.singletonList(exception);\n    try {\n        MultipleFailureException.assertEmpty(errors);\n        fail();\n    } catch (ExpectedException e) {\n        assertSame(e, exception);\n    }\n}"}, {"methodBefore": "public void assertEmptyRethrowsSingleError() throws Exception {\n    Throwable exception = new AnnotationFormatError(\"changeo\");\n    List<Throwable> errors = Collections.singletonList(exception);\n    try {\n        MultipleFailureException.assertEmpty(errors);\n        fail();\n    } catch (AnnotationFormatError e) {\n        assertSame(e, exception);\n    }\n}", "methodAfter": "@Test\npublic void assertEmptyRethrowsSingleError() throws Exception {\n    Throwable exception = new AnnotationFormatError(\"changeo\");\n    List<Throwable> errors = Collections.singletonList(exception);\n    try {\n        MultipleFailureException.assertEmpty(errors);\n        fail();\n    } catch (AnnotationFormatError e) {\n        assertSame(e, exception);\n    }\n}"}], [{"methodBefore": "public void setUp() {\n    output = new ByteArrayOutputStream();\n    runner = new TestRunner(new TestResultPrinter(new PrintStream(output)));\n}", "methodAfter": "@Override\npublic void setUp() {\n    output = new ByteArrayOutputStream();\n    runner = new TestRunner(new TestResultPrinter(new PrintStream(output)));\n}"}, {"methodBefore": "protected void setUp() {\n    fResult = new TestResult();\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fResult = new TestResult();\n}"}, {"methodBefore": "public boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}"}], [{"methodBefore": "@Test\npublic void one() throws InterruptedException {\n    Thread.sleep(1000);\n}", "methodAfter": "@Test\npublic void one() {\n    fExample1One = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void one() throws InterruptedException {\n    Thread.sleep(1000);\n}", "methodAfter": "@Test\npublic void one() {\n    fExample1One = Thread.currentThread();\n}"}], [{"methodBefore": "public Description getDescription() {\n    Description description = fRunner.getDescription();\n    return removeIgnored(description);\n}", "methodAfter": "public Description getDescription() {\n    return fRunner.getDescription();\n}"}, {"methodBefore": "public Description getDescription() {\n    Description description = fRunner.getDescription();\n    return removeIgnored(description);\n}", "methodAfter": "public Description getDescription() {\n    return fRunner.getDescription();\n}"}], [{"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}], [{"methodBefore": "public Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, testComparator());\n    return constructLeafRequest(leaves);\n}", "methodAfter": "public Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, fHistory.testComparator());\n    return constructLeafRequest(leaves);\n}"}, {"methodBefore": "public Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, testComparator());\n    return constructLeafRequest(leaves);\n}", "methodAfter": "public Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, fHistory.testComparator());\n    return constructLeafRequest(leaves);\n}"}], [{"methodBefore": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withInterceptors(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    return statement;\n}", "methodAfter": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withRules(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    return statement;\n}"}, {"methodBefore": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withInterceptors(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    return statement;\n}", "methodAfter": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withRules(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    return statement;\n}"}], [{"methodBefore": "private static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            description.addChild(makeDescription(ts.testAt(i)));\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}", "methodAfter": "public static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}"}, {"methodBefore": "private static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            description.addChild(makeDescription(ts.testAt(i)));\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}", "methodAfter": "public static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}"}], [{"methodBefore": "@Parameters\npublic static List<Object[]> params() {\n    return Parameterized.eachOne(1, 2);\n}", "methodAfter": "@Parameters\npublic static List<Object[]> params() {\n    return Arrays.asList(new Object[]{ 1 }, new Object[]{ 2 });\n}"}, {"methodBefore": "@Parameters\npublic static List<Object[]> params() {\n    return Parameterized.eachOne(1, 2);\n}", "methodAfter": "@Parameters\npublic static List<Object[]> params() {\n    return Arrays.asList(new Object[]{ 1 }, new Object[]{ 2 });\n}"}], [{"methodBefore": "private EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}", "methodAfter": "protected EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}"}, {"methodBefore": "private EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}", "methodAfter": "protected EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}"}], [{"methodBefore": "public void testRunAndTearDownFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void tearDown() {\n            super.tearDown();\n            throw new Error();\n        }\n\n        protected void runTest() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assert fails.fTornDown;\n}", "methodAfter": "public void testRunAndTearDownFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void tearDown() {\n            super.tearDown();\n            throw new Error();\n        }\n\n        protected void runTest() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assertTrue(fails.fTornDown);\n}"}, {"methodBefore": "public void testTearDownAfterError() {\n    TornDown fails = new TornDown(\"fails\");\n    verifyError(fails);\n    assert fails.fTornDown;\n}", "methodAfter": "public void testTearDownAfterError() {\n    TornDown fails = new TornDown(\"fails\");\n    verifyError(fails);\n    assertTrue(fails.fTornDown);\n}"}], [{"methodBefore": "@Test\npublic void descriptionAndRunNotificationsAreConsistent() {\n    Result result = JUnitCore.runClasses(SuiteMethodTest.CompatibilityTest.class);\n    assertEquals(0, result.getIgnoreCount());\n    Runner runner = Request.aClass(SuiteMethodTest.CompatibilityTest.class).getRunner();\n    Plan plan = runner.getPlan();\n    assertEquals(1, plan.getChildren().size());\n    assertEquals(\"initializationError\", plan.getChildren().get(0).getDescription().getMethodName());\n}", "methodAfter": "@Test\npublic void descriptionAndRunNotificationsAreConsistent() {\n    Result result = JUnitCore.runClasses(SuiteMethodTest.CompatibilityTest.class);\n    assertEquals(0, result.getIgnoreCount());\n    Description description = Request.aClass(SuiteMethodTest.CompatibilityTest.class).getRunner().getDescription();\n    assertEquals(0, description.getChildren().size());\n}"}, {"methodBefore": "@Test\npublic void descriptionAndRunNotificationsAreConsistent() {\n    Result result = JUnitCore.runClasses(SuiteMethodTest.CompatibilityTest.class);\n    assertEquals(0, result.getIgnoreCount());\n    Runner runner = Request.aClass(SuiteMethodTest.CompatibilityTest.class).getRunner();\n    Plan plan = runner.getPlan();\n    assertEquals(1, plan.getChildren().size());\n    assertEquals(\"initializationError\", plan.getChildren().get(0).getDescription().getMethodName());\n}", "methodAfter": "@Test\npublic void descriptionAndRunNotificationsAreConsistent() {\n    Result result = JUnitCore.runClasses(SuiteMethodTest.CompatibilityTest.class);\n    assertEquals(0, result.getIgnoreCount());\n    Description description = Request.aClass(SuiteMethodTest.CompatibilityTest.class).getRunner().getDescription();\n    assertEquals(0, description.getChildren().size());\n}"}], [{"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}, {"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}], [{"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}], [{"methodBefore": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    String storedResults = fMax.fHistory.getFolder();\n    MaxCore reincarnation = MaxCore.forFolder(storedResults);\n    try {\n        List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n        assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n        assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n    } finally {\n        reincarnation.fHistory.forget();\n    }\n}", "methodAfter": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore reincarnation = MaxCore.forFolder(fMaxFile);\n    List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n    assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n    assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n}"}, {"methodBefore": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    String storedResults = fMax.fHistory.getFolder();\n    MaxCore reincarnation = MaxCore.forFolder(storedResults);\n    try {\n        List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n        assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n        assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n    } finally {\n        reincarnation.fHistory.forget();\n    }\n}", "methodAfter": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore reincarnation = MaxCore.forFolder(fMaxFile);\n    List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n    assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n    assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n}"}], [{"methodBefore": "public InitializationError(List<Throwable> errors) {\n    fErrors = errors;\n}", "methodAfter": "public InitializationError(List<Throwable> errors) {\n    this.errors = errors;\n}"}, {"methodBefore": "public InitializationError(List<Throwable> errors) {\n    fErrors = errors;\n}", "methodAfter": "public InitializationError(List<Throwable> errors) {\n    this.errors = errors;\n}"}, {"methodBefore": "public MultipleFailureException(List<Throwable> errors) {\n    fErrors = new ArrayList<Throwable>(errors);\n}", "methodAfter": "public MultipleFailureException(List<Throwable> errors) {\n    this.errors = new ArrayList<Throwable>(errors);\n}"}], [{"methodBefore": "private void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}", "methodAfter": "protected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}"}, {"methodBefore": "private void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}", "methodAfter": "protected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}"}], [{"methodBefore": "@Test\npublic void preferRecentlyFailed() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = new MaxCore();\n    max.run(request);\n    List<Description> tests = max.sort(request);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, tests.get(0));\n}", "methodAfter": "@Test\npublic void preferRecentlyFailed() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = MaxCore.createFresh();\n    max.run(request);\n    List<Description> tests = max.sort(request);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, tests.get(0));\n}"}, {"methodBefore": "@Test\npublic void preferFast() {\n    Request request = Request.aClass(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore max = new MaxCore();\n    max.run(request);\n    Description thing = max.sort(request).get(1);\n    assertEquals(Description.createTestDescription(MaxStarterTest.TwoUnEqualTests.class, \"slow\"), thing);\n}", "methodAfter": "@Test\npublic void preferFast() {\n    Request request = Request.aClass(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore max = MaxCore.createFresh();\n    max.run(request);\n    Description thing = max.sort(request).get(1);\n    assertEquals(Description.createTestDescription(MaxStarterTest.TwoUnEqualTests.class, \"slow\"), thing);\n}"}], [{"methodBefore": "public void testStarted(String testName) {\n}", "methodAfter": "@Override\npublic void testStarted(String testName) {\n}"}, {"methodBefore": "protected void runFailed(String message) {\n}", "methodAfter": "@Override\nprotected void runFailed(String message) {\n}"}, {"methodBefore": "public void testEnded(String testName) {\n}", "methodAfter": "@Override\npublic void testEnded(String testName) {\n}"}, {"methodBefore": "protected void runTest() {\n    fWasRun = true;\n}", "methodAfter": "@Override\nprotected void runTest() {\n    fWasRun = true;\n}"}, {"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "public void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}"}, {"methodBefore": "protected String elapsedTimeAsString(long runTime) {\n    return \"0\";\n}", "methodAfter": "@Override\nprotected String elapsedTimeAsString(long runTime) {\n    return \"0\";\n}"}, {"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "protected void tearDown() {\n    fTornDown = true;\n}", "methodAfter": "@Override\nprotected void tearDown() {\n    fTornDown = true;\n}"}], [{"methodBefore": "@Override\nprotected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    BlockJUnit4ClassRunner runner = ((BlockJUnit4ClassRunner) (super.getRunner(builder, testClass)));\n    return fMethods ? parallelize(runner) : runner;\n}", "methodAfter": "@Override\nprotected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    Runner runner = super.getRunner(builder, testClass);\n    return fMethods ? parallelize(runner) : runner;\n}"}, {"methodBefore": "@Override\nprotected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    BlockJUnit4ClassRunner runner = ((BlockJUnit4ClassRunner) (super.getRunner(builder, testClass)));\n    return fMethods ? parallelize(runner) : runner;\n}", "methodAfter": "@Override\nprotected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    Runner runner = super.getRunner(builder, testClass);\n    return fMethods ? parallelize(runner) : runner;\n}"}], [{"methodBefore": "public String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((fFailedTest + \": \") + fThrownException.getMessage());\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((fFailedTest + \": \") + fThrownException.getMessage());\n    return buffer.toString();\n}"}, {"methodBefore": "public void validateAnnotatedField(Field field, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_FIELD_CALLED));\n}", "methodAfter": "@Override\npublic void validateAnnotatedField(Field field, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_FIELD_CALLED));\n}"}], [{"methodBefore": "private void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}", "methodAfter": "protected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}"}, {"methodBefore": "private void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}", "methodAfter": "protected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}"}], [{"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    statement = new RunAfters(statement, afters, null);\n    return statement;\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}, {"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    statement = new RunAfters(statement, afters, null);\n    return statement;\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}], [{"methodBefore": "@Factory\npublic static Matcher<String> containsString(String substring) {\n    return new StringContains(substring);\n}", "methodAfter": "@Factory\npublic static Matcher<String> containsString(String substring) {\n    return CoreMatchers.containsString(substring);\n}"}, {"methodBefore": "@Factory\npublic static Matcher<String> containsString(String substring) {\n    return new StringContains(substring);\n}", "methodAfter": "@Factory\npublic static Matcher<String> containsString(String substring) {\n    return CoreMatchers.containsString(substring);\n}"}], [{"methodBefore": "public TestRunner(PrintStream writer) {\n    this();\n    fWriter = writer;\n}", "methodAfter": "public TestRunner(PrintStream writer) {\n    this();\n    if (writer == null) {\n        throw new IllegalArgumentException(\"Writer can't be null\");\n    }\n    fWriter = writer;\n}"}, {"methodBefore": "public TestRunner(PrintStream writer) {\n    this();\n    fWriter = writer;\n}", "methodAfter": "public TestRunner(PrintStream writer) {\n    this();\n    if (writer == null) {\n        throw new IllegalArgumentException(\"Writer can't be null\");\n    }\n    fWriter = writer;\n}"}], [{"methodBefore": "public InitializationError(List<Throwable> errors) {\n    this.errors = errors;\n}", "methodAfter": "public InitializationError(List<Throwable> errors) {\n    this.fErrors = errors;\n}"}, {"methodBefore": "public InitializationError(List<Throwable> errors) {\n    this.errors = errors;\n}", "methodAfter": "public InitializationError(List<Throwable> errors) {\n    this.fErrors = errors;\n}"}], [{"methodBefore": "private void validateInterceptorField(Field field, List<Throwable> errors) {\n    if (!StatementInterceptor.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement StatementInterceptor\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}", "methodAfter": "private void validateInterceptorField(Field field, List<Throwable> errors) {\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement StatementInterceptor\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}"}, {"methodBefore": "private void validateInterceptorField(Field field, List<Throwable> errors) {\n    if (!StatementInterceptor.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement StatementInterceptor\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}", "methodAfter": "private void validateInterceptorField(Field field, List<Throwable> errors) {\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement StatementInterceptor\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}"}], [{"methodBefore": "public static MaxCore forFolder(File storedResults) {\n    return new MaxCore(storedResults);\n}", "methodAfter": "public static MaxCore storedLocally(File storedResults) {\n    return new MaxCore(storedResults);\n}"}, {"methodBefore": "public static MaxCore forFolder(File storedResults) {\n    return new MaxCore(storedResults);\n}", "methodAfter": "public static MaxCore storedLocally(File storedResults) {\n    return new MaxCore(storedResults);\n}"}], [{"methodBefore": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new TestClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}", "methodAfter": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new JUnit4ClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}"}, {"methodBefore": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new TestClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}", "methodAfter": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new JUnit4ClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}"}], [{"methodBefore": "public Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, testComparator());\n    return constructLeafRequest(leaves);\n}", "methodAfter": "public Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, fHistory.testComparator());\n    return constructLeafRequest(leaves);\n}"}, {"methodBefore": "public Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, testComparator());\n    return constructLeafRequest(leaves);\n}", "methodAfter": "public Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, fHistory.testComparator());\n    return constructLeafRequest(leaves);\n}"}], [{"methodBefore": "@Test\npublic void failsIfExceptionMessageNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsExceptionMessage.class), hasSingleFailureContaining(\"Expected exception with message: anything!\"));\n}", "methodAfter": "@Test\npublic void failsIfExceptionMessageNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsExceptionMessage.class), hasSingleFailureContaining(\"Expected test to throw exception with message a string containing \\\"anything!\\\"\"));\n}"}, {"methodBefore": "@Test\npublic void failsIfExceptionMessageNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsExceptionMessage.class), hasSingleFailureContaining(\"Expected exception with message: anything!\"));\n}", "methodAfter": "@Test\npublic void failsIfExceptionMessageNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsExceptionMessage.class), hasSingleFailureContaining(\"Expected test to throw exception with message a string containing \\\"anything!\\\"\"));\n}"}], [{"methodBefore": "private Description asDescription(Test test) {\n    if (test instanceof Describable) {\n        Describable facade = ((Describable) (test));\n        return facade.getDescription();\n    }\n    return Description.createTestDescription(test.getClass(), getName(test));\n}", "methodAfter": "private Description asDescription(Test test) {\n    if (test instanceof Describable) {\n        Describable facade = ((Describable) (test));\n        return facade.getDescription();\n    }\n    return Description.createTestDescription(getEffectiveClass(test), getName(test));\n}"}, {"methodBefore": "private Description asDescription(Test test) {\n    if (test instanceof Describable) {\n        Describable facade = ((Describable) (test));\n        return facade.getDescription();\n    }\n    return Description.createTestDescription(test.getClass(), getName(test));\n}", "methodAfter": "private Description asDescription(Test test) {\n    if (test instanceof Describable) {\n        Describable facade = ((Describable) (test));\n        return facade.getDescription();\n    }\n    return Description.createTestDescription(getEffectiveClass(test), getName(test));\n}"}], [{"methodBefore": "public void testNormalize4() {\n    Money s1[] = new Money[]{ new Money(12, \"CHF\"), new Money(3, \"USD\") };\n    MoneyBag ms1 = new MoneyBag(s1);\n    Money expected = new Money(-3, \"USD\");\n    assertEquals(expected, f12CHF.subtract(ms1));\n}", "methodAfter": "public void testNormalize4() {\n    IMoney ms1 = MoneyBag.create(new Money(12, \"CHF\"), new Money(3, \"USD\"));\n    Money expected = new Money(-3, \"USD\");\n    assertEquals(expected, f12CHF.subtract(ms1));\n}"}, {"methodBefore": "public void testNormalize3() {\n    Money s1[] = new Money[]{ new Money(12, \"CHF\"), new Money(3, \"USD\") };\n    MoneyBag ms1 = new MoneyBag(s1);\n    Money expected = new Money(4, \"USD\");\n    assertEquals(expected, fMB1.subtract(ms1));\n}", "methodAfter": "public void testNormalize3() {\n    IMoney ms1 = MoneyBag.create(new Money(12, \"CHF\"), new Money(3, \"USD\"));\n    Money expected = new Money(4, \"USD\");\n    assertEquals(expected, fMB1.subtract(ms1));\n}"}], [{"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "public void testWasRun() {\n    WasRun test = new WasRun(\"\");\n    test.run();\n    assertTrue(test.fWasRun);\n}", "methodAfter": "public void testWasRun() {\n    WasRun test = new WasRun();\n    test.run();\n    assertTrue(test.fWasRun);\n}"}, {"methodBefore": "public void testSetupErrorDontTearDown() {\n    WasRun test = new WasRun(\"\");\n    TornDown wrapper = new TornDown(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assertTrue(!wrapper.fTornDown);\n}", "methodAfter": "public void testSetupErrorDontTearDown() {\n    WasRun test = new WasRun();\n    TornDown wrapper = new TornDown(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assertTrue(!wrapper.fTornDown);\n}"}, {"methodBefore": "public void testSetupErrorInTestSetup() {\n    WasRun test = new WasRun(\"\");\n    TestSetup wrapper = new TestSetup(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assertTrue(!test.fWasRun);\n    assertTrue(!result.wasSuccessful());\n}", "methodAfter": "public void testSetupErrorInTestSetup() {\n    WasRun test = new WasRun();\n    TestSetup wrapper = new TestSetup(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assertTrue(!test.fWasRun);\n    assertTrue(!result.wasSuccessful());\n}"}], [{"methodBefore": "private void validate() throws InitializationError {\n    ErrorList errors = new ErrorList();\n    collectInitializationErrors(errors);\n    errors.assertEmpty();\n}", "methodAfter": "private void validate() throws InitializationError {\n    List<Throwable> errors = new ArrayList<Throwable>();\n    collectInitializationErrors(errors);\n    assertValid(errors);\n}"}, {"methodBefore": "protected Suite(Class<?> klass, Class<?>[] annotatedClasses) throws InitializationError {\n    super(klass.getName());\n    addParent(klass);\n    for (Class<?> each : annotatedClasses) {\n        Runner childRunner = Request.aClass(each).getRunner();\n        if (childRunner != null) {\n            add(childRunner);\n        }\n    }\n    removeParent(klass);\n    fTestClass = new TestClass(klass);\n    ErrorList errors = new ErrorList();\n    fTestClass.validateStaticMethods(errors);\n    errors.assertEmpty();\n}", "methodAfter": "protected Suite(Class<?> klass, Class<?>[] annotatedClasses) throws InitializationError {\n    super(klass.getName());\n    addParent(klass);\n    for (Class<?> each : annotatedClasses) {\n        Runner childRunner = Request.aClass(each).getRunner();\n        if (childRunner != null) {\n            add(childRunner);\n        }\n    }\n    removeParent(klass);\n    fTestClass = new TestClass(klass);\n    List<Throwable> errors = new ArrayList<Throwable>();\n    fTestClass.validateStaticMethods(errors);\n    assertValid(errors);\n}"}, {"methodBefore": "public Parameterized(Class<?> klass) throws Throwable {\n    super(klass.getName());\n    fTestClass = new TestClass(klass);\n    ErrorList errors = new ErrorList();\n    fTestClass.validateStaticMethods(errors);\n    fTestClass.validateInstanceMethods(errors);\n    errors.assertEmpty();\n    int i = 0;\n    for (final Object each : getParametersList()) {\n        if (each instanceof Object[]) {\n            add(new TestClassRunnerForParameters(klass, ((Object[]) (each)), i++));\n        } else {\n            throw new Exception(String.format(\"%s.%s() must return a Collection of arrays.\", fTestClass.getName(), getParametersMethod().getName()));\n        }\n    }\n}", "methodAfter": "public Parameterized(Class<?> klass) throws Throwable {\n    super(klass.getName());\n    fTestClass = new TestClass(klass);\n    List<Throwable> errors = new ArrayList<Throwable>();\n    fTestClass.validateStaticMethods(errors);\n    fTestClass.validateInstanceMethods(errors);\n    assertValid(errors);\n    int i = 0;\n    for (final Object each : getParametersList()) {\n        if (each instanceof Object[]) {\n            add(new TestClassRunnerForParameters(klass, ((Object[]) (each)), i++));\n        } else {\n            throw new Exception(String.format(\"%s.%s() must return a Collection of arrays.\", fTestClass.getName(), getParametersMethod().getName()));\n        }\n    }\n}"}], [{"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "@Test\npublic void assertThatIncludesDescriptionOfTestedValueInErrorMessage() {\n    String expected = \"expected\";\n    String actual = \"actual\";\n    String expectedMessage = \"identifier\\nExpected: \\\"expected\\\"\\n     got: \\\"actual\\\"\\n\";\n    try {\n        assertThat(\"identifier\", actual, equalTo(expected));\n    } catch (AssertionError e) {\n        assertEquals(expectedMessage, e.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void assertThatIncludesDescriptionOfTestedValueInErrorMessage() {\n    String expected = \"expected\";\n    String actual = \"actual\";\n    String expectedMessage = \"identifier\\nExpected: \\\"expected\\\"\\n     but: was \\\"actual\\\"\";\n    try {\n        assertThat(\"identifier\", actual, equalTo(expected));\n    } catch (AssertionError e) {\n        assertEquals(expectedMessage, e.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void assertThatIncludesDescriptionOfTestedValueInErrorMessage() {\n    String expected = \"expected\";\n    String actual = \"actual\";\n    String expectedMessage = \"identifier\\nExpected: \\\"expected\\\"\\n     got: \\\"actual\\\"\\n\";\n    try {\n        assertThat(\"identifier\", actual, equalTo(expected));\n    } catch (AssertionError e) {\n        assertEquals(expectedMessage, e.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void assertThatIncludesDescriptionOfTestedValueInErrorMessage() {\n    String expected = \"expected\";\n    String actual = \"actual\";\n    String expectedMessage = \"identifier\\nExpected: \\\"expected\\\"\\n     but: was \\\"actual\\\"\";\n    try {\n        assertThat(\"identifier\", actual, equalTo(expected));\n    } catch (AssertionError e) {\n        assertEquals(expectedMessage, e.getMessage());\n    }\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090511-2347\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090527-0039\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090511-2347\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090527-0039\";\n}"}], [{"methodBefore": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, greaterThanOrEquals(1000));\n}", "methodAfter": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, betweenInclusive(1000, 1500));\n}"}, {"methodBefore": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, greaterThanOrEquals(1000));\n}", "methodAfter": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, betweenInclusive(1000, 1500));\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090428-1600\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090504-1327\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090428-1600\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090504-1327\";\n}"}], [{"methodBefore": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fHistoryStore));\n    stream.writeObject(this);\n    stream.close();\n}"}, {"methodBefore": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fHistoryStore));\n    stream.writeObject(this);\n    stream.close();\n}"}], [{"methodBefore": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    Description description = Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n    description.setParent(getDescription());\n    return description;\n}", "methodAfter": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n}"}, {"methodBefore": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    Description description = Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n    description.setParent(getDescription());\n    return description;\n}", "methodAfter": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n}"}], [{"methodBefore": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    ensureKey(annotationClass);\n    return fMethodsForAnnotations.get(annotationClass);\n}", "methodAfter": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    ensureKey(fMethodsForAnnotations, annotationClass);\n    return fMethodsForAnnotations.get(annotationClass);\n}"}, {"methodBefore": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    ensureKey(annotationClass);\n    return fMethodsForAnnotations.get(annotationClass);\n}", "methodAfter": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    ensureKey(fMethodsForAnnotations, annotationClass);\n    return fMethodsForAnnotations.get(annotationClass);\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFailureUponUnknownTestClass() throws Exception {\n    String unknownTestClass = \"UnknownTestClass\";\n    jUnitCommandLineParser.parseParameters(new String[]{ unknownTestClass });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnknownTestClass() throws Exception {\n    String unknownTestClass = \"UnknownTestClass\";\n    jUnitCommandLineParser.parseParameters(new String[]{ unknownTestClass });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n    String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + nonExistentFilterFactory });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n    String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + nonExistentFilterFactory });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\" });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\" });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.6-RC1\";\n}", "methodAfter": "public static String id() {\n    return \"4.6\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.6-RC1\";\n}", "methodAfter": "public static String id() {\n    return \"4.6\";\n}"}], [{"methodBefore": "@Test\npublic void assertThatDescriptionCanBeElided() {\n    String expected = \"expected\";\n    String actual = \"actual\";\n    String expectedMessage = \"\\nExpected: \\\"expected\\\"\\n     got: \\\"actual\\\"\\n\";\n    try {\n        assertThat(actual, equalTo(expected));\n    } catch (AssertionError e) {\n        assertEquals(expectedMessage, e.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void assertThatDescriptionCanBeElided() {\n    String expected = \"expected\";\n    String actual = \"actual\";\n    String expectedMessage = \"\\nExpected: \\\"expected\\\"\\n     but: was \\\"actual\\\"\";\n    try {\n        assertThat(actual, equalTo(expected));\n    } catch (AssertionError e) {\n        assertEquals(expectedMessage, e.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void assertThatDescriptionCanBeElided() {\n    String expected = \"expected\";\n    String actual = \"actual\";\n    String expectedMessage = \"\\nExpected: \\\"expected\\\"\\n     got: \\\"actual\\\"\\n\";\n    try {\n        assertThat(actual, equalTo(expected));\n    } catch (AssertionError e) {\n        assertEquals(expectedMessage, e.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void assertThatDescriptionCanBeElided() {\n    String expected = \"expected\";\n    String actual = \"actual\";\n    String expectedMessage = \"\\nExpected: \\\"expected\\\"\\n     but: was \\\"actual\\\"\";\n    try {\n        assertThat(actual, equalTo(expected));\n    } catch (AssertionError e) {\n        assertEquals(expectedMessage, e.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void assertThatDescriptionCanBeElided() {\n    String expected = \"expected\";\n    String actual = \"actual\";\n    String expectedMessage = \"\\nExpected: \\\"expected\\\"\\n     got: \\\"actual\\\"\\n\";\n    try {\n        assertThat(actual, equalTo(expected));\n    } catch (AssertionError e) {\n        assertEquals(expectedMessage, e.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void assertThatDescriptionCanBeElided() {\n    String expected = \"expected\";\n    String actual = \"actual\";\n    String expectedMessage = \"\\nExpected: \\\"expected\\\"\\n     but: was \\\"actual\\\"\";\n    try {\n        assertThat(actual, equalTo(expected));\n    } catch (AssertionError e) {\n        assertEquals(expectedMessage, e.getMessage());\n    }\n}"}], [{"methodBefore": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}", "methodAfter": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        if (ClassRule.class.isAssignableFrom(field.getType())) {\n            if (!Modifier.isStatic(field.getModifiers())) {\n                errors.add(new Exception((\"Field \" + field.getName()) + \" must be static\"));\n            }\n        } else {\n            errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule or ClassRule\"));\n        }\n    }\n}"}, {"methodBefore": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}", "methodAfter": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        if (ClassRule.class.isAssignableFrom(field.getType())) {\n            if (!Modifier.isStatic(field.getModifiers())) {\n                errors.add(new Exception((\"Field \" + field.getName()) + \" must be static\"));\n            }\n        } else {\n            errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule or ClassRule\"));\n        }\n    }\n}"}], [{"methodBefore": "public static MaxCore forFolder(String storedResults) {\n    return new MaxCore(storedResults);\n}", "methodAfter": "public static MaxCore forFolder(String storedResults) {\n    return new MaxCore(new File(storedResults + \".ser\"));\n}"}, {"methodBefore": "public static MaxCore forFolder(String storedResults) {\n    return new MaxCore(storedResults);\n}", "methodAfter": "public static MaxCore forFolder(String storedResults) {\n    return new MaxCore(new File(storedResults + \".ser\"));\n}"}], [{"methodBefore": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore reincarnation = MaxCore.forFolder(fMaxFile);\n    List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n    assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n    assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n}", "methodAfter": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore reincarnation = MaxCore.storedLocally(fMaxFile);\n    List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n    assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n    assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n}"}, {"methodBefore": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore reincarnation = MaxCore.forFolder(fMaxFile);\n    List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n    assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n    assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n}", "methodAfter": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore reincarnation = MaxCore.storedLocally(fMaxFile);\n    List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n    assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n    assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n}"}], [{"methodBefore": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = MaxCore.storedLocally(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = MaxCore.storedLocally(fMaxFile);\n}"}], [{"methodBefore": "public void starting(FrameworkMethod method) {\n}", "methodAfter": "public void starting(FrameworkMethod method) throws Exception {\n}"}, {"methodBefore": "public void starting(FrameworkMethod method) {\n}", "methodAfter": "public void starting(FrameworkMethod method) throws Exception {\n}"}, {"methodBefore": "public void starting(FrameworkMethod method) {\n}", "methodAfter": "public void starting(FrameworkMethod method) throws Exception {\n}"}], [{"methodBefore": "public void addChild(Description description) {\n    fChildren.add(description);\n}", "methodAfter": "public void addChild(Description description) {\n    getChildren().add(description);\n}"}, {"methodBefore": "public void addChild(Description description) {\n    fChildren.add(description);\n}", "methodAfter": "public void addChild(Description description) {\n    getChildren().add(description);\n}"}], [{"methodBefore": "public InitializationError(String string) {\n    this(Arrays.<Throwable>asList(new Exception(string)));\n}", "methodAfter": "public InitializationError(String string) {\n    this(new Exception(string));\n}"}, {"methodBefore": "public InitializationError(String string) {\n    this(Arrays.<Throwable>asList(new Exception(string)));\n}", "methodAfter": "public InitializationError(String string) {\n    this(new Exception(string));\n}"}], [{"methodBefore": "public static PrintableResult testResult(Class<?> type) {\n    return new PrintableResult(type);\n}", "methodAfter": "public static PrintableResult testResult(Class<?> type) {\n    return testResult(type, new Computer());\n}"}, {"methodBefore": "public static PrintableResult testResult(Class<?> type) {\n    return new PrintableResult(type);\n}", "methodAfter": "public static PrintableResult testResult(Class<?> type) {\n    return testResult(type, new Computer());\n}"}], [{"methodBefore": "private Description parentDescription(Description description) {\n    return description.getParentDescription();\n}", "methodAfter": "private Description parentDescription(Description description) {\n    return Description.createSuiteDescription(description.getTestClass());\n}"}, {"methodBefore": "private Description parentDescription(Description description) {\n    return description.getParentDescription();\n}", "methodAfter": "private Description parentDescription(Description description) {\n    return Description.createSuiteDescription(description.getTestClass());\n}"}], [{"methodBefore": "protected List<MethodRule> rules(Object test) {\n    List<MethodRule> results = new ArrayList<MethodRule>();\n    for (FrameworkField each : ruleFields()) {\n        results.add(createRule(test, each));\n    }\n    return results;\n}", "methodAfter": "protected List<MethodRule> rules(Object test) {\n    List<MethodRule> results = new ArrayList<MethodRule>();\n    for (FrameworkField each : ruleFields()) {\n        if (MethodRule.class.isAssignableFrom(each.getField().getType())) {\n            results.add(createRule(test, each));\n        }\n    }\n    return results;\n}"}, {"methodBefore": "protected List<MethodRule> rules(Object test) {\n    List<MethodRule> results = new ArrayList<MethodRule>();\n    for (FrameworkField each : ruleFields()) {\n        results.add(createRule(test, each));\n    }\n    return results;\n}", "methodAfter": "protected List<MethodRule> rules(Object test) {\n    List<MethodRule> results = new ArrayList<MethodRule>();\n    for (FrameworkField each : ruleFields()) {\n        if (MethodRule.class.isAssignableFrom(each.getField().getType())) {\n            results.add(createRule(test, each));\n        }\n    }\n    return results;\n}"}], [{"methodBefore": "public void addChild(Description description) {\n    fChildren.add(description);\n}", "methodAfter": "public void addChild(Description description) {\n    getChildren().add(description);\n}"}, {"methodBefore": "public void addChild(Description description) {\n    fChildren.add(description);\n}", "methodAfter": "public void addChild(Description description) {\n    getChildren().add(description);\n}"}], [{"methodBefore": "public TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}", "methodAfter": "public TestSuite(final Class<?> theClass) {\n    addTestsFromTestCase(theClass);\n}"}, {"methodBefore": "public TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}", "methodAfter": "public TestSuite(final Class<?> theClass) {\n    addTestsFromTestCase(theClass);\n}"}, {"methodBefore": "public TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}", "methodAfter": "public TestSuite(final Class<?> theClass) {\n    addTestsFromTestCase(theClass);\n}"}], [{"methodBefore": "@Override\npublic Description getDescription() {\n    return null;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    return new EmptyDescription();\n}"}, {"methodBefore": "@Override\npublic Description getDescription() {\n    return null;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    return new EmptyDescription();\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}"}], [{"methodBefore": "public void testAssertNull() {\n    assertNull(null);\n    try {\n        assertNull(new Object());\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNull() {\n    assertNull(null);\n    try {\n        assertNull(new Object());\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNullNotEqualsNull() {\n    try {\n        assertEquals(null, new Object());\n        fail();\n    } catch (AssertionFailedError e) {\n        e.getMessage();\n    }\n}", "methodAfter": "public void testAssertNullNotEqualsNull() {\n    try {\n        assertEquals(null, new Object());\n    } catch (AssertionFailedError e) {\n        e.getMessage();\n        return;\n    }\n    fail();\n}"}], [{"methodBefore": "@Override\nprotected List<Runner> getChildren() {\n    return fRunners;\n}", "methodAfter": "@Override\nprotected List<Runner> getChildren() {\n    return runners;\n}"}, {"methodBefore": "@Override\nprotected List<Runner> getChildren() {\n    return fRunners;\n}", "methodAfter": "@Override\nprotected List<Runner> getChildren() {\n    return runners;\n}"}], [{"methodBefore": "@Test\npublic void theoryMeansOnlyAssumeShouldFail() throws InitializationError {\n    JUnitCore junitRunner = new JUnitCore();\n    Runner theoryRunner = new Theories(AssumingInTheoriesTest.TheoryWithNoUnassumedParameters.class);\n    Request request = Request.runner(theoryRunner);\n    Result result = junitRunner.run(request);\n    Assert.assertEquals(1, result.getFailureCount());\n}", "methodAfter": "@Test\npublic void theoryMeansOnlyAssumeShouldFail() throws InitializationError {\n    Result result = runTheoryClass(AssumingInTheoriesTest.TheoryWithNoUnassumedParameters.class);\n    Assert.assertEquals(1, result.getFailureCount());\n}"}, {"methodBefore": "@Test\npublic void theoryMeansOnlyAssumeShouldFail() throws InitializationError {\n    JUnitCore junitRunner = new JUnitCore();\n    Runner theoryRunner = new Theories(AssumingInTheoriesTest.TheoryWithNoUnassumedParameters.class);\n    Request request = Request.runner(theoryRunner);\n    Result result = junitRunner.run(request);\n    Assert.assertEquals(1, result.getFailureCount());\n}", "methodAfter": "@Test\npublic void theoryMeansOnlyAssumeShouldFail() throws InitializationError {\n    Result result = runTheoryClass(AssumingInTheoriesTest.TheoryWithNoUnassumedParameters.class);\n    Assert.assertEquals(1, result.getFailureCount());\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testOneTestCaseEclipseSeesSameStructureAs381\"));\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testOneTestCaseEclipseSeesSameStructureAs381\"));\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testOneTestCaseEclipseSeesSameStructureAs381\"));\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}"}], [{"methodBefore": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}], [{"methodBefore": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}], [{"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getPlan(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getPlan(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getDescription(), results);\n    return results;\n}"}], [{"methodBefore": "protected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}"}, {"methodBefore": "protected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}"}, {"methodBefore": "protected void validateInstanceMethods(List<Throwable> errors) {\n    validatePublicVoidNoArgMethods(After.class, false, errors);\n    validatePublicVoidNoArgMethods(Before.class, false, errors);\n    validateTestMethods(errors);\n    if (computeTestMethods().size() == 0) {\n        errors.add(new Exception(\"No runnable methods\"));\n    }\n}", "methodAfter": "@Deprecated\nprotected void validateInstanceMethods(List<Throwable> errors) {\n    validatePublicVoidNoArgMethods(After.class, false, errors);\n    validatePublicVoidNoArgMethods(Before.class, false, errors);\n    validateTestMethods(errors);\n    if (computeTestMethods().size() == 0) {\n        errors.add(new Exception(\"No runnable methods\"));\n    }\n}"}, {"methodBefore": "protected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}"}, {"methodBefore": "public void testRunStarted(Description description) throws Exception {\n}", "methodAfter": "@Deprecated\npublic void testRunStarted(Description description) throws Exception {\n}"}, {"methodBefore": "protected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}"}], [{"methodBefore": "public Result run(Runner runner) {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    addFirstListener(listener);\n    try {\n        fNotifier.fireTestRunStarted(runner.getDescription());\n        runner.run(fNotifier);\n        fNotifier.fireTestRunFinished(result);\n    } finally {\n        removeListener(listener);\n    }\n    return result;\n}", "methodAfter": "public Result run(Runner runner) {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    fNotifier.addFirstListener(listener);\n    try {\n        fNotifier.fireTestRunStarted(runner.getDescription());\n        runner.run(fNotifier);\n        fNotifier.fireTestRunFinished(result);\n    } finally {\n        removeListener(listener);\n    }\n    return result;\n}"}, {"methodBefore": "public Result run(Runner runner) {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    addFirstListener(listener);\n    try {\n        fNotifier.fireTestRunStarted(runner.getDescription());\n        runner.run(fNotifier);\n        fNotifier.fireTestRunFinished(result);\n    } finally {\n        removeListener(listener);\n    }\n    return result;\n}", "methodAfter": "public Result run(Runner runner) {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    fNotifier.addFirstListener(listener);\n    try {\n        fNotifier.fireTestRunStarted(runner.getDescription());\n        runner.run(fNotifier);\n        fNotifier.fireTestRunFinished(result);\n    } finally {\n        removeListener(listener);\n    }\n    return result;\n}"}], [{"methodBefore": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fTwo = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fTwo = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fOne = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fOne = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1One = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fExample1One = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1One = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fExample1One = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1Two = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fExample1Two = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1Two = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fExample1Two = Thread.currentThread();\n}"}], [{"methodBefore": "private Description removeIgnored(Description description) {\n    if (isIgnored(description)) {\n        return Description.EMPTY;\n    }\n    Description result = description.childlessCopy();\n    for (Description each : description.getChildren()) {\n        Description child = removeIgnored(each);\n        if (!child.isEmpty()) {\n            result.addChild(child);\n        }\n    }\n    return result;\n}", "methodAfter": "private Filter removeIgnored() {\n    return new Filter() {\n        @Override\n        public boolean shouldRun(Description description) {\n            return !isIgnored(description);\n        }\n\n        @Override\n        public String describe() {\n            return \"not ignored\";\n        }\n    };\n}"}, {"methodBefore": "private Description removeIgnored(Description description) {\n    if (isIgnored(description)) {\n        return Description.EMPTY;\n    }\n    Description result = description.childlessCopy();\n    for (Description each : description.getChildren()) {\n        Description child = removeIgnored(each);\n        if (!child.isEmpty()) {\n            result.addChild(child);\n        }\n    }\n    return result;\n}", "methodAfter": "private Filter removeIgnored() {\n    return new Filter() {\n        @Override\n        public boolean shouldRun(Description description) {\n            return !isIgnored(description);\n        }\n\n        @Override\n        public String describe() {\n            return \"not ignored\";\n        }\n    };\n}"}], [{"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}, {"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.6\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.6\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.6\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT\";\n}"}], [{"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}], [{"methodBefore": "@Test\npublic void newFolderWithGivenPathThrowsIllegalArgumentExceptionIfPathExists() throws IOException {\n    tempFolder.create();\n    tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"a folder with the name 'level3' already exists\");\n    tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n}", "methodAfter": "@Test\npublic void newFolderWithGivenPathThrowsIllegalArgumentExceptionIfPathExists() throws IOException {\n    tempFolder.create();\n    tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n    thrown.expect(IOException.class);\n    thrown.expectMessage(\"a folder with the name 'level3' already exists\");\n    tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n}"}, {"methodBefore": "@Test\npublic void newFolderWithGivenFolderThrowsIllegalArgumentExceptionIfFolderExists() throws IOException {\n    tempFolder.create();\n    tempFolder.newFolder(\"level1\");\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"a folder with the name 'level1' already exists\");\n    tempFolder.newFolder(\"level1\");\n}", "methodAfter": "@Test\npublic void newFolderWithGivenFolderThrowsIllegalArgumentExceptionIfFolderExists() throws IOException {\n    tempFolder.create();\n    tempFolder.newFolder(\"level1\");\n    thrown.expect(IOException.class);\n    thrown.expectMessage(\"a folder with the name 'level1' already exists\");\n    tempFolder.newFolder(\"level1\");\n}"}], [{"methodBefore": "@Test\npublic void failsIfExceptionNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsException.class), hasSingleFailureContaining(\"Expected exception: java.lang.NullPointerException\"));\n}", "methodAfter": "@Test\npublic void failsIfExceptionNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsException.class), hasSingleFailureContaining(\"Expected test to throw an instance of java.lang.NullPointerException\"));\n}"}, {"methodBefore": "@Test\npublic void failsIfExceptionNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsException.class), hasSingleFailureContaining(\"Expected exception: java.lang.NullPointerException\"));\n}", "methodAfter": "@Test\npublic void failsIfExceptionNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsException.class), hasSingleFailureContaining(\"Expected test to throw an instance of java.lang.NullPointerException\"));\n}"}], [{"methodBefore": "public void testAssertNullNotEqualsNull() {\n    try {\n        assertEquals(null, new Object());\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}", "methodAfter": "public void testAssertNullNotEqualsNull() {\n    try {\n        assertEquals(null, new Object());\n    } catch (AssertionFailedError e) {\n        e.getMessage();\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertStringNotEqualsNull() {\n    try {\n        assertEquals(\"foo\", null);\n    } catch (ComparisonFailure e) {\n        return;\n    }\n    fail();\n}", "methodAfter": "public void testAssertStringNotEqualsNull() {\n    try {\n        assertEquals(\"foo\", null);\n    } catch (ComparisonFailure e) {\n        e.getMessage();\n        return;\n    }\n    fail();\n}"}], [{"methodBefore": "public CombinableMatcher(Matcher<? extends T> matcher) {\n    fMatcher = matcher;\n}", "methodAfter": "private CombinableMatcher(Matcher<? super T> matcher) {\n    super(matcher);\n}"}, {"methodBefore": "public CombinableMatcher(Matcher<? extends T> matcher) {\n    fMatcher = matcher;\n}", "methodAfter": "private CombinableMatcher(Matcher<? super T> matcher) {\n    super(matcher);\n}"}], [{"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getPlan(), results);\n    return results;\n}"}, {"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getPlan(), results);\n    return results;\n}"}], [{"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "@Test\npublic void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    try {\n        evaluateWithException(new RuntimeException());\n    } catch (Throwable expected) {\n    }\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    try {\n        evaluateWithException(new RuntimeException());\n    } catch (Throwable expected) {\n    }\n    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n}"}, {"methodBefore": "@Test\npublic void throwExceptionWithNiceMessageOnTimeout() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwExceptionWithNiceMessageOnTimeout() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n}"}, {"methodBefore": "@Test\npublic void throwsTestTimedOutException() throws Throwable {\n    thrown.expect(TestTimedOutException.class);\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwsTestTimedOutException() throws Throwable {\n    thrown.expect(TestTimedOutException.class);\n    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n}"}, {"methodBefore": "@Test\npublic void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime() throws Throwable {\n    thrown.expect(TestTimedOutException.class);\n    evaluateWithWaitDuration(0);\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime() throws Throwable {\n    thrown.expect(TestTimedOutException.class);\n    evaluateWithWaitDuration(0);\n    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n}"}], [{"methodBefore": "public void expect(Class<? extends Throwable> type) {\n    fMatcher = instanceOf(type);\n}", "methodAfter": "public void expect(Class<? extends Throwable> type) {\n    expect(instanceOf(type));\n}"}, {"methodBefore": "public void expect(Class<? extends Throwable> type) {\n    fMatcher = instanceOf(type);\n}", "methodAfter": "public void expect(Class<? extends Throwable> type) {\n    expect(instanceOf(type));\n}"}], [{"methodBefore": "@Test\npublic void addFailureDelegatesToNotifier() {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    RunNotifier notifier = new RunNotifier();\n    notifier.addFirstListener(listener);\n    TestListener adaptingListener = JUnit38ClassRunner.createAdaptingListener(notifier);\n    TestCase testCase = new TestCase() {};\n    adaptingListener.addFailure(testCase, new AssertionFailedError());\n    assertEquals(1, result.getFailureCount());\n}", "methodAfter": "@Test\npublic void addFailureDelegatesToNotifier() {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    RunNotifier notifier = new RunNotifier();\n    notifier.addFirstListener(listener);\n    TestCase testCase = new TestCase() {};\n    TestListener adaptingListener = new JUnit38ClassRunner(testCase).createAdaptingListener(notifier);\n    adaptingListener.addFailure(testCase, new AssertionFailedError());\n    assertEquals(1, result.getFailureCount());\n}"}, {"methodBefore": "@Test\npublic void addFailureDelegatesToNotifier() {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    RunNotifier notifier = new RunNotifier();\n    notifier.addFirstListener(listener);\n    TestListener adaptingListener = JUnit38ClassRunner.createAdaptingListener(notifier);\n    TestCase testCase = new TestCase() {};\n    adaptingListener.addFailure(testCase, new AssertionFailedError());\n    assertEquals(1, result.getFailureCount());\n}", "methodAfter": "@Test\npublic void addFailureDelegatesToNotifier() {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    RunNotifier notifier = new RunNotifier();\n    notifier.addFirstListener(listener);\n    TestCase testCase = new TestCase() {};\n    TestListener adaptingListener = new JUnit38ClassRunner(testCase).createAdaptingListener(notifier);\n    adaptingListener.addFailure(testCase, new AssertionFailedError());\n    assertEquals(1, result.getFailureCount());\n}"}], [{"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return new RunBefores(statement, befores, target);\n}", "methodAfter": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return new RunBefores(statement, befores, target);\n}", "methodAfter": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}], [{"methodBefore": "public List<Test> getTests() {\n    return fCache.asTestList(fRunner.getPlan());\n}", "methodAfter": "public List<Test> getTests() {\n    return fCache.asTestList(getDescription());\n}"}, {"methodBefore": "public List<Test> getTests() {\n    return fCache.asTestList(fRunner.getPlan());\n}", "methodAfter": "public List<Test> getTests() {\n    return fCache.asTestList(getDescription());\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090601-1258\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090604-0055\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT-20090601-1258\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090604-0055\";\n}"}], [{"methodBefore": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method, getTestClass());\n}"}, {"methodBefore": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method, getTestClass());\n}"}], [{"methodBefore": "public ThrowableMessageMatcher(Matcher<String> matcher) {\n    fMatcher = matcher;\n}", "methodAfter": "public ThrowableMessageMatcher(Matcher<String> matcher) {\n    this.matcher = matcher;\n}"}, {"methodBefore": "public ThrowableCauseMatcher(Matcher<T> matcher) {\n    fMatcher = matcher;\n}", "methodAfter": "public ThrowableCauseMatcher(Matcher<T> matcher) {\n    this.matcher = matcher;\n}"}], [{"methodBefore": "public Statement intercept(Statement base, FrameworkMethod method, Object target) {\n    return new FailOnTimeout(base, fMillis);\n}", "methodAfter": "public Statement apply(Statement base, FrameworkMethod method, Object target) {\n    return new FailOnTimeout(base, fMillis);\n}"}, {"methodBefore": "public Statement intercept(Statement base, FrameworkMethod method, Object target) {\n    return new FailOnTimeout(base, fMillis);\n}", "methodAfter": "public Statement apply(Statement base, FrameworkMethod method, Object target) {\n    return new FailOnTimeout(base, fMillis);\n}"}], [{"methodBefore": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}", "methodAfter": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        if (ClassRule.class.isAssignableFrom(field.getType())) {\n            if (!Modifier.isStatic(field.getModifiers())) {\n                errors.add(new Exception((\"Field \" + field.getName()) + \" must be static\"));\n            }\n        } else {\n            errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule or ClassRule\"));\n        }\n    }\n}"}, {"methodBefore": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}", "methodAfter": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        if (ClassRule.class.isAssignableFrom(field.getType())) {\n            if (!Modifier.isStatic(field.getModifiers())) {\n                errors.add(new Exception((\"Field \" + field.getName()) + \" must be static\"));\n            }\n        } else {\n            errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule or ClassRule\"));\n        }\n    }\n}"}], [{"methodBefore": "public void expectMessage(Matcher<String> matcher) {\n    fMatcher = hasMessage(matcher);\n}", "methodAfter": "public void expectMessage(Matcher<String> matcher) {\n    expect(hasMessage(matcher));\n}"}, {"methodBefore": "public void expectMessage(Matcher<String> matcher) {\n    fMatcher = hasMessage(matcher);\n}", "methodAfter": "public void expectMessage(Matcher<String> matcher) {\n    expect(hasMessage(matcher));\n}"}], [{"methodBefore": "@Test\npublic void assertNotEqualsIncludesCorrectMessage() {\n    Integer value1 = new Integer(1);\n    Integer value2 = new Integer(1);\n    String message = \"The values should be different\";\n    try {\n        assertNotEquals(message, value1, value2);\n        fail();\n    } catch (AssertionError e) {\n        assertEquals((message + \". Actual: \") + value1, e.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void assertNotEqualsIncludesCorrectMessage() {\n    Integer value1 = new Integer(1);\n    Integer value2 = new Integer(1);\n    String message = \"The values should be different\";\n    try {\n        assertNotEquals(message, value1, value2);\n    } catch (AssertionError e) {\n        assertEquals((message + \". Actual: \") + value1, e.getMessage());\n        return;\n    }\n    fail(\"Failed on assertion.\");\n}"}, {"methodBefore": "@Test\npublic void assertNotEqualsIncludesTheValueBeingTested() {\n    Integer value1 = new Integer(1);\n    Integer value2 = new Integer(1);\n    try {\n        assertNotEquals(value1, value2);\n        fail();\n    } catch (AssertionError e) {\n        assertTrue(e.getMessage().contains(value1.toString()));\n    }\n}", "methodAfter": "@Test\npublic void assertNotEqualsIncludesTheValueBeingTested() {\n    Integer value1 = new Integer(1);\n    Integer value2 = new Integer(1);\n    try {\n        assertNotEquals(value1, value2);\n    } catch (AssertionError e) {\n        assertTrue(e.getMessage().contains(value1.toString()));\n        return;\n    }\n    fail(\"Failed on assertion.\");\n}"}], [{"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "public String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((((\"[\" + amount()) + \" \") + currency()) + \"]\");\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((((\"[\" + amount()) + \" \") + currency()) + \"]\");\n    return buffer.toString();\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.8.1\";\n}", "methodAfter": "public static String id() {\n    return \"4.8.2\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.8.1\";\n}", "methodAfter": "public static String id() {\n    return \"4.8.2\";\n}"}], [{"methodBefore": "@Test\npublic void ignoreRunner() {\n    JUnitCore runner = new JUnitCore();\n    Result result = runner.run(TestMethodTest.IgnoredTest.class);\n    assertEquals(2, result.getIgnoreCount());\n}", "methodAfter": "@Test\npublic void ignoreRunner() {\n    JUnitCore runner = new JUnitCore();\n    Result result = runner.run(TestMethodTest.IgnoredTest.class);\n    assertEquals(2, result.getIgnoreCount());\n    assertEquals(1, result.getRunCount());\n}"}, {"methodBefore": "@Test\npublic void ignoreRunner() {\n    JUnitCore runner = new JUnitCore();\n    Result result = runner.run(TestMethodTest.IgnoredTest.class);\n    assertEquals(2, result.getIgnoreCount());\n}", "methodAfter": "@Test\npublic void ignoreRunner() {\n    JUnitCore runner = new JUnitCore();\n    Result result = runner.run(TestMethodTest.IgnoredTest.class);\n    assertEquals(2, result.getIgnoreCount());\n    assertEquals(1, result.getRunCount());\n}"}], [{"methodBefore": "@Test\npublic void shouldParseFilterArgWithEqualsSyntax() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ ((\"--filter=\" + IncludeCategories.class.getName()) + \"=\") + JUnitCommandLineParserTest.DummyCategory0.class.getName() });\n    Filter filter = jUnitCommandLineParser.getFilter();\n    assertThat(filter, instanceOf(IncludesAny.class));\n}", "methodAfter": "@Test\npublic void shouldParseFilterArgWithEqualsSyntax() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ ((\"--filter=\" + IncludeCategories.class.getName()) + \"=\") + JUnitCommandLineParserTest.DummyCategory0.class.getName() });\n    Filter filter = jUnitCommandLineParser.getFilter();\n    assertThat(filter.describe(), startsWith(\"includes \"));\n}"}, {"methodBefore": "@Test\npublic void shouldParseFilterArgInWhichValueIsASeparateArg() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\", (IncludeCategories.class.getName() + \"=\") + JUnitCommandLineParserTest.DummyCategory0.class.getName() });\n    Filter filter = jUnitCommandLineParser.getFilter();\n    assertThat(filter, instanceOf(IncludesAny.class));\n}", "methodAfter": "@Test\npublic void shouldParseFilterArgInWhichValueIsASeparateArg() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\", (IncludeCategories.class.getName() + \"=\") + JUnitCommandLineParserTest.DummyCategory0.class.getName() });\n    Filter filter = jUnitCommandLineParser.getFilter();\n    assertThat(filter.describe(), startsWith(\"includes \"));\n}"}], [{"methodBefore": "public static MaxCore createFresh() {\n    return new MaxCore();\n}", "methodAfter": "public static MaxCore createFresh() {\n    File file = new File(\"MaxCore.ser\");\n    if (file.exists()) {\n        file.delete();\n    }\n    try {\n        return new MaxCore();\n    } catch (Throwable e) {\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    }\n}"}, {"methodBefore": "public static MaxCore createFresh() {\n    return new MaxCore();\n}", "methodAfter": "public static MaxCore createFresh() {\n    File file = new File(\"MaxCore.ser\");\n    if (file.exists()) {\n        file.delete();\n    }\n    try {\n        return new MaxCore();\n    } catch (Throwable e) {\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    }\n}"}], [{"methodBefore": "@Parameters\npublic static Collection<Object[]> getParameters() {\n    return Collections.singletonList(new Object[]{ \"a\" });\n}", "methodAfter": "@Parameters\npublic static Iterable<String> getParameters() {\n    return Arrays.asList(\"first\", \"second\");\n}"}, {"methodBefore": "@Parameters\npublic static Collection<Object[]> getParameters() {\n    return Collections.singletonList(new Object[]{ \"a\" });\n}", "methodAfter": "@Parameters\npublic static Iterable<String> getParameters() {\n    return Arrays.asList(\"first\", \"second\");\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "public void validateAnnotatedField(Field field, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_FIELD_CALLED));\n}", "methodAfter": "@Override\npublic void validateAnnotatedField(Field field, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_FIELD_CALLED));\n}"}, {"methodBefore": "public void validateAnnotatedMethod(Method method, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_METHOD_CALLED));\n}", "methodAfter": "@Override\npublic void validateAnnotatedMethod(Method method, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_METHOD_CALLED));\n}"}], [{"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}, {"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}], [{"methodBefore": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : eachClass.getDeclaredMethods()) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod));\n        }\n    }\n}", "methodAfter": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : eachClass.getDeclaredMethods()) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod), fMethodsForAnnotations);\n        }\n        for (Field eachField : eachClass.getDeclaredFields()) {\n            addToAnnotationLists(new FrameworkField(eachField), fFieldsForAnnotations);\n        }\n    }\n}"}, {"methodBefore": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : eachClass.getDeclaredMethods()) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod));\n        }\n    }\n}", "methodAfter": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : eachClass.getDeclaredMethods()) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod), fMethodsForAnnotations);\n        }\n        for (Field eachField : eachClass.getDeclaredFields()) {\n            addToAnnotationLists(new FrameworkField(eachField), fFieldsForAnnotations);\n        }\n    }\n}"}], [{"methodBefore": "public String getMessage() {\n    return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n}", "methodAfter": "@Override\npublic String getMessage() {\n    return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n}"}, {"methodBefore": "public boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}"}, {"methodBefore": "public boolean isStatic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isStatic(modifiers);\n}", "methodAfter": "@Override\npublic boolean isStatic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isStatic(modifiers);\n}"}, {"methodBefore": "public void runTest() {\n    fail();\n}", "methodAfter": "@Override\npublic void runTest() {\n    fail();\n}"}, {"methodBefore": "public String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((((\"[\" + amount()) + \" \") + currency()) + \"]\");\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((((\"[\" + amount()) + \" \") + currency()) + \"]\");\n    return buffer.toString();\n}"}, {"methodBefore": "public String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}"}, {"methodBefore": "public void run(TestResult result) {\n    fActiveTestDeathCount = 0;\n    super.run(result);\n    waitUntilFinished();\n}", "methodAfter": "@Override\npublic void run(TestResult result) {\n    fActiveTestDeathCount = 0;\n    super.run(result);\n    waitUntilFinished();\n}"}, {"methodBefore": "public String getName() {\n    return getField().getName();\n}", "methodAfter": "@Override\npublic String getName() {\n    return getField().getName();\n}"}, {"methodBefore": "public String toString() {\n    return ((getName() + \"(\") + getClass().getName()) + \")\";\n}", "methodAfter": "@Override\npublic String toString() {\n    return ((getName() + \"(\") + getClass().getName()) + \")\";\n}"}, {"methodBefore": "public void testStarted(String testName) {\n}", "methodAfter": "@Override\npublic void testStarted(String testName) {\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(runner.getDescription())) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(runner.getDescription())) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}"}, {"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "public String toString() {\n    return fTest.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    return fTest.toString();\n}"}, {"methodBefore": "protected void setUp() {\n    fValue1 = 2;\n    fValue2 = 3;\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fValue1 = 2;\n    fValue2 = 3;\n}"}, {"methodBefore": "public void testCase() {\n}", "methodAfter": "@Override\npublic void testCase() {\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}"}, {"methodBefore": "protected void setUp() {\n    f12CHF = new Money(12, \"CHF\");\n    f14CHF = new Money(14, \"CHF\");\n    f7USD = new Money(7, \"USD\");\n    f21USD = new Money(21, \"USD\");\n    fMB1 = MoneyBag.create(f12CHF, f7USD);\n    fMB2 = MoneyBag.create(f14CHF, f21USD);\n}", "methodAfter": "@Override\nprotected void setUp() {\n    f12CHF = new Money(12, \"CHF\");\n    f14CHF = new Money(14, \"CHF\");\n    f7USD = new Money(7, \"USD\");\n    f21USD = new Money(21, \"USD\");\n    fMB1 = MoneyBag.create(f12CHF, f7USD);\n    fMB2 = MoneyBag.create(f14CHF, f21USD);\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}"}, {"methodBefore": "public String getTestHeader() {\n    return fDescription.getDisplayName();\n}", "methodAfter": "@Override\npublic String getTestHeader() {\n    return fDescription.getDisplayName();\n}"}, {"methodBefore": "public String toString() {\n    if (getName() != null) {\n        return getName();\n    }\n    return super.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    if (getName() != null) {\n        return getName();\n    }\n    return super.toString();\n}"}, {"methodBefore": "public boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}"}, {"methodBefore": "public boolean equals(Object anObject) {\n    if (isZero()) {\n        if (anObject instanceof IMoney) {\n            return ((IMoney) (anObject)).isZero();\n        }\n    }\n    if (anObject instanceof Money) {\n        Money aMoney = ((Money) (anObject));\n        return aMoney.currency().equals(currency()) && (amount() == aMoney.amount());\n    }\n    return false;\n}", "methodAfter": "@Override\npublic boolean equals(Object anObject) {\n    if (isZero()) {\n        if (anObject instanceof IMoney) {\n            return ((IMoney) (anObject)).isZero();\n        }\n    }\n    if (anObject instanceof Money) {\n        Money aMoney = ((Money) (anObject));\n        return aMoney.currency().equals(currency()) && (amount() == aMoney.amount());\n    }\n    return false;\n}"}, {"methodBefore": "public String getName() {\n    return fMethod.getName();\n}", "methodAfter": "@Override\npublic String getName() {\n    return fMethod.getName();\n}"}, {"methodBefore": "public void setUp() {\n    output = new ByteArrayOutputStream();\n    runner = new TestRunner(new TestResultPrinter(new PrintStream(output)));\n}", "methodAfter": "@Override\npublic void setUp() {\n    output = new ByteArrayOutputStream();\n    runner = new TestRunner(new TestResultPrinter(new PrintStream(output)));\n}"}, {"methodBefore": "protected void setUp() {\n    fResult = new TestResult();\n    fResult.addListener(this);\n    fStartCount = 0;\n    fEndCount = 0;\n    fFailureCount = 0;\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fResult = new TestResult();\n    fResult.addListener(this);\n    fStartCount = 0;\n    fEndCount = 0;\n    fFailureCount = 0;\n}"}, {"methodBefore": "protected void setUp() {\n    StringWriter swin = new StringWriter();\n    PrintWriter pwin = new PrintWriter(swin);\n    pwin.println(\"junit.framework.AssertionFailedError\");\n    pwin.println(\"\tat junit.framework.Assert.fail(Assert.java:144)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:19)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:26)\");\n    pwin.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwin.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    pwin.println(\"\tat java.lang.reflect.Method.invoke(Native Method)\");\n    pwin.println(\"\tat junit.framework.TestCase.runTest(TestCase.java:156)\");\n    pwin.println(\"\tat junit.framework.TestCase.runBare(TestCase.java:130)\");\n    pwin.println(\"\tat junit.framework.TestResult$1.protect(TestResult.java:100)\");\n    pwin.println(\"\tat junit.framework.TestResult.runProtected(TestResult.java:118)\");\n    pwin.println(\"\tat junit.framework.TestResult.run(TestResult.java:103)\");\n    pwin.println(\"\tat junit.framework.TestCase.run(TestCase.java:121)\");\n    pwin.println(\"\tat junit.framework.TestSuite.runTest(TestSuite.java:157)\");\n    pwin.println(\"\tat junit.framework.TestSuite.run(TestSuite.java, Compiled Code)\");\n    pwin.println(\"\tat junit.swingui.TestRunner$17.run(TestRunner.java:669)\");\n    fUnfiltered = swin.toString();\n    StringWriter swout = new StringWriter();\n    PrintWriter pwout = new PrintWriter(swout);\n    pwout.println(\"junit.framework.AssertionFailedError\");\n    pwout.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwout.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    fFiltered = swout.toString();\n}", "methodAfter": "@Override\nprotected void setUp() {\n    StringWriter swin = new StringWriter();\n    PrintWriter pwin = new PrintWriter(swin);\n    pwin.println(\"junit.framework.AssertionFailedError\");\n    pwin.println(\"\tat junit.framework.Assert.fail(Assert.java:144)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:19)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:26)\");\n    pwin.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwin.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    pwin.println(\"\tat java.lang.reflect.Method.invoke(Native Method)\");\n    pwin.println(\"\tat junit.framework.TestCase.runTest(TestCase.java:156)\");\n    pwin.println(\"\tat junit.framework.TestCase.runBare(TestCase.java:130)\");\n    pwin.println(\"\tat junit.framework.TestResult$1.protect(TestResult.java:100)\");\n    pwin.println(\"\tat junit.framework.TestResult.runProtected(TestResult.java:118)\");\n    pwin.println(\"\tat junit.framework.TestResult.run(TestResult.java:103)\");\n    pwin.println(\"\tat junit.framework.TestCase.run(TestCase.java:121)\");\n    pwin.println(\"\tat junit.framework.TestSuite.runTest(TestSuite.java:157)\");\n    pwin.println(\"\tat junit.framework.TestSuite.run(TestSuite.java, Compiled Code)\");\n    pwin.println(\"\tat junit.swingui.TestRunner$17.run(TestRunner.java:669)\");\n    fUnfiltered = swin.toString();\n    StringWriter swout = new StringWriter();\n    PrintWriter pwout = new PrintWriter(swout);\n    pwout.println(\"junit.framework.AssertionFailedError\");\n    pwout.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwout.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    fFiltered = swout.toString();\n}"}, {"methodBefore": "public boolean isPublic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isPublic(modifiers);\n}", "methodAfter": "@Override\npublic boolean isPublic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isPublic(modifiers);\n}"}, {"methodBefore": "public String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((fFailedTest + \": \") + fThrownException.getMessage());\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((fFailedTest + \": \") + fThrownException.getMessage());\n    return buffer.toString();\n}"}, {"methodBefore": "protected void collectInitializationErrors(List<Throwable> errors) {\n    getTestClass().validateMethodsForDefaultRunner(errors);\n}", "methodAfter": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    getTestClass().validateMethodsForDefaultRunner(errors);\n}"}, {"methodBefore": "protected void runFailed(String message) {\n    System.err.println(message);\n    System.exit(FAILURE_EXIT);\n}", "methodAfter": "@Override\nprotected void runFailed(String message) {\n    System.err.println(message);\n    System.exit(FAILURE_EXIT);\n}"}, {"methodBefore": "public void testEnded(String testName) {\n}", "methodAfter": "@Override\npublic void testEnded(String testName) {\n}"}], [{"methodBefore": "@Test\npublic void shouldThrowExceptionIfNotInstantiable() throws Exception {\n    expectedException.expect(FilterFactoryNotCreatedException.class);\n    FilterFactories.createFilterFactory(FilterFactoriesTest.NonInstantiableFilterFactory.class);\n}", "methodAfter": "@Test\npublic void shouldThrowExceptionIfNotInstantiable() throws Exception {\n    expectedException.expect(FilterNotCreatedException.class);\n    FilterFactories.createFilterFactory(FilterFactoriesTest.NonInstantiableFilterFactory.class);\n}"}, {"methodBefore": "@Test\npublic void shouldThrowExceptionIfNotFilterFactory() throws Exception {\n    expectedException.expect(FilterFactoryNotCreatedException.class);\n    FilterFactories.createFilterFactory(FilterFactoriesTest.NonFilterFactory.class.getName());\n}", "methodAfter": "@Test\npublic void shouldThrowExceptionIfNotFilterFactory() throws Exception {\n    expectedException.expect(FilterNotCreatedException.class);\n    FilterFactories.createFilterFactory(FilterFactoriesTest.NonFilterFactory.class.getName());\n}"}], [{"methodBefore": "@Test\npublic void unExpectedExceptionFails() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.HasWrongExpectedException.class), hasSingleFailureContaining(\"Unexpected exception, expected<java.lang.NullPointerException> but was<java.lang.IllegalArgumentException>\"));\n}", "methodAfter": "@Test\npublic void unExpectedExceptionFails() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.HasWrongExpectedException.class), hasSingleFailureContaining(\"Expected: an instance of java.lang.NullPointerException\"));\n}"}, {"methodBefore": "@Test\npublic void unExpectedExceptionFails() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.HasWrongExpectedException.class), hasSingleFailureContaining(\"Unexpected exception, expected<java.lang.NullPointerException> but was<java.lang.IllegalArgumentException>\"));\n}", "methodAfter": "@Test\npublic void unExpectedExceptionFails() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.HasWrongExpectedException.class), hasSingleFailureContaining(\"Expected: an instance of java.lang.NullPointerException\"));\n}"}], [{"methodBefore": "@Override\npublic void run(final RunNotifier notifier) {\n    new ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {\n        public void run() {\n            runChildren(notifier);\n        }\n    }).runProtected();\n}", "methodAfter": "@Override\npublic void run(final RunNotifier notifier) {\n    fTestClass.runProtected(notifier, getDescription(), new Runnable() {\n        public void run() {\n            runChildren(notifier);\n        }\n    });\n}"}, {"methodBefore": "@Override\npublic void run(final RunNotifier notifier) {\n    new ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {\n        public void run() {\n            runChildren(notifier);\n        }\n    }).runProtected();\n}", "methodAfter": "@Override\npublic void run(final RunNotifier notifier) {\n    fTestClass.runProtected(notifier, getDescription(), new Runnable() {\n        public void run() {\n            runChildren(notifier);\n        }\n    });\n}"}], [{"methodBefore": "@Test\npublic void newFolderWithGivenPathThrowsIllegalArgumentExceptionIfPathExists() throws IOException {\n    tempFolder.create();\n    tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"a folder with the name 'level3' already exists\");\n    tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n}", "methodAfter": "@Test\npublic void newFolderWithGivenPathThrowsIllegalArgumentExceptionIfPathExists() throws IOException {\n    tempFolder.create();\n    tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n    thrown.expect(IOException.class);\n    thrown.expectMessage(\"a folder with the name 'level3' already exists\");\n    tempFolder.newFolder(\"level1\", \"level2\", \"level3\");\n}"}, {"methodBefore": "@Test\npublic void newFileWithGivenFilenameThrowsIllegalArgumentExceptionIfFileExists() throws IOException {\n    tempFolder.create();\n    tempFolder.newFile(\"MyFile.txt\");\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"a file with the name 'MyFile.txt' already exists in the test folder\");\n    tempFolder.newFile(\"MyFile.txt\");\n}", "methodAfter": "@Test\npublic void newFileWithGivenFilenameThrowsIllegalArgumentExceptionIfFileExists() throws IOException {\n    tempFolder.create();\n    tempFolder.newFile(\"MyFile.txt\");\n    thrown.expect(IOException.class);\n    thrown.expectMessage(\"a file with the name 'MyFile.txt' already exists in the test folder\");\n    tempFolder.newFile(\"MyFile.txt\");\n}"}, {"methodBefore": "@Test\npublic void newFolderWithGivenFolderThrowsIllegalArgumentExceptionIfFolderExists() throws IOException {\n    tempFolder.create();\n    tempFolder.newFolder(\"level1\");\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"a folder with the name 'level1' already exists\");\n    tempFolder.newFolder(\"level1\");\n}", "methodAfter": "@Test\npublic void newFolderWithGivenFolderThrowsIllegalArgumentExceptionIfFolderExists() throws IOException {\n    tempFolder.create();\n    tempFolder.newFolder(\"level1\");\n    thrown.expect(IOException.class);\n    thrown.expectMessage(\"a folder with the name 'level1' already exists\");\n    tempFolder.newFolder(\"level1\");\n}"}], [{"methodBefore": "public Result run(Runner runner) {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    fNotifier.addFirstListener(listener);\n    try {\n        fNotifier.fireTestRunStarted(runner.getPlan());\n        runner.run(fNotifier);\n        fNotifier.fireTestRunFinished(result);\n    } finally {\n        removeListener(listener);\n    }\n    return result;\n}", "methodAfter": "public Result run(Runner runner) {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    fNotifier.addFirstListener(listener);\n    try {\n        fNotifier.fireTestRunStarted(runner.getDescription());\n        runner.run(fNotifier);\n        fNotifier.fireTestRunFinished(result);\n    } finally {\n        removeListener(listener);\n    }\n    return result;\n}"}, {"methodBefore": "public Result run(Runner runner) {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    fNotifier.addFirstListener(listener);\n    try {\n        fNotifier.fireTestRunStarted(runner.getPlan());\n        runner.run(fNotifier);\n        fNotifier.fireTestRunFinished(result);\n    } finally {\n        removeListener(listener);\n    }\n    return result;\n}", "methodAfter": "public Result run(Runner runner) {\n    Result result = new Result();\n    RunListener listener = result.createListener();\n    fNotifier.addFirstListener(listener);\n    try {\n        fNotifier.fireTestRunStarted(runner.getDescription());\n        runner.run(fNotifier);\n        fNotifier.fireTestRunFinished(result);\n    } finally {\n        removeListener(listener);\n    }\n    return result;\n}"}], [{"methodBefore": "@Override\nprotected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    return fMethods ? new ParallelRunner(testClass) : super.getRunner(builder, testClass);\n}", "methodAfter": "@Override\nprotected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    BlockJUnit4ClassRunner runner = ((BlockJUnit4ClassRunner) (super.getRunner(builder, testClass)));\n    return fMethods ? parallelize(runner) : runner;\n}"}, {"methodBefore": "@Override\nprotected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    return fMethods ? new ParallelRunner(testClass) : super.getRunner(builder, testClass);\n}", "methodAfter": "@Override\nprotected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    BlockJUnit4ClassRunner runner = ((BlockJUnit4ClassRunner) (super.getRunner(builder, testClass)));\n    return fMethods ? parallelize(runner) : runner;\n}"}], [{"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}, {"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}], [{"methodBefore": "public TestRunner(PrintStream writer) {\n    this();\n    fWriter = writer;\n}", "methodAfter": "public TestRunner(PrintStream writer) {\n    this();\n    if (writer == null) {\n        throw new IllegalArgumentException(\"Writer can't be null\");\n    }\n    fWriter = writer;\n}"}, {"methodBefore": "public TestRunner(PrintStream writer) {\n    this();\n    fWriter = writer;\n}", "methodAfter": "public TestRunner(PrintStream writer) {\n    this();\n    if (writer == null) {\n        throw new IllegalArgumentException(\"Writer can't be null\");\n    }\n    fWriter = writer;\n}"}], [{"methodBefore": "public TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}", "methodAfter": "public TestSuite(final Class<?> theClass) {\n    addTestsFromTestCase(theClass);\n}"}, {"methodBefore": "public TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}", "methodAfter": "public TestSuite(final Class<?> theClass) {\n    addTestsFromTestCase(theClass);\n}"}, {"methodBefore": "public TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}", "methodAfter": "public TestSuite(final Class<?> theClass) {\n    addTestsFromTestCase(theClass);\n}"}], [{"methodBefore": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "public void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}"}, {"methodBefore": "public void testStarted(String testName) {\n}", "methodAfter": "@Override\npublic void testStarted(String testName) {\n}"}], [{"methodBefore": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}", "methodAfter": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        if (ClassRule.class.isAssignableFrom(field.getType())) {\n            if (!Modifier.isStatic(field.getModifiers())) {\n                errors.add(new Exception((\"Field \" + field.getName()) + \" must be static\"));\n            }\n        } else {\n            errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule or ClassRule\"));\n        }\n    }\n}"}, {"methodBefore": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}", "methodAfter": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        if (ClassRule.class.isAssignableFrom(field.getType())) {\n            if (!Modifier.isStatic(field.getModifiers())) {\n                errors.add(new Exception((\"Field \" + field.getName()) + \" must be static\"));\n            }\n        } else {\n            errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule or ClassRule\"));\n        }\n    }\n}"}], [{"methodBefore": "private StatementInterceptor createInterceptor(Object test, FrameworkField each) {\n    try {\n        return ((StatementInterceptor) (each.get(test)));\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"How did getFields return a field we couldn't access?\");\n    }\n}", "methodAfter": "private MethodRule createRule(Object test, FrameworkField each) {\n    try {\n        return ((MethodRule) (each.get(test)));\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"How did getFields return a field we couldn't access?\");\n    }\n}"}, {"methodBefore": "private StatementInterceptor createInterceptor(Object test, FrameworkField each) {\n    try {\n        return ((StatementInterceptor) (each.get(test)));\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"How did getFields return a field we couldn't access?\");\n    }\n}", "methodAfter": "private MethodRule createRule(Object test, FrameworkField each) {\n    try {\n        return ((MethodRule) (each.get(test)));\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"How did getFields return a field we couldn't access?\");\n    }\n}"}], [{"methodBefore": "private void rerunTest(Test test) {\n    if (!(test instanceof TestCase)) {\n        showInfo(\"Could not reload \" + test.toString());\n        return;\n    }\n    Test reloadedTest = null;\n    try {\n        Class reloadedTestClass = getLoader().reload(test.getClass());\n        Class[] classArgs = new Class[]{ String.class };\n        Object[] args = new Object[]{ ((TestCase) (test)).name() };\n        Constructor constructor = reloadedTestClass.getConstructor(classArgs);\n        reloadedTest = ((Test) (constructor.newInstance(args)));\n    } catch (Exception e) {\n        showInfo(\"Could not reload \" + test.toString());\n        return;\n    }\n    TestResult result = new TestResult();\n    reloadedTest.run(result);\n    String message = reloadedTest.toString();\n    if (result.wasSuccessful()) {\n        showInfo(message + \" was successful\");\n    } else if (result.errorCount() == 1) {\n        showStatus(message + \" had an error\");\n    } else {\n        showStatus(message + \" had a failure\");\n    }\n}", "methodAfter": "private void rerunTest(Test test) {\n    if (!(test instanceof TestCase)) {\n        showInfo(\"Could not reload \" + test.toString());\n        return;\n    }\n    Test reloadedTest = null;\n    try {\n        Class reloadedTestClass = getLoader().reload(test.getClass());\n        Class[] classArgs = new Class[]{ String.class };\n        Object[] args = new Object[]{ ((TestCase) (test)).getName() };\n        Constructor constructor = reloadedTestClass.getConstructor(classArgs);\n        reloadedTest = ((Test) (constructor.newInstance(args)));\n    } catch (Exception e) {\n        showInfo(\"Could not reload \" + test.toString());\n        return;\n    }\n    TestResult result = new TestResult();\n    reloadedTest.run(result);\n    String message = reloadedTest.toString();\n    if (result.wasSuccessful()) {\n        showInfo(message + \" was successful\");\n    } else if (result.errorCount() == 1) {\n        showStatus(message + \" had an error\");\n    } else {\n        showStatus(message + \" had a failure\");\n    }\n}"}, {"methodBefore": "public void rerun() {\n    int index = fFailureList.getSelectedIndex();\n    if (index == (-1)) {\n        return;\n    }\n    Test test = ((Test) (fFailedTests.elementAt(index)));\n    if (!(test instanceof TestCase)) {\n        showInfo(\"Could not reload \" + test.toString());\n        return;\n    }\n    Test reloadedTest = null;\n    try {\n        Class reloadedTestClass = getLoader().reload(test.getClass());\n        Class[] classArgs = new Class[]{ String.class };\n        Constructor constructor = reloadedTestClass.getConstructor(classArgs);\n        Object[] args = new Object[]{ ((TestCase) (test)).name() };\n        reloadedTest = ((Test) (constructor.newInstance(args)));\n    } catch (Exception e) {\n        showInfo(\"Could not reload \" + test.toString());\n        return;\n    }\n    TestResult result = new TestResult();\n    reloadedTest.run(result);\n    String message = reloadedTest.toString();\n    if (result.wasSuccessful()) {\n        showInfo(message + \" was successful\");\n    } else if (result.errorCount() == 1) {\n        showStatus(message + \" had an error\");\n    } else {\n        showStatus(message + \" had a failure\");\n    }\n}", "methodAfter": "public void rerun() {\n    int index = fFailureList.getSelectedIndex();\n    if (index == (-1)) {\n        return;\n    }\n    Test test = ((Test) (fFailedTests.elementAt(index)));\n    if (!(test instanceof TestCase)) {\n        showInfo(\"Could not reload \" + test.toString());\n        return;\n    }\n    Test reloadedTest = null;\n    try {\n        Class reloadedTestClass = getLoader().reload(test.getClass());\n        Class[] classArgs = new Class[]{ String.class };\n        Constructor constructor = reloadedTestClass.getConstructor(classArgs);\n        Object[] args = new Object[]{ ((TestCase) (test)).getName() };\n        reloadedTest = ((Test) (constructor.newInstance(args)));\n    } catch (Exception e) {\n        showInfo(\"Could not reload \" + test.toString());\n        return;\n    }\n    TestResult result = new TestResult();\n    reloadedTest.run(result);\n    String message = reloadedTest.toString();\n    if (result.wasSuccessful()) {\n        showInfo(message + \" was successful\");\n    } else if (result.errorCount() == 1) {\n        showStatus(message + \" had an error\");\n    } else {\n        showStatus(message + \" had a failure\");\n    }\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "private String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}", "methodAfter": "private String parseMethod() {\n    Matcher matcher = methodStringMatcher();\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}"}, {"methodBefore": "private String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}", "methodAfter": "private String parseMethod() {\n    Matcher matcher = methodStringMatcher();\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}"}], [{"methodBefore": "private void runChildren(final RunNotifier notifier) {\n    for (final T each : getCachedChildren()) {\n        fScheduler.schedule(new Runnable() {\n            public void run() {\n                ParentRunner.this.runChild(each, notifier);\n            }\n        });\n    }\n    fScheduler.finished();\n}", "methodAfter": "private void runChildren(final RunNotifier notifier) {\n    for (final T each : getFilteredChildren()) {\n        fScheduler.schedule(new Runnable() {\n            public void run() {\n                ParentRunner.this.runChild(each, notifier);\n            }\n        });\n    }\n    fScheduler.finished();\n}"}, {"methodBefore": "private void runChildren(final RunNotifier notifier) {\n    for (final T each : getCachedChildren()) {\n        fScheduler.schedule(new Runnable() {\n            public void run() {\n                ParentRunner.this.runChild(each, notifier);\n            }\n        });\n    }\n    fScheduler.finished();\n}", "methodAfter": "private void runChildren(final RunNotifier notifier) {\n    for (final T each : getFilteredChildren()) {\n        fScheduler.schedule(new Runnable() {\n            public void run() {\n                ParentRunner.this.runChild(each, notifier);\n            }\n        });\n    }\n    fScheduler.finished();\n}"}], [{"methodBefore": "protected Description(final String displayName) {\n    fDisplayName = displayName;\n}", "methodAfter": "@Deprecated\nprotected Description(final String displayName) {\n    fDisplayName = displayName;\n}"}, {"methodBefore": "public static Request errorReport(Class<?> klass, Throwable cause) {\n    return runner(new ErrorReportingRunner(klass, cause));\n}", "methodAfter": "@Deprecated\npublic static Request errorReport(Class<?> klass, Throwable cause) {\n    return runner(new ErrorReportingRunner(klass, cause));\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}"}], [{"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return new RunBefores(statement, befores, target);\n}", "methodAfter": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return new RunBefores(statement, befores, target);\n}", "methodAfter": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}], [{"methodBefore": "public String getName() {\n    return fName;\n}", "methodAfter": "public String getName() {\n    return name;\n}"}, {"methodBefore": "public String getMethodName() {\n    return fName;\n}", "methodAfter": "public String getMethodName() {\n    return name;\n}"}, {"methodBefore": "@Override\nprotected String getName() {\n    return fName;\n}", "methodAfter": "@Override\nprotected String getName() {\n    return name;\n}"}], [{"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}"}, {"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}"}, {"methodBefore": "protected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory();\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec(FilterFactoryFactoryTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec(FilterFactoryFactoryTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFilter() throws Exception {\n    FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory();\n    Filter filter = filterFactoryFactory.createFilter(FilterFactoryFactoryTest.FilterFactoryStub.class, new NoFilterFactoryParams());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilter() throws Exception {\n    Filter filter = filterFactoryFactory.createFilter(FilterFactoryFactoryTest.FilterFactoryStub.class, new NoFilterFactoryParams());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}"}], [{"methodBefore": "public Description getDescription() {\n    return fRunner.getDescription();\n}", "methodAfter": "public Description getDescription() {\n    Description description = fRunner.getDescription();\n    return removeIgnored(description);\n}"}, {"methodBefore": "public Description getDescription() {\n    return fRunner.getDescription();\n}", "methodAfter": "public Description getDescription() {\n    Description description = fRunner.getDescription();\n    return removeIgnored(description);\n}"}, {"methodBefore": "public Description getDescription() {\n    return fRunner.getDescription();\n}", "methodAfter": "public Description getDescription() {\n    Description description = fRunner.getDescription();\n    return removeIgnored(description);\n}"}], [{"methodBefore": "@Override\nprotected Statement classBlock(RunNotifier notifier) {\n    return runChildren(notifier);\n}", "methodAfter": "@Override\nprotected Statement classBlock(RunNotifier notifier) {\n    return childrenInvoker(notifier);\n}"}, {"methodBefore": "@Override\nprotected Statement classBlock(RunNotifier notifier) {\n    return runChildren(notifier);\n}", "methodAfter": "@Override\nprotected Statement classBlock(RunNotifier notifier) {\n    return childrenInvoker(notifier);\n}"}], [{"methodBefore": "public List<Test> getTests() {\n    return fCache.asTestList(fRunner.getPlan());\n}", "methodAfter": "public List<Test> getTests() {\n    return fCache.asTestList(getDescription());\n}"}, {"methodBefore": "public List<Test> getTests() {\n    return fCache.asTestList(fRunner.getPlan());\n}", "methodAfter": "public List<Test> getTests() {\n    return fCache.asTestList(getDescription());\n}"}], [{"methodBefore": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n    for (T child : getFilteredChildren()) {\n        description.addChild(describeChild(child));\n    }\n    return description;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n    for (T child : getCachedChildren()) {\n        description.addChild(describeChild(child));\n    }\n    return description;\n}"}, {"methodBefore": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n    for (T child : getFilteredChildren()) {\n        description.addChild(describeChild(child));\n    }\n    return description;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n    for (T child : getCachedChildren()) {\n        description.addChild(describeChild(child));\n    }\n    return description;\n}"}, {"methodBefore": "private void runChildren(final RunNotifier notifier) {\n    for (final T each : getFilteredChildren()) {\n        fScheduler.schedule(new Runnable() {\n            public void run() {\n                ParentRunner.this.runChild(each, notifier);\n            }\n        });\n    }\n    fScheduler.finished();\n}", "methodAfter": "private void runChildren(final RunNotifier notifier) {\n    for (final T each : getCachedChildren()) {\n        fScheduler.schedule(new Runnable() {\n            public void run() {\n                ParentRunner.this.runChild(each, notifier);\n            }\n        });\n    }\n    fScheduler.finished();\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return statement(base);\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    return statement(base);\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return statement(base);\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    return statement(base);\n}"}], [{"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "private EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}", "methodAfter": "protected EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}"}, {"methodBefore": "private EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}", "methodAfter": "protected EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}"}, {"methodBefore": "public void failed(Throwable e, Description description) {\n}", "methodAfter": "protected void failed(Throwable e, Description description) {\n}"}], [{"methodBefore": "public IsCollectionContaining(Matcher<? extends T> elementMatcher) {\n    this.elementMatcher = elementMatcher;\n}", "methodAfter": "private IsCollectionContaining(Matcher<? super T> elementMatcher) {\n    super(elementMatcher);\n}"}, {"methodBefore": "public IsCollectionContaining(Matcher<? extends T> elementMatcher) {\n    this.elementMatcher = elementMatcher;\n}", "methodAfter": "private IsCollectionContaining(Matcher<? super T> elementMatcher) {\n    super(elementMatcher);\n}"}], [{"methodBefore": "public void testAssertFalse() {\n    assertFalse(false);\n    try {\n        assertFalse(true);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertFalse() {\n    assertFalse(false);\n    try {\n        assertFalse(true);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertSame() {\n    Object o = new Object();\n    assertSame(o, o);\n    try {\n        assertSame(new Integer(1), new Integer(1));\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertSame() {\n    Object o = new Object();\n    assertSame(o, o);\n    try {\n        assertSame(new Integer(1), new Integer(1));\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNaNEqualsNaNFails() {\n    try {\n        assertEquals(Double.NaN, Double.NaN, 0.0);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNaNEqualsNaNFails() {\n    try {\n        assertEquals(Double.NaN, Double.NaN, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertEquals() {\n    Object o = new Object();\n    assertEquals(o, o);\n    try {\n        assertEquals(new Object(), new Object());\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertEquals() {\n    Object o = new Object();\n    assertEquals(o, o);\n    try {\n        assertEquals(new Object(), new Object());\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertTrue() {\n    assertTrue(true);\n    try {\n        assertTrue(false);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertTrue() {\n    assertTrue(true);\n    try {\n        assertTrue(false);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertEqualsNaNFails() {\n    try {\n        assertEquals(1.234, Double.NaN, 0.0);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertEqualsNaNFails() {\n    try {\n        assertEquals(1.234, Double.NaN, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNaNEqualsFails() {\n    try {\n        assertEquals(Double.NaN, 1.234, 0.0);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNaNEqualsFails() {\n    try {\n        assertEquals(Double.NaN, 1.234, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNotSame() {\n    assertNotSame(new Integer(1), null);\n    assertNotSame(null, new Integer(1));\n    assertNotSame(new Integer(1), new Integer(1));\n    try {\n        Integer obj = new Integer(1);\n        assertNotSame(obj, obj);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNotSame() {\n    assertNotSame(new Integer(1), null);\n    assertNotSame(null, new Integer(1));\n    assertNotSame(new Integer(1), new Integer(1));\n    try {\n        Integer obj = new Integer(1);\n        assertNotSame(obj, obj);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNotNull() {\n    assertNotNull(new Object());\n    try {\n        assertNotNull(null);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNotNull() {\n    assertNotNull(new Object());\n    try {\n        assertNotNull(null);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNotSameFailsNull() {\n    try {\n        assertNotSame(null, null);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNotSameFailsNull() {\n    try {\n        assertNotSame(null, null);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}], [{"methodBefore": "public List<Throwable> getFailures() {\n    return fErrors;\n}", "methodAfter": "public List<Throwable> getFailures() {\n    return Collections.unmodifiableList(fErrors);\n}"}, {"methodBefore": "public List<Throwable> getCauses() {\n    return fErrors;\n}", "methodAfter": "public List<Throwable> getCauses() {\n    return Collections.unmodifiableList(fErrors);\n}"}], [{"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}], [{"methodBefore": "public void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}"}, {"methodBefore": "public void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}"}], [{"methodBefore": "public Statement intercept(final Statement base, final FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(method);\n            try {\n                base.evaluate();\n                succeeded(method);\n            } catch (Throwable t) {\n                failed(t, method);\n                throw t;\n            } finally {\n                finished(method);\n            }\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(method);\n            try {\n                base.evaluate();\n                succeeded(method);\n            } catch (Throwable t) {\n                failed(t, method);\n                throw t;\n            } finally {\n                finished(method);\n            }\n        }\n    };\n}"}, {"methodBefore": "public Statement intercept(final Statement base, final FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(method);\n            try {\n                base.evaluate();\n                succeeded(method);\n            } catch (Throwable t) {\n                failed(t, method);\n                throw t;\n            } finally {\n                finished(method);\n            }\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(method);\n            try {\n                base.evaluate();\n                succeeded(method);\n            } catch (Throwable t) {\n                failed(t, method);\n                throw t;\n            } finally {\n                finished(method);\n            }\n        }\n    };\n}"}], [{"methodBefore": "protected Suite(Class<?> klass, Class<?>[] annotatedClasses) throws InitializationError {\n    super(klass.getName());\n    addParent(klass);\n    for (Class<?> each : annotatedClasses) {\n        Runner childRunner = Request.aClass(each).getRunner();\n        if (childRunner != null) {\n            add(childRunner);\n        }\n    }\n    removeParent(klass);\n    fTestClass = new TestClass(klass);\n    ErrorList errors = new ErrorList();\n    fTestClass.validateStaticMethods(errors);\n    errors.assertEmpty();\n}", "methodAfter": "protected Suite(Class<?> klass, Class<?>[] annotatedClasses) throws InitializationError {\n    super(klass.getName());\n    addParent(klass);\n    for (Class<?> each : annotatedClasses) {\n        Runner childRunner = Request.aClass(each).getRunner();\n        if (childRunner != null) {\n            add(childRunner);\n        }\n    }\n    removeParent(klass);\n    fTestClass = new TestClass(klass);\n    List<Throwable> errors = new ArrayList<Throwable>();\n    fTestClass.validateStaticMethods(errors);\n    assertValid(errors);\n}"}, {"methodBefore": "private void validate() throws InitializationError {\n    ErrorList errors = new ErrorList();\n    collectInitializationErrors(errors);\n    errors.assertEmpty();\n}", "methodAfter": "private void validate() throws InitializationError {\n    List<Throwable> errors = new ArrayList<Throwable>();\n    collectInitializationErrors(errors);\n    assertValid(errors);\n}"}], [{"methodBefore": "public Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}, {"methodBefore": "public Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}], [{"methodBefore": "protected Statement withInterceptors(FrameworkMethod method, Object test, Statement statement) {\n    Statement result = statement;\n    for (FrameworkField each : interceptorFields()) {\n        try {\n            StatementInterceptor interceptor = ((StatementInterceptor) (each.get(test)));\n            result = interceptor.intercept(result, method);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"How did getFields return a field we couldn't access?\");\n        }\n    }\n    return result;\n}", "methodAfter": "private Statement withInterceptors(FrameworkMethod method, Object test, Statement statement) {\n    Statement result = statement;\n    for (StatementInterceptor each : interceptors(test)) {\n        result = each.intercept(result, method);\n    }\n    return result;\n}"}, {"methodBefore": "protected Statement withInterceptors(FrameworkMethod method, Object test, Statement statement) {\n    Statement result = statement;\n    for (FrameworkField each : interceptorFields()) {\n        try {\n            StatementInterceptor interceptor = ((StatementInterceptor) (each.get(test)));\n            result = interceptor.intercept(result, method);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"How did getFields return a field we couldn't access?\");\n        }\n    }\n    return result;\n}", "methodAfter": "private Statement withInterceptors(FrameworkMethod method, Object test, Statement statement) {\n    Statement result = statement;\n    for (StatementInterceptor each : interceptors(test)) {\n        result = each.intercept(result, method);\n    }\n    return result;\n}"}], [{"methodBefore": "@Override\npublic void evaluate() throws Throwable {\n    try {\n        fNext.evaluate();\n    } catch (Throwable e) {\n        if (fMatcher == null) {\n            throw e;\n        }\n        Assert.assertThat(e, fMatcher);\n        return;\n    }\n    if (fMatcher != null) {\n        throw new AssertionError(\"Expected test to throw \" + StringDescription.toString(fMatcher));\n    }\n}", "methodAfter": "@Override\npublic void evaluate() throws Throwable {\n    try {\n        fNext.evaluate();\n    } catch (Throwable e) {\n        if (fMatcher == null) {\n            throw e;\n        }\n        Assert.assertThat(e, matches(fMatcher));\n        return;\n    }\n    if (fMatcher != null) {\n        throw new AssertionError(\"Expected test to throw \" + StringDescription.toString(fMatcher));\n    }\n}"}, {"methodBefore": "@Override\npublic void evaluate() throws Throwable {\n    try {\n        fNext.evaluate();\n    } catch (Throwable e) {\n        if (fMatcher == null) {\n            throw e;\n        }\n        Assert.assertThat(e, fMatcher);\n        return;\n    }\n    if (fMatcher != null) {\n        throw new AssertionError(\"Expected test to throw \" + StringDescription.toString(fMatcher));\n    }\n}", "methodAfter": "@Override\npublic void evaluate() throws Throwable {\n    try {\n        fNext.evaluate();\n    } catch (Throwable e) {\n        if (fMatcher == null) {\n            throw e;\n        }\n        Assert.assertThat(e, matches(fMatcher));\n        return;\n    }\n    if (fMatcher != null) {\n        throw new AssertionError(\"Expected test to throw \" + StringDescription.toString(fMatcher));\n    }\n}"}], [{"methodBefore": "@After\npublic void forgetMax() {\n    MaxHistory history = fMax.fHistory;\n    history.forget();\n}", "methodAfter": "@After\npublic void forgetMax() {\n    fMaxFile.delete();\n}"}, {"methodBefore": "@After\npublic void forgetMax() {\n    MaxHistory history = fMax.fHistory;\n    history.forget();\n}", "methodAfter": "@After\npublic void forgetMax() {\n    fMaxFile.delete();\n}"}], [{"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}, {"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}], [{"methodBefore": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}, {"methodBefore": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}], [{"methodBefore": "public final TestClass getTestClass() {\n    return fTestClass;\n}", "methodAfter": "public final TestClass getTestClass() {\n    return testClass;\n}"}, {"methodBefore": "public TestClass getTestClass() {\n    return fTestClass;\n}", "methodAfter": "public TestClass getTestClass() {\n    return testClass;\n}"}], [{"methodBefore": "public void printErrors(TestResult result) {\n    if (result.errorCount() != 0) {\n        if (result.errorCount() == 1) {\n            writer().println((\"There was \" + result.errorCount()) + \" error:\");\n        } else {\n            writer().println((\"There were \" + result.errorCount()) + \" errors:\");\n        }\n        int i = 1;\n        for (Enumeration e = result.errors(); e.hasMoreElements(); i++) {\n            TestFailure failure = ((TestFailure) (e.nextElement()));\n            writer().println((i + \") \") + failure.failedTest());\n            failure.thrownException().printStackTrace(writer());\n        }\n    }\n}", "methodAfter": "public void printErrors(TestResult result) {\n    if (result.errorCount() != 0) {\n        if (result.errorCount() == 1) {\n            writer().println((\"There was \" + result.errorCount()) + \" error:\");\n        } else {\n            writer().println((\"There were \" + result.errorCount()) + \" errors:\");\n        }\n        int i = 1;\n        for (Enumeration e = result.errors(); e.hasMoreElements(); i++) {\n            TestFailure failure = ((TestFailure) (e.nextElement()));\n            writer().println((i + \") \") + failure.failedTest());\n            writer().print(getFilteredTrace(failure.thrownException()));\n        }\n    }\n}"}, {"methodBefore": "public void printFailures(TestResult result) {\n    if (result.failureCount() != 0) {\n        if (result.failureCount() == 1) {\n            writer().println((\"There was \" + result.failureCount()) + \" failure:\");\n        } else {\n            writer().println((\"There were \" + result.failureCount()) + \" failures:\");\n        }\n        int i = 1;\n        for (Enumeration e = result.failures(); e.hasMoreElements(); i++) {\n            TestFailure failure = ((TestFailure) (e.nextElement()));\n            writer().print((i + \") \") + failure.failedTest());\n            Throwable t = failure.thrownException();\n            if (t.getMessage() != null) {\n                writer().println((\" \\\"\" + truncate(t.getMessage())) + \"\\\"\");\n            } else {\n                writer().println();\n                failure.thrownException().printStackTrace(writer());\n            }\n        }\n    }\n}", "methodAfter": "public void printFailures(TestResult result) {\n    if (result.failureCount() != 0) {\n        if (result.failureCount() == 1) {\n            writer().println((\"There was \" + result.failureCount()) + \" failure:\");\n        } else {\n            writer().println((\"There were \" + result.failureCount()) + \" failures:\");\n        }\n        int i = 1;\n        for (Enumeration e = result.failures(); e.hasMoreElements(); i++) {\n            TestFailure failure = ((TestFailure) (e.nextElement()));\n            writer().print((i + \") \") + failure.failedTest());\n            Throwable t = failure.thrownException();\n            if (t.getMessage() != null) {\n                writer().println((\" \\\"\" + truncate(t.getMessage())) + \"\\\"\");\n            } else {\n                writer().println();\n                writer().print(getFilteredTrace(failure.thrownException()));\n            }\n        }\n    }\n}"}], [{"methodBefore": "protected List<StatementInterceptor> interceptors(Object test) {\n    List<StatementInterceptor> results = new ArrayList<StatementInterceptor>();\n    for (FrameworkField each : interceptorFields()) {\n        results.add(createInterceptor(test, each));\n    }\n    return results;\n}", "methodAfter": "protected List<MethodRule> rules(Object test) {\n    List<MethodRule> results = new ArrayList<MethodRule>();\n    for (FrameworkField each : ruleFields()) {\n        results.add(createRule(test, each));\n    }\n    return results;\n}"}, {"methodBefore": "protected List<StatementInterceptor> interceptors(Object test) {\n    List<StatementInterceptor> results = new ArrayList<StatementInterceptor>();\n    for (FrameworkField each : interceptorFields()) {\n        results.add(createInterceptor(test, each));\n    }\n    return results;\n}", "methodAfter": "protected List<MethodRule> rules(Object test) {\n    List<MethodRule> results = new ArrayList<MethodRule>();\n    for (FrameworkField each : ruleFields()) {\n        results.add(createRule(test, each));\n    }\n    return results;\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testOneTestCaseEclipseSeesSameStructureAs381\"));\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testOneTestCaseEclipseSeesSameStructureAs381\"));\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testOneTestCaseEclipseSeesSameStructureAs381\"));\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}"}], [{"methodBefore": "public AssumptionViolatedException(String assumption, Object value, Matcher<?> matcher) {\n    this(assumption, true, value, matcher);\n}", "methodAfter": "@Deprecated\npublic AssumptionViolatedException(String assumption, Object value, Matcher<?> matcher) {\n    this(assumption, true, value, matcher);\n}"}, {"methodBefore": "public AssumptionViolatedException(Object value, Matcher<?> matcher) {\n    this(null, true, value, matcher);\n}", "methodAfter": "@Deprecated\npublic AssumptionViolatedException(Object value, Matcher<?> matcher) {\n    this(null, true, value, matcher);\n}"}], [{"methodBefore": "@Test\npublic void descriptionAndRunNotificationsAreConsistent() {\n    Result result = JUnitCore.runClasses(SuiteMethodTest.CompatibilityTest.class);\n    assertEquals(0, result.getIgnoreCount());\n    Runner runner = Request.aClass(SuiteMethodTest.CompatibilityTest.class).getRunner();\n    Plan plan = runner.getPlan();\n    assertEquals(1, plan.getChildren().size());\n    assertEquals(\"initializationError\", plan.getChildren().get(0).getDescription().getMethodName());\n}", "methodAfter": "@Test\npublic void descriptionAndRunNotificationsAreConsistent() {\n    Result result = JUnitCore.runClasses(SuiteMethodTest.CompatibilityTest.class);\n    assertEquals(0, result.getIgnoreCount());\n    Description description = Request.aClass(SuiteMethodTest.CompatibilityTest.class).getRunner().getDescription();\n    assertEquals(0, description.getChildren().size());\n}"}, {"methodBefore": "@Test\npublic void descriptionAndRunNotificationsAreConsistent() {\n    Result result = JUnitCore.runClasses(SuiteMethodTest.CompatibilityTest.class);\n    assertEquals(0, result.getIgnoreCount());\n    Runner runner = Request.aClass(SuiteMethodTest.CompatibilityTest.class).getRunner();\n    Plan plan = runner.getPlan();\n    assertEquals(1, plan.getChildren().size());\n    assertEquals(\"initializationError\", plan.getChildren().get(0).getDescription().getMethodName());\n}", "methodAfter": "@Test\npublic void descriptionAndRunNotificationsAreConsistent() {\n    Result result = JUnitCore.runClasses(SuiteMethodTest.CompatibilityTest.class);\n    assertEquals(0, result.getIgnoreCount());\n    Description description = Request.aClass(SuiteMethodTest.CompatibilityTest.class).getRunner().getDescription();\n    assertEquals(0, description.getChildren().size());\n}"}], [{"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}, {"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}"}], [{"methodBefore": "public void expect(Matcher<?> matcher) {\n    matcherBuilder.add(matcher);\n}", "methodAfter": "@Deprecated\npublic void expect(Matcher<?> matcher) {\n    matcherBuilder.add(matcher);\n}"}, {"methodBefore": "public AssumptionViolatedException(Object value, Matcher<?> matcher) {\n    this(null, true, value, matcher);\n}", "methodAfter": "@Deprecated\npublic AssumptionViolatedException(Object value, Matcher<?> matcher) {\n    this(null, true, value, matcher);\n}"}, {"methodBefore": "public AssumptionViolatedException(String assumption) {\n    this(assumption, false, null, null);\n}", "methodAfter": "@Deprecated\npublic AssumptionViolatedException(String assumption) {\n    this(assumption, false, null, null);\n}"}, {"methodBefore": "public void expectCause(Matcher<? extends Throwable> expectedCause) {\n    expect(hasCause(expectedCause));\n}", "methodAfter": "@Deprecated\npublic void expectCause(Matcher<? extends Throwable> expectedCause) {\n    expect(hasCause(expectedCause));\n}"}, {"methodBefore": "public AssumptionViolatedException(String assumption, Object value, Matcher<?> matcher) {\n    this(assumption, true, value, matcher);\n}", "methodAfter": "@Deprecated\npublic AssumptionViolatedException(String assumption, Object value, Matcher<?> matcher) {\n    this(assumption, true, value, matcher);\n}"}, {"methodBefore": "public void expectMessage(Matcher<String> matcher) {\n    expect(hasMessage(matcher));\n}", "methodAfter": "@Deprecated\npublic void expectMessage(Matcher<String> matcher) {\n    expect(hasMessage(matcher));\n}"}, {"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}], [{"methodBefore": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new JUnit4ClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}", "methodAfter": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new BlockJUnit4ClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}"}, {"methodBefore": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new JUnit4ClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}", "methodAfter": "private List<Throwable> validateAllMethods(Class<?> clazz) {\n    try {\n        new BlockJUnit4ClassRunner(clazz);\n    } catch (InitializationError e) {\n        return e.getCauses();\n    }\n    return Collections.emptyList();\n}"}], [{"methodBefore": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    ensureKey(fMethodsForAnnotations, annotationClass);\n    return fMethodsForAnnotations.get(annotationClass);\n}", "methodAfter": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    return getAnnotatedMembers(fMethodsForAnnotations, annotationClass);\n}"}, {"methodBefore": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    ensureKey(fMethodsForAnnotations, annotationClass);\n    return fMethodsForAnnotations.get(annotationClass);\n}", "methodAfter": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    return getAnnotatedMembers(fMethodsForAnnotations, annotationClass);\n}"}], [{"methodBefore": "public static void assertEquals(String message, double expected, double actual) {\n    fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n}", "methodAfter": "@Deprecated\npublic static void assertEquals(String message, double expected, double actual) {\n    fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}], [{"methodBefore": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}], [{"methodBefore": "private List<FrameworkField> interceptorFields() {\n    return getTestClass().getAnnotatedFields(Interceptor.class);\n}", "methodAfter": "private List<FrameworkField> ruleFields() {\n    return getTestClass().getAnnotatedFields(Rule.class);\n}"}, {"methodBefore": "private List<FrameworkField> interceptorFields() {\n    return getTestClass().getAnnotatedFields(Interceptor.class);\n}", "methodAfter": "private List<FrameworkField> ruleFields() {\n    return getTestClass().getAnnotatedFields(Rule.class);\n}"}], [{"methodBefore": "public static void assertEquals(String message, double expected, double actual) {\n    fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n}", "methodAfter": "@Deprecated\npublic static void assertEquals(String message, double expected, double actual) {\n    fail(\"Use assertEquals(expected, actual, delta) to compare floating-point numbers\");\n}"}, {"methodBefore": "public static void assertEquals(double expected, double actual) {\n    assertEquals(null, expected, actual);\n}", "methodAfter": "@Deprecated\npublic static void assertEquals(double expected, double actual) {\n    assertEquals(null, expected, actual);\n}"}], [{"methodBefore": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}", "methodAfter": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}"}, {"methodBefore": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}", "methodAfter": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}"}], [{"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}, {"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}], [{"methodBefore": "@Test\npublic void throwExceptionWithNiceMessageOnTimeout() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwExceptionWithNiceMessageOnTimeout() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n}"}, {"methodBefore": "@Test\npublic void throwsExceptionWithTimeoutValueAndTimeUnitSet() throws Throwable {\n    try {\n        evaluateWithWaitDuration(TIMEOUT + 50);\n        fail(\"No exception was thrown when test timed out\");\n    } catch (TestTimedOutException e) {\n        assertEquals(TIMEOUT, e.getTimeout());\n        assertEquals(TimeUnit.MILLISECONDS, e.getTimeUnit());\n    }\n}", "methodAfter": "@Test\npublic void throwsExceptionWithTimeoutValueAndTimeUnitSet() throws Throwable {\n    try {\n        evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n        fail(\"No exception was thrown when test timed out\");\n    } catch (TestTimedOutException e) {\n        assertEquals(TIMEOUT, e.getTimeout());\n        assertEquals(TimeUnit.MILLISECONDS, e.getTimeUnit());\n    }\n}"}, {"methodBefore": "@Test\npublic void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    try {\n        evaluateWithException(new RuntimeException());\n    } catch (Throwable expected) {\n    }\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    try {\n        evaluateWithException(new RuntimeException());\n    } catch (Throwable expected) {\n    }\n    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n}"}, {"methodBefore": "@Test\npublic void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime() throws Throwable {\n    thrown.expect(TestTimedOutException.class);\n    evaluateWithWaitDuration(0);\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime() throws Throwable {\n    thrown.expect(TestTimedOutException.class);\n    evaluateWithWaitDuration(0);\n    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n}"}], [{"methodBefore": "private String getMessage(Throwable e) {\n    return e.getMessage() == null ? \"\" : e.getMessage();\n}", "methodAfter": "@Override\nprotected String featureValueOf(Throwable actual) {\n    return actual.getMessage();\n}"}, {"methodBefore": "private String getMessage(Throwable e) {\n    return e.getMessage() == null ? \"\" : e.getMessage();\n}", "methodAfter": "@Override\nprotected String featureValueOf(Throwable actual) {\n    return actual.getMessage();\n}"}], [{"methodBefore": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    new ExactComparisonCriteria().internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    new ExactComparisonCriteria().internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);\n}"}], [{"methodBefore": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    return statement;\n}", "methodAfter": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withInterceptors(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    return statement;\n}"}, {"methodBefore": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    return statement;\n}", "methodAfter": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withInterceptors(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    return statement;\n}"}], [{"methodBefore": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}], [{"methodBefore": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    return Request.method(type, each.getMethodName()).getRunner();\n}", "methodAfter": "public Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}, {"methodBefore": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    return Request.method(type, each.getMethodName()).getRunner();\n}", "methodAfter": "public Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}], [{"methodBefore": "public Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        return Suite.emptySuite();\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}, {"methodBefore": "public Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        return Suite.emptySuite();\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}], [{"methodBefore": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(is(Integer.class)).and(matches(is(3))));\n}", "methodAfter": "@Test\npublic void superclassesAreOkInSecondPositionOnly() {\n    assertThat(\"a\", both(containsString(\"a\")).and(matches(is(String.class))));\n}"}, {"methodBefore": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(is(Integer.class)).and(matches(is(3))));\n}", "methodAfter": "@Test\npublic void superclassesAreOkInSecondPositionOnly() {\n    assertThat(\"a\", both(containsString(\"a\")).and(matches(is(String.class))));\n}"}], [{"methodBefore": "public void validateAnnotatedMethod(Method method, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_METHOD_CALLED));\n}", "methodAfter": "@Override\npublic void validateAnnotatedMethod(Method method, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_METHOD_CALLED));\n}"}, {"methodBefore": "public void validateAnnotatedClass(Class<?> type, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_CLASS_CALLED));\n}", "methodAfter": "@Override\npublic void validateAnnotatedClass(Class<?> type, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_CLASS_CALLED));\n}"}, {"methodBefore": "public void validateAnnotatedField(Field field, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_FIELD_CALLED));\n}", "methodAfter": "@Override\npublic void validateAnnotatedField(Field field, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_FIELD_CALLED));\n}"}], [{"methodBefore": "public static void assertEquals(double expected, double actual) {\n    assertEquals(null, expected, actual);\n}", "methodAfter": "@Deprecated\npublic static void assertEquals(double expected, double actual) {\n    assertEquals(null, expected, actual);\n}"}, {"methodBefore": "public AssumptionViolatedException(String assumption) {\n    this(assumption, false, null, null);\n}", "methodAfter": "@Deprecated\npublic AssumptionViolatedException(String assumption) {\n    this(assumption, false, null, null);\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}, {"methodBefore": "protected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}"}, {"methodBefore": "public void expect(Matcher<?> matcher) {\n    matcherBuilder.add(matcher);\n}", "methodAfter": "@Deprecated\npublic void expect(Matcher<?> matcher) {\n    matcherBuilder.add(matcher);\n}"}, {"methodBefore": "public void testRunStarted(Description description) throws Exception {\n}", "methodAfter": "@Deprecated\npublic void testRunStarted(Description description) throws Exception {\n}"}, {"methodBefore": "protected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}"}, {"methodBefore": "public AssumptionViolatedException(String assumption, Object value, Matcher<?> matcher) {\n    this(assumption, true, value, matcher);\n}", "methodAfter": "@Deprecated\npublic AssumptionViolatedException(String assumption, Object value, Matcher<?> matcher) {\n    this(assumption, true, value, matcher);\n}"}, {"methodBefore": "protected void validateInstanceMethods(List<Throwable> errors) {\n    validatePublicVoidNoArgMethods(After.class, false, errors);\n    validatePublicVoidNoArgMethods(Before.class, false, errors);\n    validateTestMethods(errors);\n    if (computeTestMethods().size() == 0) {\n        errors.add(new Exception(\"No runnable methods\"));\n    }\n}", "methodAfter": "@Deprecated\nprotected void validateInstanceMethods(List<Throwable> errors) {\n    validatePublicVoidNoArgMethods(After.class, false, errors);\n    validatePublicVoidNoArgMethods(Before.class, false, errors);\n    validateTestMethods(errors);\n    if (computeTestMethods().size() == 0) {\n        errors.add(new Exception(\"No runnable methods\"));\n    }\n}"}, {"methodBefore": "public AssumptionViolatedException(Object value, Matcher<?> matcher) {\n    this(null, true, value, matcher);\n}", "methodAfter": "@Deprecated\npublic AssumptionViolatedException(Object value, Matcher<?> matcher) {\n    this(null, true, value, matcher);\n}"}], [{"methodBefore": "@After\npublic void forgetMax() {\n    fMax.forget();\n}", "methodAfter": "@After\npublic void forgetMax() {\n    fMax.fHistory.forget();\n}"}, {"methodBefore": "@After\npublic void forgetMax() {\n    fMax.forget();\n}", "methodAfter": "@After\npublic void forgetMax() {\n    fMax.fHistory.forget();\n}"}], [{"methodBefore": "public void testRunAndTearDownFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void tearDown() {\n            super.tearDown();\n            throw new Error();\n        }\n\n        protected void runTest() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assert fails.fTornDown;\n}", "methodAfter": "public void testRunAndTearDownFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void tearDown() {\n            super.tearDown();\n            throw new Error();\n        }\n\n        protected void runTest() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assertTrue(fails.fTornDown);\n}"}, {"methodBefore": "public void testTearDownAfterError() {\n    TornDown fails = new TornDown(\"fails\");\n    verifyError(fails);\n    assert fails.fTornDown;\n}", "methodAfter": "public void testTearDownAfterError() {\n    TornDown fails = new TornDown(\"fails\");\n    verifyError(fails);\n    assertTrue(fails.fTornDown);\n}"}], [{"methodBefore": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = MaxCore.storedLocally(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = MaxCore.storedLocally(fMaxFile);\n}"}], [{"methodBefore": "public String getName() {\n    return getField().getName();\n}", "methodAfter": "@Override\npublic String getName() {\n    return getField().getName();\n}"}, {"methodBefore": "public boolean equals(Object anObject) {\n    if (isZero()) {\n        if (anObject instanceof IMoney) {\n            return ((IMoney) (anObject)).isZero();\n        }\n    }\n    if (anObject instanceof Money) {\n        Money aMoney = ((Money) (anObject));\n        return aMoney.currency().equals(currency()) && (amount() == aMoney.amount());\n    }\n    return false;\n}", "methodAfter": "@Override\npublic boolean equals(Object anObject) {\n    if (isZero()) {\n        if (anObject instanceof IMoney) {\n            return ((IMoney) (anObject)).isZero();\n        }\n    }\n    if (anObject instanceof Money) {\n        Money aMoney = ((Money) (anObject));\n        return aMoney.currency().equals(currency()) && (amount() == aMoney.amount());\n    }\n    return false;\n}"}], [{"methodBefore": "public static PrintableResult testResult(Class<?> type) {\n    return new PrintableResult(type);\n}", "methodAfter": "public static PrintableResult testResult(Class<?> type) {\n    return testResult(type, new Computer());\n}"}, {"methodBefore": "public static PrintableResult testResult(Class<?> type) {\n    return new PrintableResult(type);\n}", "methodAfter": "public static PrintableResult testResult(Class<?> type) {\n    return testResult(type, new Computer());\n}"}], [{"methodBefore": "public Runner getSuite(final RunnerBuilder builder, Class<?>[] classes) throws InitializationError {\n    return new Suite(new RunnerBuilder() {\n        @Override\n        public Runner runnerForClass(Class<?> testClass) throws Throwable {\n            return getRunner(builder, testClass);\n        }\n    }, classes);\n}", "methodAfter": "public Runner getSuite(final RunnerBuilder builder, Class<?>[] classes) throws InitializationError {\n    return modify(new Suite(new RunnerBuilder() {\n        @Override\n        public Runner runnerForClass(Class<?> testClass) throws Throwable {\n            return getRunner(builder, testClass);\n        }\n    }, classes));\n}"}, {"methodBefore": "public Runner getSuite(final RunnerBuilder builder, Class<?>[] classes) throws InitializationError {\n    return new Suite(new RunnerBuilder() {\n        @Override\n        public Runner runnerForClass(Class<?> testClass) throws Throwable {\n            return getRunner(builder, testClass);\n        }\n    }, classes);\n}", "methodAfter": "public Runner getSuite(final RunnerBuilder builder, Class<?>[] classes) throws InitializationError {\n    return modify(new Suite(new RunnerBuilder() {\n        @Override\n        public Runner runnerForClass(Class<?> testClass) throws Throwable {\n            return getRunner(builder, testClass);\n        }\n    }, classes));\n}"}], [{"methodBefore": "public void expect(Class<? extends Throwable> type) {\n    fType = type;\n}", "methodAfter": "public void expect(Class<? extends Throwable> type) {\n    fMatcher = instanceOf(type);\n}"}, {"methodBefore": "public void expect(Class<? extends Throwable> type) {\n    fType = type;\n}", "methodAfter": "public void expect(Class<? extends Throwable> type) {\n    fMatcher = instanceOf(type);\n}"}], [{"methodBefore": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    if (expecteds == actuals) {\n        return;\n    }\n    String header = (message == null) ? \"\" : message + \": \";\n    int expectedsLength = assertArraysAreSameLength(expecteds, actuals, header);\n    for (int i = 0; i < expectedsLength; i++) {\n        Object expected = Array.get(expecteds, i);\n        Object actual = Array.get(actuals, i);\n        if (isArray(expected) && isArray(actual)) {\n            try {\n                internalArrayEquals(message, expected, actual);\n            } catch (ArrayComparisonFailure e) {\n                e.addDimension(i);\n                throw e;\n            }\n        } else {\n            try {\n                assertEquals(expected, actual);\n            } catch (AssertionError e) {\n                throw new ArrayComparisonFailure(header, e, i);\n            }\n        }\n    }\n}", "methodAfter": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    new ExactComparisonCriteria().internalArrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    if (expecteds == actuals) {\n        return;\n    }\n    String header = (message == null) ? \"\" : message + \": \";\n    int expectedsLength = assertArraysAreSameLength(expecteds, actuals, header);\n    for (int i = 0; i < expectedsLength; i++) {\n        Object expected = Array.get(expecteds, i);\n        Object actual = Array.get(actuals, i);\n        if (isArray(expected) && isArray(actual)) {\n            try {\n                internalArrayEquals(message, expected, actual);\n            } catch (ArrayComparisonFailure e) {\n                e.addDimension(i);\n                throw e;\n            }\n        } else {\n            try {\n                assertEquals(expected, actual);\n            } catch (AssertionError e) {\n                throw new ArrayComparisonFailure(header, e, i);\n            }\n        }\n    }\n}", "methodAfter": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    new ExactComparisonCriteria().internalArrayEquals(message, expecteds, actuals);\n}"}], [{"methodBefore": "void save() throws FileNotFoundException, IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder + \".ser\"));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "public void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}"}, {"methodBefore": "void save() throws FileNotFoundException, IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder + \".ser\"));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "public void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}"}], [{"methodBefore": "public TestRunner(PrintStream writer) {\n    this();\n    fWriter = writer;\n}", "methodAfter": "public TestRunner(PrintStream writer) {\n    this();\n    if (writer == null) {\n        throw new IllegalArgumentException(\"Writer can't be null\");\n    }\n    fWriter = writer;\n}"}, {"methodBefore": "public TestRunner(PrintStream writer) {\n    this();\n    fWriter = writer;\n}", "methodAfter": "public TestRunner(PrintStream writer) {\n    this();\n    if (writer == null) {\n        throw new IllegalArgumentException(\"Writer can't be null\");\n    }\n    fWriter = writer;\n}"}], [{"methodBefore": "@Override\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}", "methodAfter": "@Override\npublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}"}, {"methodBefore": "@Override\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}", "methodAfter": "@Override\npublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}"}], [{"methodBefore": "public String getClassName() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    return matcher.matches() ? matcher.group(2) : toString();\n}", "methodAfter": "public String getClassName() {\n    Matcher matcher = methodStringMatcher();\n    return matcher.matches() ? matcher.group(2) : toString();\n}"}, {"methodBefore": "public String getClassName() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    return matcher.matches() ? matcher.group(2) : toString();\n}", "methodAfter": "public String getClassName() {\n    Matcher matcher = methodStringMatcher();\n    return matcher.matches() ? matcher.group(2) : toString();\n}"}], [{"methodBefore": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method, getTestClass());\n}"}, {"methodBefore": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method, getTestClass());\n}"}], [{"methodBefore": "protected void validateFields(List<Throwable> errors) {\n    for (FrameworkField each : interceptorFields()) {\n        validateInterceptorField(each.getField(), errors);\n    }\n}", "methodAfter": "protected void validateFields(List<Throwable> errors) {\n    for (FrameworkField each : ruleFields()) {\n        validateInterceptorField(each.getField(), errors);\n    }\n}"}, {"methodBefore": "protected void validateFields(List<Throwable> errors) {\n    for (FrameworkField each : interceptorFields()) {\n        validateInterceptorField(each.getField(), errors);\n    }\n}", "methodAfter": "protected void validateFields(List<Throwable> errors) {\n    for (FrameworkField each : ruleFields()) {\n        validateInterceptorField(each.getField(), errors);\n    }\n}"}], [{"methodBefore": "@Override\npublic Description getDescription() {\n    if (fDescription == null) {\n        fDescription = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n        for (T child : getCachedChildren()) {\n            fDescription.addChild(describeChild(child));\n        }\n    }\n    return fDescription;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n    for (T child : getFilteredChildren()) {\n        description.addChild(describeChild(child));\n    }\n    return description;\n}"}, {"methodBefore": "@Override\npublic Description getDescription() {\n    if (fDescription == null) {\n        fDescription = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n        for (T child : getCachedChildren()) {\n            fDescription.addChild(describeChild(child));\n        }\n    }\n    return fDescription;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(getName(), fTestClass.getAnnotations());\n    for (T child : getFilteredChildren()) {\n        description.addChild(describeChild(child));\n    }\n    return description;\n}"}], [{"methodBefore": "@Test\npublic void subFolderIsDeleted() {\n    assertThat(testResult(TempFolderRuleTest.CreatesSubFolder.class), isSuccessful());\n    assertFalse(createdFile.exists());\n}", "methodAfter": "@Test\npublic void subFolderIsDeleted() {\n    assertThat(testResult(TempFolderRuleTest.CreatesSubFolder.class), isSuccessful());\n    assertFalse(createdFiles[0].exists());\n}"}, {"methodBefore": "@Test\npublic void tempFolderIsDeleted() {\n    assertThat(testResult(TempFolderRuleTest.HasTempFolder.class), isSuccessful());\n    assertFalse(createdFile.exists());\n}", "methodAfter": "@Test\npublic void tempFolderIsDeleted() {\n    assertThat(testResult(TempFolderRuleTest.HasTempFolder.class), isSuccessful());\n    assertFalse(createdFiles[0].exists());\n}"}], [{"methodBefore": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    String storedResults = fMax.fHistory.getFolder();\n    MaxCore reincarnation = MaxCore.forFolder(storedResults);\n    try {\n        List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n        assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n        assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n    } finally {\n        reincarnation.fHistory.forget();\n    }\n}", "methodAfter": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore reincarnation = MaxCore.forFolder(fMaxFile);\n    List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n    assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n    assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n}"}, {"methodBefore": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    String storedResults = fMax.fHistory.getFolder();\n    MaxCore reincarnation = MaxCore.forFolder(storedResults);\n    try {\n        List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n        assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n        assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n    } finally {\n        reincarnation.fHistory.forget();\n    }\n}", "methodAfter": "@Test\npublic void rememberOldRuns() {\n    fMax.run(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore reincarnation = MaxCore.forFolder(fMaxFile);\n    List<Failure> failures = reincarnation.run(MaxStarterTest.TwoUnEqualTests.class).getFailures();\n    assertEquals(\"fast\", failures.get(0).getDescription().getMethodName());\n    assertEquals(\"slow\", failures.get(1).getDescription().getMethodName());\n}"}], [{"methodBefore": "public String toString() {\n    if (getName() != null) {\n        return getName();\n    }\n    return super.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    if (getName() != null) {\n        return getName();\n    }\n    return super.toString();\n}"}, {"methodBefore": "protected void runTest() {\n    fWasRun = true;\n}", "methodAfter": "@Override\nprotected void runTest() {\n    fWasRun = true;\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(describeChild(runner))) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(describeChild(runner))) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}"}], [{"methodBefore": "private void runChildren(final RunNotifier notifier) {\n    for (final T each : getCachedChildren()) {\n        fScheduler.schedule(new Runnable() {\n            public void run() {\n                ParentRunner.this.runChild(each, notifier);\n            }\n        });\n    }\n    fScheduler.finished();\n}", "methodAfter": "private void runChildren(final RunNotifier notifier) {\n    for (final T each : getFilteredChildren()) {\n        fScheduler.schedule(new Runnable() {\n            public void run() {\n                ParentRunner.this.runChild(each, notifier);\n            }\n        });\n    }\n    fScheduler.finished();\n}"}, {"methodBefore": "private void runChildren(final RunNotifier notifier) {\n    for (final T each : getCachedChildren()) {\n        fScheduler.schedule(new Runnable() {\n            public void run() {\n                ParentRunner.this.runChild(each, notifier);\n            }\n        });\n    }\n    fScheduler.finished();\n}", "methodAfter": "private void runChildren(final RunNotifier notifier) {\n    for (final T each : getFilteredChildren()) {\n        fScheduler.schedule(new Runnable() {\n            public void run() {\n                ParentRunner.this.runChild(each, notifier);\n            }\n        });\n    }\n    fScheduler.finished();\n}"}], [{"methodBefore": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, betweenInclusive(1000, 1500));\n}", "methodAfter": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, betweenInclusive(1000, 1900));\n}"}, {"methodBefore": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, betweenInclusive(1000, 1500));\n}", "methodAfter": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, betweenInclusive(1000, 1900));\n}"}], [{"methodBefore": "private void finishedQuietly(Description description, List<Throwable> errors) {\n    try {\n        finished(description);\n    } catch (Throwable t) {\n        errors.add(t);\n    }\n}", "methodAfter": "private void finishedQuietly(Description description, List<Throwable> errors) {\n    try {\n        finished(description);\n    } catch (Throwable e) {\n        errors.add(e);\n    }\n}"}, {"methodBefore": "private void startingQuietly(Description description, List<Throwable> errors) {\n    try {\n        starting(description);\n    } catch (Throwable t) {\n        errors.add(t);\n    }\n}", "methodAfter": "private void startingQuietly(Description description, List<Throwable> errors) {\n    try {\n        starting(description);\n    } catch (Throwable e) {\n        errors.add(e);\n    }\n}"}, {"methodBefore": "private void succeededQuietly(Description description, List<Throwable> errors) {\n    try {\n        succeeded(description);\n    } catch (Throwable t) {\n        errors.add(t);\n    }\n}", "methodAfter": "private void succeededQuietly(Description description, List<Throwable> errors) {\n    try {\n        succeeded(description);\n    } catch (Throwable e) {\n        errors.add(e);\n    }\n}"}], [{"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}], [{"methodBefore": "private void succeededQuietly(Description description, List<Throwable> errors) {\n    try {\n        succeeded(description);\n    } catch (Throwable t) {\n        errors.add(t);\n    }\n}", "methodAfter": "private void succeededQuietly(Description description, List<Throwable> errors) {\n    try {\n        succeeded(description);\n    } catch (Throwable e) {\n        errors.add(e);\n    }\n}"}, {"methodBefore": "private void finishedQuietly(Description description, List<Throwable> errors) {\n    try {\n        finished(description);\n    } catch (Throwable t) {\n        errors.add(t);\n    }\n}", "methodAfter": "private void finishedQuietly(Description description, List<Throwable> errors) {\n    try {\n        finished(description);\n    } catch (Throwable e) {\n        errors.add(e);\n    }\n}"}], [{"methodBefore": "protected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    return builder.runnerForClass(testClass);\n}", "methodAfter": "protected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    return modify(builder.runnerForClass(testClass));\n}"}, {"methodBefore": "protected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    return builder.runnerForClass(testClass);\n}", "methodAfter": "protected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n    return modify(builder.runnerForClass(testClass));\n}"}], [{"methodBefore": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    Field[] fields = getTestClass().getJavaClass().getDeclaredFields();\n    for (Field each : fields) {\n        if ((each.getAnnotation(DataPoint.class) != null) && (!Modifier.isStatic(each.getModifiers()))) {\n            errors.add(new Error(\"DataPoint field THREE must be static\"));\n        }\n    }\n}"}, {"methodBefore": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    Field[] fields = getTestClass().getJavaClass().getDeclaredFields();\n    for (Field each : fields) {\n        if ((each.getAnnotation(DataPoint.class) != null) && (!Modifier.isStatic(each.getModifiers()))) {\n            errors.add(new Error(\"DataPoint field THREE must be static\"));\n        }\n    }\n}"}], [{"methodBefore": "@Test\npublic void bothPasses() {\n    assertThat(3, both(is(Integer.class)).and(is(3)));\n}", "methodAfter": "@Test\npublic void bothPasses() {\n    assertThat(3, both(is(3)).and(matches(is(Integer.class))));\n}"}, {"methodBefore": "@Test\npublic void bothPasses() {\n    assertThat(3, both(is(Integer.class)).and(is(3)));\n}", "methodAfter": "@Test\npublic void bothPasses() {\n    assertThat(3, both(is(3)).and(matches(is(Integer.class))));\n}"}], [{"methodBefore": "public MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}", "methodAfter": "private MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}"}, {"methodBefore": "public MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}", "methodAfter": "private MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}"}], [{"methodBefore": "private Matcher<Iterable<Failure>> empty() {\n    Matcher<Failure> nullValue = nullValue();\n    return each(nullValue);\n}", "methodAfter": "private Matcher<Iterable<Failure>> empty() {\n    Matcher<Failure> nullValue = nullValue();\n    return everyItem(nullValue);\n}"}, {"methodBefore": "private Matcher<Iterable<Failure>> empty() {\n    Matcher<Failure> nullValue = nullValue();\n    return each(nullValue);\n}", "methodAfter": "private Matcher<Iterable<Failure>> empty() {\n    Matcher<Failure> nullValue = nullValue();\n    return everyItem(nullValue);\n}"}], [{"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}], [{"methodBefore": "@Test\npublic void failsWithMatcher() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.ExpectsMatcherFails.class), hasSingleFailureContaining(\"Wrong start\"));\n}", "methodAfter": "@Test\npublic void failsWithMatcher() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.ExpectedMessageMatcherFails.class), hasSingleFailureContaining(\"Wrong start\"));\n}"}, {"methodBefore": "@Test\npublic void failsWithMatcher() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.ExpectsMatcherFails.class), hasSingleFailureContaining(\"Wrong start\"));\n}", "methodAfter": "@Test\npublic void failsWithMatcher() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.ExpectedMessageMatcherFails.class), hasSingleFailureContaining(\"Wrong start\"));\n}"}], [{"methodBefore": "private Statement intercept(Statement statement, Object target, FrameworkMethod method) {\n    Class<?> javaClass = getTestClass().getJavaClass();\n    Statement result = statement;\n    Field[] fields = javaClass.getFields();\n    for (Field each : fields) {\n        if (each.getAnnotation(Interceptor.class) != null) {\n            try {\n                StatementInterceptor interceptor = ((StatementInterceptor) (each.get(target)));\n                result = interceptor.intercept(result, method);\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(\"How did getFields return a field we couldn't access?\");\n            }\n        }\n    }\n    return result;\n}", "methodAfter": "private Statement intercept(Statement statement, Object target, FrameworkMethod method) {\n    Statement result = statement;\n    for (FrameworkField each : interceptorFields()) {\n        try {\n            StatementInterceptor interceptor = ((StatementInterceptor) (each.get(target)));\n            result = interceptor.intercept(result, method);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"How did getFields return a field we couldn't access?\");\n        }\n    }\n    return result;\n}"}, {"methodBefore": "private Statement intercept(Statement statement, Object target, FrameworkMethod method) {\n    Class<?> javaClass = getTestClass().getJavaClass();\n    Statement result = statement;\n    Field[] fields = javaClass.getFields();\n    for (Field each : fields) {\n        if (each.getAnnotation(Interceptor.class) != null) {\n            try {\n                StatementInterceptor interceptor = ((StatementInterceptor) (each.get(target)));\n                result = interceptor.intercept(result, method);\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(\"How did getFields return a field we couldn't access?\");\n            }\n        }\n    }\n    return result;\n}", "methodAfter": "private Statement intercept(Statement statement, Object target, FrameworkMethod method) {\n    Statement result = statement;\n    for (FrameworkField each : interceptorFields()) {\n        try {\n            StatementInterceptor interceptor = ((StatementInterceptor) (each.get(target)));\n            result = interceptor.intercept(result, method);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"How did getFields return a field we couldn't access?\");\n        }\n    }\n    return result;\n}"}], [{"methodBefore": "public Request filterWith(final Description desiredDescription) {\n    return filterWith(Filter.matchDescription(desiredDescription));\n}", "methodAfter": "public Request filterWith(final Description desiredDescription) {\n    return filterWith(Filter.matchMethodDescription(desiredDescription));\n}"}, {"methodBefore": "public Request filterWith(final Description desiredDescription) {\n    return filterWith(Filter.matchDescription(desiredDescription));\n}", "methodAfter": "public Request filterWith(final Description desiredDescription) {\n    return filterWith(Filter.matchMethodDescription(desiredDescription));\n}"}], [{"methodBefore": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1Two = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fExample1Two = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fOne = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n    fOne = Thread.currentThread();\n}"}], [{"methodBefore": "@Test\npublic void fast() {\n}", "methodAfter": "@Test\npublic void fast() {\n    fail();\n}"}, {"methodBefore": "@Test\npublic void slow() throws InterruptedException {\n    Thread.sleep(100);\n}", "methodAfter": "@Test\npublic void slow() throws InterruptedException {\n    Thread.sleep(100);\n    fail();\n}"}], [{"methodBefore": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    fResults.add(fService.submit(callable));\n}", "methodAfter": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}"}, {"methodBefore": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    fResults.add(fService.submit(callable));\n}", "methodAfter": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}"}], [{"methodBefore": "@Override\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}", "methodAfter": "@Override\npublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}"}, {"methodBefore": "@Override\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}", "methodAfter": "@Override\npublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}"}], [{"methodBefore": "List<Method> getBefores() {\n    return getAnnotatedMethods(BeforeClass.class);\n}", "methodAfter": "@Override\nprotected List<Method> getBefores() {\n    return getAnnotatedMethods(BeforeClass.class);\n}"}, {"methodBefore": "List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}", "methodAfter": "@Override\nprotected List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}"}], [{"methodBefore": "public void starting(FrameworkMethod method) {\n}", "methodAfter": "public void starting(FrameworkMethod method) throws Exception {\n}"}, {"methodBefore": "public void starting(FrameworkMethod method) {\n}", "methodAfter": "public void starting(FrameworkMethod method) throws Exception {\n}"}], [{"methodBefore": "public Test getTest() {\n    return fTest;\n}", "methodAfter": "private Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "public Test getTest() {\n    return fTest;\n}", "methodAfter": "private Test getTest() {\n    return fTest;\n}"}], [{"methodBefore": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = MaxCore.storedLocally(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = MaxCore.storedLocally(fMaxFile);\n}"}], [{"methodBefore": "public String getClassName() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    return matcher.matches() ? matcher.group(2) : null;\n}", "methodAfter": "public String getClassName() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    return matcher.matches() ? matcher.group(2) : toString();\n}"}, {"methodBefore": "public String getClassName() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    return matcher.matches() ? matcher.group(2) : null;\n}", "methodAfter": "public String getClassName() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    return matcher.matches() ? matcher.group(2) : toString();\n}"}], [{"methodBefore": "@Test\npublic void saffSqueezeExample() throws Exception {\n    final Description method = Description.createTestDescription(MaxStarterTest.TwoOldTests.class, \"testOne\");\n    Filter filter = Filter.matchDescription(method);\n    JUnit38ClassRunner child = new JUnit38ClassRunner(MaxStarterTest.TwoOldTests.class);\n    child.filter(filter);\n    assertEquals(1, child.testCount());\n}", "methodAfter": "@Test\npublic void saffSqueezeExample() throws Exception {\n    final Description method = Description.createTestDescription(MaxStarterTest.TwoOldTests.class, \"testOne\");\n    Filter filter = Filter.matchMethodDescription(method);\n    JUnit38ClassRunner child = new JUnit38ClassRunner(MaxStarterTest.TwoOldTests.class);\n    child.filter(filter);\n    assertEquals(1, child.testCount());\n}"}, {"methodBefore": "@Test\npublic void saffSqueezeExample() throws Exception {\n    final Description method = Description.createTestDescription(MaxStarterTest.TwoOldTests.class, \"testOne\");\n    Filter filter = Filter.matchDescription(method);\n    JUnit38ClassRunner child = new JUnit38ClassRunner(MaxStarterTest.TwoOldTests.class);\n    child.filter(filter);\n    assertEquals(1, child.testCount());\n}", "methodAfter": "@Test\npublic void saffSqueezeExample() throws Exception {\n    final Description method = Description.createTestDescription(MaxStarterTest.TwoOldTests.class, \"testOne\");\n    Filter filter = Filter.matchMethodDescription(method);\n    JUnit38ClassRunner child = new JUnit38ClassRunner(MaxStarterTest.TwoOldTests.class);\n    child.filter(filter);\n    assertEquals(1, child.testCount());\n}"}], [{"methodBefore": "public void testAssertFalse() {\n    assertFalse(false);\n    try {\n        assertFalse(true);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}", "methodAfter": "public void testAssertFalse() {\n    assertFalse(false);\n    try {\n        assertFalse(true);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}"}, {"methodBefore": "public void testAssertNotSameFailsNull() {\n    try {\n        assertNotSame(null, null);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}", "methodAfter": "public void testAssertNotSameFailsNull() {\n    try {\n        assertNotSame(null, null);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}"}], [{"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}, {"methodBefore": "public final Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            before();\n            try {\n                base.evaluate();\n            } finally {\n                after();\n            }\n        }\n    };\n}", "methodAfter": "public final Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            before();\n            try {\n                base.evaluate();\n            } finally {\n                after();\n            }\n        }\n    };\n}"}, {"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}, {"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "public final Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            before();\n            try {\n                base.evaluate();\n            } finally {\n                after();\n            }\n        }\n    };\n}", "methodAfter": "public final Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            before();\n            try {\n                base.evaluate();\n            } finally {\n                after();\n            }\n        }\n    };\n}"}, {"methodBefore": "public Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "public InitializationError(List<Throwable> errors) {\n    fErrors = errors;\n}", "methodAfter": "public InitializationError(List<Throwable> errors) {\n    this.errors = errors;\n}"}, {"methodBefore": "public InitializationError(List<Throwable> errors) {\n    fErrors = errors;\n}", "methodAfter": "public InitializationError(List<Throwable> errors) {\n    this.errors = errors;\n}"}], [{"methodBefore": "@Test\npublic void slow() throws InterruptedException {\n    Thread.sleep(100);\n}", "methodAfter": "@Test\npublic void slow() throws InterruptedException {\n    Thread.sleep(100);\n    fail();\n}"}, {"methodBefore": "@Test\npublic void fast() {\n}", "methodAfter": "@Test\npublic void fast() {\n    fail();\n}"}, {"methodBefore": "@Test\npublic void nullMessageDisappearsWithAssertEquals() {\n    try {\n        assertEquals(null, 1, 2);\n    } catch (AssertionError e) {\n        assertEquals(\"expected:<1> but was:<2>\", e.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void nullMessageDisappearsWithAssertEquals() {\n    try {\n        assertEquals(null, 1, 2);\n        fail();\n    } catch (AssertionError e) {\n        assertEquals(\"expected:<1> but was:<2>\", e.getMessage());\n    }\n}"}], [{"methodBefore": "private MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}", "methodAfter": "private MaxHistory(File storedResults) {\n    fHistoryStore = storedResults;\n}"}, {"methodBefore": "private MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}", "methodAfter": "private MaxHistory(File storedResults) {\n    fHistoryStore = storedResults;\n}"}, {"methodBefore": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fHistoryStore));\n    stream.writeObject(this);\n    stream.close();\n}"}, {"methodBefore": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fHistoryStore));\n    stream.writeObject(this);\n    stream.close();\n}"}], [{"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}, {"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}, {"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}, {"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}], [{"methodBefore": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        return Suite.empty();\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}, {"methodBefore": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        return Suite.empty();\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}], [{"methodBefore": "public Object call() throws Exception {\n    superRunChild(runner, notifier);\n    return null;\n}", "methodAfter": "@Override\npublic List<T> getChildren() {\n    return fDelegate.internalGetChildren();\n}"}, {"methodBefore": "public Object call() throws Exception {\n    superRunChild(runner, notifier);\n    return null;\n}", "methodAfter": "@Override\npublic List<T> getChildren() {\n    return fDelegate.internalGetChildren();\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFailureUponUncreatedFilter() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + JUnitCommandLineParserTest.FilterFactoryStub.class.getName() });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUncreatedFilter() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + JUnitCommandLineParserTest.FilterFactoryStub.class.getName() });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n    String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + nonExistentFilterFactory });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n    String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + nonExistentFilterFactory });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponUnknownTestClass() throws Exception {\n    String unknownTestClass = \"UnknownTestClass\";\n    jUnitCommandLineParser.parseParameters(new String[]{ unknownTestClass });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnknownTestClass() throws Exception {\n    String unknownTestClass = \"UnknownTestClass\";\n    jUnitCommandLineParser.parseParameters(new String[]{ unknownTestClass });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\" });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\" });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}, {"methodBefore": "private Description describeCause(Throwable child) {\n    return Description.createTestDescription(fTestClass, \"initializationError:\");\n}", "methodAfter": "private Description describeCause(Throwable child) {\n    return Description.createTestDescription(fTestClass, \"initializationError\");\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponUnknownOption() throws Exception {\n    String unknownOption = \"--unknown-option\";\n    jUnitCommandLineParser.parseOptions(new String[]{ unknownOption });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnknownOption() throws Exception {\n    String unknownOption = \"--unknown-option\";\n    jUnitCommandLineParser.parseOptions(new String[]{ unknownOption });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}], [{"methodBefore": "public void testSetupErrorInTestSetup() {\n    WasRun test = new WasRun(\"\");\n    TestSetup wrapper = new TestSetup(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assertTrue(!test.fWasRun);\n    assertTrue(!result.wasSuccessful());\n}", "methodAfter": "public void testSetupErrorInTestSetup() {\n    WasRun test = new WasRun();\n    TestSetup wrapper = new TestSetup(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assertTrue(!test.fWasRun);\n    assertTrue(!result.wasSuccessful());\n}"}, {"methodBefore": "public void testSetupErrorDontTearDown() {\n    WasRun test = new WasRun(\"\");\n    TornDown wrapper = new TornDown(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assertTrue(!wrapper.fTornDown);\n}", "methodAfter": "public void testSetupErrorDontTearDown() {\n    WasRun test = new WasRun();\n    TornDown wrapper = new TornDown(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assertTrue(!wrapper.fTornDown);\n}"}, {"methodBefore": "public void testWasRun() {\n    WasRun test = new WasRun(\"\");\n    test.run();\n    assertTrue(test.fWasRun);\n}", "methodAfter": "public void testWasRun() {\n    WasRun test = new WasRun();\n    test.run();\n    assertTrue(test.fWasRun);\n}"}], [{"methodBefore": "public void expectMessage(String message) {\n    fMessage = message;\n}", "methodAfter": "public void expectMessage(String substring) {\n    expectMessage(containsString(substring));\n}"}, {"methodBefore": "public void expectMessage(String message) {\n    fMessage = message;\n}", "methodAfter": "public void expectMessage(String substring) {\n    expectMessage(containsString(substring));\n}"}], [{"methodBefore": "public void addError(Test test, Throwable t) {\n    getWriter().print(\"E\");\n}", "methodAfter": "public void addError(Test test, Throwable e) {\n    getWriter().print(\"E\");\n}"}, {"methodBefore": "public void addError(Test test, Throwable t) {\n    fErrorCount++;\n}", "methodAfter": "public void addError(Test test, Throwable e) {\n    fErrorCount++;\n}"}], [{"methodBefore": "public void describeTo(Description description) {\n    description.appendText(\"exception with message \");\n    description.appendDescriptionOf(fMatcher);\n}", "methodAfter": "public void describeTo(Description description) {\n    description.appendText(\"exception with message \");\n    description.appendDescriptionOf(matcher);\n}"}, {"methodBefore": "public void describeTo(Description description) {\n    description.appendText(\"exception with cause \");\n    description.appendDescriptionOf(fMatcher);\n}", "methodAfter": "public void describeTo(Description description) {\n    description.appendText(\"exception with cause \");\n    description.appendDescriptionOf(matcher);\n}"}], [{"methodBefore": "public int countTestCases() {\n    return super.countTestCases() * fTimesRepeat;\n}", "methodAfter": "@Override\npublic int countTestCases() {\n    return super.countTestCases() * fTimesRepeat;\n}"}, {"methodBefore": "public String toString() {\n    return super.toString() + \"(repeated)\";\n}", "methodAfter": "@Override\npublic String toString() {\n    return super.toString() + \"(repeated)\";\n}"}], [{"methodBefore": "@Test\npublic void two() {\n    fExample1Two = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1Two = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void two() {\n    fTwo = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fTwo = Thread.currentThread();\n}"}], [{"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "public void expectCause(Matcher<? extends Throwable> expectedCause) {\n    expect(hasCause(expectedCause));\n}", "methodAfter": "@Deprecated\npublic void expectCause(Matcher<? extends Throwable> expectedCause) {\n    expect(hasCause(expectedCause));\n}"}, {"methodBefore": "public void expectMessage(Matcher<String> matcher) {\n    expect(hasMessage(matcher));\n}", "methodAfter": "@Deprecated\npublic void expectMessage(Matcher<String> matcher) {\n    expect(hasMessage(matcher));\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}], [{"methodBefore": "protected void validateInstanceMethods(List<Throwable> errors) {\n    validatePublicVoidNoArgMethods(After.class, false, errors);\n    validatePublicVoidNoArgMethods(Before.class, false, errors);\n    validateTestMethods(errors);\n    if (computeTestMethods().size() == 0) {\n        errors.add(new Exception(\"No runnable methods\"));\n    }\n}", "methodAfter": "@Deprecated\nprotected void validateInstanceMethods(List<Throwable> errors) {\n    validatePublicVoidNoArgMethods(After.class, false, errors);\n    validatePublicVoidNoArgMethods(Before.class, false, errors);\n    validateTestMethods(errors);\n    if (computeTestMethods().size() == 0) {\n        errors.add(new Exception(\"No runnable methods\"));\n    }\n}"}, {"methodBefore": "public void testRunStarted(Description description) throws Exception {\n}", "methodAfter": "@Deprecated\npublic void testRunStarted(Description description) throws Exception {\n}"}, {"methodBefore": "protected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}"}, {"methodBefore": "protected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}"}, {"methodBefore": "protected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}", "methodAfter": "@Deprecated\nprotected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}"}], [{"methodBefore": "private Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, new TestComparator());\n    return constructLeafRequest(leaves);\n}", "methodAfter": "public Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, testComparator());\n    return constructLeafRequest(leaves);\n}"}, {"methodBefore": "private Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, new TestComparator());\n    return constructLeafRequest(leaves);\n}", "methodAfter": "public Request sortRequest(Request request) {\n    if (request instanceof SortingRequest) {\n        return request;\n    }\n    List<Description> leaves = findLeaves(request);\n    Collections.sort(leaves, testComparator());\n    return constructLeafRequest(leaves);\n}"}], [{"methodBefore": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, betweenInclusive(1000, 1500));\n}", "methodAfter": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, betweenInclusive(1000, 1900));\n}"}, {"methodBefore": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, betweenInclusive(1000, 1500));\n}", "methodAfter": "@Test\npublic void testsRunInParallel() {\n    long start = System.currentTimeMillis();\n    Result result = JUnitCore.runClasses(ParallelComputer.methods(), ParallelMethodTest.Example.class);\n    assertTrue(result.wasSuccessful());\n    long end = System.currentTimeMillis();\n    assertThat(end - start, betweenInclusive(1000, 1900));\n}"}], [{"methodBefore": "public MaxCore(File storedResults) {\n    fHistory = MaxHistory.forFolder(storedResults);\n}", "methodAfter": "private MaxCore(File storedResults) {\n    fHistory = MaxHistory.locallyStored(storedResults);\n}"}, {"methodBefore": "public MaxCore(File storedResults) {\n    fHistory = MaxHistory.forFolder(storedResults);\n}", "methodAfter": "private MaxCore(File storedResults) {\n    fHistory = MaxHistory.locallyStored(storedResults);\n}"}], [{"methodBefore": "public String getClassName() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    return matcher.matches() ? matcher.group(2) : toString();\n}", "methodAfter": "public String getClassName() {\n    Matcher matcher = methodStringMatcher();\n    return matcher.matches() ? matcher.group(2) : toString();\n}"}, {"methodBefore": "private String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}", "methodAfter": "private String parseMethod() {\n    Matcher matcher = methodStringMatcher();\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}"}, {"methodBefore": "private String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}", "methodAfter": "private String parseMethod() {\n    Matcher matcher = methodStringMatcher();\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}"}, {"methodBefore": "public String getClassName() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    return matcher.matches() ? matcher.group(2) : toString();\n}", "methodAfter": "public String getClassName() {\n    Matcher matcher = methodStringMatcher();\n    return matcher.matches() ? matcher.group(2) : toString();\n}"}], [{"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}], [{"methodBefore": "public void runTest() {\n    fail();\n}", "methodAfter": "@Override\npublic void runTest() {\n    fail();\n}"}, {"methodBefore": "public void testCase() {\n}", "methodAfter": "@Override\npublic void testCase() {\n}"}], [{"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMax = MaxCore.createFresh();\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.7\";\n}", "methodAfter": "public static String id() {\n    return \"4.7.1-SNAPSHOT\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.7\";\n}", "methodAfter": "public static String id() {\n    return \"4.7.1-SNAPSHOT\";\n}"}], [{"methodBefore": "@Test\npublic void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime() throws Throwable {\n    thrown.expect(TestTimedOutException.class);\n    evaluateWithWaitDuration(0);\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime() throws Throwable {\n    thrown.expect(TestTimedOutException.class);\n    evaluateWithWaitDuration(0);\n    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n}"}, {"methodBefore": "@Test\npublic void throwsExceptionWithTimeoutValueAndTimeUnitSet() throws Throwable {\n    try {\n        evaluateWithWaitDuration(TIMEOUT + 50);\n        fail(\"No exception was thrown when test timed out\");\n    } catch (TestTimedOutException e) {\n        assertEquals(TIMEOUT, e.getTimeout());\n        assertEquals(TimeUnit.MILLISECONDS, e.getTimeUnit());\n    }\n}", "methodAfter": "@Test\npublic void throwsExceptionWithTimeoutValueAndTimeUnitSet() throws Throwable {\n    try {\n        evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n        fail(\"No exception was thrown when test timed out\");\n    } catch (TestTimedOutException e) {\n        assertEquals(TIMEOUT, e.getTimeout());\n        assertEquals(TimeUnit.MILLISECONDS, e.getTimeUnit());\n    }\n}"}, {"methodBefore": "@Test\npublic void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    try {\n        evaluateWithException(new RuntimeException());\n    } catch (Throwable expected) {\n    }\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    try {\n        evaluateWithException(new RuntimeException());\n    } catch (Throwable expected) {\n    }\n    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n}"}, {"methodBefore": "@Test\npublic void throwsTestTimedOutException() throws Throwable {\n    thrown.expect(TestTimedOutException.class);\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwsTestTimedOutException() throws Throwable {\n    thrown.expect(TestTimedOutException.class);\n    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n}"}, {"methodBefore": "@Test\npublic void throwExceptionWithNiceMessageOnTimeout() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwExceptionWithNiceMessageOnTimeout() throws Throwable {\n    thrown.expectMessage(\"test timed out after 100 milliseconds\");\n    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);\n}"}], [{"methodBefore": "public TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}", "methodAfter": "public TestSuite(final Class<?> theClass) {\n    addTestsFromTestCase(theClass);\n}"}, {"methodBefore": "public TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}", "methodAfter": "public TestSuite(final Class<?> theClass) {\n    addTestsFromTestCase(theClass);\n}"}], [{"methodBefore": "public static MaxCore createFresh() {\n    return new MaxCore();\n}", "methodAfter": "public static MaxCore createFresh() {\n    File file = new File(\"MaxCore.ser\");\n    if (file.exists()) {\n        file.delete();\n    }\n    try {\n        return new MaxCore();\n    } catch (Throwable e) {\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    }\n}"}, {"methodBefore": "public static MaxCore createFresh() {\n    return new MaxCore();\n}", "methodAfter": "public static MaxCore createFresh() {\n    File file = new File(\"MaxCore.ser\");\n    if (file.exists()) {\n        file.delete();\n    }\n    try {\n        return new MaxCore();\n    } catch (Throwable e) {\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    }\n}"}], [{"methodBefore": "public static String id() {\n    return \"3.7\";\n}", "methodAfter": "public static String id() {\n    return \"@version@\";\n}"}, {"methodBefore": "public static String id() {\n    return \"3.7\";\n}", "methodAfter": "public static String id() {\n    return \"@version@\";\n}"}], [{"methodBefore": "private void validateOnlyOneConstructor(List<Throwable> errors) {\n    if (!hasOneConstructor()) {\n        String gripe = \"Test class should have exactly one public constructor\";\n        errors.add(new Exception(gripe));\n    }\n}", "methodAfter": "protected void validateOnlyOneConstructor(List<Throwable> errors) {\n    if (!hasOneConstructor()) {\n        String gripe = \"Test class should have exactly one public constructor\";\n        errors.add(new Exception(gripe));\n    }\n}"}, {"methodBefore": "private void validateOnlyOneConstructor(List<Throwable> errors) {\n    if (!hasOneConstructor()) {\n        String gripe = \"Test class should have exactly one public constructor\";\n        errors.add(new Exception(gripe));\n    }\n}", "methodAfter": "protected void validateOnlyOneConstructor(List<Throwable> errors) {\n    if (!hasOneConstructor()) {\n        String gripe = \"Test class should have exactly one public constructor\";\n        errors.add(new Exception(gripe));\n    }\n}"}], [{"methodBefore": "@Override\npublic String getDescription() throws CouldNotGenerateValueException {\n    return fMethod.getName();\n}", "methodAfter": "@Override\npublic String getDescription() throws CouldNotGenerateValueException {\n    return method.getName();\n}"}, {"methodBefore": "@Override\npublic String getName() {\n    return fMethod.getName();\n}", "methodAfter": "@Override\npublic String getName() {\n    return method.getName();\n}"}], [{"methodBefore": "@Test\npublic void failsIfExceptionNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsException.class), hasSingleFailureContaining(\"Expected exception: java.lang.NullPointerException\"));\n}", "methodAfter": "@Test\npublic void failsIfExceptionNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsException.class), hasSingleFailureContaining(\"Expected test to throw an instance of java.lang.NullPointerException\"));\n}"}, {"methodBefore": "@Test\npublic void failsIfExceptionNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsException.class), hasSingleFailureContaining(\"Expected exception: java.lang.NullPointerException\"));\n}", "methodAfter": "@Test\npublic void failsIfExceptionNeverComes() {\n    assertThat(testResult(ExpectedExceptionInterceptorTest.WronglyExpectsException.class), hasSingleFailureContaining(\"Expected test to throw an instance of java.lang.NullPointerException\"));\n}"}], [{"methodBefore": "public void sort(Sorter sorter) {\n    fSorter = sorter;\n}", "methodAfter": "public void sort(Sorter sorter) {\n    Collections.sort(getCachedChildren(), comparator(sorter));\n    for (T each : getCachedChildren()) {\n        sorter.apply(each);\n    }\n}"}, {"methodBefore": "public void sort(Sorter sorter) {\n    fSorter = sorter;\n}", "methodAfter": "public void sort(Sorter sorter) {\n    Collections.sort(getCachedChildren(), comparator(sorter));\n    for (T each : getCachedChildren()) {\n        sorter.apply(each);\n    }\n}"}], [{"methodBefore": "public final Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            before();\n            try {\n                base.evaluate();\n            } finally {\n                after();\n            }\n        }\n    };\n}", "methodAfter": "public final Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            before();\n            try {\n                base.evaluate();\n            } finally {\n                after();\n            }\n        }\n    };\n}"}, {"methodBefore": "public final Statement intercept(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            before();\n            try {\n                base.evaluate();\n            } finally {\n                after();\n            }\n        }\n    };\n}", "methodAfter": "public final Statement apply(final Statement base, FrameworkMethod method, Object target) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            before();\n            try {\n                base.evaluate();\n            } finally {\n                after();\n            }\n        }\n    };\n}"}], [{"methodBefore": "protected void runFailed(String message) {\n    System.err.println(message);\n    System.exit(FAILURE_EXIT);\n}", "methodAfter": "@Override\nprotected void runFailed(String message) {\n    System.err.println(message);\n    System.exit(FAILURE_EXIT);\n}"}, {"methodBefore": "public void run(final TestResult result) {\n    Protectable p = new Protectable() {\n        public void protect() throws Exception {\n            setUp();\n            basicRun(result);\n            tearDown();\n        }\n    };\n    result.runProtected(this, p);\n}", "methodAfter": "@Override\npublic void run(final TestResult result) {\n    Protectable p = new Protectable() {\n        public void protect() throws Exception {\n            setUp();\n            basicRun(result);\n            tearDown();\n        }\n    };\n    result.runProtected(this, p);\n}"}], [{"methodBefore": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = MaxCore.storedLocally(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = MaxCore.storedLocally(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = MaxCore.storedLocally(fMaxFile);\n}"}, {"methodBefore": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = new MaxCore(fMaxFile);\n}", "methodAfter": "@Before\npublic void createMax() {\n    fMaxFile = new File(\"MaxCore.ser\");\n    if (fMaxFile.exists()) {\n        fMaxFile.delete();\n    }\n    fMax = MaxCore.storedLocally(fMaxFile);\n}"}], [{"methodBefore": "@Test\npublic void testCountsStandUpToFiltration() {\n    Class<AllTests> testClass = AllTests.class;\n    assertFilterLeavesTestUnscathed(testClass);\n}", "methodAfter": "@Test\npublic void testCountsStandUpToFiltration() {\n    assertFilterLeavesTestUnscathed(AllTests.class);\n}"}, {"methodBefore": "@Test\npublic void testCountsStandUpToFiltration() {\n    Class<AllTests> testClass = AllTests.class;\n    assertFilterLeavesTestUnscathed(testClass);\n}", "methodAfter": "@Test\npublic void testCountsStandUpToFiltration() {\n    assertFilterLeavesTestUnscathed(AllTests.class);\n}"}], [{"methodBefore": "public Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}"}, {"methodBefore": "protected void collectInitializationErrors(List<Throwable> errors) {\n    getTestClass().validateMethodsForDefaultRunner(errors);\n}", "methodAfter": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    getTestClass().validateMethodsForDefaultRunner(errors);\n}"}, {"methodBefore": "public void testEnded(String testName) {\n}", "methodAfter": "@Override\npublic void testEnded(String testName) {\n}"}, {"methodBefore": "public String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}"}, {"methodBefore": "protected void tearDown() {\n    fTornDown = true;\n}", "methodAfter": "@Override\nprotected void tearDown() {\n    fTornDown = true;\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(runner.getDescription())) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(runner.getDescription())) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}"}, {"methodBefore": "protected String elapsedTimeAsString(long runTime) {\n    return \"0\";\n}", "methodAfter": "@Override\nprotected String elapsedTimeAsString(long runTime) {\n    return \"0\";\n}"}, {"methodBefore": "public void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}"}, {"methodBefore": "protected void setUp() {\n    StringWriter swin = new StringWriter();\n    PrintWriter pwin = new PrintWriter(swin);\n    pwin.println(\"junit.framework.AssertionFailedError\");\n    pwin.println(\"\tat junit.framework.Assert.fail(Assert.java:144)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:19)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:26)\");\n    pwin.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwin.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    pwin.println(\"\tat java.lang.reflect.Method.invoke(Native Method)\");\n    pwin.println(\"\tat junit.framework.TestCase.runTest(TestCase.java:156)\");\n    pwin.println(\"\tat junit.framework.TestCase.runBare(TestCase.java:130)\");\n    pwin.println(\"\tat junit.framework.TestResult$1.protect(TestResult.java:100)\");\n    pwin.println(\"\tat junit.framework.TestResult.runProtected(TestResult.java:118)\");\n    pwin.println(\"\tat junit.framework.TestResult.run(TestResult.java:103)\");\n    pwin.println(\"\tat junit.framework.TestCase.run(TestCase.java:121)\");\n    pwin.println(\"\tat junit.framework.TestSuite.runTest(TestSuite.java:157)\");\n    pwin.println(\"\tat junit.framework.TestSuite.run(TestSuite.java, Compiled Code)\");\n    pwin.println(\"\tat junit.swingui.TestRunner$17.run(TestRunner.java:669)\");\n    fUnfiltered = swin.toString();\n    StringWriter swout = new StringWriter();\n    PrintWriter pwout = new PrintWriter(swout);\n    pwout.println(\"junit.framework.AssertionFailedError\");\n    pwout.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwout.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    fFiltered = swout.toString();\n}", "methodAfter": "@Override\nprotected void setUp() {\n    StringWriter swin = new StringWriter();\n    PrintWriter pwin = new PrintWriter(swin);\n    pwin.println(\"junit.framework.AssertionFailedError\");\n    pwin.println(\"\tat junit.framework.Assert.fail(Assert.java:144)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:19)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:26)\");\n    pwin.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwin.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    pwin.println(\"\tat java.lang.reflect.Method.invoke(Native Method)\");\n    pwin.println(\"\tat junit.framework.TestCase.runTest(TestCase.java:156)\");\n    pwin.println(\"\tat junit.framework.TestCase.runBare(TestCase.java:130)\");\n    pwin.println(\"\tat junit.framework.TestResult$1.protect(TestResult.java:100)\");\n    pwin.println(\"\tat junit.framework.TestResult.runProtected(TestResult.java:118)\");\n    pwin.println(\"\tat junit.framework.TestResult.run(TestResult.java:103)\");\n    pwin.println(\"\tat junit.framework.TestCase.run(TestCase.java:121)\");\n    pwin.println(\"\tat junit.framework.TestSuite.runTest(TestSuite.java:157)\");\n    pwin.println(\"\tat junit.framework.TestSuite.run(TestSuite.java, Compiled Code)\");\n    pwin.println(\"\tat junit.swingui.TestRunner$17.run(TestRunner.java:669)\");\n    fUnfiltered = swin.toString();\n    StringWriter swout = new StringWriter();\n    PrintWriter pwout = new PrintWriter(swout);\n    pwout.println(\"junit.framework.AssertionFailedError\");\n    pwout.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwout.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    fFiltered = swout.toString();\n}"}, {"methodBefore": "public String getName() {\n    return fMethod.getName();\n}", "methodAfter": "@Override\npublic String getName() {\n    return fMethod.getName();\n}"}, {"methodBefore": "public String getTestHeader() {\n    return fDescription.getDisplayName();\n}", "methodAfter": "@Override\npublic String getTestHeader() {\n    return fDescription.getDisplayName();\n}"}, {"methodBefore": "public boolean isPublic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isPublic(modifiers);\n}", "methodAfter": "@Override\npublic boolean isPublic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isPublic(modifiers);\n}"}, {"methodBefore": "public void validateAnnotatedClass(Class<?> type, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_CLASS_CALLED));\n}", "methodAfter": "@Override\npublic void validateAnnotatedClass(Class<?> type, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_CLASS_CALLED));\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<FrameworkMethod> iter = fTestMethods.iterator(); iter.hasNext();) {\n        FrameworkMethod method = iter.next();\n        if (!filter.shouldRun(describeChild(method))) {\n            iter.remove();\n        }\n    }\n    if (fTestMethods.isEmpty()) {\n        throw new NoTestsRemainException();\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<FrameworkMethod> iter = fTestMethods.iterator(); iter.hasNext();) {\n        FrameworkMethod method = iter.next();\n        if (!filter.shouldRun(describeChild(method))) {\n            iter.remove();\n        }\n    }\n    if (fTestMethods.isEmpty()) {\n        throw new NoTestsRemainException();\n    }\n}"}, {"methodBefore": "protected void runFailed(String message) {\n}", "methodAfter": "@Override\nprotected void runFailed(String message) {\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}"}, {"methodBefore": "protected void setUp() {\n    fResult = new TestResult();\n    fResult.addListener(this);\n    fStartCount = 0;\n    fEndCount = 0;\n    fFailureCount = 0;\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fResult = new TestResult();\n    fResult.addListener(this);\n    fStartCount = 0;\n    fEndCount = 0;\n    fFailureCount = 0;\n}"}, {"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "public void validateAnnotatedMethod(Method method, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_METHOD_CALLED));\n}", "methodAfter": "@Override\npublic void validateAnnotatedMethod(Method method, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_METHOD_CALLED));\n}"}, {"methodBefore": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n    notifying(method, childBlock(method)).run(eachNotifier);\n}", "methodAfter": "@Override\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n    notifying(method, childBlock(method)).run(eachNotifier);\n}"}, {"methodBefore": "public void testStarted(String testName) {\n}", "methodAfter": "@Override\npublic void testStarted(String testName) {\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}"}, {"methodBefore": "public String getMessage() {\n    return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n}", "methodAfter": "@Override\npublic String getMessage() {\n    return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n}"}], [{"methodBefore": "public void test() {\n    fail();\n}", "methodAfter": "public void runTest() {\n    fail();\n}"}, {"methodBefore": "public void test() {\n}", "methodAfter": "public void runTest() {\n}"}], [{"methodBefore": "@Override\npublic boolean shouldRun(Description description) {\n    if (isExcluded(description)) {\n        return false;\n    }\n    if (description.isSuite()) {\n        return true;\n    }\n    return isIncludedMethod(description);\n}", "methodAfter": "@Override\npublic boolean shouldRun(Description description) {\n    if (hasCorrectCategoryAnnotation(description)) {\n        return true;\n    }\n    for (Description each : description.getChildren()) {\n        if (shouldRun(each)) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "@Override\npublic boolean shouldRun(Description description) {\n    if (isExcluded(description)) {\n        return false;\n    }\n    if (description.isSuite()) {\n        return true;\n    }\n    return isIncludedMethod(description);\n}", "methodAfter": "@Override\npublic boolean shouldRun(Description description) {\n    if (hasCorrectCategoryAnnotation(description)) {\n        return true;\n    }\n    for (Description each : description.getChildren()) {\n        if (shouldRun(each)) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "public boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}"}, {"methodBefore": "public String toString() {\n    return fTest.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    return fTest.toString();\n}"}], [{"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    if (getTest() instanceof Filterable) {\n        Filterable adapter = ((Filterable) (getTest()));\n        adapter.filter(filter);\n    } else if (getTest() instanceof TestSuite) {\n        TestSuite suite = ((TestSuite) (getTest()));\n        TestSuite filtered = new TestSuite(suite.getName());\n        int n = suite.testCount();\n        for (int i = 0; i < n; i++) {\n            Test test = suite.testAt(i);\n            if (filter.shouldRun(makeDescription(test))) {\n                filtered.addTest(test);\n            }\n        }\n        setTest(filtered);\n    }\n}", "methodAfter": "public void filter(Filter filter) throws NoTestsRemainException {\n    if (getTest() instanceof Filterable) {\n        Filterable adapter = ((Filterable) (getTest()));\n        adapter.filter(filter);\n    } else if (getTest() instanceof TestSuite) {\n        TestSuite suite = ((TestSuite) (getTest()));\n        TestSuite filtered = new TestSuite(suite.getName());\n        int n = suite.testCount();\n        for (int i = 0; i < n; i++) {\n            Test test = suite.testAt(i);\n            if (filter.shouldRun(makeDescription(test))) {\n                filtered.addTest(test);\n            }\n        }\n        setTest(filtered);\n        if (filtered.testCount() == 0) {\n            throw new NoTestsRemainException();\n        }\n    }\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    if (getTest() instanceof Filterable) {\n        Filterable adapter = ((Filterable) (getTest()));\n        adapter.filter(filter);\n    } else if (getTest() instanceof TestSuite) {\n        TestSuite suite = ((TestSuite) (getTest()));\n        TestSuite filtered = new TestSuite(suite.getName());\n        int n = suite.testCount();\n        for (int i = 0; i < n; i++) {\n            Test test = suite.testAt(i);\n            if (filter.shouldRun(makeDescription(test))) {\n                filtered.addTest(test);\n            }\n        }\n        setTest(filtered);\n    }\n}", "methodAfter": "public void filter(Filter filter) throws NoTestsRemainException {\n    if (getTest() instanceof Filterable) {\n        Filterable adapter = ((Filterable) (getTest()));\n        adapter.filter(filter);\n    } else if (getTest() instanceof TestSuite) {\n        TestSuite suite = ((TestSuite) (getTest()));\n        TestSuite filtered = new TestSuite(suite.getName());\n        int n = suite.testCount();\n        for (int i = 0; i < n; i++) {\n            Test test = suite.testAt(i);\n            if (filter.shouldRun(makeDescription(test))) {\n                filtered.addTest(test);\n            }\n        }\n        setTest(filtered);\n        if (filtered.testCount() == 0) {\n            throw new NoTestsRemainException();\n        }\n    }\n}"}], [{"methodBefore": "public List<Throwable> getCauses() {\n    return fErrors;\n}", "methodAfter": "public List<Throwable> getCauses() {\n    return errors;\n}"}, {"methodBefore": "public List<Throwable> getCauses() {\n    return fErrors;\n}", "methodAfter": "public List<Throwable> getCauses() {\n    return errors;\n}"}], [{"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}"}, {"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}"}], [{"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return new RunAfters(statement, afters, target);\n}", "methodAfter": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}"}, {"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return new RunAfters(statement, afters, target);\n}", "methodAfter": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);\n}"}], [{"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "protected void setUp() {\n    fValue1 = 2;\n    fValue2 = 3;\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fValue1 = 2;\n    fValue2 = 3;\n}"}], [{"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fResults) {\n        try {\n            each.get(2000, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "@Test\npublic void eitherPasses() {\n    assertThat(3, either(is(3)).or(is(4)));\n}", "methodAfter": "@Test\npublic void eitherPasses() {\n    assertThat(3, either(is(3)).or(matches(is(4))));\n}"}, {"methodBefore": "@Test\npublic void eitherPasses() {\n    assertThat(3, either(is(3)).or(is(4)));\n}", "methodAfter": "@Test\npublic void eitherPasses() {\n    assertThat(3, either(is(3)).or(matches(is(4))));\n}"}], [{"methodBefore": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    super.collectInitializationErrors(errors);\n    validateConstructor(errors);\n    validateInstanceMethods(errors);\n}", "methodAfter": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    super.collectInitializationErrors(errors);\n    validateConstructor(errors);\n    validateInstanceMethods(errors);\n    validateFields(errors);\n}"}, {"methodBefore": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    super.collectInitializationErrors(errors);\n    validateConstructor(errors);\n    validateInstanceMethods(errors);\n}", "methodAfter": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    super.collectInitializationErrors(errors);\n    validateConstructor(errors);\n    validateInstanceMethods(errors);\n    validateFields(errors);\n}"}], [{"methodBefore": "private Test getTest() {\n    return fTest;\n}", "methodAfter": "public Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "private Test getTest() {\n    return fTest;\n}", "methodAfter": "public Test getTest() {\n    return fTest;\n}"}], [{"methodBefore": "@Test\npublic void theoryClassMethodsShowUp() throws Exception {\n    assertThat(new Theories(UnsuccessfulWithDataPointFields.HasATheory.class).getPlan().getChildren().size(), is(1));\n}", "methodAfter": "@Test\npublic void theoryClassMethodsShowUp() throws Exception {\n    assertThat(new Theories(UnsuccessfulWithDataPointFields.HasATheory.class).getDescription().getChildren().size(), is(1));\n}"}, {"methodBefore": "@Test\npublic void theoryClassMethodsShowUp() throws Exception {\n    assertThat(new Theories(UnsuccessfulWithDataPointFields.HasATheory.class).getPlan().getChildren().size(), is(1));\n}", "methodAfter": "@Test\npublic void theoryClassMethodsShowUp() throws Exception {\n    assertThat(new Theories(UnsuccessfulWithDataPointFields.HasATheory.class).getDescription().getChildren().size(), is(1));\n}"}], [{"methodBefore": "public boolean isStatic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isStatic(modifiers);\n}", "methodAfter": "@Override\npublic boolean isStatic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isStatic(modifiers);\n}"}, {"methodBefore": "public void run(TestResult result) {\n    for (int i = 0; i < fTimesRepeat; i++) {\n        if (result.shouldStop()) {\n            break;\n        }\n        super.run(result);\n    }\n}", "methodAfter": "@Override\npublic void run(TestResult result) {\n    for (int i = 0; i < fTimesRepeat; i++) {\n        if (result.shouldStop()) {\n            break;\n        }\n        super.run(result);\n    }\n}"}], [{"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}, {"methodBefore": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n}"}], [{"methodBefore": "public TestRunner(PrintStream writer) {\n    this();\n    fWriter = writer;\n}", "methodAfter": "public TestRunner(PrintStream writer) {\n    this();\n    if (writer == null) {\n        throw new IllegalArgumentException(\"Writer can't be null\");\n    }\n    fWriter = writer;\n}"}, {"methodBefore": "public TestRunner(PrintStream writer) {\n    this();\n    fWriter = writer;\n}", "methodAfter": "public TestRunner(PrintStream writer) {\n    this();\n    if (writer == null) {\n        throw new IllegalArgumentException(\"Writer can't be null\");\n    }\n    fWriter = writer;\n}"}], [{"methodBefore": "@Parameters\npublic static Collection<Object[]> getParameters() {\n    return Collections.singletonList(new Object[]{ \"a\" });\n}", "methodAfter": "@Parameters\npublic static Iterable<String> getParameters() {\n    return Arrays.asList(\"first\", \"second\");\n}"}, {"methodBefore": "@Parameters\npublic static Collection<Object[]> getParameters() {\n    return Collections.singletonList(new Object[]{ \"a\" });\n}", "methodAfter": "@Parameters\npublic static Iterable<String> getParameters() {\n    return Arrays.asList(\"first\", \"second\");\n}"}, {"methodBefore": "@Parameters\npublic static Collection<Object[]> getParameters() {\n    return Collections.singletonList(new Object[]{ \"a\" });\n}", "methodAfter": "@Parameters\npublic static Iterable<String> getParameters() {\n    return Arrays.asList(\"first\", \"second\");\n}"}], [{"methodBefore": "@Test\npublic void sameWithMessage() {\n    try {\n        assertSame(\"not same\", \"hello\", \"good-bye\");\n    } catch (AssertionError exception) {\n        assertEquals(\"not same expected same:<hello> was not:<good-bye>\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void sameWithMessage() {\n    try {\n        assertSame(\"not same\", \"hello\", \"good-bye\");\n        fail();\n    } catch (AssertionError exception) {\n        assertEquals(\"not same expected same:<hello> was not:<good-bye>\", exception.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void fast() {\n}", "methodAfter": "@Test\npublic void fast() {\n    fail();\n}"}, {"methodBefore": "@Test\npublic void nullMessageDisappearsWithStringAssertEquals() {\n    try {\n        assertEquals(null, \"a\", \"b\");\n    } catch (ComparisonFailure e) {\n        assertEquals(\"expected:<[a]> but was:<[b]>\", e.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void nullMessageDisappearsWithStringAssertEquals() {\n    try {\n        assertEquals(null, \"a\", \"b\");\n        fail();\n    } catch (ComparisonFailure e) {\n        assertEquals(\"expected:<[a]> but was:<[b]>\", e.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void sameNullMessage() {\n    try {\n        assertSame(\"hello\", \"good-bye\");\n    } catch (AssertionError exception) {\n        assertEquals(\"expected same:<hello> was not:<good-bye>\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void sameNullMessage() {\n    try {\n        assertSame(\"hello\", \"good-bye\");\n        fail();\n    } catch (AssertionError exception) {\n        assertEquals(\"expected same:<hello> was not:<good-bye>\", exception.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void slow() throws InterruptedException {\n    Thread.sleep(100);\n}", "methodAfter": "@Test\npublic void slow() throws InterruptedException {\n    Thread.sleep(100);\n    fail();\n}"}, {"methodBefore": "@Test\npublic void slow() throws InterruptedException {\n    Thread.sleep(100);\n}", "methodAfter": "@Test\npublic void slow() throws InterruptedException {\n    Thread.sleep(100);\n    fail();\n}"}, {"methodBefore": "@Test\npublic void nullMessageDisappearsWithAssertEquals() {\n    try {\n        assertEquals(null, 1, 2);\n    } catch (AssertionError e) {\n        assertEquals(\"expected:<1> but was:<2>\", e.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void nullMessageDisappearsWithAssertEquals() {\n    try {\n        assertEquals(null, 1, 2);\n        fail();\n    } catch (AssertionError e) {\n        assertEquals(\"expected:<1> but was:<2>\", e.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void fast() {\n}", "methodAfter": "@Test\npublic void fast() {\n    fail();\n}"}], [{"methodBefore": "private MaxCore(String folder) {\n    fFolder = folder;\n}", "methodAfter": "private MaxCore(String folder) {\n    fHistory = MaxHistory.forFolder(folder);\n}"}, {"methodBefore": "private MaxCore(String folder) {\n    fFolder = folder;\n}", "methodAfter": "private MaxCore(String folder) {\n    fHistory = MaxHistory.forFolder(folder);\n}"}], [{"methodBefore": "public void sort(Sorter sorter) {\n    Collections.sort(getCachedChildren(), comparator(sorter));\n    for (T each : getCachedChildren()) {\n        sorter.apply(each);\n    }\n}", "methodAfter": "public void sort(Sorter sorter) {\n    fSorter = sorter;\n}"}, {"methodBefore": "public void sort(Sorter sorter) {\n    Collections.sort(getCachedChildren(), comparator(sorter));\n    for (T each : getCachedChildren()) {\n        sorter.apply(each);\n    }\n}", "methodAfter": "public void sort(Sorter sorter) {\n    fSorter = sorter;\n}"}], [{"methodBefore": "@Test\npublic void preferNewTests() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"succeed\");\n    MaxCore max = new MaxCore();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sort(two);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, things.get(0));\n    assertEquals(2, things.size());\n}", "methodAfter": "@Test\npublic void preferNewTests() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"succeed\");\n    MaxCore max = MaxCore.createFresh();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sort(two);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, things.get(0));\n    assertEquals(2, things.size());\n}"}, {"methodBefore": "@Test\npublic void preferNewTestsOverTestsThatFailed() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    MaxCore max = new MaxCore();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sort(two);\n    Description succeed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"succeed\");\n    assertEquals(succeed, things.get(0));\n    assertEquals(2, things.size());\n}", "methodAfter": "@Test\npublic void preferNewTestsOverTestsThatFailed() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    MaxCore max = MaxCore.createFresh();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sort(two);\n    Description succeed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"succeed\");\n    assertEquals(succeed, things.get(0));\n    assertEquals(2, things.size());\n}"}, {"methodBefore": "@Test\npublic void preferRecentlyFailed() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = new MaxCore();\n    max.run(request);\n    List<Description> tests = max.sort(request);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, tests.get(0));\n}", "methodAfter": "@Test\npublic void preferRecentlyFailed() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = MaxCore.createFresh();\n    max.run(request);\n    List<Description> tests = max.sort(request);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, tests.get(0));\n}"}, {"methodBefore": "@Test\npublic void preferFast() {\n    Request request = Request.aClass(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore max = new MaxCore();\n    max.run(request);\n    Description thing = max.sort(request).get(1);\n    assertEquals(Description.createTestDescription(MaxStarterTest.TwoUnEqualTests.class, \"slow\"), thing);\n}", "methodAfter": "@Test\npublic void preferFast() {\n    Request request = Request.aClass(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore max = MaxCore.createFresh();\n    max.run(request);\n    Description thing = max.sort(request).get(1);\n    assertEquals(Description.createTestDescription(MaxStarterTest.TwoUnEqualTests.class, \"slow\"), thing);\n}"}], [{"methodBefore": "@Test\npublic void preferNewTests() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"succeed\");\n    MaxCore max = new MaxCore();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sort(two);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, things.get(0));\n    assertEquals(2, things.size());\n}", "methodAfter": "@Test\npublic void preferNewTests() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"succeed\");\n    MaxCore max = MaxCore.createFresh();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sort(two);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, things.get(0));\n    assertEquals(2, things.size());\n}"}, {"methodBefore": "@Test\npublic void preferNewTestsOverTestsThatFailed() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    MaxCore max = new MaxCore();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sort(two);\n    Description succeed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"succeed\");\n    assertEquals(succeed, things.get(0));\n    assertEquals(2, things.size());\n}", "methodAfter": "@Test\npublic void preferNewTestsOverTestsThatFailed() {\n    Request one = Request.method(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    MaxCore max = MaxCore.createFresh();\n    max.run(one);\n    Request two = Request.aClass(MaxStarterTest.TwoTests.class);\n    List<Description> things = max.sort(two);\n    Description succeed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"succeed\");\n    assertEquals(succeed, things.get(0));\n    assertEquals(2, things.size());\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "public Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}", "methodAfter": "@Override\nprotected Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}"}, {"methodBefore": "public Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}", "methodAfter": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}"}], [{"methodBefore": "@Test\npublic void two() {\n    fExample1Two = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1Two = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void two() {\n    fExample1Two = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1Two = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void two() {\n    fTwo = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fTwo = Thread.currentThread();\n}"}], [{"methodBefore": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    fResults.add(fService.submit(callable));\n}", "methodAfter": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}"}, {"methodBefore": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    fResults.add(fService.submit(callable));\n}", "methodAfter": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}"}, {"methodBefore": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    fResults.add(fService.submit(callable));\n}", "methodAfter": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}"}, {"methodBefore": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    fResults.add(fService.submit(callable));\n}", "methodAfter": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}"}], [{"methodBefore": "public void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(runner.getDescription())) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(runner.getDescription())) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}"}, {"methodBefore": "public String getName() {\n    return fMethod.getName();\n}", "methodAfter": "@Override\npublic String getName() {\n    return fMethod.getName();\n}"}, {"methodBefore": "public String toString() {\n    return ((getName() + \"(\") + getClass().getName()) + \")\";\n}", "methodAfter": "@Override\npublic String toString() {\n    return ((getName() + \"(\") + getClass().getName()) + \")\";\n}"}, {"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "public void setUp() {\n    output = new ByteArrayOutputStream();\n    runner = new TestRunner(new TestResultPrinter(new PrintStream(output)));\n}", "methodAfter": "@Override\npublic void setUp() {\n    output = new ByteArrayOutputStream();\n    runner = new TestRunner(new TestResultPrinter(new PrintStream(output)));\n}"}, {"methodBefore": "protected void setUp() {\n    StringWriter swin = new StringWriter();\n    PrintWriter pwin = new PrintWriter(swin);\n    pwin.println(\"junit.framework.AssertionFailedError\");\n    pwin.println(\"\tat junit.framework.Assert.fail(Assert.java:144)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:19)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:26)\");\n    pwin.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwin.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    pwin.println(\"\tat java.lang.reflect.Method.invoke(Native Method)\");\n    pwin.println(\"\tat junit.framework.TestCase.runTest(TestCase.java:156)\");\n    pwin.println(\"\tat junit.framework.TestCase.runBare(TestCase.java:130)\");\n    pwin.println(\"\tat junit.framework.TestResult$1.protect(TestResult.java:100)\");\n    pwin.println(\"\tat junit.framework.TestResult.runProtected(TestResult.java:118)\");\n    pwin.println(\"\tat junit.framework.TestResult.run(TestResult.java:103)\");\n    pwin.println(\"\tat junit.framework.TestCase.run(TestCase.java:121)\");\n    pwin.println(\"\tat junit.framework.TestSuite.runTest(TestSuite.java:157)\");\n    pwin.println(\"\tat junit.framework.TestSuite.run(TestSuite.java, Compiled Code)\");\n    pwin.println(\"\tat junit.swingui.TestRunner$17.run(TestRunner.java:669)\");\n    fUnfiltered = swin.toString();\n    StringWriter swout = new StringWriter();\n    PrintWriter pwout = new PrintWriter(swout);\n    pwout.println(\"junit.framework.AssertionFailedError\");\n    pwout.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwout.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    fFiltered = swout.toString();\n}", "methodAfter": "@Override\nprotected void setUp() {\n    StringWriter swin = new StringWriter();\n    PrintWriter pwin = new PrintWriter(swin);\n    pwin.println(\"junit.framework.AssertionFailedError\");\n    pwin.println(\"\tat junit.framework.Assert.fail(Assert.java:144)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:19)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:26)\");\n    pwin.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwin.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    pwin.println(\"\tat java.lang.reflect.Method.invoke(Native Method)\");\n    pwin.println(\"\tat junit.framework.TestCase.runTest(TestCase.java:156)\");\n    pwin.println(\"\tat junit.framework.TestCase.runBare(TestCase.java:130)\");\n    pwin.println(\"\tat junit.framework.TestResult$1.protect(TestResult.java:100)\");\n    pwin.println(\"\tat junit.framework.TestResult.runProtected(TestResult.java:118)\");\n    pwin.println(\"\tat junit.framework.TestResult.run(TestResult.java:103)\");\n    pwin.println(\"\tat junit.framework.TestCase.run(TestCase.java:121)\");\n    pwin.println(\"\tat junit.framework.TestSuite.runTest(TestSuite.java:157)\");\n    pwin.println(\"\tat junit.framework.TestSuite.run(TestSuite.java, Compiled Code)\");\n    pwin.println(\"\tat junit.swingui.TestRunner$17.run(TestRunner.java:669)\");\n    fUnfiltered = swin.toString();\n    StringWriter swout = new StringWriter();\n    PrintWriter pwout = new PrintWriter(swout);\n    pwout.println(\"junit.framework.AssertionFailedError\");\n    pwout.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwout.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    fFiltered = swout.toString();\n}"}, {"methodBefore": "public boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}"}, {"methodBefore": "public String toString() {\n    return super.toString() + \"(repeated)\";\n}", "methodAfter": "@Override\npublic String toString() {\n    return super.toString() + \"(repeated)\";\n}"}, {"methodBefore": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n    notifying(method, childBlock(method)).run(eachNotifier);\n}", "methodAfter": "@Override\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);\n    notifying(method, childBlock(method)).run(eachNotifier);\n}"}, {"methodBefore": "public void testEnded(String testName) {\n}", "methodAfter": "@Override\npublic void testEnded(String testName) {\n}"}, {"methodBefore": "protected void setUp() {\n    fValue1 = 2;\n    fValue2 = 3;\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fValue1 = 2;\n    fValue2 = 3;\n}"}, {"methodBefore": "protected void collectInitializationErrors(List<Throwable> errors) {\n    getTestClass().validateMethodsForDefaultRunner(errors);\n}", "methodAfter": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    getTestClass().validateMethodsForDefaultRunner(errors);\n}"}, {"methodBefore": "public boolean isStatic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isStatic(modifiers);\n}", "methodAfter": "@Override\npublic boolean isStatic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isStatic(modifiers);\n}"}, {"methodBefore": "public String toString() {\n    if (getName() != null) {\n        return getName();\n    }\n    return super.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    if (getName() != null) {\n        return getName();\n    }\n    return super.toString();\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(describeChild(runner))) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(describeChild(runner))) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}"}, {"methodBefore": "public void testStarted(String testName) {\n}", "methodAfter": "@Override\npublic void testStarted(String testName) {\n}"}, {"methodBefore": "protected String elapsedTimeAsString(long runTime) {\n    return \"0\";\n}", "methodAfter": "@Override\nprotected String elapsedTimeAsString(long runTime) {\n    return \"0\";\n}"}, {"methodBefore": "public void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}"}, {"methodBefore": "public boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}"}, {"methodBefore": "public void validateAnnotatedClass(Class<?> type, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_CLASS_CALLED));\n}", "methodAfter": "@Override\npublic void validateAnnotatedClass(Class<?> type, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_CLASS_CALLED));\n}"}, {"methodBefore": "public void validateAnnotatedField(Field field, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_FIELD_CALLED));\n}", "methodAfter": "@Override\npublic void validateAnnotatedField(Field field, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_FIELD_CALLED));\n}"}, {"methodBefore": "public void run(final TestResult result) {\n    Protectable p = new Protectable() {\n        public void protect() throws Exception {\n            setUp();\n            basicRun(result);\n            tearDown();\n        }\n    };\n    result.runProtected(this, p);\n}", "methodAfter": "@Override\npublic void run(final TestResult result) {\n    Protectable p = new Protectable() {\n        public void protect() throws Exception {\n            setUp();\n            basicRun(result);\n            tearDown();\n        }\n    };\n    result.runProtected(this, p);\n}"}, {"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "public void testStarted(String testName) {\n}", "methodAfter": "@Override\npublic void testStarted(String testName) {\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}"}, {"methodBefore": "public boolean equals(Object anObject) {\n    if (isZero()) {\n        if (anObject instanceof IMoney) {\n            return ((IMoney) (anObject)).isZero();\n        }\n    }\n    if (anObject instanceof Money) {\n        Money aMoney = ((Money) (anObject));\n        return aMoney.currency().equals(currency()) && (amount() == aMoney.amount());\n    }\n    return false;\n}", "methodAfter": "@Override\npublic boolean equals(Object anObject) {\n    if (isZero()) {\n        if (anObject instanceof IMoney) {\n            return ((IMoney) (anObject)).isZero();\n        }\n    }\n    if (anObject instanceof Money) {\n        Money aMoney = ((Money) (anObject));\n        return aMoney.currency().equals(currency()) && (amount() == aMoney.amount());\n    }\n    return false;\n}"}, {"methodBefore": "public void run(TestResult result) {\n    for (int i = 0; i < fTimesRepeat; i++) {\n        if (result.shouldStop()) {\n            break;\n        }\n        super.run(result);\n    }\n}", "methodAfter": "@Override\npublic void run(TestResult result) {\n    for (int i = 0; i < fTimesRepeat; i++) {\n        if (result.shouldStop()) {\n            break;\n        }\n        super.run(result);\n    }\n}"}, {"methodBefore": "protected void runFailed(String message) {\n    System.err.println(message);\n    System.exit(FAILURE_EXIT);\n}", "methodAfter": "@Override\nprotected void runFailed(String message) {\n    System.err.println(message);\n    System.exit(FAILURE_EXIT);\n}"}, {"methodBefore": "public String getMessage() {\n    return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n}", "methodAfter": "@Override\npublic String getMessage() {\n    return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n}"}, {"methodBefore": "public String getName() {\n    return getField().getName();\n}", "methodAfter": "@Override\npublic String getName() {\n    return getField().getName();\n}"}, {"methodBefore": "public void testCase() {\n}", "methodAfter": "@Override\npublic void testCase() {\n}"}, {"methodBefore": "public String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((fFailedTest + \": \") + fThrownException.getMessage());\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((fFailedTest + \": \") + fThrownException.getMessage());\n    return buffer.toString();\n}"}, {"methodBefore": "public void testEnded(String testName) {\n}", "methodAfter": "@Override\npublic void testEnded(String testName) {\n}"}, {"methodBefore": "public String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}"}, {"methodBefore": "public String toString() {\n    return fTest.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    return fTest.toString();\n}"}, {"methodBefore": "protected void setUp() {\n    fResult = new TestResult();\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fResult = new TestResult();\n}"}, {"methodBefore": "protected void runFailed(String message) {\n}", "methodAfter": "@Override\nprotected void runFailed(String message) {\n}"}, {"methodBefore": "public int countTestCases() {\n    return super.countTestCases() * fTimesRepeat;\n}", "methodAfter": "@Override\npublic int countTestCases() {\n    return super.countTestCases() * fTimesRepeat;\n}"}, {"methodBefore": "public boolean isPublic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isPublic(modifiers);\n}", "methodAfter": "@Override\npublic boolean isPublic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isPublic(modifiers);\n}"}, {"methodBefore": "public String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((((\"[\" + amount()) + \" \") + currency()) + \"]\");\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((((\"[\" + amount()) + \" \") + currency()) + \"]\");\n    return buffer.toString();\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}"}, {"methodBefore": "protected void setUp() {\n    f12CHF = new Money(12, \"CHF\");\n    f14CHF = new Money(14, \"CHF\");\n    f7USD = new Money(7, \"USD\");\n    f21USD = new Money(21, \"USD\");\n    fMB1 = MoneyBag.create(f12CHF, f7USD);\n    fMB2 = MoneyBag.create(f14CHF, f21USD);\n}", "methodAfter": "@Override\nprotected void setUp() {\n    f12CHF = new Money(12, \"CHF\");\n    f14CHF = new Money(14, \"CHF\");\n    f7USD = new Money(7, \"USD\");\n    f21USD = new Money(21, \"USD\");\n    fMB1 = MoneyBag.create(f12CHF, f7USD);\n    fMB2 = MoneyBag.create(f14CHF, f21USD);\n}"}, {"methodBefore": "protected void setUp() {\n    fResult = new TestResult();\n    fResult.addListener(this);\n    fStartCount = 0;\n    fEndCount = 0;\n    fFailureCount = 0;\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fResult = new TestResult();\n    fResult.addListener(this);\n    fStartCount = 0;\n    fEndCount = 0;\n    fFailureCount = 0;\n}"}, {"methodBefore": "public void runTest() {\n    fail();\n}", "methodAfter": "@Override\npublic void runTest() {\n    fail();\n}"}, {"methodBefore": "public void validateAnnotatedMethod(Method method, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_METHOD_CALLED));\n}", "methodAfter": "@Override\npublic void validateAnnotatedMethod(Method method, List<Throwable> errors) {\n    errors.add(new Throwable(ANNOTATED_METHOD_CALLED));\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}"}, {"methodBefore": "protected void runTest() {\n    fWasRun = true;\n}", "methodAfter": "@Override\nprotected void runTest() {\n    fWasRun = true;\n}"}, {"methodBefore": "protected void tearDown() {\n    fTornDown = true;\n}", "methodAfter": "@Override\nprotected void tearDown() {\n    fTornDown = true;\n}"}, {"methodBefore": "public void run(TestResult result) {\n    fActiveTestDeathCount = 0;\n    super.run(result);\n    waitUntilFinished();\n}", "methodAfter": "@Override\npublic void run(TestResult result) {\n    fActiveTestDeathCount = 0;\n    super.run(result);\n    waitUntilFinished();\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<FrameworkMethod> iter = fTestMethods.iterator(); iter.hasNext();) {\n        FrameworkMethod method = iter.next();\n        if (!filter.shouldRun(describeChild(method))) {\n            iter.remove();\n        }\n    }\n    if (fTestMethods.isEmpty()) {\n        throw new NoTestsRemainException();\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<FrameworkMethod> iter = fTestMethods.iterator(); iter.hasNext();) {\n        FrameworkMethod method = iter.next();\n        if (!filter.shouldRun(describeChild(method))) {\n            iter.remove();\n        }\n    }\n    if (fTestMethods.isEmpty()) {\n        throw new NoTestsRemainException();\n    }\n}"}, {"methodBefore": "public String getTestHeader() {\n    return fDescription.getDisplayName();\n}", "methodAfter": "@Override\npublic String getTestHeader() {\n    return fDescription.getDisplayName();\n}"}], [{"methodBefore": "public List<Throwable> getCauses() {\n    return fErrors;\n}", "methodAfter": "public List<Throwable> getCauses() {\n    return Collections.unmodifiableList(fErrors);\n}"}, {"methodBefore": "public List<Throwable> getFailures() {\n    return fErrors;\n}", "methodAfter": "public List<Throwable> getFailures() {\n    return Collections.unmodifiableList(fErrors);\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n    String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + nonExistentFilterFactory });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n    String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + nonExistentFilterFactory });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponUnknownTestClass() throws Exception {\n    String unknownTestClass = \"UnknownTestClass\";\n    jUnitCommandLineParser.parseParameters(new String[]{ unknownTestClass });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnknownTestClass() throws Exception {\n    String unknownTestClass = \"UnknownTestClass\";\n    jUnitCommandLineParser.parseParameters(new String[]{ unknownTestClass });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponUnknownOption() throws Exception {\n    String unknownOption = \"--unknown-option\";\n    jUnitCommandLineParser.parseOptions(new String[]{ unknownOption });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnknownOption() throws Exception {\n    String unknownOption = \"--unknown-option\";\n    jUnitCommandLineParser.parseOptions(new String[]{ unknownOption });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponUncreatedFilter() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + JUnitCommandLineParserTest.FilterFactoryStub.class.getName() });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUncreatedFilter() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + JUnitCommandLineParserTest.FilterFactoryStub.class.getName() });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\" });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError:\"));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\" });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), containsString(\"initializationError\"));\n}"}], [{"methodBefore": "protected final TestClass getTestClass() {\n    return fTestClass;\n}", "methodAfter": "public final TestClass getTestClass() {\n    return fTestClass;\n}"}, {"methodBefore": "protected final TestClass getTestClass() {\n    return fTestClass;\n}", "methodAfter": "public final TestClass getTestClass() {\n    return fTestClass;\n}"}], [{"methodBefore": "@Override\npublic void run(final Roadie context) {\n    context.runProtected(this, new Runnable() {\n        public void run() {\n            try {\n                fNext.run(context);\n            } catch (Throwable e) {\n                context.addFailure(e);\n            }\n        }\n    });\n}", "methodAfter": "@Override\npublic void run(final Roadie context) throws Throwable {\n    try {\n        if (context.runBefores(this)) {\n            fNext.run(context);\n        }\n    } finally {\n        context.runAfters(this);\n    }\n}"}, {"methodBefore": "@Override\npublic void run(final Roadie context) {\n    context.runProtected(this, new Runnable() {\n        public void run() {\n            try {\n                fNext.run(context);\n            } catch (Throwable e) {\n                context.addFailure(e);\n            }\n        }\n    });\n}", "methodAfter": "@Override\npublic void run(final Roadie context) throws Throwable {\n    try {\n        if (context.runBefores(this)) {\n            fNext.run(context);\n        }\n    } finally {\n        context.runAfters(this);\n    }\n}"}], [{"methodBefore": "private MaxCore(String folder) {\n    fHistory = MaxHistory.forFolder(folder);\n}", "methodAfter": "public MaxCore(File storedResults) {\n    fHistory = MaxHistory.forFolder(storedResults);\n}"}, {"methodBefore": "private MaxCore(String folder) {\n    fHistory = MaxHistory.forFolder(folder);\n}", "methodAfter": "public MaxCore(File storedResults) {\n    fHistory = MaxHistory.forFolder(storedResults);\n}"}], [{"methodBefore": "@Test\npublic void divideByZero() {\n    int zero = 0;\n    int result = 8 / zero;\n    result++;\n}", "methodAfter": "@Test\npublic void divideByZero() {\n    int zero = 0;\n    int result = 8 / zero;\n    unused = result;\n}"}, {"methodBefore": "public void testDivideByZero() {\n    int zero = 0;\n    int result = 8 / zero;\n    result++;\n}", "methodAfter": "public void testDivideByZero() {\n    int zero = 0;\n    int result = 8 / zero;\n    unused = result;\n}"}], [{"methodBefore": "@Test\npublic void one() {\n    fExample1One = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1One = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void one() {\n    fOne = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fOne = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void two() {\n    fTwo = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fTwo = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void two() {\n    fExample1Two = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1Two = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void two() {\n    fExample1Two = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void two() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1Two = Thread.currentThread();\n}"}, {"methodBefore": "@Test\npublic void one() {\n    fExample1One = Thread.currentThread();\n}", "methodAfter": "@Test\npublic void one() throws InterruptedException {\n    fSynchronizer.countDown();\n    fSynchronizer.await();\n    fExample1One = Thread.currentThread();\n}"}], [{"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "public void sort(Sorter sorter) {\n    Collections.sort(getCachedChildren(), comparator(sorter));\n    for (T each : getCachedChildren()) {\n        sorter.apply(each);\n    }\n}", "methodAfter": "public void sort(Sorter sorter) {\n    fSorter = sorter;\n}"}, {"methodBefore": "public void sort(Sorter sorter) {\n    Collections.sort(getCachedChildren(), comparator(sorter));\n    for (T each : getCachedChildren()) {\n        sorter.apply(each);\n    }\n}", "methodAfter": "public void sort(Sorter sorter) {\n    fSorter = sorter;\n}"}], [{"methodBefore": "public static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}", "methodAfter": "private static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}"}, {"methodBefore": "public static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}", "methodAfter": "private static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}"}], [{"methodBefore": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    Description description = Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n    description.setParent(getDescription());\n    return description;\n}", "methodAfter": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n}"}, {"methodBefore": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    Description description = Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n    description.setParent(getDescription());\n    return description;\n}", "methodAfter": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());\n}"}], [{"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}], [{"methodBefore": "public static void assertNull(Object object) {\n    assertNull(null, object);\n}", "methodAfter": "public static void assertNull(Object object) {\n    String message = \"Expected: <null> but was: \" + object.toString();\n    assertNull(message, object);\n}"}, {"methodBefore": "public static void assertNull(Object object) {\n    assertNull(null, object);\n}", "methodAfter": "public static void assertNull(Object object) {\n    String message = \"Expected: <null> but was: \" + object.toString();\n    assertNull(message, object);\n}"}], [{"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}, {"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}], [{"methodBefore": "public String getFolder() {\n    return fFolder;\n}", "methodAfter": "public File getFile() {\n    return fFolder;\n}"}, {"methodBefore": "public String getFolder() {\n    return fFolder;\n}", "methodAfter": "public File getFile() {\n    return fFolder;\n}"}], [{"methodBefore": "public void expect(Class<? extends Throwable> type) {\n    fMatcher = instanceOf(type);\n}", "methodAfter": "public void expect(Class<? extends Throwable> type) {\n    expect(instanceOf(type));\n}"}, {"methodBefore": "public void expect(Class<? extends Throwable> type) {\n    fMatcher = instanceOf(type);\n}", "methodAfter": "public void expect(Class<? extends Throwable> type) {\n    expect(instanceOf(type));\n}"}], [{"methodBefore": "public void testSimpleBagAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(7, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, f14CHF.add(fMB1));\n}", "methodAfter": "public void testSimpleBagAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n    assertEquals(expected, f14CHF.add(fMB1));\n}"}, {"methodBefore": "public void testBagSimpleAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(7, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.add(f14CHF));\n}", "methodAfter": "public void testBagSimpleAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n    assertEquals(expected, fMB1.add(f14CHF));\n}"}, {"methodBefore": "public void testBagSumAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(28, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.add(fMB2));\n}", "methodAfter": "public void testBagSumAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(28, \"USD\"));\n    assertEquals(expected, fMB1.add(fMB2));\n}"}], [{"methodBefore": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(is(Integer.class)).and(is(3)));\n}", "methodAfter": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(is(Integer.class)).and(matches(is(3))));\n}"}, {"methodBefore": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(is(Integer.class)).and(is(3)));\n}", "methodAfter": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(is(Integer.class)).and(matches(is(3))));\n}"}], [{"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}", "methodAfter": "@Deprecated\nprotected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);\n}"}], [{"methodBefore": "@Test\npublic void inaccessibleBaseClassIsCaughtAtValidation() {\n    TestClass testClass = new TestClass(Sub.class);\n    ErrorList errors = new ErrorList();\n    testClass.validateMethodsForDefaultRunner(errors);\n    assertFalse(errors.isEmpty());\n}", "methodAfter": "@Test\npublic void inaccessibleBaseClassIsCaughtAtValidation() {\n    TestClass testClass = new TestClass(Sub.class);\n    List<Throwable> errors = new ArrayList<Throwable>();\n    testClass.validateMethodsForDefaultRunner(errors);\n    assertFalse(errors.isEmpty());\n}"}, {"methodBefore": "@Test\npublic void overloaded() {\n    TestClass testClass = new TestClass(TestMethodTest.Confused.class);\n    ErrorList errors = new ErrorList();\n    testClass.validateMethodsForDefaultRunner(errors);\n    assertFalse(errors.isEmpty());\n}", "methodAfter": "@Test\npublic void overloaded() {\n    TestClass testClass = new TestClass(TestMethodTest.Confused.class);\n    List<Throwable> errors = new ArrayList<Throwable>();\n    testClass.validateMethodsForDefaultRunner(errors);\n    assertFalse(errors.isEmpty());\n}"}], [{"methodBefore": "public String getClassName() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    return matcher.matches() ? matcher.group(2) : toString();\n}", "methodAfter": "public String getClassName() {\n    Matcher matcher = methodStringMatcher();\n    return matcher.matches() ? matcher.group(2) : toString();\n}"}, {"methodBefore": "public String getClassName() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    return matcher.matches() ? matcher.group(2) : toString();\n}", "methodAfter": "public String getClassName() {\n    Matcher matcher = methodStringMatcher();\n    return matcher.matches() ? matcher.group(2) : toString();\n}"}, {"methodBefore": "private String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}", "methodAfter": "private String parseMethod() {\n    Matcher matcher = methodStringMatcher();\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}"}], [{"methodBefore": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}", "methodAfter": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}"}, {"methodBefore": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}", "methodAfter": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090428-1600\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.7-SNAPSHOT\";\n}", "methodAfter": "public static String id() {\n    return \"4.7-SNAPSHOT-20090428-1600\";\n}"}], [{"methodBefore": "public boolean isShadowedBy(FrameworkField otherMember) {\n    return false;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkField otherMember) {\n    return otherMember.getField().getName().equals(getField().getName());\n}"}, {"methodBefore": "public boolean isShadowedBy(FrameworkField otherMember) {\n    return false;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkField otherMember) {\n    return otherMember.getField().getName().equals(getField().getName());\n}"}], [{"methodBefore": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    Field[] fields = getTestClass().getJavaClass().getDeclaredFields();\n    for (Field each : fields) {\n        if ((each.getAnnotation(DataPoint.class) != null) && (!Modifier.isStatic(each.getModifiers()))) {\n            errors.add(new Error(\"DataPoint field THREE must be static\"));\n        }\n    }\n}"}, {"methodBefore": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    Field[] fields = getTestClass().getJavaClass().getDeclaredFields();\n    for (Field each : fields) {\n        if ((each.getAnnotation(DataPoint.class) != null) && (!Modifier.isStatic(each.getModifiers()))) {\n            errors.add(new Error(\"DataPoint field THREE must be static\"));\n        }\n    }\n}"}], [{"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}], [{"methodBefore": "public static Filter matchDescription(final Description desiredDescription) {\n    return new Filter() {\n        @Override\n        public boolean shouldRun(Description description) {\n            if (description.isTest()) {\n                return desiredDescription.equals(description);\n            }\n            for (Description each : description.getChildren()) {\n                if (shouldRun(each)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public String describe() {\n            return String.format(\"Method %s\", desiredDescription.getDisplayName());\n        }\n    };\n}", "methodAfter": "public static Filter matchMethodDescription(final Description desiredDescription) {\n    return new Filter() {\n        @Override\n        public boolean shouldRun(Description description) {\n            if (description.isTest()) {\n                return desiredDescription.equals(description);\n            }\n            for (Description each : description.getChildren()) {\n                if (shouldRun(each)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public String describe() {\n            return String.format(\"Method %s\", desiredDescription.getDisplayName());\n        }\n    };\n}"}, {"methodBefore": "public static Filter matchDescription(final Description desiredDescription) {\n    return new Filter() {\n        @Override\n        public boolean shouldRun(Description description) {\n            if (description.isTest()) {\n                return desiredDescription.equals(description);\n            }\n            for (Description each : description.getChildren()) {\n                if (shouldRun(each)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public String describe() {\n            return String.format(\"Method %s\", desiredDescription.getDisplayName());\n        }\n    };\n}", "methodAfter": "public static Filter matchMethodDescription(final Description desiredDescription) {\n    return new Filter() {\n        @Override\n        public boolean shouldRun(Description description) {\n            if (description.isTest()) {\n                return desiredDescription.equals(description);\n            }\n            for (Description each : description.getChildren()) {\n                if (shouldRun(each)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public String describe() {\n            return String.format(\"Method %s\", desiredDescription.getDisplayName());\n        }\n    };\n}"}], [{"methodBefore": "public void reset() {\n    fError = false;\n    setForeground(getStatusColor());\n    setValue(0);\n}", "methodAfter": "public void reset() {\n    fError = false;\n    updateBarColor();\n    setValue(0);\n}"}, {"methodBefore": "public void step(int value, boolean successful) {\n    setValue(value);\n    if ((!fError) && (!successful)) {\n        fError = true;\n        setForeground(getStatusColor());\n    }\n}", "methodAfter": "public void step(int value, boolean successful) {\n    setValue(value);\n    if ((!fError) && (!successful)) {\n        fError = true;\n        updateBarColor();\n    }\n}"}], [{"methodBefore": "@Override\nprotected final void failed(Throwable e, Description description) {\n    endTime = System.nanoTime();\n    failed(getNanos(), e, description);\n}", "methodAfter": "@Override\nprotected final void failed(Throwable e, Description description) {\n    endNanos = System.nanoTime();\n    failed(getNanos(), e, description);\n}"}, {"methodBefore": "@Override\nprotected final void succeeded(Description description) {\n    endTime = System.nanoTime();\n    succeeded(getNanos(), description);\n}", "methodAfter": "@Override\nprotected final void succeeded(Description description) {\n    endNanos = System.nanoTime();\n    succeeded(getNanos(), description);\n}"}, {"methodBefore": "@Override\nprotected final void skipped(AssumptionViolatedException e, Description description) {\n    endTime = System.nanoTime();\n    skipped(getNanos(), e, description);\n}", "methodAfter": "@Override\nprotected final void skipped(AssumptionViolatedException e, Description description) {\n    endNanos = System.nanoTime();\n    skipped(getNanos(), e, description);\n}"}], [{"methodBefore": "private void verifyApplicationClassLoadedByTestLoader() {\n    assert isTestCaseClassLoader(getClass().getClassLoader());\n}", "methodAfter": "private void verifyApplicationClassLoadedByTestLoader() {\n    assertTrue(isTestCaseClassLoader(getClass().getClassLoader()));\n}"}, {"methodBefore": "private void verifyApplicationClassLoadedByTestLoader() {\n    assert isTestCaseClassLoader(getClass().getClassLoader());\n}", "methodAfter": "private void verifyApplicationClassLoadedByTestLoader() {\n    assertTrue(isTestCaseClassLoader(getClass().getClassLoader()));\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "public String getFolder() {\n    return fFolder;\n}", "methodAfter": "public File getFile() {\n    return fFolder;\n}"}, {"methodBefore": "public String getFolder() {\n    return fFolder;\n}", "methodAfter": "public File getFile() {\n    return fFolder;\n}"}], [{"methodBefore": "public static MaxCore forFolder(String folder) throws CouldNotReadCoreException {\n    if (new File(folder + \".ser\").exists()) {\n        return readCore(folder);\n    }\n    return new MaxCore(folder);\n}", "methodAfter": "public static MaxCore forFolder(String storedResults) {\n    return new MaxCore(storedResults);\n}"}, {"methodBefore": "public static MaxCore forFolder(String folder) throws CouldNotReadCoreException {\n    if (new File(folder + \".ser\").exists()) {\n        return readCore(folder);\n    }\n    return new MaxCore(folder);\n}", "methodAfter": "public static MaxCore forFolder(String storedResults) {\n    return new MaxCore(storedResults);\n}"}], [{"methodBefore": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}, {"methodBefore": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}, {"methodBefore": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}, {"methodBefore": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}], [{"methodBefore": "public static String id() {\n    return \"3.7\";\n}", "methodAfter": "public static String id() {\n    return \"@version@\";\n}"}, {"methodBefore": "public static String id() {\n    return \"3.7\";\n}", "methodAfter": "public static String id() {\n    return \"@version@\";\n}"}, {"methodBefore": "public static String id() {\n    return \"3.8\";\n}", "methodAfter": "public static String id() {\n    return \"@version@\";\n}"}], [{"methodBefore": "public List<Test> getTests() {\n    return fCache.asTestList(fRunner.getPlan());\n}", "methodAfter": "public List<Test> getTests() {\n    return fCache.asTestList(getDescription());\n}"}, {"methodBefore": "public List<Test> getTests() {\n    return fCache.asTestList(fRunner.getPlan());\n}", "methodAfter": "public List<Test> getTests() {\n    return fCache.asTestList(getDescription());\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "public Result run(Request request, JUnitCore core) {\n    core.addListener(new RememberingListener());\n    try {\n        return core.run(sortRequest(request).getRunner());\n    } finally {\n        try {\n            save();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "public Result run(Request request, JUnitCore core) {\n    core.addListener(fHistory.listener());\n    try {\n        return core.run(sortRequest(request).getRunner());\n    } finally {\n        try {\n            fHistory.save();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "public Result run(Request request, JUnitCore core) {\n    core.addListener(new RememberingListener());\n    try {\n        return core.run(sortRequest(request).getRunner());\n    } finally {\n        try {\n            save();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "public Result run(Request request, JUnitCore core) {\n    core.addListener(fHistory.listener());\n    try {\n        return core.run(sortRequest(request).getRunner());\n    } finally {\n        try {\n            fHistory.save();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    fResults.add(fService.submit(callable));\n}", "methodAfter": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}"}, {"methodBefore": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    fResults.add(fService.submit(callable));\n}", "methodAfter": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}"}], [{"methodBefore": "@Override\npublic Description getDescription() {\n    return new EmptyDescription();\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    return Description.EMPTY;\n}"}, {"methodBefore": "@Override\npublic Description getDescription() {\n    return new EmptyDescription();\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    return Description.EMPTY;\n}"}], [{"methodBefore": "public static MaxHistory locallyStored(File file) {\n    try {\n        if (file.exists()) {\n            return readHistory(file);\n        }\n    } catch (CouldNotReadCoreException e) {\n        e.printStackTrace();\n        file.delete();\n    }\n    return new MaxHistory(file);\n}", "methodAfter": "public static MaxHistory forFolder(File file) {\n    if (file.getPath() == null) {\n        throw new NullPointerException();\n    }\n    if (file.exists()) {\n        try {\n            return readHistory(file);\n        } catch (CouldNotReadCoreException e) {\n            e.printStackTrace();\n            file.delete();\n        }\n    }\n    return new MaxHistory(file);\n}"}, {"methodBefore": "public static MaxHistory locallyStored(File file) {\n    try {\n        if (file.exists()) {\n            return readHistory(file);\n        }\n    } catch (CouldNotReadCoreException e) {\n        e.printStackTrace();\n        file.delete();\n    }\n    return new MaxHistory(file);\n}", "methodAfter": "public static MaxHistory forFolder(File file) {\n    if (file.getPath() == null) {\n        throw new NullPointerException();\n    }\n    if (file.exists()) {\n        try {\n            return readHistory(file);\n        } catch (CouldNotReadCoreException e) {\n            e.printStackTrace();\n            file.delete();\n        }\n    }\n    return new MaxHistory(file);\n}"}], [{"methodBefore": "public void testAssertNull() {\n    assertNull(null);\n    try {\n        assertNull(new Object());\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNull() {\n    assertNull(null);\n    try {\n        assertNull(new Object());\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNaNEqualsNaNFails() {\n    try {\n        assertEquals(Double.NaN, Double.NaN, 0.0);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNaNEqualsNaNFails() {\n    try {\n        assertEquals(Double.NaN, Double.NaN, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNullNotEqualsNull() {\n    try {\n        assertEquals(null, new Object());\n        fail();\n    } catch (AssertionFailedError e) {\n        e.getMessage();\n    }\n}", "methodAfter": "public void testAssertNullNotEqualsNull() {\n    try {\n        assertEquals(null, new Object());\n    } catch (AssertionFailedError e) {\n        e.getMessage();\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNotNull() {\n    assertNotNull(new Object());\n    try {\n        assertNotNull(null);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNotNull() {\n    assertNotNull(new Object());\n    try {\n        assertNotNull(null);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertPosInfinityNotEquals() {\n    try {\n        assertEquals(Double.POSITIVE_INFINITY, 1.23, 0.0);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertPosInfinityNotEquals() {\n    try {\n        assertEquals(Double.POSITIVE_INFINITY, 1.23, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertPosInfinityNotEqualsNegInfinity() {\n    try {\n        assertEquals(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0.0);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertPosInfinityNotEqualsNegInfinity() {\n    try {\n        assertEquals(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNotSame() {\n    assertNotSame(new Integer(1), null);\n    assertNotSame(null, new Integer(1));\n    assertNotSame(new Integer(1), new Integer(1));\n    try {\n        Integer obj = new Integer(1);\n        assertNotSame(obj, obj);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNotSame() {\n    assertNotSame(new Integer(1), null);\n    assertNotSame(null, new Integer(1));\n    assertNotSame(new Integer(1), new Integer(1));\n    try {\n        Integer obj = new Integer(1);\n        assertNotSame(obj, obj);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertEquals() {\n    Object o = new Object();\n    assertEquals(o, o);\n    try {\n        assertEquals(new Object(), new Object());\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertEquals() {\n    Object o = new Object();\n    assertEquals(o, o);\n    try {\n        assertEquals(new Object(), new Object());\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertEqualsNaNFails() {\n    try {\n        assertEquals(1.234, Double.NaN, 0.0);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertEqualsNaNFails() {\n    try {\n        assertEquals(1.234, Double.NaN, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNaNEqualsFails() {\n    try {\n        assertEquals(Double.NaN, 1.234, 0.0);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNaNEqualsFails() {\n    try {\n        assertEquals(Double.NaN, 1.234, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertTrue() {\n    assertTrue(true);\n    try {\n        assertTrue(false);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertTrue() {\n    assertTrue(true);\n    try {\n        assertTrue(false);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertFalse() {\n    assertFalse(false);\n    try {\n        assertFalse(true);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertFalse() {\n    assertFalse(false);\n    try {\n        assertFalse(true);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNotSameFailsNull() {\n    try {\n        assertNotSame(null, null);\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertNotSameFailsNull() {\n    try {\n        assertNotSame(null, null);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertSame() {\n    Object o = new Object();\n    assertSame(o, o);\n    try {\n        assertSame(new Integer(1), new Integer(1));\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}", "methodAfter": "public void testAssertSame() {\n    Object o = new Object();\n    assertSame(o, o);\n    try {\n        assertSame(new Integer(1), new Integer(1));\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}], [{"methodBefore": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}", "methodAfter": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        if (ClassRule.class.isAssignableFrom(field.getType())) {\n            if (!Modifier.isStatic(field.getModifiers())) {\n                errors.add(new Exception((\"Field \" + field.getName()) + \" must be static\"));\n            }\n        } else {\n            errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule or ClassRule\"));\n        }\n    }\n}"}, {"methodBefore": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule\"));\n    }\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n}", "methodAfter": "private void validateRuleField(Field field, List<Throwable> errors) {\n    if (!Modifier.isPublic(field.getModifiers())) {\n        errors.add(new Exception((\"Field \" + field.getName()) + \" must be public\"));\n    }\n    if (!MethodRule.class.isAssignableFrom(field.getType())) {\n        if (ClassRule.class.isAssignableFrom(field.getType())) {\n            if (!Modifier.isStatic(field.getModifiers())) {\n                errors.add(new Exception((\"Field \" + field.getName()) + \" must be static\"));\n            }\n        } else {\n            errors.add(new Exception((\"Field \" + field.getName()) + \" must implement MethodRule or ClassRule\"));\n        }\n    }\n}"}], [{"methodBefore": "private Description parentDescription(Description description) {\n    return description.getParentDescription();\n}", "methodAfter": "private Description parentDescription(Description description) {\n    return Description.createSuiteDescription(description.getTestClass());\n}"}, {"methodBefore": "private Description parentDescription(Description description) {\n    return description.getParentDescription();\n}", "methodAfter": "private Description parentDescription(Description description) {\n    return Description.createSuiteDescription(description.getTestClass());\n}"}], [{"methodBefore": "@Test\npublic void matchingRunnersOnCategories() throws InitializationError {\n    assertEquals(1, CategoryFilter.include(CategoriesMark2Test.Yes.class).matchingRunners(Arrays.asList(new BlockJUnit4ClassRunner(CategoriesMark2Test.Yes1.class))).size());\n}", "methodAfter": "@Test\npublic void matchingRunnersOnCategories() throws InitializationError {\n    Runner blockJUnit4ClassRunner = new BlockJUnit4ClassRunner(CategoriesMark2Test.Yes1.class);\n    assertEquals(1, CategoryFilter.include(CategoriesMark2Test.Yes.class).matchingRunners(Arrays.asList(blockJUnit4ClassRunner)).size());\n}"}, {"methodBefore": "@Test\npublic void matchingRunnersOnCategories() throws InitializationError {\n    assertEquals(1, CategoryFilter.include(CategoriesMark2Test.Yes.class).matchingRunners(Arrays.asList(new BlockJUnit4ClassRunner(CategoriesMark2Test.Yes1.class))).size());\n}", "methodAfter": "@Test\npublic void matchingRunnersOnCategories() throws InitializationError {\n    Runner blockJUnit4ClassRunner = new BlockJUnit4ClassRunner(CategoriesMark2Test.Yes1.class);\n    assertEquals(1, CategoryFilter.include(CategoriesMark2Test.Yes.class).matchingRunners(Arrays.asList(blockJUnit4ClassRunner)).size());\n}"}], [{"methodBefore": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}, {"methodBefore": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}]]