[[{"methodBefore": "String getMethodDescriptor() {\n    return methodDescriptor;\n}", "methodAfter": "public String getMethodDescriptor() {\n    return methodDescriptor;\n}"}, {"methodBefore": "String getMethodName() {\n    return methodName;\n}", "methodAfter": "public String getMethodName() {\n    return methodName;\n}"}], [{"methodBefore": "private boolean jj_3R_348() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_343() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_443() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_432() {\n    if (jj_3R_312()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_348() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_343() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_443() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_432() {\n    if (jj_3R_312()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_378() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_378() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_100()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_160() {\n    if (jj_3R_180()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_160() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3_7() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_85()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_7() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_88()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(AT)) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_421() {\n    if (jj_3R_200()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_421() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_341()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_409() {\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_409() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_387() {\n    if (jj_3R_279()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_387() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_386()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_219() {\n    if (jj_3R_237()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_284() {\n    if (jj_3R_215()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_286() {\n    if (jj_3R_318()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_283() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_78() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_399() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    SourceFileData sourceFileData = ((SourceFileData) (obj));\n    return super.equals(obj) && this.name.equals(sourceFileData.name);\n}", "methodAfter": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    SourceFileData sourceFileData = ((SourceFileData) (obj));\n    getBothLocks(sourceFileData);\n    try {\n        return super.equals(obj) && this.name.equals(sourceFileData.name);\n    } finally {\n        lock.unlock();\n        sourceFileData.lock.unlock();\n    }\n}"}, {"methodBefore": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    PackageData packageData = ((PackageData) (obj));\n    return super.equals(obj) && this.name.equals(packageData.name);\n}", "methodAfter": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    PackageData packageData = ((PackageData) (obj));\n    getBothLocks(packageData);\n    try {\n        return super.equals(obj) && this.name.equals(packageData.name);\n    } finally {\n        lock.unlock();\n        packageData.lock.unlock();\n    }\n}"}], [{"methodBefore": "private void addInstrumentationToSingleClass(File file) {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(true);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n        cr.accept(cv, false);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        inputStream = IOUtil.closeInputStream(inputStream);\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        outputStream = IOUtil.closeOutputStream(outputStream);\n    }\n}", "methodAfter": "private void addInstrumentationToSingleClass(File file) {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n        cr.accept(cv, 0);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        inputStream = IOUtil.closeInputStream(inputStream);\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        outputStream = IOUtil.closeOutputStream(outputStream);\n    }\n}"}, {"methodBefore": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Exception {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(true);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n                    cr.accept(cv, false);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}", "methodAfter": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Exception {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n                    cr.accept(cv, 0);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}"}], [{"methodBefore": "private final boolean jj_3R_221() {\n    if (jj_3R_239()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_209() {\n    if (jj_3R_223()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_393() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_93() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_280() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_331() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_223() {\n    if (jj_3R_241()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_242() {\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_363() {\n    if (jj_3R_372()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_172() {\n    if (jj_3R_194()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_384() {\n    if (jj_3R_399()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_299() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void UnmodifiedClassDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += new String(getToken(2).image);\n    _classLevel++;\n    Modifiers();\n    jj_consume_token(CLASS);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[19] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            Name();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case LT :\n                    TypeArguments();\n                    break;\n                default :\n                    jj_la1[20] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[21] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            jj_consume_token(IMPLEMENTS);\n            NameList();\n            break;\n        default :\n            jj_la1[22] = jj_gen;\n    }\n    ClassBody();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        Vector vMetrics = new Vector();\n        vMetrics.addElement(new String(_sPackage + _sClass));\n        vMetrics.addElement(new Integer(_ncss - oldNcss));\n        vMetrics.addElement(new Integer(_functions - oldFunctions));\n        vMetrics.addElement(new Integer(_classes - oldClasses));\n        Token lastToken = getToken(0);\n        vMetrics.addElement(new Integer(lastToken.endLine));\n        vMetrics.addElement(new Integer(lastToken.endColumn));\n        _vClasses.addElement(vMetrics);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}", "methodAfter": "public final void UnmodifiedClassDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(2).image;\n    _classLevel++;\n    Modifiers();\n    jj_consume_token(CLASS);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[19] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            Name();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case LT :\n                    TypeArguments();\n                    break;\n                default :\n                    jj_la1[20] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[21] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            jj_consume_token(IMPLEMENTS);\n            NameList();\n            break;\n        default :\n            jj_la1[22] = jj_gen;\n    }\n    ClassBody();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        ObjectMetric metric = new ObjectMetric();\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}"}, {"methodBefore": "public final void UnmodifiedInterfaceDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += new String(getToken(2).image);\n    _classLevel++;\n    jj_consume_token(INTERFACE);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[40] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            NameList();\n            break;\n        default :\n            jj_la1[41] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    label_22 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n            case LT :\n                break;\n            default :\n                jj_la1[42] = jj_gen;\n                break label_22;\n        }\n        InterfaceMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        Vector vMetrics = new Vector();\n        vMetrics.addElement(new String(_sPackage + _sClass));\n        vMetrics.addElement(new Integer(_ncss - oldNcss));\n        vMetrics.addElement(new Integer(_functions - oldFunctions));\n        vMetrics.addElement(new Integer(_classes - oldClasses));\n        vMetrics.addElement(Util.getConstantObject());\n        vMetrics.addElement(Util.getConstantObject());\n        _vClasses.addElement(vMetrics);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}", "methodAfter": "public final void UnmodifiedInterfaceDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(2).image;\n    _classLevel++;\n    jj_consume_token(INTERFACE);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[40] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            NameList();\n            break;\n        default :\n            jj_la1[41] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    label_22 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n            case LT :\n                break;\n            default :\n                jj_la1[42] = jj_gen;\n                break label_22;\n        }\n        InterfaceMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        ObjectMetric metric = new ObjectMetric();\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}"}], [{"methodBefore": "public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n    MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);\n    if (!instrument) {\n        return mv;\n    }\n    return mv == null ? null : new MethodInstrumenter(mv, coverageData, this.myName, name, desc);\n}", "methodAfter": "public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n    MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);\n    if (!instrument) {\n        return mv;\n    }\n    return mv == null ? null : new MethodInstrumenter(mv, coverageData, this.myName, name, desc, ignoreRegexp);\n}"}, {"methodBefore": "private void addInstrumentation(File file) {\n    if (file.isDirectory()) {\n        File[] contents = file.listFiles();\n        for (int i = 0; i < contents.length; i++) {\n            addInstrumentation(contents[i]);\n        }\n        return;\n    }\n    if (!isClass(file)) {\n        return;\n    }\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"instrumenting \" + file.getAbsolutePath());\n    }\n    InputStream inputStream = null;\n    OutputStream outputStream = null;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        ClassWriter cw = new ClassWriter(true);\n        ClassInstrumenter cv = new ClassInstrumenter(cw);\n        cr.accept(cv, false);\n        byte[] instrumentedClass = cw.toByteArray();\n        if (cv.isInstrumented()) {\n            File outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            outputFile.getParentFile().mkdirs();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (IOException e) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath());\n        logger.info(e);\n    } finally {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n            }\n        }\n        if (outputStream != null) {\n            try {\n                outputStream.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}", "methodAfter": "private void addInstrumentation(File file) {\n    if (file.isDirectory()) {\n        File[] contents = file.listFiles();\n        for (int i = 0; i < contents.length; i++) {\n            addInstrumentation(contents[i]);\n        }\n        return;\n    }\n    if (!isClass(file)) {\n        return;\n    }\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"instrumenting \" + file.getAbsolutePath());\n    }\n    InputStream inputStream = null;\n    OutputStream outputStream = null;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        ClassWriter cw = new ClassWriter(true);\n        ClassInstrumenter cv = new ClassInstrumenter(cw, ignoreRegexp);\n        cr.accept(cv, false);\n        byte[] instrumentedClass = cw.toByteArray();\n        if (cv.isInstrumented()) {\n            File outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            outputFile.getParentFile().mkdirs();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (IOException e) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath());\n        logger.info(e);\n    } finally {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n            }\n        }\n        if (outputStream != null) {\n            try {\n                outputStream.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}"}], [{"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreBranchesRegexs.size(); i++) {\n            IgnoreBranches ignoreBranchesRegex = ((IgnoreBranches) (ignoreBranchesRegexs.get(i)));\n            builder.addArg(\"--ignoreBranches\", ignoreBranchesRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreMethodAnnotations.size(); i++) {\n            IgnoreMethodAnnotation ignoreMethodAnn = ((IgnoreMethodAnnotation) (ignoreMethodAnnotations.get(i)));\n            builder.addArg(\"--ignoreMethodAnnotation\", ignoreMethodAnn.getAnnotationName());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (ignoreTrivial) {\n            builder.addArg(\"--ignoreTrivial\");\n        }\n        if (failOnError) {\n            builder.addArg(\"--failOnError\");\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreBranchesRegexs.size(); i++) {\n            IgnoreBranches ignoreBranchesRegex = ((IgnoreBranches) (ignoreBranchesRegexs.get(i)));\n            builder.addArg(\"--ignoreBranches\", ignoreBranchesRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreMethodAnnotations.size(); i++) {\n            IgnoreMethodAnnotation ignoreMethodAnn = ((IgnoreMethodAnnotation) (ignoreMethodAnnotations.get(i)));\n            builder.addArg(\"--ignoreMethodAnnotation\", ignoreMethodAnn.getAnnotationName());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (ignoreTrivial) {\n            builder.addArg(\"--ignoreTrivial\");\n        }\n        if (threadsafeRigorous) {\n            builder.addArg(\"--threadsafeRigorous\");\n        }\n        if (failOnError) {\n            builder.addArg(\"--failOnError\");\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}"}, {"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreBranchesRegexs.size(); i++) {\n            IgnoreBranches ignoreBranchesRegex = ((IgnoreBranches) (ignoreBranchesRegexs.get(i)));\n            builder.addArg(\"--ignoreBranches\", ignoreBranchesRegex.getRegex());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreBranchesRegexs.size(); i++) {\n            IgnoreBranches ignoreBranchesRegex = ((IgnoreBranches) (ignoreBranchesRegexs.get(i)));\n            builder.addArg(\"--ignoreBranches\", ignoreBranchesRegex.getRegex());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (failOnError) {\n            builder.addArg(\"--failOnError\");\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}"}, {"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreBranchesRegexs.size(); i++) {\n            IgnoreBranches ignoreBranchesRegex = ((IgnoreBranches) (ignoreBranchesRegexs.get(i)));\n            builder.addArg(\"--ignoreBranches\", ignoreBranchesRegex.getRegex());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (failOnError) {\n            builder.addArg(\"--failOnError\");\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreBranchesRegexs.size(); i++) {\n            IgnoreBranches ignoreBranchesRegex = ((IgnoreBranches) (ignoreBranchesRegexs.get(i)));\n            builder.addArg(\"--ignoreBranches\", ignoreBranchesRegex.getRegex());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (ignoreTrivial) {\n            builder.addArg(\"--ignoreTrivial\");\n        }\n        if (failOnError) {\n            builder.addArg(\"--failOnError\");\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}"}], [{"methodBefore": "public void testSaveAndRestore() {\n    File dataFile = new File(tmpDir, CoverageDataFileHandler.FILE_NAME);\n    CoverageDataFileHandler.SaveCoverageData(a, dataFile);\n    CoverageData b;\n    b = CoverageDataFileHandler.LoadCoverageData(dataFile);\n    assertEquals(a, b);\n}", "methodAfter": "public void testSaveAndRestore() {\n    File dataFile = new File(tmpDir, CoverageDataFileHandler.FILE_NAME);\n    CoverageDataFileHandler.SaveCoverageData(a, dataFile);\n    ProjectData b;\n    b = CoverageDataFileHandler.LoadCoverageData(dataFile);\n    assertEquals(a, b);\n}"}, {"methodBefore": "public static CoverageData LoadCoverageData(File dataFile) {\n    InputStream is = null;\n    try {\n        is = new FileInputStream(dataFile);\n        return LoadCoverageData(is);\n    } catch (IOException e) {\n        logger.debug(\"Error loading file \" + dataFile.getAbsolutePath(), e);\n        return null;\n    } finally {\n        if (is != null) {\n            try {\n                is.close();\n            } catch (IOException e) {\n                logger.debug(\"Error closing file \" + dataFile.getAbsolutePath(), e);\n            }\n        }\n    }\n}", "methodAfter": "public static ProjectData LoadCoverageData(File dataFile) {\n    InputStream is = null;\n    try {\n        is = new FileInputStream(dataFile);\n        return LoadCoverageData(is);\n    } catch (IOException e) {\n        logger.debug(\"Error loading file \" + dataFile.getAbsolutePath(), e);\n        return null;\n    } finally {\n        if (is != null) {\n            try {\n                is.close();\n            } catch (IOException e) {\n                logger.debug(\"Error closing file \" + dataFile.getAbsolutePath(), e);\n            }\n        }\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_122() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_132() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_400() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_417() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_116() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_126() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_159() {\n    if (jj_3R_179()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_159() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3_40() {\n    if (jj_3R_108()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_40() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    PackageData packageData = ((PackageData) (obj));\n    return super.equals(obj) && this.name.equals(packageData.name);\n}", "methodAfter": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    PackageData packageData = ((PackageData) (obj));\n    getBothLocks(packageData);\n    try {\n        return super.equals(obj) && this.name.equals(packageData.name);\n    } finally {\n        lock.unlock();\n        packageData.lock.unlock();\n    }\n}"}, {"methodBefore": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    SourceFileData sourceFileData = ((SourceFileData) (obj));\n    return super.equals(obj) && this.name.equals(sourceFileData.name);\n}", "methodAfter": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    SourceFileData sourceFileData = ((SourceFileData) (obj));\n    getBothLocks(sourceFileData);\n    try {\n        return super.equals(obj) && this.name.equals(sourceFileData.name);\n    } finally {\n        lock.unlock();\n        sourceFileData.lock.unlock();\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_153() {\n    if (jj_3R_177()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_385() {\n    if (jj_3R_407()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_156() {\n    if (jj_3R_177()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_437() {\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void closeSocket(ServerSocket socket) {\n    try {\n        if ((socket != null) || socket.isClosed()) {\n            socket.close();\n        }\n    } catch (Throwable t) {\n        t.printStackTrace(System.err);\n    }\n}", "methodAfter": "private void closeSocket(ServerSocket socket) {\n    try {\n        if ((socket != null) && socket.isClosed()) {\n            socket.close();\n        }\n    } catch (Throwable t) {\n        t.printStackTrace(System.err);\n    }\n}"}, {"methodBefore": "private static boolean trySocket(InetSocketAddress address) {\n    boolean success = false;\n    Socket socket = null;\n    try {\n        socket = new Socket();\n        socket.connect(address);\n        success = true;\n    } catch (ConnectException e) {\n    } catch (Throwable e) {\n        e.printStackTrace();\n    } finally {\n        if ((socket != null) || (!socket.isClosed())) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return success;\n}", "methodAfter": "private static boolean trySocket(InetSocketAddress address) {\n    boolean success = false;\n    Socket socket = null;\n    try {\n        socket = new Socket();\n        socket.connect(address);\n        success = true;\n    } catch (ConnectException e) {\n    } catch (Throwable e) {\n        e.printStackTrace();\n    } finally {\n        if ((socket != null) && (!socket.isClosed())) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return success;\n}"}], [{"methodBefore": "private final boolean jj_3R_219() {\n    if (jj_3R_237()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_284() {\n    if (jj_3R_215()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_286() {\n    if (jj_3R_318()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_283() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void addLineSwitch(int lineNumber, int switchNumber, int min, int max) {\n    LineData lineData = getLineData(lineNumber);\n    if (lineData != null) {\n        lineData.addSwitch(switchNumber, min, max);\n        this.branches.put(new Integer(lineNumber), lineData);\n    }\n}", "methodAfter": "public void addLineSwitch(int lineNumber, int switchNumber, int min, int max) {\n    lock.lock();\n    try {\n        LineData lineData = getLineData(lineNumber);\n        if (lineData != null) {\n            lineData.addSwitch(switchNumber, min, max);\n            this.branches.put(Integer.valueOf(lineNumber), lineData);\n        }\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public void addLineSwitch(int lineNumber, int switchNumber, int[] keys) {\n    LineData lineData = getLineData(lineNumber);\n    if (lineData != null) {\n        lineData.addSwitch(switchNumber, keys);\n        this.branches.put(new Integer(lineNumber), lineData);\n    }\n}", "methodAfter": "public void addLineSwitch(int lineNumber, int switchNumber, int[] keys) {\n    lock.lock();\n    try {\n        LineData lineData = getLineData(lineNumber);\n        if (lineData != null) {\n            lineData.addSwitch(switchNumber, keys);\n            this.branches.put(Integer.valueOf(lineNumber), lineData);\n        }\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_289() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_287() {\n    if (jj_3R_290()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_384() {\n    if (jj_3R_399()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_299() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean addInstrumentationToArchive(CoberturaFile file, InputStream archive, OutputStream output) throws Throwable {\n    ZipInputStream zis = null;\n    ZipOutputStream zos = null;\n    try {\n        zis = new ZipInputStream(archive);\n        zos = new ZipOutputStream(output);\n        return addInstrumentationToArchive(file, zis, zos);\n    } finally {\n        zis = ((ZipInputStream) (IOUtil.closeInputStream(zis)));\n        zos = ((ZipOutputStream) (IOUtil.closeOutputStream(zos)));\n    }\n}", "methodAfter": "private boolean addInstrumentationToArchive(CoberturaFile file, InputStream archive, OutputStream output) throws Exception {\n    ZipInputStream zis = null;\n    ZipOutputStream zos = null;\n    try {\n        zis = new ZipInputStream(archive);\n        zos = new ZipOutputStream(output);\n        return addInstrumentationToArchive(file, zis, zos);\n    } finally {\n        zis = ((ZipInputStream) (IOUtil.closeInputStream(zis)));\n        zos = ((ZipOutputStream) (IOUtil.closeOutputStream(zos)));\n    }\n}"}, {"methodBefore": "private void addInstrumentationToArchive(Archive archive) throws Throwable {\n    InputStream in = null;\n    ByteArrayOutputStream out = null;\n    try {\n        in = archive.getInputStream();\n        out = new ByteArrayOutputStream();\n        boolean modified = addInstrumentationToArchive(archive.getCoberturaFile(), in, out);\n        if (modified) {\n            out.flush();\n            byte[] bytes = out.toByteArray();\n            archive.setModifiedBytes(bytes);\n        }\n    } finally {\n        in = IOUtil.closeInputStream(in);\n        out = ((ByteArrayOutputStream) (IOUtil.closeOutputStream(out)));\n    }\n}", "methodAfter": "private void addInstrumentationToArchive(Archive archive) throws Exception {\n    InputStream in = null;\n    ByteArrayOutputStream out = null;\n    try {\n        in = archive.getInputStream();\n        out = new ByteArrayOutputStream();\n        boolean modified = addInstrumentationToArchive(archive.getCoberturaFile(), in, out);\n        if (modified) {\n            out.flush();\n            byte[] bytes = out.toByteArray();\n            archive.setModifiedBytes(bytes);\n        }\n    } finally {\n        in = IOUtil.closeInputStream(in);\n        out = ((ByteArrayOutputStream) (IOUtil.closeOutputStream(out)));\n    }\n}"}], [{"methodBefore": "private void dumpPackage(PackageData packageData) {\n    logger.debug(\"Dumping package \" + packageData.getName());\n    println(((((((\"<package name=\\\"\" + packageData.getName()) + \"\\\" line-rate=\\\"\") + packageData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + packageData.getBranchCoverageRate()) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpClasses(packageData);\n    decreaseIndentation();\n    println(\"</package>\");\n}", "methodAfter": "private void dumpPackage(PackageData packageData) {\n    logger.debug(\"Dumping package \" + packageData.getName());\n    double ccn = Util.getCCN(new File(sourceDirectory, packageData.getSourceFileName()), false);\n    println(((((((((\"<package name=\\\"\" + packageData.getName()) + \"\\\" line-rate=\\\"\") + packageData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + packageData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpClasses(packageData);\n    decreaseIndentation();\n    println(\"</package>\");\n}"}, {"methodBefore": "private void dumpClass(ClassData classData) {\n    logger.debug(\"Dumping class \" + classData.getName());\n    println(((((((((\"<class name=\\\"\" + classData.getName()) + \"\\\" filename=\\\"\") + classData.getSourceFileName()) + \"\\\" line-rate=\\\"\") + classData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + classData.getBranchCoverageRate()) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpMethods(classData);\n    dumpLines(classData);\n    decreaseIndentation();\n    println(\"</class>\");\n}", "methodAfter": "private void dumpClass(ClassData classData) {\n    logger.debug(\"Dumping class \" + classData.getName());\n    double ccn = Util.getCCN(new File(sourceDirectory, classData.getSourceFileName()), false);\n    println(((((((((((\"<class name=\\\"\" + classData.getName()) + \"\\\" filename=\\\"\") + classData.getSourceFileName()) + \"\\\" line-rate=\\\"\") + classData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + classData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpMethods(classData);\n    dumpLines(classData);\n    decreaseIndentation();\n    println(\"</class>\");\n}"}], [{"methodBefore": "private void instrumentInvokeTouchJump() {\n    mv.visitMethodInsn(INVOKEVIRTUAL, \"net/sourceforge/cobertura/coveragedata/ClassData\", \"touchJump\", \"(IIZ)V\");\n    mv.visitIntInsn(SIPUSH, -1);\n    mv.visitVarInsn(ISTORE, myVariableIndex + 1);\n}", "methodAfter": "private void instrumentInvokeTouchJump() {\n    mv.visitMethodInsn(INVOKESTATIC, TOUCH_COLLECTOR_CLASS, \"touchJump\", \"(Ljava/lang/String;IIZ)V\");\n    mv.visitIntInsn(SIPUSH, -1);\n    mv.visitVarInsn(ISTORE, myVariableIndex + 1);\n}"}, {"methodBefore": "private void instrumentInvokeTouchSwitch() {\n    mv.visitMethodInsn(INVOKEVIRTUAL, \"net/sourceforge/cobertura/coveragedata/ClassData\", \"touchSwitch\", \"(III)V\");\n}", "methodAfter": "private void instrumentInvokeTouchSwitch() {\n    mv.visitMethodInsn(INVOKESTATIC, TOUCH_COLLECTOR_CLASS, \"touchSwitch\", \"(Ljava/lang/String;III)V\");\n}"}], [{"methodBefore": "private final boolean jj_3R_418() {\n    if (jj_3R_423()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_418() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_138() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_138() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_194() {\n    if (jj_3R_205()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_145() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_152() {\n    if (jj_3R_176()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_166() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_305() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_304()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_397() {\n    if (jj_3R_303()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3_47() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_113()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_43() {\n    if (jj_3R_118()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_387() {\n    if (jj_3R_279()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_387() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_386()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_378() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_378() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_100()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public Vector getFunctions() {\n    return _vFunctionMetrics;\n}", "methodAfter": "public List getFunctions() {\n    return _vFunctionMetrics;\n}"}, {"methodBefore": "public Vector getPackageMetrics() {\n    return _vPackageMetrics;\n}", "methodAfter": "public List getPackageMetrics() {\n    return _vPackageMetrics;\n}"}], [{"methodBefore": "public static double getCCN(File file, boolean recursive) {\n    int ccnAccumulator = 0;\n    Vector files = getListOfFiles(file, recursive);\n    if (files.isEmpty()) {\n        logger.warn(((\"Cannot find files to compute CCN, file=\" + file.getAbsolutePath()) + \", recursive=\") + recursive);\n        return 0;\n    }\n    Javancss javancss = new Javancss(files);\n    List functionMetrics = javancss.getFunctionMetrics();\n    if (functionMetrics.size() <= 0) {\n        return 0;\n    }\n    Iterator iter = functionMetrics.iterator();\n    while (iter.hasNext()) {\n        Vector functionMetric = ((Vector) (iter.next()));\n        ccnAccumulator += ((Integer) (functionMetric.elementAt(FCT_CCN))).intValue();\n    } \n    return ((double) (ccnAccumulator)) / functionMetrics.size();\n}", "methodAfter": "public static double getCCN(File file, boolean recursive) {\n    if (file == null) {\n        return 0;\n    }\n    int ccnAccumulator = 0;\n    Vector files = getListOfFiles(file, recursive);\n    if (files.isEmpty()) {\n        logger.warn(((\"Cannot find files to compute CCN, file=\" + file.getAbsolutePath()) + \", recursive=\") + recursive);\n        return 0;\n    }\n    Javancss javancss = new Javancss(files);\n    List functionMetrics = javancss.getFunctionMetrics();\n    if (functionMetrics.size() <= 0) {\n        return 0;\n    }\n    Iterator iter = functionMetrics.iterator();\n    while (iter.hasNext()) {\n        Vector functionMetric = ((Vector) (iter.next()));\n        ccnAccumulator += ((Integer) (functionMetric.elementAt(FCT_CCN))).intValue();\n    } \n    return ((double) (ccnAccumulator)) / functionMetrics.size();\n}"}, {"methodBefore": "public void merge(CoverageData coverageData) {\n    ProjectData projectData = ((ProjectData) (coverageData));\n    getBothLocks(projectData);\n    try {\n        super.merge(coverageData);\n        for (Iterator iter = projectData.classes.keySet().iterator(); iter.hasNext();) {\n            Object key = iter.next();\n            if (!this.classes.containsKey(key)) {\n                this.classes.put(key, projectData.classes.get(key));\n            }\n        }\n    } finally {\n        lock.unlock();\n        projectData.lock.unlock();\n    }\n}", "methodAfter": "public void merge(CoverageData coverageData) {\n    if (coverageData == null) {\n        return;\n    }\n    ProjectData projectData = ((ProjectData) (coverageData));\n    getBothLocks(projectData);\n    try {\n        super.merge(coverageData);\n        for (Iterator iter = projectData.classes.keySet().iterator(); iter.hasNext();) {\n            Object key = iter.next();\n            if (!this.classes.containsKey(key)) {\n                this.classes.put(key, projectData.classes.get(key));\n            }\n        }\n    } finally {\n        lock.unlock();\n        projectData.lock.unlock();\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_217() {\n    if (jj_3R_132()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_324() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_128() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_334() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_273() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_319() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void dumpClass(ClassData classData) {\n    logger.debug(\"Dumping class \" + classData.getName());\n    double ccn = Util.getCCN(new File(sourceDirectory, classData.getSourceFileName()), false);\n    println(((((((((((\"<class name=\\\"\" + classData.getName()) + \"\\\" filename=\\\"\") + classData.getSourceFileName()) + \"\\\" line-rate=\\\"\") + classData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + classData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpMethods(classData);\n    dumpLines(classData);\n    decreaseIndentation();\n    println(\"</class>\");\n}", "methodAfter": "private void dumpClass(ClassData classData) {\n    logger.debug(\"Dumping class \" + classData.getName());\n    double ccn = Util.getCCN(finder.findFile(classData.getSourceFileName()), false);\n    println(((((((((((\"<class name=\\\"\" + classData.getName()) + \"\\\" filename=\\\"\") + classData.getSourceFileName()) + \"\\\" line-rate=\\\"\") + classData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + classData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpMethods(classData);\n    dumpLines(classData);\n    decreaseIndentation();\n    println(\"</class>\");\n}"}, {"methodBefore": "private void dumpPackage(PackageData packageData) {\n    logger.debug(\"Dumping package \" + packageData.getName());\n    double ccn = Util.getCCN(new File(sourceDirectory, packageData.getSourceFileName()), false);\n    println(((((((((\"<package name=\\\"\" + packageData.getName()) + \"\\\" line-rate=\\\"\") + packageData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + packageData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpSourceFiles(packageData);\n    decreaseIndentation();\n    println(\"</package>\");\n}", "methodAfter": "private void dumpPackage(PackageData packageData) {\n    logger.debug(\"Dumping package \" + packageData.getName());\n    double ccn = Util.getCCN(finder.findFile(packageData.getSourceFileName()), false);\n    println(((((((((\"<package name=\\\"\" + packageData.getName()) + \"\\\" line-rate=\\\"\") + packageData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + packageData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpSourceFiles(packageData);\n    decreaseIndentation();\n    println(\"</package>\");\n}"}], [{"methodBefore": "public int getNumberOfBranches() {\n    return conditionals.size();\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    return conditionals.size();\n}"}, {"methodBefore": "public int getNumberOfLines() {\n    return lines.size();\n}", "methodAfter": "public int getNumberOfValidLines() {\n    return lines.size();\n}"}], [{"methodBefore": "public static double getCCN(File file, boolean recursive) {\n    int ccnAccumulator = 0;\n    Vector files = getListOfFiles(file, recursive);\n    if (files.isEmpty()) {\n        logger.warn(((\"Cannot find files to compute CCN, file=\" + file.getAbsolutePath()) + \", recursive=\") + recursive);\n        return 0;\n    }\n    Javancss javancss = new Javancss(files);\n    List functionMetrics = javancss.getFunctionMetrics();\n    if (functionMetrics.size() <= 0) {\n        return 0;\n    }\n    Iterator iter = functionMetrics.iterator();\n    while (iter.hasNext()) {\n        Vector functionMetric = ((Vector) (iter.next()));\n        ccnAccumulator += ((Integer) (functionMetric.elementAt(FCT_CCN))).intValue();\n    } \n    return ((double) (ccnAccumulator)) / functionMetrics.size();\n}", "methodAfter": "public static double getCCN(File file, boolean recursive) {\n    if (file == null) {\n        return 0;\n    }\n    int ccnAccumulator = 0;\n    Vector files = getListOfFiles(file, recursive);\n    if (files.isEmpty()) {\n        logger.warn(((\"Cannot find files to compute CCN, file=\" + file.getAbsolutePath()) + \", recursive=\") + recursive);\n        return 0;\n    }\n    Javancss javancss = new Javancss(files);\n    List functionMetrics = javancss.getFunctionMetrics();\n    if (functionMetrics.size() <= 0) {\n        return 0;\n    }\n    Iterator iter = functionMetrics.iterator();\n    while (iter.hasNext()) {\n        Vector functionMetric = ((Vector) (iter.next()));\n        ccnAccumulator += ((Integer) (functionMetric.elementAt(FCT_CCN))).intValue();\n    } \n    return ((double) (ccnAccumulator)) / functionMetrics.size();\n}"}, {"methodBefore": "public int getCCNForMethod(ClassData classData, String methodName, String methodDescriptor) {\n    Validate.notNull(classData, \"classData must not be null\");\n    Validate.notNull(methodName, \"methodName must not be null\");\n    Validate.notNull(methodDescriptor, \"methodDescriptor must not be null\");\n    int complexity = 0;\n    List<FunctionMetric> methodMetrics = getFunctionMetricsForSingleFile(classData.getSourceFileName());\n    String goldenMethodName = methodName;\n    boolean isConstructor = false;\n    if (goldenMethodName.equals(\"<init>\")) {\n        isConstructor = true;\n        goldenMethodName = classData.getBaseName();\n    }\n    goldenMethodName = (classData.getName() + \".\") + goldenMethodName;\n    goldenMethodName = goldenMethodName.replaceAll(Pattern.quote(\"$\"), \".\");\n    TraceSignatureVisitor v = new TraceSignatureVisitor(Opcodes.ACC_PUBLIC);\n    SignatureReader r = new SignatureReader(methodDescriptor);\n    r.accept(v);\n    String goldenSignature = v.getDeclaration();\n    goldenSignature = goldenSignature.substring(1, goldenSignature.length() - 1);\n    Map<String, Integer> candidateSignatureToCcn = new HashMap<String, Integer>();\n    for (FunctionMetric singleMethodMetrics : methodMetrics) {\n        String candidateMethodName = singleMethodMetrics.name.substring(0, singleMethodMetrics.name.indexOf('('));\n        String candidateSignature = stripTypeParameters(singleMethodMetrics.name.substring(singleMethodMetrics.name.indexOf('(') + 1, singleMethodMetrics.name.length() - 1));\n        if (goldenMethodName.equals(candidateMethodName)) {\n            candidateSignatureToCcn.put(candidateSignature, singleMethodMetrics.ccn);\n        }\n    }\n    if (candidateSignatureToCcn.size() == 1) {\n        return candidateSignatureToCcn.values().iterator().next();\n    }\n    if (!goldenSignature.isEmpty()) {\n        try {\n            String[] goldenParameterTypeStrings = goldenSignature.split(\",\");\n            Class<?>[] goldenParameterTypes = new Class[goldenParameterTypeStrings.length];\n            for (int i = 0; i < goldenParameterTypeStrings.length; i++) {\n                goldenParameterTypes[i] = ClassUtils.getClass(goldenParameterTypeStrings[i].trim(), false);\n            }\n            Class<?> klass = ClassUtils.getClass(classData.getName(), false);\n            if (isConstructor) {\n                Constructor<?> realMethod = klass.getDeclaredConstructor(goldenParameterTypes);\n                goldenSignature = realMethod.toGenericString();\n            } else {\n                Method realMethod = klass.getDeclaredMethod(methodName, goldenParameterTypes);\n                goldenSignature = realMethod.toGenericString();\n            }\n            goldenSignature = goldenSignature.replaceAll(\"\\\\.\\\\.\\\\.\", \"[]\");\n            goldenSignature = goldenSignature.substring(goldenSignature.indexOf(\"(\") + 1, goldenSignature.length() - 1);\n            goldenSignature = stripTypeParameters(goldenSignature);\n        } catch (Exception e) {\n            logger.error(\"Error while getting method CC for \" + goldenMethodName, e);\n            return 0;\n        }\n    }\n    goldenSignature = goldenSignature.replaceAll(Pattern.quote(\"$\"), \".\");\n    double signatureMatchPercentTillNow = 0;\n    for (Entry<String, Integer> candidateSignatureToCcnEntry : candidateSignatureToCcn.entrySet()) {\n        String candidateSignature = candidateSignatureToCcnEntry.getKey();\n        double currentMatchPercent = matchSignatures(candidateSignature, goldenSignature);\n        if (currentMatchPercent == 1) {\n            return candidateSignatureToCcnEntry.getValue();\n        }\n        if (currentMatchPercent > signatureMatchPercentTillNow) {\n            complexity = candidateSignatureToCcnEntry.getValue();\n            signatureMatchPercentTillNow = currentMatchPercent;\n        }\n    }\n    return complexity;\n}", "methodAfter": "public int getCCNForMethod(ClassData classData, String methodName, String methodDescriptor) {\n    if (!calculateMethodComplexity) {\n        return 0;\n    }\n    Validate.notNull(classData, \"classData must not be null\");\n    Validate.notNull(methodName, \"methodName must not be null\");\n    Validate.notNull(methodDescriptor, \"methodDescriptor must not be null\");\n    int complexity = 0;\n    List<FunctionMetric> methodMetrics = getFunctionMetricsForSingleFile(classData.getSourceFileName());\n    String goldenMethodName = methodName;\n    boolean isConstructor = false;\n    if (goldenMethodName.equals(\"<init>\")) {\n        isConstructor = true;\n        goldenMethodName = classData.getBaseName();\n    }\n    goldenMethodName = (classData.getName() + \".\") + goldenMethodName;\n    goldenMethodName = goldenMethodName.replaceAll(Pattern.quote(\"$\"), \".\");\n    TraceSignatureVisitor v = new TraceSignatureVisitor(Opcodes.ACC_PUBLIC);\n    SignatureReader r = new SignatureReader(methodDescriptor);\n    r.accept(v);\n    String goldenSignature = v.getDeclaration();\n    goldenSignature = goldenSignature.substring(1, goldenSignature.length() - 1);\n    Map<String, Integer> candidateSignatureToCcn = new HashMap<String, Integer>();\n    for (FunctionMetric singleMethodMetrics : methodMetrics) {\n        String candidateMethodName = singleMethodMetrics.name.substring(0, singleMethodMetrics.name.indexOf('('));\n        String candidateSignature = stripTypeParameters(singleMethodMetrics.name.substring(singleMethodMetrics.name.indexOf('(') + 1, singleMethodMetrics.name.length() - 1));\n        if (goldenMethodName.equals(candidateMethodName)) {\n            candidateSignatureToCcn.put(candidateSignature, singleMethodMetrics.ccn);\n        }\n    }\n    if (candidateSignatureToCcn.size() == 1) {\n        return candidateSignatureToCcn.values().iterator().next();\n    }\n    if (!goldenSignature.isEmpty()) {\n        try {\n            String[] goldenParameterTypeStrings = goldenSignature.split(\",\");\n            Class<?>[] goldenParameterTypes = new Class[goldenParameterTypeStrings.length];\n            for (int i = 0; i < goldenParameterTypeStrings.length; i++) {\n                goldenParameterTypes[i] = ClassUtils.getClass(goldenParameterTypeStrings[i].trim(), false);\n            }\n            Class<?> klass = ClassUtils.getClass(classData.getName(), false);\n            if (isConstructor) {\n                Constructor<?> realMethod = klass.getDeclaredConstructor(goldenParameterTypes);\n                goldenSignature = realMethod.toGenericString();\n            } else {\n                Method realMethod = klass.getDeclaredMethod(methodName, goldenParameterTypes);\n                goldenSignature = realMethod.toGenericString();\n            }\n            goldenSignature = goldenSignature.replaceAll(\"\\\\.\\\\.\\\\.\", \"[]\");\n            goldenSignature = goldenSignature.substring(goldenSignature.indexOf(\"(\") + 1, goldenSignature.length() - 1);\n            goldenSignature = stripTypeParameters(goldenSignature);\n        } catch (Exception e) {\n            logger.error(\"Error while getting method CC for \" + goldenMethodName, e);\n            return 0;\n        }\n    }\n    goldenSignature = goldenSignature.replaceAll(Pattern.quote(\"$\"), \".\");\n    double signatureMatchPercentTillNow = 0;\n    for (Entry<String, Integer> candidateSignatureToCcnEntry : candidateSignatureToCcn.entrySet()) {\n        String candidateSignature = candidateSignatureToCcnEntry.getKey();\n        double currentMatchPercent = matchSignatures(candidateSignature, goldenSignature);\n        if (currentMatchPercent == 1) {\n            return candidateSignatureToCcnEntry.getValue();\n        }\n        if (currentMatchPercent > signatureMatchPercentTillNow) {\n            complexity = candidateSignatureToCcnEntry.getValue();\n            signatureMatchPercentTillNow = currentMatchPercent;\n        }\n    }\n    return complexity;\n}"}, {"methodBefore": "public double getBranchCoverageRate() {\n    long numberOfBranches = getNumberOfBranches();\n    if (numberOfBranches == 0) {\n        return 1;\n    }\n    return ((double) (getNumberOfCoveredBranches())) / ((double) (numberOfBranches));\n}", "methodAfter": "public double getBranchCoverageRate() {\n    long numberOfBranches = getNumberOfBranches();\n    if (numberOfBranches == 0) {\n        if (getNumberOfCoveredLines() == 0) {\n            return 0;\n        }\n        return 1;\n    }\n    return ((double) (getNumberOfCoveredBranches())) / ((double) (numberOfBranches));\n}"}], [{"methodBefore": "public boolean isValidSourceLineNumber(int lineNumber) {\n    return children.containsKey(new Integer(lineNumber));\n}", "methodAfter": "public boolean isValidSourceLineNumber(int lineNumber) {\n    lock.lock();\n    try {\n        return children.containsKey(Integer.valueOf(lineNumber));\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public boolean hasBranch(int lineNumber) {\n    return branches.containsKey(new Integer(lineNumber));\n}", "methodAfter": "public boolean hasBranch(int lineNumber) {\n    lock.lock();\n    try {\n        return branches.containsKey(Integer.valueOf(lineNumber));\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_343() {\n    if (jj_3R_127()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_329() {\n    if (jj_3R_364()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_224() {\n    if (jj_3R_242()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_429() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public String printPackageNcss() {\n    String sRetVal = \"  <packages>\\n\";\n    Vector vPackageMetrics = _javancss.getPackageMetrics();\n    int packages = vPackageMetrics.size();\n    int classesSum = 0;\n    int functionsSum = 0;\n    int ncssSum = 0;\n    int javadocSum = 0;\n    int javadocLnSum = 0;\n    int singleLnSum = 0;\n    int multiLnSum = 0;\n    for (Enumeration ePackages = vPackageMetrics.elements(); ePackages.hasMoreElements();) {\n        PackageMetric pPackageMetric = ((PackageMetric) (ePackages.nextElement()));\n        classesSum += pPackageMetric.classes;\n        functionsSum += pPackageMetric.functions;\n        ncssSum += pPackageMetric.ncss;\n        javadocSum += pPackageMetric.javadocs;\n        javadocLnSum += pPackageMetric.javadocsLn;\n        singleLnSum += pPackageMetric.singleLn;\n        multiLnSum += pPackageMetric.multiLn;\n        sRetVal += ((((((((((((((((((((((((\"    <package>\\n\" + \"      <name>\") + pPackageMetric.name) + \"</name>\\n\") + \"      <classes>\") + pPackageMetric.classes) + \"</classes>\\n\") + \"      <functions>\") + pPackageMetric.functions) + \"</functions>\\n\") + \"      <ncss>\") + pPackageMetric.ncss) + \"</ncss>\\n\") + \"      <javadocs>\") + pPackageMetric.javadocs) + \"</javadocs>\\n\") + \"      <javadoc_lines>\") + pPackageMetric.javadocsLn) + \"</javadoc_lines>\\n\") + \"      <single_comment_lines>\") + pPackageMetric.singleLn) + \"</single_comment_lines>\\n\") + \"      <multi_comment_lines>\") + pPackageMetric.multiLn) + \"</multi_comment_lines>\\n\") + \"    </package>\\n\";\n    }\n    sRetVal += (((((((((((((((((((((\"    <total>\\n\" + \"      <classes>\") + classesSum) + \"</classes>\\n\") + \"      <functions>\") + functionsSum) + \"</functions>\\n\") + \"      <ncss>\") + ncssSum) + \"</ncss>\\n\") + \"      <javadocs>\") + javadocSum) + \"</javadocs>\\n\") + \"      <javadoc_lines>\") + javadocLnSum) + \"</javadoc_lines>\\n\") + \"      <single_comment_lines>\") + singleLnSum) + \"</single_comment_lines>\\n\") + \"      <multi_comment_lines>\") + multiLnSum) + \"</multi_comment_lines>\\n\") + \"    </total>\\n\";\n    sRetVal += _formatPackageMatrix(packages, classesSum, functionsSum, ncssSum, javadocSum, javadocLnSum, singleLnSum, multiLnSum);\n    sRetVal += \"  </packages>\\n\";\n    return sRetVal;\n}", "methodAfter": "public String printPackageNcss() {\n    String sRetVal = \"  <packages>\\n\";\n    List vPackageMetrics = _javancss.getPackageMetrics();\n    int packages = vPackageMetrics.size();\n    int classesSum = 0;\n    int functionsSum = 0;\n    int ncssSum = 0;\n    int javadocSum = 0;\n    int javadocLnSum = 0;\n    int singleLnSum = 0;\n    int multiLnSum = 0;\n    for (Iterator ePackages = vPackageMetrics.iterator(); ePackages.hasNext();) {\n        PackageMetric pPackageMetric = ((PackageMetric) (ePackages.next()));\n        classesSum += pPackageMetric.classes;\n        functionsSum += pPackageMetric.functions;\n        ncssSum += pPackageMetric.ncss;\n        javadocSum += pPackageMetric.javadocs;\n        javadocLnSum += pPackageMetric.javadocsLn;\n        singleLnSum += pPackageMetric.singleLn;\n        multiLnSum += pPackageMetric.multiLn;\n        sRetVal += ((((((((((((((((((((((((\"    <package>\\n\" + \"      <name>\") + pPackageMetric.name) + \"</name>\\n\") + \"      <classes>\") + pPackageMetric.classes) + \"</classes>\\n\") + \"      <functions>\") + pPackageMetric.functions) + \"</functions>\\n\") + \"      <ncss>\") + pPackageMetric.ncss) + \"</ncss>\\n\") + \"      <javadocs>\") + pPackageMetric.javadocs) + \"</javadocs>\\n\") + \"      <javadoc_lines>\") + pPackageMetric.javadocsLn) + \"</javadoc_lines>\\n\") + \"      <single_comment_lines>\") + pPackageMetric.singleLn) + \"</single_comment_lines>\\n\") + \"      <multi_comment_lines>\") + pPackageMetric.multiLn) + \"</multi_comment_lines>\\n\") + \"    </package>\\n\";\n    }\n    sRetVal += (((((((((((((((((((((\"    <total>\\n\" + \"      <classes>\") + classesSum) + \"</classes>\\n\") + \"      <functions>\") + functionsSum) + \"</functions>\\n\") + \"      <ncss>\") + ncssSum) + \"</ncss>\\n\") + \"      <javadocs>\") + javadocSum) + \"</javadocs>\\n\") + \"      <javadoc_lines>\") + javadocLnSum) + \"</javadoc_lines>\\n\") + \"      <single_comment_lines>\") + singleLnSum) + \"</single_comment_lines>\\n\") + \"      <multi_comment_lines>\") + multiLnSum) + \"</multi_comment_lines>\\n\") + \"    </total>\\n\";\n    sRetVal += _formatPackageMatrix(packages, classesSum, functionsSum, ncssSum, javadocSum, javadocLnSum, singleLnSum, multiLnSum);\n    sRetVal += \"  </packages>\\n\";\n    return sRetVal;\n}"}, {"methodBefore": "private void _checkJavadocLines(Javancss pJavancss, String sPackage, int javadocLines) {\n    Vector vPackageMetrics = pJavancss.getPackageMetrics();\n    Assert(vPackageMetrics.size() >= 1);\n    PackageMetric pmPackage = null;\n    Enumeration ePackageMetrics = vPackageMetrics.elements();\n    while (ePackageMetrics.hasMoreElements()) {\n        PackageMetric pmNext = ((PackageMetric) (ePackageMetrics.nextElement()));\n        if (pmNext.name.equals(sPackage)) {\n            pmPackage = pmNext;\n        }\n    } \n    Assert(pmPackage != null);\n    Assert(pmPackage.javadocsLn == javadocLines, ((\"pmJacob.javadocsLn: \" + pmPackage) + \": \") + pmPackage.javadocsLn);\n}", "methodAfter": "private void _checkJavadocLines(Javancss pJavancss, String sPackage, int javadocLines) {\n    List vPackageMetrics = pJavancss.getPackageMetrics();\n    Assert(vPackageMetrics.size() >= 1);\n    PackageMetric pmPackage = null;\n    Iterator ePackageMetrics = vPackageMetrics.iterator();\n    while (ePackageMetrics.hasNext()) {\n        PackageMetric pmNext = ((PackageMetric) (ePackageMetrics.next()));\n        if (pmNext.name.equals(sPackage)) {\n            pmPackage = pmNext;\n        }\n    } \n    Assert(pmPackage != null);\n    Assert(pmPackage.javadocsLn == javadocLines, ((\"pmJacob.javadocsLn: \" + pmPackage) + \": \") + pmPackage.javadocsLn);\n}"}, {"methodBefore": "public String printPackageNcss() {\n    Vector vPackageMetrics = _javancss.getPackageMetrics();\n    int packages = vPackageMetrics.size();\n    String sRetVal = _formatListHeader(packages, new String[]{ \"  Classes\", \"Functions\", \"     NCSS\", \" Javadocs\", \"Package\" });\n    int classesSum = 0;\n    int functionsSum = 0;\n    int javadocsSum = 0;\n    int ncssSum = 0;\n    for (Enumeration ePackages = vPackageMetrics.elements(); ePackages.hasMoreElements();) {\n        PackageMetric pPackageMetric = ((PackageMetric) (ePackages.nextElement()));\n        classesSum += pPackageMetric.classes;\n        functionsSum += pPackageMetric.functions;\n        ncssSum += pPackageMetric.ncss;\n        javadocsSum += pPackageMetric.javadocs;\n        sRetVal += _formatListLine(pPackageMetric.name, new int[]{ pPackageMetric.classes, pPackageMetric.functions, pPackageMetric.ncss, pPackageMetric.javadocs });\n    }\n    int packagesLength = Util.itoa(packages).length();\n    int spaces = Math.max(packagesLength, LEN_NR) + 1;\n    sRetVal += (Util.multiplyChar(' ', spaces) + \"--------- --------- --------- ---------\") + NL;\n    sRetVal += (((((((((Util.multiplyChar(' ', spaces) + Util.paddWithSpace(classesSum, 9)) + \" \") + Util.paddWithSpace(functionsSum, 9)) + \" \") + Util.paddWithSpace(ncssSum, 9)) + \" \") + Util.paddWithSpace(javadocsSum, 9)) + \" Total\") + NL) + NL;\n    sRetVal += _formatPackageMatrix(packages, classesSum, functionsSum, javadocsSum, ncssSum);\n    return sRetVal;\n}", "methodAfter": "public String printPackageNcss() {\n    List vPackageMetrics = _javancss.getPackageMetrics();\n    int packages = vPackageMetrics.size();\n    String sRetVal = _formatListHeader(packages, new String[]{ \"  Classes\", \"Functions\", \"     NCSS\", \" Javadocs\", \"Package\" });\n    int classesSum = 0;\n    int functionsSum = 0;\n    int javadocsSum = 0;\n    int ncssSum = 0;\n    for (Iterator ePackages = vPackageMetrics.iterator(); ePackages.hasNext();) {\n        PackageMetric pPackageMetric = ((PackageMetric) (ePackages.next()));\n        classesSum += pPackageMetric.classes;\n        functionsSum += pPackageMetric.functions;\n        ncssSum += pPackageMetric.ncss;\n        javadocsSum += pPackageMetric.javadocs;\n        sRetVal += _formatListLine(pPackageMetric.name, new int[]{ pPackageMetric.classes, pPackageMetric.functions, pPackageMetric.ncss, pPackageMetric.javadocs });\n    }\n    int packagesLength = Util.itoa(packages).length();\n    int spaces = Math.max(packagesLength, LEN_NR) + 1;\n    sRetVal += (Util.multiplyChar(' ', spaces) + \"--------- --------- --------- ---------\") + NL;\n    sRetVal += (((((((((Util.multiplyChar(' ', spaces) + Util.paddWithSpace(classesSum, 9)) + \" \") + Util.paddWithSpace(functionsSum, 9)) + \" \") + Util.paddWithSpace(ncssSum, 9)) + \" \") + Util.paddWithSpace(javadocsSum, 9)) + \" Total\") + NL) + NL;\n    sRetVal += _formatPackageMatrix(packages, classesSum, functionsSum, javadocsSum, ncssSum);\n    return sRetVal;\n}"}], [{"methodBefore": "private void addInstrumentationToSingleClass(File file) throws Throwable {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes, ignoreTrivial);\n        cr.accept(cv, 0);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        inputStream = IOUtil.closeInputStream(inputStream);\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        outputStream = IOUtil.closeOutputStream(outputStream);\n    }\n}", "methodAfter": "private void addInstrumentationToSingleClass(File file) throws Throwable {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes, ignoreMethodAnnotations, ignoreTrivial);\n        cr.accept(cv, 0);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        inputStream = IOUtil.closeInputStream(inputStream);\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        outputStream = IOUtil.closeOutputStream(outputStream);\n    }\n}"}, {"methodBefore": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Throwable {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes, ignoreTrivial);\n                    cr.accept(cv, 0);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}", "methodAfter": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Throwable {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes, ignoreMethodAnnotations, ignoreTrivial);\n                    cr.accept(cv, 0);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}"}], [{"methodBefore": "private final boolean jj_3R_346() {\n    if (jj_3R_364()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_346() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_365() {\n    if (jj_3R_127()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_365() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private File getBaseDirectory() {\n    return baseDirectory;\n}", "methodAfter": "private String getBaseDirectory() {\n    return baseDirectory;\n}"}, {"methodBefore": "public File getBaseDirectory() {\n    return baseDirectory;\n}", "methodAfter": "public String getBaseDirectory() {\n    return baseDirectory;\n}"}], [{"methodBefore": "private final boolean jj_3R_88() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_88() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_86() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_86() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void parseArguments(String[] args) {\n    Collection locations = new Vector();\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--basedir\")) {\n            baseDir = new File(args[++i]);\n        } else if (args[i].equals(\"--datafile\")) {\n            CoverageDataFileHandler.setDefaultDataFile(args[++i]);\n        } else if (args[i].equals(\"--destination\")) {\n            destinationDirectory = new File(args[++i]);\n        } else if (args[i].equals(\"--ignore\")) {\n            String regex = args[++i];\n            this.ignoreRegexp = Pattern.compile(regex);\n        } else {\n            locations.add(args[i]);\n        }\n    }\n    projectData = ProjectData.getGlobalProjectData();\n    Iterator iter = locations.iterator();\n    while (iter.hasNext()) {\n        addInstrumentation(((String) (iter.next())));\n    } \n    ProjectData.saveGlobalProjectData();\n}", "methodAfter": "private void parseArguments(String[] args) {\n    Collection locations = new Vector();\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--basedir\")) {\n            baseDir = new File(args[++i]);\n        } else if (args[i].equals(\"--datafile\")) {\n            CoverageDataFileHandler.setDefaultDataFile(args[++i]);\n        } else if (args[i].equals(\"--destination\")) {\n            destinationDirectory = new File(args[++i]);\n        } else if (args[i].equals(\"--ignore\")) {\n            String regex = args[++i];\n            try {\n                Perl5Compiler pc = new Perl5Compiler();\n                this.ignoreRegexp = pc.compile(regex);\n            } catch (MalformedPatternException e) {\n                logger.warn(((\"The regular expression \" + regex) + \" is invalid: \") + e.getLocalizedMessage());\n            }\n        } else {\n            locations.add(args[i]);\n        }\n    }\n    projectData = ProjectData.getGlobalProjectData();\n    Iterator iter = locations.iterator();\n    while (iter.hasNext()) {\n        addInstrumentation(((String) (iter.next())));\n    } \n    ProjectData.saveGlobalProjectData();\n}"}, {"methodBefore": "private void parseArguments(String[] args) {\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-d\")) {\n            destinationDirectory = new File(args[++i]);\n        } else if (args[i].equals(\"-basedir\")) {\n            baseDir = new File(args[++i]);\n        } else if (args[i].equals(\"-ignore\")) {\n            ignoreRegex = args[++i];\n        } else {\n            addInstrumentation(args[i]);\n        }\n    }\n}", "methodAfter": "private void parseArguments(String[] args) {\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-d\")) {\n            destinationDirectory = new File(args[++i]);\n        } else if (args[i].equals(\"-basedir\")) {\n            baseDir = new File(args[++i]);\n        } else if (args[i].equals(\"-ignore\")) {\n            String regex = args[++i];\n            try {\n                Perl5Compiler pc = new Perl5Compiler();\n                this.ignoreRegexp = pc.compile(regex);\n            } catch (MalformedPatternException e) {\n                logger.warn(((\"The regular expression \" + regex) + \" is invalid: \") + e.getLocalizedMessage());\n            }\n        } else {\n            addInstrumentation(args[i]);\n        }\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_120() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_130() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_122() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_132() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public String printPackageNcss() {\n    Vector vPackageMetrics = _javancss.getPackageMetrics();\n    int packages = vPackageMetrics.size();\n    String sRetVal = _formatListHeader(packages, new String[]{ \"  Classes\", \"Functions\", \"     NCSS\", \" Javadocs\", \"Package\" });\n    int classesSum = 0;\n    int functionsSum = 0;\n    int javadocsSum = 0;\n    int ncssSum = 0;\n    for (Enumeration ePackages = vPackageMetrics.elements(); ePackages.hasMoreElements();) {\n        PackageMetric pPackageMetric = ((PackageMetric) (ePackages.nextElement()));\n        classesSum += pPackageMetric.classes;\n        functionsSum += pPackageMetric.functions;\n        ncssSum += pPackageMetric.ncss;\n        javadocsSum += pPackageMetric.javadocs;\n        sRetVal += _formatListLine(pPackageMetric.name, new int[]{ pPackageMetric.classes, pPackageMetric.functions, pPackageMetric.ncss, pPackageMetric.javadocs });\n    }\n    int packagesLength = Util.itoa(packages).length();\n    int spaces = Math.max(packagesLength, LEN_NR) + 1;\n    sRetVal += (Util.multiplyChar(' ', spaces) + \"--------- --------- --------- ---------\") + NL;\n    sRetVal += (((((((((Util.multiplyChar(' ', spaces) + Util.paddWithSpace(classesSum, 9)) + \" \") + Util.paddWithSpace(functionsSum, 9)) + \" \") + Util.paddWithSpace(ncssSum, 9)) + \" \") + Util.paddWithSpace(javadocsSum, 9)) + \" Total\") + NL) + NL;\n    sRetVal += _formatPackageMatrix(packages, classesSum, functionsSum, javadocsSum, ncssSum);\n    return sRetVal;\n}", "methodAfter": "public String printPackageNcss() {\n    List vPackageMetrics = _javancss.getPackageMetrics();\n    int packages = vPackageMetrics.size();\n    String sRetVal = _formatListHeader(packages, new String[]{ \"  Classes\", \"Functions\", \"     NCSS\", \" Javadocs\", \"Package\" });\n    int classesSum = 0;\n    int functionsSum = 0;\n    int javadocsSum = 0;\n    int ncssSum = 0;\n    for (Iterator ePackages = vPackageMetrics.iterator(); ePackages.hasNext();) {\n        PackageMetric pPackageMetric = ((PackageMetric) (ePackages.next()));\n        classesSum += pPackageMetric.classes;\n        functionsSum += pPackageMetric.functions;\n        ncssSum += pPackageMetric.ncss;\n        javadocsSum += pPackageMetric.javadocs;\n        sRetVal += _formatListLine(pPackageMetric.name, new int[]{ pPackageMetric.classes, pPackageMetric.functions, pPackageMetric.ncss, pPackageMetric.javadocs });\n    }\n    int packagesLength = Util.itoa(packages).length();\n    int spaces = Math.max(packagesLength, LEN_NR) + 1;\n    sRetVal += (Util.multiplyChar(' ', spaces) + \"--------- --------- --------- ---------\") + NL;\n    sRetVal += (((((((((Util.multiplyChar(' ', spaces) + Util.paddWithSpace(classesSum, 9)) + \" \") + Util.paddWithSpace(functionsSum, 9)) + \" \") + Util.paddWithSpace(ncssSum, 9)) + \" \") + Util.paddWithSpace(javadocsSum, 9)) + \" Total\") + NL) + NL;\n    sRetVal += _formatPackageMatrix(packages, classesSum, functionsSum, javadocsSum, ncssSum);\n    return sRetVal;\n}"}, {"methodBefore": "private void _checkJavadocLines(Javancss pJavancss, String sPackage, int javadocLines) {\n    Vector vPackageMetrics = pJavancss.getPackageMetrics();\n    Assert(vPackageMetrics.size() >= 1);\n    PackageMetric pmPackage = null;\n    Enumeration ePackageMetrics = vPackageMetrics.elements();\n    while (ePackageMetrics.hasMoreElements()) {\n        PackageMetric pmNext = ((PackageMetric) (ePackageMetrics.nextElement()));\n        if (pmNext.name.equals(sPackage)) {\n            pmPackage = pmNext;\n        }\n    } \n    Assert(pmPackage != null);\n    Assert(pmPackage.javadocsLn == javadocLines, ((\"pmJacob.javadocsLn: \" + pmPackage) + \": \") + pmPackage.javadocsLn);\n}", "methodAfter": "private void _checkJavadocLines(Javancss pJavancss, String sPackage, int javadocLines) {\n    List vPackageMetrics = pJavancss.getPackageMetrics();\n    Assert(vPackageMetrics.size() >= 1);\n    PackageMetric pmPackage = null;\n    Iterator ePackageMetrics = vPackageMetrics.iterator();\n    while (ePackageMetrics.hasNext()) {\n        PackageMetric pmNext = ((PackageMetric) (ePackageMetrics.next()));\n        if (pmNext.name.equals(sPackage)) {\n            pmPackage = pmNext;\n        }\n    } \n    Assert(pmPackage != null);\n    Assert(pmPackage.javadocsLn == javadocLines, ((\"pmJacob.javadocsLn: \" + pmPackage) + \": \") + pmPackage.javadocsLn);\n}"}], [{"methodBefore": "private final boolean jj_3R_299() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    if (jj_3R_290()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_336()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_202() {\n    if (jj_3R_215()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_249() {\n    if (jj_scan_token(LBRACE)) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_257()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(RBRACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_244() {\n    if (jj_3R_264()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public boolean isCovered() {\n    lock.lock();\n    try {\n        return (getHits() > 0) && ((getNumberOfValidBranches() == 0) || ((1.0 - getBranchCoverageRate()) < 1.0E-4));\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized boolean isCovered() {\n    try {\n        return (getHits() > 0) && ((getNumberOfValidBranches() == 0) || ((1.0 - getBranchCoverageRate()) < 1.0E-4));\n    } finally {\n    }\n}"}, {"methodBefore": "public boolean hasBranch() {\n    lock.lock();\n    try {\n        return (jumps != null) || (switches != null);\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized boolean hasBranch() {\n    try {\n        return (jumps != null) || (switches != null);\n    } finally {\n    }\n}"}, {"methodBefore": "public long getHits() {\n    lock.lock();\n    try {\n        return hits;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized long getHits() {\n    try {\n        return hits;\n    } finally {\n    }\n}"}], [{"methodBefore": "public GenerateCallCoberturaInitMethodVisitor(MethodVisitor arg0, String className) {\n    super(arg0);\n    this.className = className;\n}", "methodAfter": "public GenerateCallCoberturaInitMethodVisitor(MethodVisitor arg0, String className) {\n    super(ASM4, arg0);\n    this.className = className;\n}"}, {"methodBefore": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}", "methodAfter": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(ASM4, mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}"}, {"methodBefore": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(mv);\n    this.eventsToTrace = eventsToTrace;\n}", "methodAfter": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(ASM4, mv);\n    this.eventsToTrace = eventsToTrace;\n}"}, {"methodBefore": "public GenerateCallCoberturaInitMethodVisitor(MethodVisitor arg0, String className) {\n    super(arg0);\n    this.className = className;\n}", "methodAfter": "public GenerateCallCoberturaInitMethodVisitor(MethodVisitor arg0, String className) {\n    super(ASM4, arg0);\n    this.className = className;\n}"}, {"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}, {"methodBefore": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(cv);\n}", "methodAfter": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, cv);\n}"}, {"methodBefore": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(cv);\n}", "methodAfter": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, cv);\n}"}, {"methodBefore": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(mv);\n    this.eventsToTrace = eventsToTrace;\n}", "methodAfter": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(ASM4, mv);\n    this.eventsToTrace = eventsToTrace;\n}"}, {"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}, {"methodBefore": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}", "methodAfter": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(ASM4, mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}"}], [{"methodBefore": "public void addLineSwitch(int lineNumber, int switchNumber, int[] keys) {\n    LineData lineData = getLineData(lineNumber);\n    if (lineData != null) {\n        lineData.addSwitch(switchNumber, keys);\n        this.branches.put(new Integer(lineNumber), lineData);\n    }\n}", "methodAfter": "public void addLineSwitch(int lineNumber, int switchNumber, int[] keys) {\n    lock.lock();\n    try {\n        LineData lineData = getLineData(lineNumber);\n        if (lineData != null) {\n            lineData.addSwitch(switchNumber, keys);\n            this.branches.put(Integer.valueOf(lineNumber), lineData);\n        }\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public void addLineSwitch(int lineNumber, int switchNumber, int min, int max) {\n    LineData lineData = getLineData(lineNumber);\n    if (lineData != null) {\n        lineData.addSwitch(switchNumber, min, max);\n        this.branches.put(new Integer(lineNumber), lineData);\n    }\n}", "methodAfter": "public void addLineSwitch(int lineNumber, int switchNumber, int min, int max) {\n    lock.lock();\n    try {\n        LineData lineData = getLineData(lineNumber);\n        if (lineData != null) {\n            lineData.addSwitch(switchNumber, min, max);\n            this.branches.put(Integer.valueOf(lineNumber), lineData);\n        }\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "public double getBranchCoverageRate() {\n    long numberOfBranches = getNumberOfBranches();\n    if (numberOfBranches == 0) {\n        return 1;\n    }\n    return ((double) (getNumberOfCoveredBranches())) / ((double) (numberOfBranches));\n}", "methodAfter": "public double getBranchCoverageRate() {\n    long numberOfBranches = getNumberOfBranches();\n    if (numberOfBranches == 0) {\n        if (getNumberOfCoveredLines() == 0) {\n            return 0;\n        }\n        return 1;\n    }\n    return ((double) (getNumberOfCoveredBranches())) / ((double) (numberOfBranches));\n}"}, {"methodBefore": "public static double getCCN(File file, boolean recursive) {\n    int ccnAccumulator = 0;\n    Vector files = getListOfFiles(file, recursive);\n    if (files.isEmpty()) {\n        logger.warn(((\"Cannot find files to compute CCN, file=\" + file.getAbsolutePath()) + \", recursive=\") + recursive);\n        return 0;\n    }\n    Javancss javancss = new Javancss(files);\n    List functionMetrics = javancss.getFunctionMetrics();\n    if (functionMetrics.size() <= 0) {\n        return 0;\n    }\n    Iterator iter = functionMetrics.iterator();\n    while (iter.hasNext()) {\n        Vector functionMetric = ((Vector) (iter.next()));\n        ccnAccumulator += ((Integer) (functionMetric.elementAt(FCT_CCN))).intValue();\n    } \n    return ((double) (ccnAccumulator)) / functionMetrics.size();\n}", "methodAfter": "public static double getCCN(File file, boolean recursive) {\n    if (file == null) {\n        return 0;\n    }\n    int ccnAccumulator = 0;\n    Vector files = getListOfFiles(file, recursive);\n    if (files.isEmpty()) {\n        logger.warn(((\"Cannot find files to compute CCN, file=\" + file.getAbsolutePath()) + \", recursive=\") + recursive);\n        return 0;\n    }\n    Javancss javancss = new Javancss(files);\n    List functionMetrics = javancss.getFunctionMetrics();\n    if (functionMetrics.size() <= 0) {\n        return 0;\n    }\n    Iterator iter = functionMetrics.iterator();\n    while (iter.hasNext()) {\n        Vector functionMetric = ((Vector) (iter.next()));\n        ccnAccumulator += ((Integer) (functionMetric.elementAt(FCT_CCN))).intValue();\n    } \n    return ((double) (ccnAccumulator)) / functionMetrics.size();\n}"}], [{"methodBefore": "public int getNumberOfBranches() {\n    return conditionals.size();\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    return conditionals.size();\n}"}, {"methodBefore": "public int getNumberOfLines() {\n    return lines.size();\n}", "methodAfter": "public int getNumberOfValidLines() {\n    return lines.size();\n}"}], [{"methodBefore": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new CoberturaClassWriter(ClassWriter.COMPUTE_FRAMES);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(new CheckClassAdapter(cv2), SKIP_FRAMES);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        CheckClassAdapter.verify(new ClassReader(cw2.toByteArray()), false, pw);\n        logger.debug(sw.toString());\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}", "methodAfter": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, ignoreClassAnnotations, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new CoberturaClassWriter(ClassWriter.COMPUTE_FRAMES);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(new CheckClassAdapter(cv2), SKIP_FRAMES);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        CheckClassAdapter.verify(new ClassReader(cw2.toByteArray()), false, pw);\n        logger.debug(sw.toString());\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}"}, {"methodBefore": "public Arguments build() {\n    FileFinder sources = new FileFinder();\n    if (this.sources != null) {\n        for (CodeSource codeSource : this.sources) {\n            if (codeSource.isDirectory()) {\n                sources.addSourceDirectory(codeSource.getPath());\n            } else {\n                sources.addSourceFile(getBaseDirectory().getPath(), codeSource.getPath());\n            }\n        }\n    }\n    return new Arguments(baseDirectory, dataFile, destinationDirectory, commandsFile, ignoreRegexes, ignoreBranchesRegexes, classPatternIncludeClassesRegexes, classPatternExcludeClassesRegexes, failOnError, ignoreTrivial, threadsafeRigorous, encoding, minimumCoverageThresholds, classLineThreshold, classBranchThreshold, packageLineThreshold, packageBranchThreshold, totalLineThreshold, totalBranchThreshold, filesToInstrument, filesToMerge, ignoreMethodAnnotations, sources);\n}", "methodAfter": "public Arguments build() {\n    FileFinder sources = new FileFinder();\n    if (this.sources != null) {\n        for (CodeSource codeSource : this.sources) {\n            if (codeSource.isDirectory()) {\n                sources.addSourceDirectory(codeSource.getPath());\n            } else {\n                sources.addSourceFile(getBaseDirectory().getPath(), codeSource.getPath());\n            }\n        }\n    }\n    return new Arguments(baseDirectory, dataFile, destinationDirectory, commandsFile, ignoreRegexes, ignoreBranchesRegexes, classPatternIncludeClassesRegexes, classPatternExcludeClassesRegexes, failOnError, ignoreTrivial, threadsafeRigorous, encoding, minimumCoverageThresholds, classLineThreshold, classBranchThreshold, packageLineThreshold, packageBranchThreshold, totalLineThreshold, totalBranchThreshold, filesToInstrument, filesToMerge, ignoreMethodAnnotations, ignoreClassAnnotations, sources);\n}"}], [{"methodBefore": "private final boolean jj_3R_321() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_351() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_322() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_352() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_333() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_371() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_334() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_372() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public XMLReport(ProjectData projectData, File destinationDir, FileFinder finder, ComplexityCalculator complexity) throws IOException {\n    this.complexity = complexity;\n    this.finder = finder;\n    File file = new File(destinationDir, \"coverage.xml\");\n    setPrintWriter(IOUtil.getPrintWriter(file));\n    try {\n        printHeader();\n        printCoverageElement(projectData, complexity);\n        increaseIndentation();\n        dumpSources();\n        dumpPackages(projectData);\n        decreaseIndentation();\n        println(\"</coverage>\");\n    } finally {\n        close();\n    }\n}", "methodAfter": "public XMLReport(ProjectData projectData, File destinationDir, FileFinder finder, ComplexityCalculator complexity) throws IOException {\n    this.complexity = complexity;\n    this.finder = finder;\n    File file = new File(destinationDir, \"coverage.xml\");\n    pw = IOUtil.getPrintWriter(file);\n    try {\n        println(\"<?xml version=\\\"1.0\\\"?>\");\n        println((\"<!DOCTYPE coverage SYSTEM \\\"http://cobertura.sourceforge.net/xml/\" + coverageDTD) + \"\\\">\");\n        println(\"\");\n        double ccn = complexity.getCCNForProject(projectData);\n        int numLinesCovered = projectData.getNumberOfCoveredLines();\n        int numLinesValid = projectData.getNumberOfValidLines();\n        int numBranchesCovered = projectData.getNumberOfCoveredBranches();\n        int numBranchesValid = projectData.getNumberOfValidBranches();\n        println((((((((((((((((((\"<coverage line-rate=\\\"\" + projectData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + projectData.getBranchCoverageRate()) + \"\\\" lines-covered=\\\"\") + numLinesCovered) + \"\\\" lines-valid=\\\"\") + numLinesValid) + \"\\\" branches-covered=\\\"\") + numBranchesCovered) + \"\\\" branches-valid=\\\"\") + numBranchesValid) + \"\\\" complexity=\\\"\") + ccn) + \"\\\" version=\\\"\") + Header.version()) + \"\\\" timestamp=\\\"\") + new Date().getTime()) + \"\\\">\");\n        increaseIndentation();\n        dumpSources();\n        dumpPackages(projectData);\n        decreaseIndentation();\n        println(\"</coverage>\");\n    } finally {\n        pw.close();\n    }\n}"}, {"methodBefore": "public SummaryXMLReport(ProjectData projectData, File destinationDir, FileFinder finder, ComplexityCalculator complexity) throws IOException {\n    File file = new File(destinationDir, \"coverage-summary.xml\");\n    setPrintWriter(IOUtil.getPrintWriter(file));\n    try {\n        printHeader();\n        printCoverageElement(projectData, complexity);\n        increaseIndentation();\n        println(\"<packages />\");\n        decreaseIndentation();\n        println(\"</coverage>\");\n    } finally {\n        close();\n    }\n}", "methodAfter": "public SummaryXMLReport(ProjectData projectData, File destinationDir, FileFinder finder, ComplexityCalculator complexity) throws IOException {\n    File file = new File(destinationDir, \"coverage-summary.xml\");\n    pw = IOUtil.getPrintWriter(file);\n    try {\n        println(\"<?xml version=\\\"1.0\\\"?>\");\n        println((\"<!DOCTYPE coverage SYSTEM \\\"http://cobertura.sourceforge.net/xml/\" + XMLReport.coverageDTD) + \"\\\">\");\n        println(\"\");\n        double ccn = complexity.getCCNForProject(projectData);\n        int numLinesCovered = projectData.getNumberOfCoveredLines();\n        int numLinesValid = projectData.getNumberOfValidLines();\n        int numBranchesCovered = projectData.getNumberOfCoveredBranches();\n        int numBranchesValid = projectData.getNumberOfValidBranches();\n        println((((((((((((((((((\"<coverage line-rate=\\\"\" + projectData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + projectData.getBranchCoverageRate()) + \"\\\" lines-covered=\\\"\") + numLinesCovered) + \"\\\" lines-valid=\\\"\") + numLinesValid) + \"\\\" branches-covered=\\\"\") + numBranchesCovered) + \"\\\" branches-valid=\\\"\") + numBranchesValid) + \"\\\" complexity=\\\"\") + ccn) + \"\\\" version=\\\"\") + Header.version()) + \"\\\" timestamp=\\\"\") + new Date().getTime()) + \"\\\">\");\n        increaseIndentation();\n        println(\"<packages />\");\n        decreaseIndentation();\n        println(\"</coverage>\");\n    } finally {\n        pw.close();\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_327() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_322() {\n    if (jj_3R_356()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_313() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_213() {\n    if (jj_3R_227()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_301() {\n    if (jj_3R_132()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_201() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_286() {\n    if (jj_3R_318()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_283() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public String getPackageName() {\n    return ClassHelper.getPackageName(this.name);\n}", "methodAfter": "public String getPackageName() {\n    int lastDot = this.name.lastIndexOf('.');\n    if (lastDot == (-1)) {\n        return \"\";\n    }\n    return this.name.substring(0, lastDot);\n}"}, {"methodBefore": "public String getBaseName() {\n    return ClassHelper.getBaseName(this.name);\n}", "methodAfter": "public String getBaseName() {\n    int lastDot = this.name.lastIndexOf('.');\n    if (lastDot == (-1)) {\n        return this.name;\n    }\n    return this.name.substring(lastDot + 1);\n}"}], [{"methodBefore": "private final boolean jj_3R_277() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_203() {\n    if (jj_3R_216()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_223() {\n    if (jj_3R_241()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_242() {\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_224() {\n    if (jj_3R_242()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_429() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_228() {\n    if (jj_3R_246()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_197() {\n    if (jj_3R_212()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_280() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_331() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_208() {\n    if (jj_3R_206()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_204() {\n    if (jj_3R_217()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_269() {\n    if (jj_3R_279()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_252() {\n    if (jj_3R_272()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_226() {\n    if (jj_3R_244()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_426() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_229() {\n    if (jj_3R_247()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_229() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_408() {\n    if (jj_3R_417()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_408() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_310() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_310() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_88() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_88() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_128() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_334() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_217() {\n    if (jj_3R_132()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_324() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_301() {\n    if (jj_3R_132()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_201() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public Vector getFunction() {\n    return _vFunctions;\n}", "methodAfter": "public List getFunction() {\n    return _vFunctions;\n}"}, {"methodBefore": "public Vector getFunctionMetrics() {\n    return _vFunctionMetrics;\n}", "methodAfter": "public List getFunctionMetrics() {\n    return _vFunctionMetrics;\n}"}, {"methodBefore": "public Vector getPackageMetrics() {\n    return _vPackageMetrics;\n}", "methodAfter": "public List getPackageMetrics() {\n    return _vPackageMetrics;\n}"}, {"methodBefore": "public Vector getObjectMetrics() {\n    return _vObjectMetrics;\n}", "methodAfter": "public List getObjectMetrics() {\n    return _vObjectMetrics;\n}"}, {"methodBefore": "public Vector getFunctions() {\n    return _vFunctionMetrics;\n}", "methodAfter": "public List getFunctions() {\n    return _vFunctionMetrics;\n}"}], [{"methodBefore": "public double getBranchCoverageRate() {\n    if (getNumberOfValidBranches() == 0) {\n        return 1.0;\n    }\n    lock.lock();\n    try {\n        return ((double) (getNumberOfCoveredBranches())) / getNumberOfValidBranches();\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized double getBranchCoverageRate() {\n    if (getNumberOfValidBranches() == 0) {\n        return 1.0;\n    }\n    try {\n        return ((double) (getNumberOfCoveredBranches())) / getNumberOfValidBranches();\n    } finally {\n    }\n}"}, {"methodBefore": "public int getConditionSize() {\n    lock.lock();\n    try {\n        return (jumps == null ? 0 : jumps.size()) + (switches == null ? 0 : switches.size());\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized int getConditionSize() {\n    try {\n        return (jumps == null ? 0 : jumps.size()) + (switches == null ? 0 : switches.size());\n    } finally {\n    }\n}"}, {"methodBefore": "public String getConditionCoverage() {\n    StringBuffer ret = new StringBuffer();\n    if (getNumberOfValidBranches() == 0) {\n        ret.append(StringUtil.getPercentValue(1.0));\n    } else {\n        lock.lock();\n        try {\n            ret.append(StringUtil.getPercentValue(getBranchCoverageRate()));\n            ret.append(\" (\").append(getNumberOfCoveredBranches()).append(\"/\").append(getNumberOfValidBranches()).append(\")\");\n        } finally {\n            lock.unlock();\n        }\n    }\n    return ret.toString();\n}", "methodAfter": "public synchronized String getConditionCoverage() {\n    StringBuffer ret = new StringBuffer();\n    if (getNumberOfValidBranches() == 0) {\n        ret.append(StringUtil.getPercentValue(1.0));\n    } else {\n        try {\n            ret.append(StringUtil.getPercentValue(getBranchCoverageRate()));\n            ret.append(\" (\").append(getNumberOfCoveredBranches()).append(\"/\").append(getNumberOfValidBranches()).append(\")\");\n        } finally {\n        }\n    }\n    return ret.toString();\n}"}], [{"methodBefore": "private final boolean jj_3R_368() {\n    if (jj_3R_260()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_245() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_369() {\n    if (jj_3R_261()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_249() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public Collection getClasses() {\n    return this.classes.values();\n}", "methodAfter": "public Collection getClasses() {\n    lock.lock();\n    try {\n        return this.classes.values();\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public int getNumberOfClasses() {\n    return this.classes.size();\n}", "methodAfter": "public int getNumberOfClasses() {\n    lock.lock();\n    try {\n        return this.classes.size();\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfValidBranches();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfCoveredLines();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfValidLines();\n        numberCovered += coverageContainer.getNumberOfCoveredLines();\n    } \n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}, {"methodBefore": "public int getNumberOfValidLines() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfValidLines();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfCoveredBranches();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}], [{"methodBefore": "private final boolean jj_3_27() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_41() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3_38() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_30() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private LineData getLineData(int lineNumber) {\n    lock.lock();\n    try {\n        return ((LineData) (children.get(Integer.valueOf(lineNumber))));\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public LineData getLineData(int lineNumber) {\n    lock.lock();\n    try {\n        return ((LineData) (children.get(Integer.valueOf(lineNumber))));\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "private static void initialize() {\n    if (System.getProperty(\"catalina.home\") != null) {\n        saveGlobalProjectData();\n        ClassData.class.toString();\n        CoverageData.class.toString();\n        CoverageDataContainer.class.toString();\n        FileLocker.class.toString();\n        HasBeenInstrumented.class.toString();\n        LineData.class.toString();\n        PackageData.class.toString();\n        SourceFileData.class.toString();\n    }\n    Runtime.getRuntime().addShutdownHook(new Thread(new SaveTimer()));\n}", "methodAfter": "public static void initialize() {\n    if (System.getProperty(\"catalina.home\") != null) {\n        saveGlobalProjectData();\n        ClassData.class.toString();\n        CoverageData.class.toString();\n        CoverageDataContainer.class.toString();\n        FileLocker.class.toString();\n        HasBeenInstrumented.class.toString();\n        LineData.class.toString();\n        PackageData.class.toString();\n        SourceFileData.class.toString();\n    }\n    Runtime.getRuntime().addShutdownHook(new Thread(new SaveTimer()));\n}"}], [{"methodBefore": "public MergeTask() {\n    super(\"net.sourceforge.cobertura.merge.Main\");\n}", "methodAfter": "public MergeTask() {\n    super(Main.class.getCanonicalName());\n}"}, {"methodBefore": "public ReportTask() {\n    super(\"net.sourceforge.cobertura.reporting.Main\");\n}", "methodAfter": "public ReportTask() {\n    super(Main.class.getCanonicalName());\n}"}, {"methodBefore": "public CheckTask() {\n    super(\"net.sourceforge.cobertura.check.Main\");\n}", "methodAfter": "public CheckTask() {\n    super(Main.class.getCanonicalName());\n}"}], [{"methodBefore": "@Test\npublic void validateComparisonAndEquality() {\n    final SourceLocation sl1 = new SourceLocation(packageName, className, methodName, lineNumber);\n    final SourceLocation sl2 = new SourceLocation(packageName, className, methodName, lineNumber);\n    Assert.assertEquals(sl1, sl2);\n    Assert.assertNotSame(sl1, sl2);\n    Assert.assertEquals(0, sl1.compareTo(sl2));\n    Assert.assertFalse(sl1.equals(null));\n    Assert.assertTrue(sl1.equals(sl1));\n    Assert.assertTrue(sl1.equals(sl2));\n    Assert.assertFalse(sl1.equals(new Rate()));\n    Assert.assertEquals(0, sl1.compareTo(sl1));\n    Assert.assertEquals(0, sl1.compareTo(sl2));\n    Assert.assertEquals(Integer.MIN_VALUE, sl1.compareTo(null));\n    Assert.assertEquals(sl1.hashCode(), sl2.hashCode());\n}", "methodAfter": "@Test\npublic void validateComparisonAndEquality() {\n    final SourceLocation sl1 = new SourceLocation(packageName, className, methodName, lineNumber, branchSegment);\n    final SourceLocation sl2 = new SourceLocation(packageName, className, methodName, lineNumber, branchSegment);\n    Assert.assertEquals(sl1, sl2);\n    Assert.assertNotSame(sl1, sl2);\n    Assert.assertEquals(0, sl1.compareTo(sl2));\n    Assert.assertFalse(sl1.equals(null));\n    Assert.assertTrue(sl1.equals(sl1));\n    Assert.assertTrue(sl1.equals(sl2));\n    Assert.assertFalse(sl1.equals(new Rate()));\n    Assert.assertEquals(0, sl1.compareTo(sl1));\n    Assert.assertEquals(0, sl1.compareTo(sl2));\n    Assert.assertEquals(Integer.MIN_VALUE, sl1.compareTo(null));\n    Assert.assertEquals(sl1.hashCode(), sl2.hashCode());\n}"}, {"methodBefore": "@Test\npublic void validateStringForm() {\n    final String expected = \"net.sourceforge.cobertura.metrics.model.coverage.Rate::toString,line:122\";\n    final SourceLocation sl1 = new SourceLocation(packageName, className, methodName, lineNumber);\n    Assert.assertEquals(expected, sl1.toString());\n}", "methodAfter": "@Test\npublic void validateStringForm() {\n    final String expected = \"net.sourceforge.cobertura.metrics.model.coverage.Rate::toString,line:122,segment:0\";\n    final SourceLocation sl1 = new SourceLocation(packageName, className, methodName, lineNumber, branchSegment);\n    Assert.assertEquals(expected, sl1.toString());\n}"}], [{"methodBefore": "private final boolean jj_3R_129() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_120() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_248() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_275() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public Vector getImports() {\n    return _vImports;\n}", "methodAfter": "public List getImports() {\n    return _vImports;\n}"}, {"methodBefore": "public Vector getObjectMetrics() {\n    return _vObjectMetrics;\n}", "methodAfter": "public List getObjectMetrics() {\n    return _vObjectMetrics;\n}"}], [{"methodBefore": "private final boolean jj_3R_329() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_367() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_117() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_127() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public static Path getCoberturaDefaultClasspath() {\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(new File(getTempDir(), \"instrument\"));\n    dirSetSrcDir.setDir(new File(getTempDir(), \"src\"));\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    return classpath;\n}", "methodAfter": "public static Path getCoberturaDefaultClasspath() {\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(new File(getTempDir(), \"instrument\"));\n    dirSetSrcDir.setDir(new File(getTempDir(), \"src\"));\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    return classpath;\n}"}, {"methodBefore": "@Test\npublic void ignoreTrivialTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File reportDir = new File(tempDir, \"report\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    instrumentDir.mkdirs();\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File interfaceSourceFile = new File(srcDir, \"mypackage/MyInterface.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(interfaceSourceFile, (((\"\\n package mypackage;\" + \"\\n \") + \"\\n public interface MyInterface {\") + \"\\n \\tpublic void myInterfaceMethod();\") + \"\\n }\");\n    FileUtils.write(mainSourceFile, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic static class MyObject implements MyInterface\") + \"\\n \\t{\") + \"\\n \\t\\tpublic void myInterfaceMethod()\") + \"\\n \\t\\t{\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tMain main = new Main();\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * Call all methods so they will be considered \\\"covered\\\" unless\") + \"\\n \\t\\t * they are ignored as trivial.\") + \"\\n \\t\\t *\") + \"\\n \\t\\t * These are in no particular order.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tmain.getterTrivial();\") + \"\\n \\t\\tmain.empty();\") + \"\\n \\t\\tmain.getVoid();\") + \"\\n \\t\\tmain.getIntWithIntParm(0);\") + \"\\n \\t\\tmain.isBool();\") + \"\\n \\t\\tmain.hasBool();\") + \"\\n \\t\\tmain.set();\") + \"\\n \\t\\tmain.setInt(1);\") + \"\\n \\t\\tmain.setIntWithTwoParms(1, 2);\") + \"\\n \\t\\tmain.getMultiDimArray();\") + \"\\n \\t\\tmain.setIncrement(1);\") + \"\\n \\t\\tmain.setConst(\\\"\\\");\") + \"\\n \\t\\tmain.getArray();\") + \"\\n \\t\\tmain.getObject();\") + \"\\n \\t\\tmain.getStatic();\") + \"\\n \\t\\tmain.setStatic(1);\") + \"\\n \\t\\tmain.setISTORE(1);\") + \"\\n \\t\\tmain.setLSTORE(1);\") + \"\\n \\t\\tmain.setFSTORE((float)1.0);\") + \"\\n \\t\\tmain.setDSTORE(1.0);\") + \"\\n \\t\\tmain.setASTORE(null);\") + \"\\n \\t\\tmain.getINVOKEVIRTUAL();\") + \"\\n \\t\\tmain.getINVOKESPECIAL();\") + \"\\n \\t\\tmain.getINVOKESTATIC();\") + \"\\n \\t\\tmain.setINVOKEINTERFACE(new MyObject());\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t// call constructors in no particular order\") + \"\\n \\t\\tnew Main(1);\") + \"\\n \\t\\tnew Main(true);\") + \"\\n \\t\\tnew Main(\\\"str\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", \\\"\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", 0);\") + \"\\n \\t\\tnew Main(\\\"\\\", true);\") + \"\\n \\t\\tnew Main((Thread) null, \\\"string\\\");\") + \"\\n \\t\\tnew Main((Thread) null, 0);\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// Be careful when initializing members.  If you instantiate an\") + \"\\n \\t// object, then trivial constructors will become non-trivial.\") + \"\\n \\t// Ex. Integer myInteger = new Integer(1); will cause Main() to be non-trivial.\") + \"\\n \\tint myint;\") + \"\\n \\tboolean mybool;\") + \"\\n \\tprivate static int mystatic;\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial constructor\") + \"\\n \\tpublic Main() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// constructors that just call super() are trivial\") + \"\\n \\tpublic Main(Thread t, String str)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(str);\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// constructors that just call super() are usually trivial, but\") + \"\\n \\t// this constructor uses a constant, so it is considered non-trivial.\") + \"\\n \\tpublic Main(Thread t, int i)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(\\\"string\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(boolean bool) {\") + \"\\n \\t\\t// non-trivial conditional\") + \"\\n \\t\\tmyint = bool ? 0 : 1;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(int num) {\") + \"\\n \\t\\t// non-trivial switch\") + \"\\n \\t\\tswitch(num) {\") + \"\\n \\t\\t\\tdefault:\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str) {\") + \"\\n \\t\\t// setting of statics is non-trivial\") + \"\\n \\t\\tmystatic = 2;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, String str2)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial method call\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic Main(String str1, int i)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial object construction\") + \"\\n \\t\\tnew StringBuffer();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, boolean bool)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial this() call\") + \"\\n \\t\\tthis(str1, 0);\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic int getterTrivial() {\") + \"\\n \\t\\treturn myint;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean isBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean hasBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial setter\") + \"\\n \\tpublic void setInt(int i) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be trivial, but it is a getter that with no return value\") + \"\\n \\tpublic void getVoid() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// \\\"empty\\\" does not start with \\\"get\\\", \\\"is\\\", \\\"has\\\", or \\\"set\\\", so\") + \"\\n \\t// it is considered non-trivial.\") + \"\\n \\tprivate int empty() {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this is a getter that takes a parameter, so it is non-trivial.\") + \"\\n \\tpublic int getIntWithIntParm(int i) {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// this would be a trivial setter, but it does not have a parameter.\") + \"\\n \\tpublic void set() {\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be a trivial setter, but it has more than one parameter.\") + \"\\n \\tpublic void setIntWithTwoParms(int i, int j) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic int[][] getMultiDimArray() {\") + \"\\n \\t\\t// non-trivial construction of a multi-dimensional array\") + \"\\n \\t\\treturn new int[1][1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setIncrement(int i) {\") + \"\\n \\t\\t// non-trivial increment of local variable\") + \"\\n \\t\\ti++;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setConst(String str) {\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * cause visitLdcInsn to be called because \\\"str\\\" is in the\") + \"\\n \\t\\t * runtime constant pool.  An LDC operation is performed\") + \"\\n \\t\\t * which is considered non-trivial.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tSystem.out.println(\\\"str\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int[] getArray() {\") + \"\\n \\t\\t// causes visitIntInsn to be called.  Creating an array is a \\\"single int operand\\\".\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new int[1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Object getObject() {\") + \"\\n \\t\\t// causes visitTypeInsn to be called.  Creating an object is a type instruction.\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new Object();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int getStatic() {\") + \"\\n \\t\\t// getting a static is non-trivial.\") + \"\\n \\t\\treturn mystatic;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setStatic(int i) {\") + \"\\n \\t\\t// setting a static is non-trivial.\") + \"\\n \\t\\tmystatic = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ISTORE)) (int store to local var)\") + \"\\n \\tpublic void setISTORE(int i) {\") + \"\\n \\t\\ti = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(LSTORE)) (long store to local var)\") + \"\\n \\tpublic void setLSTORE(long l) {\") + \"\\n \\t\\tl = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(FSTORE)) (floating store to local var)\") + \"\\n \\tpublic void setFSTORE(float f) {\") + \"\\n \\t\\tf = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(DSTORE)) (double store to local var)\") + \"\\n \\tpublic void setDSTORE(double d) {\") + \"\\n \\t\\td = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ASTORE)) (object store to local var)\") + \"\\n \\tpublic void setASTORE(Object obj) {\") + \"\\n \\t\\tobj = null;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic void publicMethod() {\") + \"\\n \\t}\") + \"\\n \\tprivate void privateMethod() {\") + \"\\n \\t}\") + \"\\n \\tpublic static void staticMethod() {\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \\t// non-trivial public method call (causes visitMethodInsn(INVOKEVIRTUAL))\") + \"\\n \\tpublic int getINVOKEVIRTUAL() {\") + \"\\n \\t\\tpublicMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial private method call (causes visitMethodInsn(INVOKESPECIAL)) \") + \"\\n \\tpublic int getINVOKESPECIAL() {\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial static method call (causes visitMethodInsn(INVOKESTATIC)) \") + \"\\n \\tpublic int getINVOKESTATIC() {\") + \"\\n \\t\\tstaticMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial interface method call (causes visitMethodInsn(INVOKEINTERFACE))\") + \"\\n \\tpublic void setINVOKEINTERFACE(MyInterface obj) {\") + \"\\n \\t\\tobj.myInterfaceMethod();\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"ignoretrivial\", true);\n        }\n    });\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    ignoreUtil = new IgnoreUtil(\"mypackage.Main\", dom);\n    assertIgnored(\"<init>\", \"()V\");\n    assertIgnored(\"<init>\", \"(Ljava/lang/Thread;Ljava/lang/String;)V\");\n    assertIgnored(\"getterTrivial\");\n    assertIgnored(\"isBool\");\n    assertIgnored(\"hasBool\");\n    assertIgnored(\"setInt\");\n    assertNotIgnored(\"<init>\", \"(I)V\");\n    assertNotIgnored(\"<init>\", \"(Z)V\");\n    assertNotIgnored(\"empty\");\n    assertNotIgnored(\"getVoid\");\n    assertNotIgnored(\"getIntWithIntParm\");\n    assertNotIgnored(\"set\");\n    assertNotIgnored(\"setIntWithTwoParms\");\n    assertNotIgnored(\"getMultiDimArray\");\n    assertNotIgnored(\"setIncrement\");\n    assertNotIgnored(\"setConst\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/Thread;I)V\");\n    assertNotIgnored(\"getArray\");\n    assertNotIgnored(\"getObject\");\n    assertNotIgnored(\"getStatic\");\n    assertNotIgnored(\"setStatic\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;)V\");\n    assertNotIgnored(\"setISTORE\");\n    assertNotIgnored(\"setLSTORE\");\n    assertNotIgnored(\"setFSTORE\");\n    assertNotIgnored(\"setDSTORE\");\n    assertNotIgnored(\"setASTORE\");\n    assertNotIgnored(\"getINVOKEVIRTUAL\");\n    assertNotIgnored(\"getINVOKESPECIAL\");\n    assertNotIgnored(\"getINVOKESTATIC\");\n    assertNotIgnored(\"setINVOKEINTERFACE\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Ljava/lang/String;)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;I)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Z)V\");\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"html\");\n    reportTask.setDestDir(reportDir);\n    reportTask.setSrcDir(srcDir.getAbsolutePath());\n    reportTask.execute();\n    assertTrue(new File(reportDir, \"index.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.Main.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.MyInterface.html\").exists());\n    File frameSummaryFile = new File(reportDir, \"frame-summary.html\");\n    assertTrue(frameSummaryFile.exists());\n    TestUtils.checkFrameSummaryHtmlFile(frameSummaryFile);\n}", "methodAfter": "@Test\npublic void ignoreTrivialTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File reportDir = new File(tempDir, \"report\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    instrumentDir.mkdirs();\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File interfaceSourceFile = new File(srcDir, \"mypackage/MyInterface.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(interfaceSourceFile, (((\"\\n package mypackage;\" + \"\\n \") + \"\\n public interface MyInterface {\") + \"\\n \\tpublic void myInterfaceMethod();\") + \"\\n }\");\n    FileUtils.write(mainSourceFile, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic static class MyObject implements MyInterface\") + \"\\n \\t{\") + \"\\n \\t\\tpublic void myInterfaceMethod()\") + \"\\n \\t\\t{\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tMain main = new Main();\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * Call all methods so they will be considered \\\"covered\\\" unless\") + \"\\n \\t\\t * they are ignored as trivial.\") + \"\\n \\t\\t *\") + \"\\n \\t\\t * These are in no particular order.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tmain.getterTrivial();\") + \"\\n \\t\\tmain.empty();\") + \"\\n \\t\\tmain.getVoid();\") + \"\\n \\t\\tmain.getIntWithIntParm(0);\") + \"\\n \\t\\tmain.isBool();\") + \"\\n \\t\\tmain.hasBool();\") + \"\\n \\t\\tmain.set();\") + \"\\n \\t\\tmain.setInt(1);\") + \"\\n \\t\\tmain.setIntWithTwoParms(1, 2);\") + \"\\n \\t\\tmain.getMultiDimArray();\") + \"\\n \\t\\tmain.setIncrement(1);\") + \"\\n \\t\\tmain.setConst(\\\"\\\");\") + \"\\n \\t\\tmain.getArray();\") + \"\\n \\t\\tmain.getObject();\") + \"\\n \\t\\tmain.getStatic();\") + \"\\n \\t\\tmain.setStatic(1);\") + \"\\n \\t\\tmain.setISTORE(1);\") + \"\\n \\t\\tmain.setLSTORE(1);\") + \"\\n \\t\\tmain.setFSTORE((float)1.0);\") + \"\\n \\t\\tmain.setDSTORE(1.0);\") + \"\\n \\t\\tmain.setASTORE(null);\") + \"\\n \\t\\tmain.getINVOKEVIRTUAL();\") + \"\\n \\t\\tmain.getINVOKESPECIAL();\") + \"\\n \\t\\tmain.getINVOKESTATIC();\") + \"\\n \\t\\tmain.setINVOKEINTERFACE(new MyObject());\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t// call constructors in no particular order\") + \"\\n \\t\\tnew Main(1);\") + \"\\n \\t\\tnew Main(true);\") + \"\\n \\t\\tnew Main(\\\"str\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", \\\"\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", 0);\") + \"\\n \\t\\tnew Main(\\\"\\\", true);\") + \"\\n \\t\\tnew Main((Thread) null, \\\"string\\\");\") + \"\\n \\t\\tnew Main((Thread) null, 0);\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// Be careful when initializing members.  If you instantiate an\") + \"\\n \\t// object, then trivial constructors will become non-trivial.\") + \"\\n \\t// Ex. Integer myInteger = new Integer(1); will cause Main() to be non-trivial.\") + \"\\n \\tint myint;\") + \"\\n \\tboolean mybool;\") + \"\\n \\tprivate static int mystatic;\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial constructor\") + \"\\n \\tpublic Main() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// constructors that just call super() are trivial\") + \"\\n \\tpublic Main(Thread t, String str)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(str);\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// constructors that just call super() are usually trivial, but\") + \"\\n \\t// this constructor uses a constant, so it is considered non-trivial.\") + \"\\n \\tpublic Main(Thread t, int i)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(\\\"string\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(boolean bool) {\") + \"\\n \\t\\t// non-trivial conditional\") + \"\\n \\t\\tmyint = bool ? 0 : 1;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(int num) {\") + \"\\n \\t\\t// non-trivial switch\") + \"\\n \\t\\tswitch(num) {\") + \"\\n \\t\\t\\tdefault:\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str) {\") + \"\\n \\t\\t// setting of statics is non-trivial\") + \"\\n \\t\\tmystatic = 2;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, String str2)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial method call\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic Main(String str1, int i)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial object construction\") + \"\\n \\t\\tnew StringBuffer();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, boolean bool)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial this() call\") + \"\\n \\t\\tthis(str1, 0);\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic int getterTrivial() {\") + \"\\n \\t\\treturn myint;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean isBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean hasBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial setter\") + \"\\n \\tpublic void setInt(int i) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be trivial, but it is a getter that with no return value\") + \"\\n \\tpublic void getVoid() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// \\\"empty\\\" does not start with \\\"get\\\", \\\"is\\\", \\\"has\\\", or \\\"set\\\", so\") + \"\\n \\t// it is considered non-trivial.\") + \"\\n \\tprivate int empty() {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this is a getter that takes a parameter, so it is non-trivial.\") + \"\\n \\tpublic int getIntWithIntParm(int i) {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// this would be a trivial setter, but it does not have a parameter.\") + \"\\n \\tpublic void set() {\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be a trivial setter, but it has more than one parameter.\") + \"\\n \\tpublic void setIntWithTwoParms(int i, int j) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic int[][] getMultiDimArray() {\") + \"\\n \\t\\t// non-trivial construction of a multi-dimensional array\") + \"\\n \\t\\treturn new int[1][1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setIncrement(int i) {\") + \"\\n \\t\\t// non-trivial increment of local variable\") + \"\\n \\t\\ti++;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setConst(String str) {\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * cause visitLdcInsn to be called because \\\"str\\\" is in the\") + \"\\n \\t\\t * runtime constant pool.  An LDC operation is performed\") + \"\\n \\t\\t * which is considered non-trivial.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tSystem.out.println(\\\"str\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int[] getArray() {\") + \"\\n \\t\\t// causes visitIntInsn to be called.  Creating an array is a \\\"single int operand\\\".\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new int[1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Object getObject() {\") + \"\\n \\t\\t// causes visitTypeInsn to be called.  Creating an object is a type instruction.\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new Object();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int getStatic() {\") + \"\\n \\t\\t// getting a static is non-trivial.\") + \"\\n \\t\\treturn mystatic;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setStatic(int i) {\") + \"\\n \\t\\t// setting a static is non-trivial.\") + \"\\n \\t\\tmystatic = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ISTORE)) (int store to local var)\") + \"\\n \\tpublic void setISTORE(int i) {\") + \"\\n \\t\\ti = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(LSTORE)) (long store to local var)\") + \"\\n \\tpublic void setLSTORE(long l) {\") + \"\\n \\t\\tl = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(FSTORE)) (floating store to local var)\") + \"\\n \\tpublic void setFSTORE(float f) {\") + \"\\n \\t\\tf = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(DSTORE)) (double store to local var)\") + \"\\n \\tpublic void setDSTORE(double d) {\") + \"\\n \\t\\td = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ASTORE)) (object store to local var)\") + \"\\n \\tpublic void setASTORE(Object obj) {\") + \"\\n \\t\\tobj = null;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic void publicMethod() {\") + \"\\n \\t}\") + \"\\n \\tprivate void privateMethod() {\") + \"\\n \\t}\") + \"\\n \\tpublic static void staticMethod() {\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \\t// non-trivial public method call (causes visitMethodInsn(INVOKEVIRTUAL))\") + \"\\n \\tpublic int getINVOKEVIRTUAL() {\") + \"\\n \\t\\tpublicMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial private method call (causes visitMethodInsn(INVOKESPECIAL)) \") + \"\\n \\tpublic int getINVOKESPECIAL() {\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial static method call (causes visitMethodInsn(INVOKESTATIC)) \") + \"\\n \\tpublic int getINVOKESTATIC() {\") + \"\\n \\t\\tstaticMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial interface method call (causes visitMethodInsn(INVOKEINTERFACE))\") + \"\\n \\tpublic void setINVOKEINTERFACE(MyInterface obj) {\") + \"\\n \\t\\tobj.myInterfaceMethod();\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"ignoretrivial\", true);\n        }\n    });\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    ignoreUtil = new IgnoreUtil(\"mypackage.Main\", dom);\n    assertIgnored(\"<init>\", \"()V\");\n    assertIgnored(\"<init>\", \"(Ljava/lang/Thread;Ljava/lang/String;)V\");\n    assertIgnored(\"getterTrivial\");\n    assertIgnored(\"isBool\");\n    assertIgnored(\"hasBool\");\n    assertIgnored(\"setInt\");\n    assertNotIgnored(\"<init>\", \"(I)V\");\n    assertNotIgnored(\"<init>\", \"(Z)V\");\n    assertNotIgnored(\"empty\");\n    assertNotIgnored(\"getVoid\");\n    assertNotIgnored(\"getIntWithIntParm\");\n    assertNotIgnored(\"set\");\n    assertNotIgnored(\"setIntWithTwoParms\");\n    assertNotIgnored(\"getMultiDimArray\");\n    assertNotIgnored(\"setIncrement\");\n    assertNotIgnored(\"setConst\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/Thread;I)V\");\n    assertNotIgnored(\"getArray\");\n    assertNotIgnored(\"getObject\");\n    assertNotIgnored(\"getStatic\");\n    assertNotIgnored(\"setStatic\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;)V\");\n    assertNotIgnored(\"setISTORE\");\n    assertNotIgnored(\"setLSTORE\");\n    assertNotIgnored(\"setFSTORE\");\n    assertNotIgnored(\"setDSTORE\");\n    assertNotIgnored(\"setASTORE\");\n    assertNotIgnored(\"getINVOKEVIRTUAL\");\n    assertNotIgnored(\"getINVOKESPECIAL\");\n    assertNotIgnored(\"getINVOKESTATIC\");\n    assertNotIgnored(\"setINVOKEINTERFACE\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Ljava/lang/String;)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;I)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Z)V\");\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"html\");\n    reportTask.setDestDir(reportDir);\n    reportTask.setSrcDir(srcDir.getAbsolutePath());\n    reportTask.execute();\n    assertTrue(new File(reportDir, \"index.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.Main.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.MyInterface.html\").exists());\n    File frameSummaryFile = new File(reportDir, \"frame-summary.html\");\n    assertTrue(frameSummaryFile.exists());\n    TestUtils.checkFrameSummaryHtmlFile(frameSummaryFile);\n}"}, {"methodBefore": "private void runTest(String code) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    final File srcDir = new File(tempDir, \"src\");\n    File sourceFile = new File(srcDir, \"mypackage/MyThreads.java\");\n    final File datafile = new File(srcDir, \"cobertura.ser\");\n    sourceFile.getParentFile().mkdirs();\n    BufferedWriter bw = null;\n    try {\n        bw = new BufferedWriter(new FileWriter(sourceFile));\n        bw.write(getThreadedCode(code));\n    } finally {\n        bw.close();\n    }\n    compileSource(srcDir);\n    instrumentClasses(srcDir, datafile);\n    Path p = new Path(TestUtils.project);\n    DirSet dirSet = new DirSet();\n    FileSet fileSet = new FileSet();\n    dirSet.setDir(srcDir);\n    fileSet.setDir(new File(\"src/test/resources/antLibrary/common/groovy\"));\n    fileSet.setIncludes(\"*.jar\");\n    p.addFileset(fileSet);\n    p.addDirset(dirSet);\n    p.setProject(project);\n    p.addDirset(TestUtils.getCoberturaClassDirSet());\n    for (int i = 0; i < numberOfRetries; i++) {\n        System.out.println(\"Executing build: \" + i);\n        Java java = new Java();\n        java.setClassname(\"mypackage.MyThreads\");\n        java.setDir(srcDir);\n        java.setFork(true);\n        java.setProject(project);\n        java.setFailonerror(true);\n        java.setClasspath(p);\n        java.execute();\n    }\n    System.out.println(\"Starting reporting task.\");\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    System.out.println(\"Finish reporting task.\");\n    Node dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    int hitCount = TestUtils.getHitCount(dom, \"mypackage.MyThreads\", \"acall\");\n    assertEquals(\"hit count incorrect\", (numberOfRetries * numberOfThreads) * numberOfCalls, hitCount);\n}", "methodAfter": "private void runTest(String code) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    final File srcDir = new File(tempDir, \"src\");\n    File sourceFile = new File(srcDir, \"mypackage/MyThreads.java\");\n    final File datafile = new File(srcDir, \"cobertura.ser\");\n    sourceFile.getParentFile().mkdirs();\n    BufferedWriter bw = null;\n    try {\n        bw = new BufferedWriter(new FileWriter(sourceFile));\n        bw.write(getThreadedCode(code));\n    } finally {\n        bw.close();\n    }\n    compileSource(srcDir);\n    instrumentClasses(srcDir, datafile);\n    Path p = new Path(TestUtils.project);\n    DirSet dirSet = new DirSet();\n    FileSet fileSet = new FileSet();\n    dirSet.setDir(srcDir);\n    fileSet.setDir(new File(\"src/test/resources/antLibrary/common/groovy\"));\n    fileSet.setIncludes(\"*.jar\");\n    p.addFileset(fileSet);\n    p.addDirset(dirSet);\n    p.setProject(project);\n    p.addDirset(TestUtils.getCoberturaClassDirSet());\n    p.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    for (int i = 0; i < numberOfRetries; i++) {\n        System.out.println(\"Executing build: \" + i);\n        Java java = new Java();\n        java.setClassname(\"mypackage.MyThreads\");\n        java.setDir(srcDir);\n        java.setFork(true);\n        java.setProject(project);\n        java.setFailonerror(true);\n        java.setClasspath(p);\n        java.execute();\n    }\n    System.out.println(\"Starting reporting task.\");\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    System.out.println(\"Finish reporting task.\");\n    Node dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    int hitCount = TestUtils.getHitCount(dom, \"mypackage.MyThreads\", \"acall\");\n    assertEquals(\"hit count incorrect\", (numberOfRetries * numberOfThreads) * numberOfCalls, hitCount);\n}"}, {"methodBefore": "private void runTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    BufferedWriter bw = null;\n    try {\n        bw = new BufferedWriter(new FileWriter(mainSourceFile));\n        bw.write(getMainCode(instrumentDir));\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    File calledSourceFile = new File(srcDir, \"mypackage/Called.java\");\n    try {\n        bw = new BufferedWriter(new FileWriter(calledSourceFile));\n        bw.write(CALLED_CODE);\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    DirSet dirSet = new DirSet();\n    dirSet.setDir(srcDir);\n    dirSet.setProject(project);\n    Path classpath = new Path(TestUtils.project);\n    classpath.addDirset(dirSet);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    List<Node> lines = TestUtils.getLineCounts(dom, \"mypackage.Called\", \"callThis\", null);\n    assertEquals(1, lines.size());\n    for (int i = 0; i < lines.size(); i++) {\n        assertEquals(\"hit count incorrect\", \"2\", lines.get(i).attribute(\"hits\"));\n    }\n}", "methodAfter": "private void runTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    BufferedWriter bw = null;\n    try {\n        bw = new BufferedWriter(new FileWriter(mainSourceFile));\n        bw.write(getMainCode(instrumentDir));\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    File calledSourceFile = new File(srcDir, \"mypackage/Called.java\");\n    try {\n        bw = new BufferedWriter(new FileWriter(calledSourceFile));\n        bw.write(CALLED_CODE);\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    DirSet dirSet = new DirSet();\n    dirSet.setDir(srcDir);\n    dirSet.setProject(project);\n    Path classpath = new Path(TestUtils.project);\n    classpath.addDirset(dirSet);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    List<Node> lines = TestUtils.getLineCounts(dom, \"mypackage.Called\", \"callThis\", null);\n    assertEquals(1, lines.size());\n    for (int i = 0; i < lines.size(); i++) {\n        assertEquals(\"hit count incorrect\", \"2\", lines.get(i).attribute(\"hits\"));\n    }\n}"}, {"methodBefore": "@Test\npublic void performanceTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(mainSourceFile, (((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tlong start = System.nanoTime();\") + \"\\n \\t\\tint j = 0;\") + \"\\n \\t\\tfor (int i = 0; i < 100000; i++) {\") + \"\\n \\t\\t   if (i % 2 == 0) { j+=2; };\") + \"\\n \\t\\t   switch (i % 4) {\") + \"\\n \\t\\t      case 0 : \") + \"\\n \\t\\t      case 1 : j++;\") + \"\\n \\t\\t      case 2 : j+=2;\") + \"\\n \\t\\t      default: j+=3;\") + \"\\n \\t\\t   } \") + \"\\n \\t\\t}\") + \"\\n \\t\\tlong stop = System.nanoTime();\") + \"\\n \\t\\tSystem.out.println(\\\"Test took:\\\" + (stop - start)/100000.0 + \\\" milis\\\");\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    System.out.println(\"Run without instrumentation:\\n\");\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetSrcDir);\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setOutput(new File(tempDir, \"PT_uninstrumented.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_uninstrumented.log\")));\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    System.out.println(\"Run with instrumentation (not threadsafe-rigorous):\\n\");\n    classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\")).toString());\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"threadsafeRigorous\", true);\n        }\n    });\n    System.out.println(\"Run with instrumentation (threadsafe-rigorous):\\n\");\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedThreadSafe.log\")));\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n}", "methodAfter": "@Test\npublic void performanceTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(mainSourceFile, (((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tlong start = System.nanoTime();\") + \"\\n \\t\\tint j = 0;\") + \"\\n \\t\\tfor (int i = 0; i < 100000; i++) {\") + \"\\n \\t\\t   if (i % 2 == 0) { j+=2; };\") + \"\\n \\t\\t   switch (i % 4) {\") + \"\\n \\t\\t      case 0 : \") + \"\\n \\t\\t      case 1 : j++;\") + \"\\n \\t\\t      case 2 : j+=2;\") + \"\\n \\t\\t      default: j+=3;\") + \"\\n \\t\\t   } \") + \"\\n \\t\\t}\") + \"\\n \\t\\tlong stop = System.nanoTime();\") + \"\\n \\t\\tSystem.out.println(\\\"Test took:\\\" + (stop - start)/100000.0 + \\\" milis\\\");\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    System.out.println(\"Run without instrumentation:\\n\");\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetSrcDir);\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setOutput(new File(tempDir, \"PT_uninstrumented.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_uninstrumented.log\")));\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    System.out.println(\"Run with instrumentation (not threadsafe-rigorous):\\n\");\n    classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\")).toString());\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"threadsafeRigorous\", true);\n        }\n    });\n    System.out.println(\"Run with instrumentation (threadsafe-rigorous):\\n\");\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedThreadSafe.log\")));\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n}"}], [{"methodBefore": "public Vector getImports() {\n    return _vImports;\n}", "methodAfter": "public List getImports() {\n    return _vImports;\n}"}, {"methodBefore": "public Vector getFunction() {\n    return _vFunctions;\n}", "methodAfter": "public List getFunction() {\n    return _vFunctions;\n}"}, {"methodBefore": "public Vector getImports() {\n    return _vImports;\n}", "methodAfter": "public List getImports() {\n    return _vImports;\n}"}, {"methodBefore": "public Vector getFunctionMetrics() {\n    return _vFunctionMetrics;\n}", "methodAfter": "public List getFunctionMetrics() {\n    return _vFunctionMetrics;\n}"}, {"methodBefore": "public Vector getFunctions() {\n    return _vFunctionMetrics;\n}", "methodAfter": "public List getFunctions() {\n    return _vFunctionMetrics;\n}"}, {"methodBefore": "public Vector getFunctionMetrics() {\n    return _vFunctionMetrics;\n}", "methodAfter": "public List getFunctionMetrics() {\n    return _vFunctionMetrics;\n}"}, {"methodBefore": "public Vector getPackageMetrics() {\n    return _vPackageMetrics;\n}", "methodAfter": "public List getPackageMetrics() {\n    return _vPackageMetrics;\n}"}, {"methodBefore": "public Vector getFunctions() {\n    return _vFunctionMetrics;\n}", "methodAfter": "public List getFunctions() {\n    return _vFunctionMetrics;\n}"}, {"methodBefore": "public Vector getImports() {\n    return _vImports;\n}", "methodAfter": "public List getImports() {\n    return _vImports;\n}"}, {"methodBefore": "public Vector getObjectMetrics() {\n    return _vObjectMetrics;\n}", "methodAfter": "public List getObjectMetrics() {\n    return _vObjectMetrics;\n}"}, {"methodBefore": "public Vector getObjectMetrics() {\n    return _vObjectMetrics;\n}", "methodAfter": "public List getObjectMetrics() {\n    return _vObjectMetrics;\n}"}, {"methodBefore": "public Vector getPackageMetrics() {\n    return _vPackageMetrics;\n}", "methodAfter": "public List getPackageMetrics() {\n    return _vPackageMetrics;\n}"}], [{"methodBefore": "public void visitEnd() {\n    if ((!doNotInstrument) && (coverageData.getValidLineNumbers().size() == 0)) {\n        logger.warn((\"No line number information found for class \" + this.myName) + \".  Perhaps you need to compile with debug=true?\");\n    }\n}", "methodAfter": "public void visitEnd() {\n    if (instrument && (coverageData.getValidLineNumbers().size() == 0)) {\n        logger.warn((\"No line number information found for class \" + this.myName) + \".  Perhaps you need to compile with debug=true?\");\n    }\n}"}, {"methodBefore": "public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n    MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);\n    if (doNotInstrument) {\n        return mv;\n    }\n    return mv == null ? null : new MethodInstrumenter(mv, coverageData, this.myName, name, desc);\n}", "methodAfter": "public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n    MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);\n    if (!instrument) {\n        return mv;\n    }\n    return mv == null ? null : new MethodInstrumenter(mv, coverageData, this.myName, name, desc);\n}"}], [{"methodBefore": "private final boolean jj_3R_159() {\n    if (jj_3R_179()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_159() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3_40() {\n    if (jj_3R_108()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_40() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void testRemoveLine() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    a.removeLine(3);\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, b.getNumberOfValidLines());\n    b.removeLine(3);\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, b.getNumberOfValidLines());\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 2);\n    c.addLineJump(3, 0);\n    c.addLineJump(4, 0);\n    assertEquals(9, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, c.getNumberOfValidLines());\n    c.removeLine(3);\n    assertEquals(4, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, c.getNumberOfValidLines());\n}", "methodAfter": "public void testRemoveLine() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    a.removeLine(3);\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, b.getNumberOfValidLines());\n    b.removeLine(3);\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, b.getNumberOfValidLines());\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 2, Integer.MAX_VALUE);\n    c.addLineJump(3, 0);\n    c.addLineJump(4, 0);\n    assertEquals(9, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, c.getNumberOfValidLines());\n    c.removeLine(3);\n    assertEquals(4, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, c.getNumberOfValidLines());\n}"}, {"methodBefore": "public void testBranch() {\n    assertFalse(a.hasBranch(2));\n    a.addLineJump(2, 0);\n    assertFalse(a.hasBranch(2));\n    assertFalse(b.hasBranch(2));\n    b.addLineJump(2, 0);\n    assertTrue(b.hasBranch(2));\n    assertTrue(b.hasBranch(2));\n    b.addLineJump(2, 1);\n    assertTrue(b.hasBranch(2));\n    assertFalse(b.hasBranch(4));\n    b.addLineSwitch(4, 0, 1, 9);\n    assertTrue(b.hasBranch(4));\n    Collection branches = b.getBranches();\n    assertEquals(2, branches.size());\n    assertEquals(14, b.getNumberOfValidBranches());\n    assertTrue(branches.contains(new Integer(2)));\n    assertTrue(branches.contains(new Integer(4)));\n}", "methodAfter": "public void testBranch() {\n    assertFalse(a.hasBranch(2));\n    a.addLineJump(2, 0);\n    assertFalse(a.hasBranch(2));\n    assertFalse(b.hasBranch(2));\n    b.addLineJump(2, 0);\n    assertTrue(b.hasBranch(2));\n    assertTrue(b.hasBranch(2));\n    b.addLineJump(2, 1);\n    assertTrue(b.hasBranch(2));\n    assertFalse(b.hasBranch(4));\n    b.addLineSwitch(4, 0, 1, 9, Integer.MAX_VALUE);\n    assertTrue(b.hasBranch(4));\n    Collection branches = b.getBranches();\n    assertEquals(2, branches.size());\n    assertEquals(14, b.getNumberOfValidBranches());\n    assertTrue(branches.contains(new Integer(2)));\n    assertTrue(branches.contains(new Integer(4)));\n}"}], [{"methodBefore": "private final boolean jj_3_58() {\n    if (jj_scan_token(GT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_44() {\n    if (jj_3R_119()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3_47() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_113()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_43() {\n    if (jj_3R_118()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public static void copy(File destinationDir) throws IOException {\n    File cssOutputDir = new File(destinationDir, \"css\");\n    File imagesOutputDir = new File(destinationDir, \"images\");\n    File jsOutputDir = new File(destinationDir, \"js\");\n    destinationDir.mkdirs();\n    cssOutputDir.mkdir();\n    imagesOutputDir.mkdir();\n    jsOutputDir.mkdir();\n    copyResourceFromJar(\"help.css\", cssOutputDir);\n    copyResourceFromJar(\"main.css\", cssOutputDir);\n    copyResourceFromJar(\"sortabletable.css\", cssOutputDir);\n    copyResourceFromJar(\"source-viewer.css\", cssOutputDir);\n    copyResourceFromJar(\"tooltip.css\", cssOutputDir);\n    copyResourceFromJar(\"blank.png\", imagesOutputDir);\n    copyResourceFromJar(\"downsimple.png\", imagesOutputDir);\n    copyResourceFromJar(\"upsimple.png\", imagesOutputDir);\n    copyResourceFromJar(\"percentagesorttype.js\", jsOutputDir);\n    copyResourceFromJar(\"popup.js\", jsOutputDir);\n    copyResourceFromJar(\"sortabletable.js\", jsOutputDir);\n    copyResourceFromJar(\"stringbuilder.js\", jsOutputDir);\n    copyResourceFromJar(\"help.html\", destinationDir);\n    copyResourceFromJar(\"index.html\", destinationDir);\n}", "methodAfter": "public static void copy(File destinationDir) throws IOException {\n    File cssOutputDir = new File(destinationDir, \"css\");\n    File imagesOutputDir = new File(destinationDir, \"images\");\n    File jsOutputDir = new File(destinationDir, \"js\");\n    destinationDir.mkdirs();\n    cssOutputDir.mkdir();\n    imagesOutputDir.mkdir();\n    jsOutputDir.mkdir();\n    copyResourceFromJar(\"help.css\", cssOutputDir);\n    copyResourceFromJar(\"main.css\", cssOutputDir);\n    copyResourceFromJar(\"sortabletable.css\", cssOutputDir);\n    copyResourceFromJar(\"source-viewer.css\", cssOutputDir);\n    copyResourceFromJar(\"tooltip.css\", cssOutputDir);\n    copyResourceFromJar(\"blank.png\", imagesOutputDir);\n    copyResourceFromJar(\"downsimple.png\", imagesOutputDir);\n    copyResourceFromJar(\"upsimple.png\", imagesOutputDir);\n    copyResourceFromJar(\"customsorttypes.js\", jsOutputDir);\n    copyResourceFromJar(\"popup.js\", jsOutputDir);\n    copyResourceFromJar(\"sortabletable.js\", jsOutputDir);\n    copyResourceFromJar(\"stringbuilder.js\", jsOutputDir);\n    copyResourceFromJar(\"help.html\", destinationDir);\n    copyResourceFromJar(\"index.html\", destinationDir);\n}"}, {"methodBefore": "public static void testCopy() throws IOException {\n    CopyFiles.copy(tmpDir);\n    assertTrue(new File(tmpDir, \"help.html\").isFile());\n    assertTrue(new File(tmpDir, \"index.html\").isFile());\n    File cssDir = new File(tmpDir, \"css\");\n    assertTrue(cssDir.isDirectory());\n    assertTrue(new File(cssDir, \"help.css\").isFile());\n    assertTrue(new File(cssDir, \"main.css\").isFile());\n    assertTrue(new File(cssDir, \"sortabletable.css\").isFile());\n    assertTrue(new File(cssDir, \"source-viewer.css\").isFile());\n    assertTrue(new File(cssDir, \"tooltip.css\").isFile());\n    File imagesDir = new File(tmpDir, \"images\");\n    assertTrue(imagesDir.isDirectory());\n    assertTrue(new File(imagesDir, \"blank.png\").isFile());\n    assertTrue(new File(imagesDir, \"downsimple.png\").isFile());\n    assertTrue(new File(imagesDir, \"upsimple.png\").isFile());\n    File jsDir = new File(tmpDir, \"js\");\n    assertTrue(jsDir.isDirectory());\n    assertTrue(new File(jsDir, \"percentagesorttype.js\").isFile());\n    assertTrue(new File(jsDir, \"popup.js\").isFile());\n    assertTrue(new File(jsDir, \"sortabletable.js\").isFile());\n    assertTrue(new File(jsDir, \"stringbuilder.js\").isFile());\n}", "methodAfter": "public static void testCopy() throws IOException {\n    CopyFiles.copy(tmpDir);\n    assertTrue(new File(tmpDir, \"help.html\").isFile());\n    assertTrue(new File(tmpDir, \"index.html\").isFile());\n    File cssDir = new File(tmpDir, \"css\");\n    assertTrue(cssDir.isDirectory());\n    assertTrue(new File(cssDir, \"help.css\").isFile());\n    assertTrue(new File(cssDir, \"main.css\").isFile());\n    assertTrue(new File(cssDir, \"sortabletable.css\").isFile());\n    assertTrue(new File(cssDir, \"source-viewer.css\").isFile());\n    assertTrue(new File(cssDir, \"tooltip.css\").isFile());\n    File imagesDir = new File(tmpDir, \"images\");\n    assertTrue(imagesDir.isDirectory());\n    assertTrue(new File(imagesDir, \"blank.png\").isFile());\n    assertTrue(new File(imagesDir, \"downsimple.png\").isFile());\n    assertTrue(new File(imagesDir, \"upsimple.png\").isFile());\n    File jsDir = new File(tmpDir, \"js\");\n    assertTrue(jsDir.isDirectory());\n    assertTrue(new File(jsDir, \"customsorttypes.js\").isFile());\n    assertTrue(new File(jsDir, \"popup.js\").isFile());\n    assertTrue(new File(jsDir, \"sortabletable.js\").isFile());\n    assertTrue(new File(jsDir, \"stringbuilder.js\").isFile());\n}"}], [{"methodBefore": "public MergeTask() {\n    super(\"net.sourceforge.cobertura.merge.Main\");\n}", "methodAfter": "public MergeTask() {\n    super(Main.class.getCanonicalName());\n}"}, {"methodBefore": "public CheckTask() {\n    super(\"net.sourceforge.cobertura.check.Main\");\n}", "methodAfter": "public CheckTask() {\n    super(Main.class.getCanonicalName());\n}"}], [{"methodBefore": "private final boolean jj_3_3() {\n    if (jj_3R_81()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_3() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3_4() {\n    if (jj_3R_81()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_4() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Exception {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                ClassReader cr = new ClassReader(entryBytes);\n                ClassWriter cw = new ClassWriter(true);\n                ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes);\n                cr.accept(cv, false);\n                if (cv.isInstrumented()) {\n                    logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                    entryBytes = cw.toByteArray();\n                    modified = true;\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry);\n            throw e;\n        }\n        output.flush();\n    } \n    return modified;\n}", "methodAfter": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Exception {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                ClassReader cr = new ClassReader(entryBytes);\n                ClassWriter cw = new ClassWriter(true);\n                ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n                cr.accept(cv, false);\n                if (cv.isInstrumented()) {\n                    logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                    entryBytes = cw.toByteArray();\n                    modified = true;\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry);\n            throw e;\n        }\n        output.flush();\n    } \n    return modified;\n}"}, {"methodBefore": "private void addInstrumentationToSingleClass(File file) {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(true);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegexes);\n        cr.accept(cv, false);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        inputStream = IOUtil.closeInputStream(inputStream);\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        outputStream = IOUtil.closeOutputStream(outputStream);\n    }\n}", "methodAfter": "private void addInstrumentationToSingleClass(File file) {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(true);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n        cr.accept(cv, false);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        inputStream = IOUtil.closeInputStream(inputStream);\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        outputStream = IOUtil.closeOutputStream(outputStream);\n    }\n}"}], [{"methodBefore": "public ReportTask() {\n    super(\"net.sourceforge.cobertura.reporting.Main\");\n}", "methodAfter": "public ReportTask() {\n    super(Main.class.getCanonicalName());\n}"}, {"methodBefore": "public MergeTask() {\n    super(\"net.sourceforge.cobertura.merge.Main\");\n}", "methodAfter": "public MergeTask() {\n    super(Main.class.getCanonicalName());\n}"}, {"methodBefore": "public InstrumentTask() {\n    super(\"net.sourceforge.cobertura.instrument.Main\");\n}", "methodAfter": "public InstrumentTask() {\n    super(Main.class.getCanonicalName());\n}"}, {"methodBefore": "public CheckTask() {\n    super(\"net.sourceforge.cobertura.check.Main\");\n}", "methodAfter": "public CheckTask() {\n    super(Main.class.getCanonicalName());\n}"}], [{"methodBefore": "private final boolean jj_3R_135() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_135() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_86() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_86() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void parseArguments(String[] args) {\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-d\")) {\n            destinationDirectory = new File(args[++i]);\n        } else if (args[i].equals(\"-basedir\")) {\n            baseDir = new File(args[++i]);\n        } else if (args[i].equals(\"-ignore\")) {\n            ignoreRegex = args[++i];\n        } else {\n            addInstrumentation(args[i]);\n        }\n    }\n}", "methodAfter": "private void parseArguments(String[] args) {\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-d\")) {\n            destinationDirectory = new File(args[++i]);\n        } else if (args[i].equals(\"-basedir\")) {\n            baseDir = new File(args[++i]);\n        } else if (args[i].equals(\"-ignore\")) {\n            String regex = args[++i];\n            try {\n                Perl5Compiler pc = new Perl5Compiler();\n                this.ignoreRegexp = pc.compile(regex);\n            } catch (MalformedPatternException e) {\n                logger.warn(((\"The regular expression \" + regex) + \" is invalid: \") + e.getLocalizedMessage());\n            }\n        } else {\n            addInstrumentation(args[i]);\n        }\n    }\n}"}, {"methodBefore": "private void parseArguments(String[] args) {\n    Collection locations = new Vector();\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--basedir\")) {\n            baseDir = new File(args[++i]);\n        } else if (args[i].equals(\"--datafile\")) {\n            CoverageDataFileHandler.setDefaultDataFile(args[++i]);\n        } else if (args[i].equals(\"--destination\")) {\n            destinationDirectory = new File(args[++i]);\n        } else if (args[i].equals(\"--ignore\")) {\n            String regex = args[++i];\n            this.ignoreRegexp = Pattern.compile(regex);\n        } else {\n            locations.add(args[i]);\n        }\n    }\n    projectData = ProjectData.getGlobalProjectData();\n    Iterator iter = locations.iterator();\n    while (iter.hasNext()) {\n        addInstrumentation(((String) (iter.next())));\n    } \n    ProjectData.saveGlobalProjectData();\n}", "methodAfter": "private void parseArguments(String[] args) {\n    Collection locations = new Vector();\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--basedir\")) {\n            baseDir = new File(args[++i]);\n        } else if (args[i].equals(\"--datafile\")) {\n            CoverageDataFileHandler.setDefaultDataFile(args[++i]);\n        } else if (args[i].equals(\"--destination\")) {\n            destinationDirectory = new File(args[++i]);\n        } else if (args[i].equals(\"--ignore\")) {\n            String regex = args[++i];\n            try {\n                Perl5Compiler pc = new Perl5Compiler();\n                this.ignoreRegexp = pc.compile(regex);\n            } catch (MalformedPatternException e) {\n                logger.warn(((\"The regular expression \" + regex) + \" is invalid: \") + e.getLocalizedMessage());\n            }\n        } else {\n            locations.add(args[i]);\n        }\n    }\n    projectData = ProjectData.getGlobalProjectData();\n    Iterator iter = locations.iterator();\n    while (iter.hasNext()) {\n        addInstrumentation(((String) (iter.next())));\n    } \n    ProjectData.saveGlobalProjectData();\n}"}], [{"methodBefore": "private void instrumentInvokeTouchSwitch() {\n    mv.visitMethodInsn(INVOKEVIRTUAL, \"net/sourceforge/cobertura/coveragedata/ClassData\", \"touchSwitch\", \"(III)V\");\n}", "methodAfter": "private void instrumentInvokeTouchSwitch() {\n    mv.visitMethodInsn(INVOKESTATIC, TOUCH_COLLECTOR_CLASS, \"touchSwitch\", \"(Ljava/lang/String;III)V\");\n}"}, {"methodBefore": "private void instrumentInvokeTouchJump() {\n    mv.visitMethodInsn(INVOKEVIRTUAL, \"net/sourceforge/cobertura/coveragedata/ClassData\", \"touchJump\", \"(IIZ)V\");\n    mv.visitIntInsn(SIPUSH, -1);\n    mv.visitVarInsn(ISTORE, myVariableIndex + 1);\n}", "methodAfter": "private void instrumentInvokeTouchJump() {\n    mv.visitMethodInsn(INVOKESTATIC, TOUCH_COLLECTOR_CLASS, \"touchJump\", \"(Ljava/lang/String;IIZ)V\");\n    mv.visitIntInsn(SIPUSH, -1);\n    mv.visitVarInsn(ISTORE, myVariableIndex + 1);\n}"}, {"methodBefore": "public void visitLineNumber(int line, Label start) {\n    currentLine = line;\n    currentJump = 0;\n    instrumentGetClassData();\n    mv.visitIntInsn(SIPUSH, line);\n    mv.visitMethodInsn(INVOKEVIRTUAL, \"net/sourceforge/cobertura/coveragedata/ClassData\", \"touch\", \"(I)V\");\n    super.visitLineNumber(line, start);\n}", "methodAfter": "public void visitLineNumber(int line, Label start) {\n    currentLine = line;\n    currentJump = 0;\n    instrumentGetClassData();\n    mv.visitIntInsn(SIPUSH, line);\n    mv.visitMethodInsn(INVOKESTATIC, TOUCH_COLLECTOR_CLASS, \"touch\", \"(Ljava/lang/String;I)V\");\n    super.visitLineNumber(line, start);\n}"}], [{"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        for (Iterator<LineData> i = branches.values().iterator(); i.hasNext(); number += i.next().getNumberOfValidBranches());\n        return number;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        for (Iterator<LineData> i = branches.values().iterator(); i.hasNext(); number += ((LineData) (i.next())).getNumberOfValidBranches());\n        return number;\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        for (Iterator<LineData> i = branches.values().iterator(); i.hasNext(); number += i.next().getNumberOfCoveredBranches());\n        return number;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        for (Iterator<LineData> i = branches.values().iterator(); i.hasNext(); number += ((LineData) (i.next())).getNumberOfCoveredBranches());\n        return number;\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "public final void UnmodifiedClassDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += new String(getToken(2).image);\n    _classLevel++;\n    Modifiers();\n    jj_consume_token(CLASS);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[19] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            Name();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case LT :\n                    TypeArguments();\n                    break;\n                default :\n                    jj_la1[20] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[21] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            jj_consume_token(IMPLEMENTS);\n            NameList();\n            break;\n        default :\n            jj_la1[22] = jj_gen;\n    }\n    ClassBody();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        Vector vMetrics = new Vector();\n        vMetrics.addElement(new String(_sPackage + _sClass));\n        vMetrics.addElement(new Integer(_ncss - oldNcss));\n        vMetrics.addElement(new Integer(_functions - oldFunctions));\n        vMetrics.addElement(new Integer(_classes - oldClasses));\n        Token lastToken = getToken(0);\n        vMetrics.addElement(new Integer(lastToken.endLine));\n        vMetrics.addElement(new Integer(lastToken.endColumn));\n        _vClasses.addElement(vMetrics);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}", "methodAfter": "public final void UnmodifiedClassDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(2).image;\n    _classLevel++;\n    Modifiers();\n    jj_consume_token(CLASS);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[19] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            Name();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case LT :\n                    TypeArguments();\n                    break;\n                default :\n                    jj_la1[20] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[21] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            jj_consume_token(IMPLEMENTS);\n            NameList();\n            break;\n        default :\n            jj_la1[22] = jj_gen;\n    }\n    ClassBody();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        ObjectMetric metric = new ObjectMetric();\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}"}, {"methodBefore": "public final void UnmodifiedInterfaceDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += new String(getToken(2).image);\n    _classLevel++;\n    jj_consume_token(INTERFACE);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[40] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            NameList();\n            break;\n        default :\n            jj_la1[41] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    label_22 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n            case LT :\n                break;\n            default :\n                jj_la1[42] = jj_gen;\n                break label_22;\n        }\n        InterfaceMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        Vector vMetrics = new Vector();\n        vMetrics.addElement(new String(_sPackage + _sClass));\n        vMetrics.addElement(new Integer(_ncss - oldNcss));\n        vMetrics.addElement(new Integer(_functions - oldFunctions));\n        vMetrics.addElement(new Integer(_classes - oldClasses));\n        vMetrics.addElement(Util.getConstantObject());\n        vMetrics.addElement(Util.getConstantObject());\n        _vClasses.addElement(vMetrics);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}", "methodAfter": "public final void UnmodifiedInterfaceDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(2).image;\n    _classLevel++;\n    jj_consume_token(INTERFACE);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[40] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            NameList();\n            break;\n        default :\n            jj_la1[41] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    label_22 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n            case LT :\n                break;\n            default :\n                jj_la1[42] = jj_gen;\n                break label_22;\n        }\n        InterfaceMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        ObjectMetric metric = new ObjectMetric();\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}"}], [{"methodBefore": "private final boolean jj_3_38() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_30() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3_27() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_41() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "String getMethodName() {\n    return methodName;\n}", "methodAfter": "public String getMethodName() {\n    return methodName;\n}"}, {"methodBefore": "String getMethodDescriptor() {\n    return methodDescriptor;\n}", "methodAfter": "public String getMethodDescriptor() {\n    return methodDescriptor;\n}"}], [{"methodBefore": "private final boolean jj_3R_153() {\n    if (jj_3R_177()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_385() {\n    if (jj_3R_407()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_217() {\n    if (jj_3R_132()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_324() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_194() {\n    if (jj_3R_205()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_145() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_293() {\n    if (jj_3R_326()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_246() {\n    if (jj_3R_266()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_79() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_436() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_381() {\n    if (jj_3R_387()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_453() {\n    if (jj_3R_454()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_384() {\n    if (jj_3R_399()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_299() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_368() {\n    if (jj_3R_260()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_245() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_231() {\n    if (jj_3R_249()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_210() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_289() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_287() {\n    if (jj_3R_290()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_369() {\n    if (jj_3R_261()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_249() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_301() {\n    if (jj_3R_132()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_201() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_111() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_98() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_394() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_398() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_292() {\n    if (jj_3R_326()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_247() {\n    if (jj_3R_267()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_128() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_334() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_139() {\n    if (jj_3R_166()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_396() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_173() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_178() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_266() {\n    if (jj_3R_275()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_256() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_303() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_381() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_97() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_91() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public double getBranchCoverageRate() {\n    if (getNumberOfValidBranches() == 0) {\n        return 1.0;\n    }\n    lock.lock();\n    try {\n        return ((double) (getNumberOfCoveredBranches())) / getNumberOfValidBranches();\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized double getBranchCoverageRate() {\n    if (getNumberOfValidBranches() == 0) {\n        return 1.0;\n    }\n    try {\n        return ((double) (getNumberOfCoveredBranches())) / getNumberOfValidBranches();\n    } finally {\n    }\n}"}, {"methodBefore": "public Object getConditionData(int index) {\n    Object branchData = null;\n    lock.lock();\n    try {\n        int jumpsSize = (jumps == null) ? 0 : jumps.size();\n        int switchesSize = (switches == null) ? 0 : switches.size();\n        if (index < jumpsSize) {\n            branchData = jumps.get(index);\n        } else if (index < (jumpsSize + switchesSize)) {\n            branchData = switches.get(index - jumpsSize);\n        }\n        return branchData;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized Object getConditionData(int index) {\n    Object branchData = null;\n    try {\n        int jumpsSize = (jumps == null) ? 0 : jumps.size();\n        int switchesSize = (switches == null) ? 0 : switches.size();\n        if (index < jumpsSize) {\n            branchData = jumps.get(index);\n        } else if (index < (jumpsSize + switchesSize)) {\n            branchData = switches.get(index - jumpsSize);\n        }\n        return branchData;\n    } finally {\n    }\n}"}, {"methodBefore": "public int getNumberOfValidBranches() {\n    int ret = 0;\n    lock.lock();\n    try {\n        if (jumps != null) {\n            for (int i = jumps.size() - 1; i >= 0; i--) {\n                ret += ((JumpData) (jumps.get(i))).getNumberOfValidBranches();\n            }\n        }\n        if (switches != null) {\n            for (int i = switches.size() - 1; i >= 0; i--) {\n                ret += ((SwitchData) (switches.get(i))).getNumberOfValidBranches();\n            }\n        }\n        return ret;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized int getNumberOfValidBranches() {\n    int ret = 0;\n    try {\n        if (jumps != null) {\n            for (int i = jumps.size() - 1; i >= 0; i--) {\n                ret += ((JumpData) (jumps.get(i))).getNumberOfValidBranches();\n            }\n        }\n        if (switches != null) {\n            for (int i = switches.size() - 1; i >= 0; i--) {\n                ret += ((SwitchData) (switches.get(i))).getNumberOfValidBranches();\n            }\n        }\n        return ret;\n    } finally {\n    }\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int ret = 0;\n    lock.lock();\n    try {\n        if (jumps != null) {\n            for (int i = jumps.size() - 1; i >= 0; i--) {\n                ret += ((JumpData) (jumps.get(i))).getNumberOfCoveredBranches();\n            }\n        }\n        if (switches != null) {\n            for (int i = switches.size() - 1; i >= 0; i--) {\n                ret += ((SwitchData) (switches.get(i))).getNumberOfCoveredBranches();\n            }\n        }\n        return ret;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized int getNumberOfCoveredBranches() {\n    int ret = 0;\n    try {\n        if (jumps != null) {\n            for (int i = jumps.size() - 1; i >= 0; i--) {\n                ret += ((JumpData) (jumps.get(i))).getNumberOfCoveredBranches();\n            }\n        }\n        if (switches != null) {\n            for (int i = switches.size() - 1; i >= 0; i--) {\n                ret += ((SwitchData) (switches.get(i))).getNumberOfCoveredBranches();\n            }\n        }\n        return ret;\n    } finally {\n    }\n}"}, {"methodBefore": "public String getConditionCoverage() {\n    StringBuffer ret = new StringBuffer();\n    if (getNumberOfValidBranches() == 0) {\n        ret.append(StringUtil.getPercentValue(1.0));\n    } else {\n        lock.lock();\n        try {\n            ret.append(StringUtil.getPercentValue(getBranchCoverageRate()));\n            ret.append(\" (\").append(getNumberOfCoveredBranches()).append(\"/\").append(getNumberOfValidBranches()).append(\")\");\n        } finally {\n            lock.unlock();\n        }\n    }\n    return ret.toString();\n}", "methodAfter": "public synchronized String getConditionCoverage() {\n    StringBuffer ret = new StringBuffer();\n    if (getNumberOfValidBranches() == 0) {\n        ret.append(StringUtil.getPercentValue(1.0));\n    } else {\n        try {\n            ret.append(StringUtil.getPercentValue(getBranchCoverageRate()));\n            ret.append(\" (\").append(getNumberOfCoveredBranches()).append(\"/\").append(getNumberOfValidBranches()).append(\")\");\n        } finally {\n        }\n    }\n    return ret.toString();\n}"}, {"methodBefore": "public int getConditionSize() {\n    lock.lock();\n    try {\n        return (jumps == null ? 0 : jumps.size()) + (switches == null ? 0 : switches.size());\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized int getConditionSize() {\n    try {\n        return (jumps == null ? 0 : jumps.size()) + (switches == null ? 0 : switches.size());\n    } finally {\n    }\n}"}, {"methodBefore": "public boolean isCovered() {\n    lock.lock();\n    try {\n        return (getHits() > 0) && ((getNumberOfValidBranches() == 0) || ((1.0 - getBranchCoverageRate()) < 1.0E-4));\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized boolean isCovered() {\n    try {\n        return (getHits() > 0) && ((getNumberOfValidBranches() == 0) || ((1.0 - getBranchCoverageRate()) < 1.0E-4));\n    } finally {\n    }\n}"}, {"methodBefore": "public boolean hasBranch() {\n    lock.lock();\n    try {\n        return (jumps != null) || (switches != null);\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized boolean hasBranch() {\n    try {\n        return (jumps != null) || (switches != null);\n    } finally {\n    }\n}"}, {"methodBefore": "public long getHits() {\n    lock.lock();\n    try {\n        return hits;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized long getHits() {\n    try {\n        return hits;\n    } finally {\n    }\n}"}], [{"methodBefore": "public boolean isValidSourceLineNumber(int lineNumber) {\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        ClassData classData = ((ClassData) (iter.next()));\n        if (classData.isValidSourceLineNumber(lineNumber)) {\n            return true;\n        }\n    } \n    return false;\n}", "methodAfter": "public boolean isValidSourceLineNumber(int lineNumber) {\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            if (classData.isValidSourceLineNumber(lineNumber)) {\n                return true;\n            }\n        } \n    } finally {\n        lock.unlock();\n    }\n    return false;\n}"}, {"methodBefore": "public LineData getLineCoverage(int lineNumber) {\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        ClassData classData = ((ClassData) (iter.next()));\n        if (classData.isValidSourceLineNumber(lineNumber)) {\n            return classData.getLineCoverage(lineNumber);\n        }\n    } \n    return null;\n}", "methodAfter": "public LineData getLineCoverage(int lineNumber) {\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            if (classData.isValidSourceLineNumber(lineNumber)) {\n                return classData.getLineCoverage(lineNumber);\n            }\n        } \n    } finally {\n        lock.unlock();\n    }\n    return null;\n}"}], [{"methodBefore": "private void dumpPackage(PackageData packageData) {\n    logger.debug(\"Dumping package \" + packageData.getName());\n    println(((((((\"<package name=\\\"\" + packageData.getName()) + \"\\\" line-rate=\\\"\") + packageData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + packageData.getBranchCoverageRate()) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpClasses(packageData);\n    decreaseIndentation();\n    println(\"</package>\");\n}", "methodAfter": "private void dumpPackage(PackageData packageData) {\n    logger.debug(\"Dumping package \" + packageData.getName());\n    double ccn = Util.getCCN(new File(sourceDirectory, packageData.getSourceFileName()), false);\n    println(((((((((\"<package name=\\\"\" + packageData.getName()) + \"\\\" line-rate=\\\"\") + packageData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + packageData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpClasses(packageData);\n    decreaseIndentation();\n    println(\"</package>\");\n}"}, {"methodBefore": "private void dumpClass(ClassData classData) {\n    logger.debug(\"Dumping class \" + classData.getName());\n    println(((((((((\"<class name=\\\"\" + classData.getName()) + \"\\\" filename=\\\"\") + classData.getSourceFileName()) + \"\\\" line-rate=\\\"\") + classData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + classData.getBranchCoverageRate()) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpMethods(classData);\n    dumpLines(classData);\n    decreaseIndentation();\n    println(\"</class>\");\n}", "methodAfter": "private void dumpClass(ClassData classData) {\n    logger.debug(\"Dumping class \" + classData.getName());\n    double ccn = Util.getCCN(new File(sourceDirectory, classData.getSourceFileName()), false);\n    println(((((((((((\"<class name=\\\"\" + classData.getName()) + \"\\\" filename=\\\"\") + classData.getSourceFileName()) + \"\\\" line-rate=\\\"\") + classData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + classData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpMethods(classData);\n    dumpLines(classData);\n    decreaseIndentation();\n    println(\"</class>\");\n}"}], [{"methodBefore": "public InstrumentTask() {\n    super(\"net.sourceforge.cobertura.instrument.Main\");\n}", "methodAfter": "public InstrumentTask() {\n    super(Main.class.getCanonicalName());\n}"}, {"methodBefore": "public MergeTask() {\n    super(\"net.sourceforge.cobertura.merge.Main\");\n}", "methodAfter": "public MergeTask() {\n    super(Main.class.getCanonicalName());\n}"}], [{"methodBefore": "public static void main(String[] args) {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufferedReader = null;\n        try {\n            bufferedReader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufferedReader != null) {\n                try {\n                    bufferedReader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Instrument time: \" + (stopTime - startTime)) + \"ms\");\n}", "methodAfter": "public static void main(String[] args) {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Instrument time: \" + (stopTime - startTime)) + \"ms\");\n}"}, {"methodBefore": "public static void main(String[] args) {\n    Header.print(System.out);\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufreader = null;\n        try {\n            bufreader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufreader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufreader != null) {\n                try {\n                    bufreader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    new Main(args);\n}", "methodAfter": "public static void main(String[] args) {\n    Header.print(System.out);\n    args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    new Main(args);\n}"}], [{"methodBefore": "private final boolean jj_3R_83() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_388() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_273() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_319() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}, {"methodBefore": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    lock.lock();\n    try {\n        Iterator iter = children.values().iterator();\n        while (iter.hasNext()) {\n            LineData next = ((LineData) (iter.next()));\n            if (methodNameAndDescriptor.equals(next.getMethodName() + next.getMethodDescriptor())) {\n                total++;\n                if (next.getHits() > 0) {\n                    hits++;\n                }\n            }\n        } \n        if (total == 0) {\n            return 1.0;\n        }\n        return ((double) (hits)) / total;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = children.values().iterator();\n        while (iter.hasNext()) {\n            LineData next = ((LineData) (iter.next()));\n            if (methodNameAndDescriptor.equals(next.getMethodName() + next.getMethodDescriptor())) {\n                total++;\n                if (next.getHits() > 0) {\n                    hits++;\n                }\n            }\n        } \n        if (total == 0) {\n            return 1.0;\n        }\n        return ((double) (hits)) / total;\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}], [{"methodBefore": "private boolean jj_3R_427() {\n    if (jj_3R_429()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_427() {\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_399() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_399() {\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_399() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_399() {\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_427() {\n    if (jj_3R_429()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_427() {\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfCoveredBranches();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfCoveredLines();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}], [{"methodBefore": "private String generateTableRowForPackage(PackageData packageData) {\n    StringBuffer ret = new StringBuffer();\n    String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n    double lineCoverage = -1;\n    double branchCoverage = -1;\n    double ccn = complexity.getCCNForPackage(packageData);\n    if (packageData.getNumberOfValidLines() > 0) {\n        lineCoverage = packageData.getLineCoverageRate();\n    }\n    if (packageData.getNumberOfValidBranches() > 0) {\n        branchCoverage = packageData.getBranchCoverageRate();\n    }\n    ret.append(\"  <tr>\");\n    ret.append((((((\"<td class=\\\"text\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\'>\") + generatePackageName(packageData)) + \"</a></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + packageData.getNumberOfChildren()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(lineCoverage, packageData.getNumberOfValidLines(), branchCoverage, packageData.getNumberOfValidBranches(), ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}", "methodAfter": "private String generateTableRowForPackage(PackageData packageData) {\n    StringBuffer ret = new StringBuffer();\n    String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n    double ccn = complexity.getCCNForPackage(packageData);\n    ret.append(\"  <tr>\");\n    ret.append((((((\"<td><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\'>\") + generatePackageName(packageData)) + \"</a></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + packageData.getNumberOfChildren()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(packageData, ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}"}, {"methodBefore": "private String generateTableRowForClass(ClassData classData, String sourceFileName, double ccn) {\n    StringBuffer ret = new StringBuffer();\n    double lineCoverage = -1;\n    double branchCoverage = -1;\n    if (classData.getNumberOfValidLines() > 0) {\n        lineCoverage = classData.getLineCoverageRate();\n    }\n    if (classData.getNumberOfValidBranches() > 0) {\n        branchCoverage = classData.getBranchCoverageRate();\n    }\n    ret.append(\"  <tr>\");\n    ret.append((((\"<td class=\\\"text\\\"><a href=\\\"\" + sourceFileName) + \".html\\\">\") + classData.getBaseName()) + \"</a></td>\");\n    ret.append(generateTableColumnsFromData(lineCoverage, classData.getNumberOfValidLines(), branchCoverage, classData.getNumberOfValidBranches(), ccn));\n    ret.append(\"</tr>\\n\");\n    return ret.toString();\n}", "methodAfter": "private String generateTableRowForClass(ClassData classData, String sourceFileName, double ccn) {\n    StringBuffer ret = new StringBuffer();\n    ret.append(\"  <tr>\");\n    ret.append((((\"<td><a href=\\\"\" + sourceFileName) + \".html\\\">\") + classData.getBaseName()) + \"</a></td>\");\n    ret.append(generateTableColumnsFromData(classData, ccn));\n    ret.append(\"</tr>\\n\");\n    return ret.toString();\n}"}], [{"methodBefore": "private final boolean jj_3R_387() {\n    if (jj_3R_279()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_387() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_386()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_160() {\n    if (jj_3R_180()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_160() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_378() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_378() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_100()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void addInstrumentationToSingleClass(File file) throws Throwable {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n        cr.accept(cv, 0);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        inputStream = IOUtil.closeInputStream(inputStream);\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        outputStream = IOUtil.closeOutputStream(outputStream);\n    }\n}", "methodAfter": "private void addInstrumentationToSingleClass(File file) throws Throwable {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes, ignoreTrivial);\n        cr.accept(cv, 0);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        inputStream = IOUtil.closeInputStream(inputStream);\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        outputStream = IOUtil.closeOutputStream(outputStream);\n    }\n}"}, {"methodBefore": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Throwable {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n                    cr.accept(cv, 0);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}", "methodAfter": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Throwable {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes, ignoreTrivial);\n                    cr.accept(cv, 0);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}"}], [{"methodBefore": "double inRangeAndDivideByOneHundred(int coverageRateAsPercentage) {\n    if ((coverageRateAsPercentage >= 0) && (coverageRateAsPercentage <= 100)) {\n        return ((double) (coverageRateAsPercentage)) / 100;\n    }\n    throw new IllegalArgumentException((\"The value \" + coverageRateAsPercentage) + \"% is invalid.  Percentages must be between 0 and 100.\");\n}", "methodAfter": "private double inRangeAndDivideByOneHundred(int coverageRateAsPercentage) {\n    if ((coverageRateAsPercentage >= 0) && (coverageRateAsPercentage <= 100)) {\n        return ((double) (coverageRateAsPercentage)) / 100;\n    }\n    throw new IllegalArgumentException((\"The value \" + coverageRateAsPercentage) + \"% is invalid.  Percentages must be between 0 and 100.\");\n}"}, {"methodBefore": "double inRangeAndDivideByOneHundred(String coverageRateAsPercentage) {\n    return inRangeAndDivideByOneHundred(Integer.valueOf(coverageRateAsPercentage).intValue());\n}", "methodAfter": "private double inRangeAndDivideByOneHundred(String coverageRateAsPercentage) {\n    return inRangeAndDivideByOneHundred(Integer.valueOf(coverageRateAsPercentage).intValue());\n}"}], [{"methodBefore": "private final boolean jj_3R_228() {\n    if (jj_3R_246()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_197() {\n    if (jj_3R_212()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_226() {\n    if (jj_3R_244()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_426() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public long getFalseHits() {\n    return this.falseHits;\n}", "methodAfter": "public long getFalseHits() {\n    lock.lock();\n    try {\n        return this.falseHits;\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public long getTrueHits() {\n    return this.trueHits;\n}", "methodAfter": "public long getTrueHits() {\n    lock.lock();\n    try {\n        return this.trueHits;\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_117() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_127() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_116() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_126() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_153() {\n    if (jj_3R_177()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_385() {\n    if (jj_3R_407()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_146() {\n    if (jj_3R_101()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_144() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_277() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_203() {\n    if (jj_3R_216()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_301() {\n    if (jj_3R_132()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_201() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_343() {\n    if (jj_3R_127()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_329() {\n    if (jj_3R_364()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_173() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_178() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_394() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_398() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_387() {\n    if (jj_3R_279()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_387() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_386()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_421() {\n    if (jj_3R_200()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_421() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_341()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfValidLines();\n        numberCovered += coverageContainer.getNumberOfCoveredLines();\n    } \n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}, {"methodBefore": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfValidBranches();\n        numberCovered += coverageContainer.getNumberOfCoveredBranches();\n    } \n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}], [{"methodBefore": "private final boolean jj_3R_277() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_203() {\n    if (jj_3R_216()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_303() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_381() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_79() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_436() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_146() {\n    if (jj_3R_101()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_144() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_137() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_113() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_343() {\n    if (jj_3R_127()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_329() {\n    if (jj_3R_364()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_140() {\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_104() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public Vector getFunctions() {\n    return _vFunctionMetrics;\n}", "methodAfter": "public List getFunctions() {\n    return _vFunctionMetrics;\n}"}, {"methodBefore": "public Vector getObjectMetrics() {\n    return _vObjectMetrics;\n}", "methodAfter": "public List getObjectMetrics() {\n    return _vObjectMetrics;\n}"}, {"methodBefore": "public Vector getImports() {\n    return _vImports;\n}", "methodAfter": "public List getImports() {\n    return _vImports;\n}"}, {"methodBefore": "public Vector getFunctionMetrics() {\n    return _vFunctionMetrics;\n}", "methodAfter": "public List getFunctionMetrics() {\n    return _vFunctionMetrics;\n}"}, {"methodBefore": "public Vector getPackageMetrics() {\n    return _vPackageMetrics;\n}", "methodAfter": "public List getPackageMetrics() {\n    return _vPackageMetrics;\n}"}], [{"methodBefore": "private final boolean jj_3R_155() {\n    if (jj_3R_178()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_451() {\n    if (jj_3R_454()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_381() {\n    if (jj_3R_387()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_453() {\n    if (jj_3R_454()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_277() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_203() {\n    if (jj_3R_216()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_280() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_331() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_331() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_369() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_119() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_129() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_394() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_398() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_97() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_91() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_194() {\n    if (jj_3R_205()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_145() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_111() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_98() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_173() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_178() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_62 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[163] = jj_gen;\n                break label_62;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}", "methodAfter": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}"}, {"methodBefore": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_62 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[156] = jj_gen;\n                break label_62;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}"}, {"methodBefore": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_62 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[163] = jj_gen;\n                break label_62;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}", "methodAfter": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}"}], [{"methodBefore": "public double getLineCoverageRate(String methodNameAndSignature) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = lines.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndSignature)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}", "methodAfter": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = lines.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndDescriptor)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}"}, {"methodBefore": "public double getBranchCoverageRate(String methodNameAndSignature) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = conditionals.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndSignature)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}", "methodAfter": "public double getBranchCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = conditionals.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndDescriptor)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}"}], [{"methodBefore": "@Test\npublic void testGetMinBranchPercentage() throws Exception {\n    assertEquals(MIN_BRANCH_PERCENTAGE, coverageThreshold.getMinBranchPercentage());\n}", "methodAfter": "@Test\npublic void testGetMinBranchPercentage() throws Exception {\n    assertEquals(MIN_BRANCH_PERCENTAGE, coverageThreshold.getMinBranchPercentage(), DELTA);\n}"}, {"methodBefore": "@Test\npublic void testGetMinLinePercentage() throws Exception {\n    assertEquals(MIN_LINE_PERCENTAGE, coverageThreshold.getMinLinePercentage());\n}", "methodAfter": "@Test\npublic void testGetMinLinePercentage() throws Exception {\n    assertEquals(MIN_LINE_PERCENTAGE, coverageThreshold.getMinLinePercentage(), DELTA);\n}"}], [{"methodBefore": "SwitchData getSwitchData(int switchNumber, SwitchData data) {\n    lock.lock();\n    try {\n        if (switches == null) {\n            switches = new ArrayList();\n        }\n        if (switches.size() < switchNumber) {\n            for (int i = switches.size(); i < switchNumber; switches.add(new SwitchData(i++)));\n        }\n        if (switches.size() == switchNumber) {\n            if (data != null) {\n                switches.add(data);\n            } else {\n                switches.add(new SwitchData(switchNumber));\n            }\n        }\n        return ((SwitchData) (switches.get(switchNumber)));\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "synchronized SwitchData getSwitchData(int switchNumber, SwitchData data) {\n    try {\n        if (switches == null) {\n            switches = new ArrayList();\n        }\n        if (switches.size() < switchNumber) {\n            for (int i = switches.size(); i < switchNumber; switches.add(new SwitchData(i++)));\n        }\n        if (switches.size() == switchNumber) {\n            if (data != null) {\n                switches.add(data);\n            } else {\n                switches.add(new SwitchData(switchNumber));\n            }\n        }\n        return ((SwitchData) (switches.get(switchNumber)));\n    } finally {\n    }\n}"}, {"methodBefore": "void setMethodNameAndDescriptor(String name, String descriptor) {\n    lock.lock();\n    try {\n        this.methodName = name;\n        this.methodDescriptor = descriptor;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "synchronized void setMethodNameAndDescriptor(String name, String descriptor) {\n    try {\n        this.methodName = name;\n        this.methodDescriptor = descriptor;\n    } finally {\n    }\n}"}], [{"methodBefore": "private static void touchIteratively(SwitchData data, int num) {\n    for (int i = 0; i < 2000; i++) {\n        Thread.yield();\n        data.touchBranch(i);\n    }\n}", "methodAfter": "private static void touchIteratively(SwitchData data, int num) {\n    for (int i = 0; i < 2000; i++) {\n        Thread.yield();\n        data.touchBranch(i, 1);\n    }\n}"}, {"methodBefore": "public void testXMLReportWithNonSourceLines() throws Exception {\n    ProjectData projectData = new ProjectData();\n    ClassData cd = projectData.getOrCreateClassData(XMLReport.class.getName());\n    cd.touch(7777);\n    File reportDir = File.createTempFile(\"XMLReportTest\", \"\");\n    reportDir.delete();\n    reportDir.mkdir();\n    FileFinder fileFinder = new FileFinder();\n    ComplexityCalculator complexity = new ComplexityCalculator(fileFinder);\n    new XMLReport(projectData, reportDir, fileFinder, complexity);\n    File coverageFile = new File(reportDir, \"coverage.xml\");\n    JUnitXMLHelper.readXmlFile(coverageFile, true);\n    coverageFile.delete();\n    reportDir.delete();\n}", "methodAfter": "public void testXMLReportWithNonSourceLines() throws Exception {\n    ProjectData projectData = new ProjectData();\n    ClassData cd = projectData.getOrCreateClassData(XMLReport.class.getName());\n    cd.touch(7777, 1);\n    File reportDir = File.createTempFile(\"XMLReportTest\", \"\");\n    reportDir.delete();\n    reportDir.mkdir();\n    FileFinder fileFinder = new FileFinder();\n    ComplexityCalculator complexity = new ComplexityCalculator(fileFinder);\n    new XMLReport(projectData, reportDir, fileFinder, complexity);\n    File coverageFile = new File(reportDir, \"coverage.xml\");\n    JUnitXMLHelper.readXmlFile(coverageFile, true);\n    coverageFile.delete();\n    reportDir.delete();\n}"}], [{"methodBefore": "private final boolean jj_3R_377() {\n    if (jj_3R_385()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_89() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_289() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_287() {\n    if (jj_3R_290()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_208() {\n    if (jj_3R_206()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_204() {\n    if (jj_3R_217()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void dumpPackage(PackageData packageData) {\n    logger.debug(\"Dumping package \" + packageData.getName());\n    println(((((((\"<package name=\\\"\" + packageData.getName()) + \"\\\" line-rate=\\\"\") + packageData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + packageData.getBranchCoverageRate()) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpClasses(packageData);\n    decreaseIndentation();\n    println(\"</package>\");\n}", "methodAfter": "private void dumpPackage(PackageData packageData) {\n    logger.debug(\"Dumping package \" + packageData.getName());\n    double ccn = Util.getCCN(new File(sourceDirectory, packageData.getSourceFileName()), false);\n    println(((((((((\"<package name=\\\"\" + packageData.getName()) + \"\\\" line-rate=\\\"\") + packageData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + packageData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpClasses(packageData);\n    decreaseIndentation();\n    println(\"</package>\");\n}"}, {"methodBefore": "private void dumpClass(ClassData classData) {\n    logger.debug(\"Dumping class \" + classData.getName());\n    println(((((((((\"<class name=\\\"\" + classData.getName()) + \"\\\" filename=\\\"\") + classData.getSourceFileName()) + \"\\\" line-rate=\\\"\") + classData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + classData.getBranchCoverageRate()) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpMethods(classData);\n    dumpLines(classData);\n    decreaseIndentation();\n    println(\"</class>\");\n}", "methodAfter": "private void dumpClass(ClassData classData) {\n    logger.debug(\"Dumping class \" + classData.getName());\n    double ccn = Util.getCCN(new File(sourceDirectory, classData.getSourceFileName()), false);\n    println(((((((((((\"<class name=\\\"\" + classData.getName()) + \"\\\" filename=\\\"\") + classData.getSourceFileName()) + \"\\\" line-rate=\\\"\") + classData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + classData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpMethods(classData);\n    dumpLines(classData);\n    decreaseIndentation();\n    println(\"</class>\");\n}"}], [{"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        for (Iterator i = branches.values().iterator(); i.hasNext(); number += ((LineData) (i.next())).getNumberOfValidBranches());\n        return number;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        for (Iterator<LineData> i = branches.values().iterator(); i.hasNext(); number += ((LineData) (i.next())).getNumberOfValidBranches());\n        return number;\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        for (Iterator i = branches.values().iterator(); i.hasNext(); number += ((LineData) (i.next())).getNumberOfCoveredBranches());\n        return number;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        for (Iterator<LineData> i = branches.values().iterator(); i.hasNext(); number += ((LineData) (i.next())).getNumberOfCoveredBranches());\n        return number;\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private String generateTableRowForPackage(PackageData packageData) {\n    StringBuffer ret = new StringBuffer();\n    String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n    double lineCoverage = -1;\n    double branchCoverage = -1;\n    double ccn = complexity.getCCNForPackage(packageData);\n    if (packageData.getNumberOfValidLines() > 0) {\n        lineCoverage = packageData.getLineCoverageRate();\n    }\n    if (packageData.getNumberOfValidBranches() > 0) {\n        branchCoverage = packageData.getBranchCoverageRate();\n    }\n    ret.append(\"  <tr>\");\n    ret.append((((((\"<td class=\\\"text\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\'>\") + generatePackageName(packageData)) + \"</a></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + packageData.getNumberOfChildren()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(lineCoverage, packageData.getNumberOfValidLines(), branchCoverage, packageData.getNumberOfValidBranches(), ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}", "methodAfter": "private String generateTableRowForPackage(PackageData packageData) {\n    StringBuffer ret = new StringBuffer();\n    String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n    double ccn = complexity.getCCNForPackage(packageData);\n    ret.append(\"  <tr>\");\n    ret.append((((((\"<td><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\'>\") + generatePackageName(packageData)) + \"</a></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + packageData.getNumberOfChildren()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(packageData, ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}"}, {"methodBefore": "private String generateTableRowForClass(ClassData classData, String sourceFileName, double ccn) {\n    StringBuffer ret = new StringBuffer();\n    double lineCoverage = -1;\n    double branchCoverage = -1;\n    if (classData.getNumberOfValidLines() > 0) {\n        lineCoverage = classData.getLineCoverageRate();\n    }\n    if (classData.getNumberOfValidBranches() > 0) {\n        branchCoverage = classData.getBranchCoverageRate();\n    }\n    ret.append(\"  <tr>\");\n    ret.append((((\"<td class=\\\"text\\\"><a href=\\\"\" + sourceFileName) + \".html\\\">\") + classData.getBaseName()) + \"</a></td>\");\n    ret.append(generateTableColumnsFromData(lineCoverage, classData.getNumberOfValidLines(), branchCoverage, classData.getNumberOfValidBranches(), ccn));\n    ret.append(\"</tr>\\n\");\n    return ret.toString();\n}", "methodAfter": "private String generateTableRowForClass(ClassData classData, String sourceFileName, double ccn) {\n    StringBuffer ret = new StringBuffer();\n    ret.append(\"  <tr>\");\n    ret.append((((\"<td><a href=\\\"\" + sourceFileName) + \".html\\\">\") + classData.getBaseName()) + \"</a></td>\");\n    ret.append(generateTableColumnsFromData(classData, ccn));\n    ret.append(\"</tr>\\n\");\n    return ret.toString();\n}"}], [{"methodBefore": "private final boolean jj_3R_78() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_399() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_83() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_388() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_393() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_93() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_97() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_91() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, 0);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(cv2, 0);\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}", "methodAfter": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, 0);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(cv2, EXPAND_FRAMES);\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}"}, {"methodBefore": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, 0);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(cv2, EXPAND_FRAMES);\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}", "methodAfter": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(cv2, EXPAND_FRAMES);\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}"}], [{"methodBefore": "private LineData getLineData(int lineNumber) {\n    return ((LineData) (lines.get(new Integer(lineNumber))));\n}", "methodAfter": "private LineData getLineData(int lineNumber) {\n    return ((LineData) (children.get(new Integer(lineNumber))));\n}"}, {"methodBefore": "public boolean isValidSourceLineNumber(int lineNumber) {\n    return lines.containsKey(new Integer(lineNumber));\n}", "methodAfter": "public boolean isValidSourceLineNumber(int lineNumber) {\n    return children.containsKey(new Integer(lineNumber));\n}"}], [{"methodBefore": "public static void main(String[] asArgs) {\n    Locale.setDefault(Locale.US);\n    Javancss pJavancss = new Javancss(asArgs, S_RCS_HEADER);\n    if (pJavancss.getLastErrorMessage() != null) {\n        System.exit(1);\n    }\n    System.exit(0);\n}", "methodAfter": "public static void main(String[] asArgs) throws IOException {\n    Locale.setDefault(Locale.US);\n    Javancss pJavancss = new Javancss(asArgs, S_RCS_HEADER);\n    if (pJavancss.getLastErrorMessage() != null) {\n        System.exit(1);\n    }\n    System.exit(0);\n}"}, {"methodBefore": "public static void main(String[] args) {\n    new Main(args);\n}", "methodAfter": "public static void main(String[] args) throws MalformedPatternException {\n    new Main(args);\n}"}], [{"methodBefore": "private String generateTableRowForClass(ClassData classData, String sourceFileName, double ccn) {\n    StringBuffer ret = new StringBuffer();\n    double lineCoverage = -1;\n    double branchCoverage = -1;\n    if (classData.getNumberOfValidLines() > 0) {\n        lineCoverage = classData.getLineCoverageRate();\n    }\n    if (classData.getNumberOfValidBranches() > 0) {\n        branchCoverage = classData.getBranchCoverageRate();\n    }\n    ret.append(\"  <tr>\");\n    ret.append((((\"<td class=\\\"text\\\"><a href=\\\"\" + sourceFileName) + \".html\\\">\") + classData.getBaseName()) + \"</a></td>\");\n    ret.append(generateTableColumnsFromData(lineCoverage, classData.getNumberOfValidLines(), branchCoverage, classData.getNumberOfValidBranches(), ccn));\n    ret.append(\"</tr>\\n\");\n    return ret.toString();\n}", "methodAfter": "private String generateTableRowForClass(ClassData classData, String sourceFileName, double ccn) {\n    StringBuffer ret = new StringBuffer();\n    ret.append(\"  <tr>\");\n    ret.append((((\"<td><a href=\\\"\" + sourceFileName) + \".html\\\">\") + classData.getBaseName()) + \"</a></td>\");\n    ret.append(generateTableColumnsFromData(classData, ccn));\n    ret.append(\"</tr>\\n\");\n    return ret.toString();\n}"}, {"methodBefore": "private String generateTableRowForPackage(PackageData packageData) {\n    StringBuffer ret = new StringBuffer();\n    String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n    double lineCoverage = -1;\n    double branchCoverage = -1;\n    double ccn = complexity.getCCNForPackage(packageData);\n    if (packageData.getNumberOfValidLines() > 0) {\n        lineCoverage = packageData.getLineCoverageRate();\n    }\n    if (packageData.getNumberOfValidBranches() > 0) {\n        branchCoverage = packageData.getBranchCoverageRate();\n    }\n    ret.append(\"  <tr>\");\n    ret.append((((((\"<td class=\\\"text\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\'>\") + generatePackageName(packageData)) + \"</a></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + packageData.getNumberOfChildren()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(lineCoverage, packageData.getNumberOfValidLines(), branchCoverage, packageData.getNumberOfValidBranches(), ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}", "methodAfter": "private String generateTableRowForPackage(PackageData packageData) {\n    StringBuffer ret = new StringBuffer();\n    String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n    double ccn = complexity.getCCNForPackage(packageData);\n    ret.append(\"  <tr>\");\n    ret.append((((((\"<td><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\'>\") + generatePackageName(packageData)) + \"</a></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + packageData.getNumberOfChildren()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(packageData, ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}"}], [{"methodBefore": "public void testHTMLReportValidity() throws Exception {\n    ProjectData.saveGlobalProjectData();\n    String dataFileName = CoverageDataFileHandler.getDefaultDataFile().getAbsolutePath();\n    String[] args = new String[]{ \"--format\", \"html\", \"--datafile\", dataFileName, \"--destination\", PATH_TO_TEST_OUTPUT.getAbsolutePath(), PATH_TO_SOURCES.getAbsolutePath(), PATH_TO_SOURCES_2.getAbsolutePath() };\n    Main.main(args);\n    String htmlFiles[] = PATH_TO_TEST_OUTPUT.list(new FilenameFilter() {\n        public boolean accept(File dir, String name) {\n            return name.endsWith(\".html\");\n        }\n    });\n    Arrays.sort(htmlFiles);\n    assertTrue(htmlFiles.length >= 5);\n    String[] requiredFiles = new String[]{ \"index.html\", \"help.html\", \"frame-packages.html\", \"frame-summary.html\", \"frame-sourcefiles.html\" };\n    for (int i = 0; i < requiredFiles.length; i++) {\n        if (!containsFile(htmlFiles, requiredFiles[i])) {\n            fail((\"File \" + requiredFiles[i]) + \" not found among report files\");\n        }\n    }\n    String previousPrefix = \"NONE\";\n    for (int i = 0; i < htmlFiles.length; i++) {\n        if (containsFile(requiredFiles, htmlFiles[i]) || (!htmlFiles[i].startsWith(previousPrefix))) {\n            JUnitXMLHelper.validate(new File(PATH_TO_TEST_OUTPUT, htmlFiles[i]));\n        }\n        if (htmlFiles[i].length() > 7) {\n            previousPrefix = htmlFiles[i].substring(0, 7);\n        } else {\n            previousPrefix = htmlFiles[i];\n        }\n    }\n    testSuccessful = true;\n}", "methodAfter": "public void testHTMLReportValidity() throws Exception {\n    ProjectData.saveGlobalProjectData();\n    String dataFileName = CoverageDataFileHandler.getDefaultDataFile().getAbsolutePath();\n    String[] args = new String[]{ \"--format\", \"html\", \"--datafile\", dataFileName, \"--destination\", PATH_TO_TEST_OUTPUT.getAbsolutePath(), PATH_TO_SOURCES.getAbsolutePath(), PATH_TO_SOURCES_2.getAbsolutePath() };\n    Main.main(args);\n    String htmlFiles[] = PATH_TO_TEST_OUTPUT.list(new FilenameFilter() {\n        public boolean accept(File dir, String name) {\n            return name.endsWith(\".html\");\n        }\n    });\n    Arrays.sort(htmlFiles);\n    assertTrue(htmlFiles.length >= 5);\n    String[] requiredFiles = new String[]{ \"index.html\", \"help.html\", \"frame-packages.html\", \"frame-summary.html\", \"frame-sourcefiles.html\" };\n    for (int i = 0; i < requiredFiles.length; i++) {\n        if (!containsFile(htmlFiles, requiredFiles[i])) {\n            fail((\"File \" + requiredFiles[i]) + \" not found among report files\");\n        }\n    }\n    String previousPrefix = \"NONE\";\n    for (int i = 0; i < htmlFiles.length; i++) {\n        if (containsFile(requiredFiles, htmlFiles[i]) || (!htmlFiles[i].startsWith(previousPrefix))) {\n            JUnitXMLHelper.readXmlFile(new File(PATH_TO_TEST_OUTPUT, htmlFiles[i]), true);\n        }\n        if (htmlFiles[i].length() > 7) {\n            previousPrefix = htmlFiles[i].substring(0, 7);\n        } else {\n            previousPrefix = htmlFiles[i];\n        }\n    }\n    testSuccessful = true;\n}"}, {"methodBefore": "public void testXMLReportValidity() throws Exception {\n    String[] args;\n    ProjectData.saveGlobalProjectData();\n    String dataFileName = CoverageDataFileHandler.getDefaultDataFile().getAbsolutePath();\n    args = new String[]{ \"--format\", \"xml\", \"--datafile\", dataFileName, \"--destination\", PATH_TO_TEST_OUTPUT, PATH_TO_SOURCE_CODE };\n    Main.main(args);\n    JUnitXMLHelper.validate(new File(PATH_TO_XML_REPORT));\n}", "methodAfter": "public void testXMLReportValidity() throws Exception {\n    String[] args;\n    ProjectData.saveGlobalProjectData();\n    String dataFileName = CoverageDataFileHandler.getDefaultDataFile().getAbsolutePath();\n    args = new String[]{ \"--format\", \"xml\", \"--datafile\", dataFileName, \"--destination\", PATH_TO_TEST_OUTPUT, PATH_TO_SOURCE_CODE };\n    Main.main(args);\n    JUnitXMLHelper.readXmlFile(new File(PATH_TO_XML_REPORT), true);\n}"}], [{"methodBefore": "private final boolean jj_3R_384() {\n    if (jj_3R_399()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_299() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_223() {\n    if (jj_3R_241()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_242() {\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_128() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_334() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_217() {\n    if (jj_3R_132()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_324() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_363() {\n    if (jj_3R_372()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_172() {\n    if (jj_3R_194()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_280() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_331() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_273() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_319() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private File getBaseDirectory() {\n    return baseDirectory;\n}", "methodAfter": "private String getBaseDirectory() {\n    return baseDirectory;\n}"}, {"methodBefore": "public File getBaseDirectory() {\n    return baseDirectory;\n}", "methodAfter": "public String getBaseDirectory() {\n    return baseDirectory;\n}"}], [{"methodBefore": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new CoberturaClassWriter(ClassWriter.COMPUTE_FRAMES);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(new CheckClassAdapter(cv2), SKIP_FRAMES);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        CheckClassAdapter.verify(new ClassReader(cw2.toByteArray()), false, pw);\n        logger.debug(sw.toString());\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}", "methodAfter": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, ignoreClassAnnotations, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new CoberturaClassWriter(ClassWriter.COMPUTE_FRAMES);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(new CheckClassAdapter(cv2), SKIP_FRAMES);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        CheckClassAdapter.verify(new ClassReader(cw2.toByteArray()), false, pw);\n        logger.debug(sw.toString());\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}"}, {"methodBefore": "public Arguments build() {\n    FileFinder sources = new FileFinder();\n    if (this.sources != null) {\n        for (CodeSource codeSource : this.sources) {\n            if (codeSource.isDirectory()) {\n                sources.addSourceDirectory(codeSource.getPath());\n            } else {\n                sources.addSourceFile(getBaseDirectory().getPath(), codeSource.getPath());\n            }\n        }\n    }\n    return new Arguments(baseDirectory, dataFile, destinationDirectory, commandsFile, ignoreRegexes, ignoreBranchesRegexes, classPatternIncludeClassesRegexes, classPatternExcludeClassesRegexes, failOnError, ignoreTrivial, threadsafeRigorous, encoding, minimumCoverageThresholds, classLineThreshold, classBranchThreshold, packageLineThreshold, packageBranchThreshold, totalLineThreshold, totalBranchThreshold, filesToInstrument, filesToMerge, ignoreMethodAnnotations, sources);\n}", "methodAfter": "public Arguments build() {\n    FileFinder sources = new FileFinder();\n    if (this.sources != null) {\n        for (CodeSource codeSource : this.sources) {\n            if (codeSource.isDirectory()) {\n                sources.addSourceDirectory(codeSource.getPath());\n            } else {\n                sources.addSourceFile(getBaseDirectory().getPath(), codeSource.getPath());\n            }\n        }\n    }\n    return new Arguments(baseDirectory, dataFile, destinationDirectory, commandsFile, ignoreRegexes, ignoreBranchesRegexes, classPatternIncludeClassesRegexes, classPatternExcludeClassesRegexes, failOnError, ignoreTrivial, threadsafeRigorous, encoding, minimumCoverageThresholds, classLineThreshold, classBranchThreshold, packageLineThreshold, packageBranchThreshold, totalLineThreshold, totalBranchThreshold, filesToInstrument, filesToMerge, ignoreMethodAnnotations, ignoreClassAnnotations, sources);\n}"}], [{"methodBefore": "private final boolean jj_3R_303() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_381() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_156() {\n    if (jj_3R_177()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_437() {\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_137() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_113() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public String getConditionCoverage() {\n    StringBuffer ret = new StringBuffer();\n    if (getNumberOfValidBranches() == 0) {\n        ret.append(StringUtil.getPercentValue(1.0));\n    } else {\n        lock.lock();\n        try {\n            ret.append(StringUtil.getPercentValue(getBranchCoverageRate()));\n            ret.append(\" (\").append(getNumberOfCoveredBranches()).append(\"/\").append(getNumberOfValidBranches()).append(\")\");\n        } finally {\n            lock.unlock();\n        }\n    }\n    return ret.toString();\n}", "methodAfter": "public synchronized String getConditionCoverage() {\n    StringBuffer ret = new StringBuffer();\n    if (getNumberOfValidBranches() == 0) {\n        ret.append(StringUtil.getPercentValue(1.0));\n    } else {\n        try {\n            ret.append(StringUtil.getPercentValue(getBranchCoverageRate()));\n            ret.append(\" (\").append(getNumberOfCoveredBranches()).append(\"/\").append(getNumberOfValidBranches()).append(\")\");\n        } finally {\n        }\n    }\n    return ret.toString();\n}"}, {"methodBefore": "public int getConditionSize() {\n    lock.lock();\n    try {\n        return (jumps == null ? 0 : jumps.size()) + (switches == null ? 0 : switches.size());\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized int getConditionSize() {\n    try {\n        return (jumps == null ? 0 : jumps.size()) + (switches == null ? 0 : switches.size());\n    } finally {\n    }\n}"}, {"methodBefore": "public Object getConditionData(int index) {\n    Object branchData = null;\n    lock.lock();\n    try {\n        int jumpsSize = (jumps == null) ? 0 : jumps.size();\n        int switchesSize = (switches == null) ? 0 : switches.size();\n        if (index < jumpsSize) {\n            branchData = jumps.get(index);\n        } else if (index < (jumpsSize + switchesSize)) {\n            branchData = switches.get(index - jumpsSize);\n        }\n        return branchData;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized Object getConditionData(int index) {\n    Object branchData = null;\n    try {\n        int jumpsSize = (jumps == null) ? 0 : jumps.size();\n        int switchesSize = (switches == null) ? 0 : switches.size();\n        if (index < jumpsSize) {\n            branchData = jumps.get(index);\n        } else if (index < (jumpsSize + switchesSize)) {\n            branchData = switches.get(index - jumpsSize);\n        }\n        return branchData;\n    } finally {\n    }\n}"}, {"methodBefore": "public double getBranchCoverageRate() {\n    if (getNumberOfValidBranches() == 0) {\n        return 1.0;\n    }\n    lock.lock();\n    try {\n        return ((double) (getNumberOfCoveredBranches())) / getNumberOfValidBranches();\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized double getBranchCoverageRate() {\n    if (getNumberOfValidBranches() == 0) {\n        return 1.0;\n    }\n    try {\n        return ((double) (getNumberOfCoveredBranches())) / getNumberOfValidBranches();\n    } finally {\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_368() {\n    if (jj_scan_token(STATIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_368() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_127() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_127() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_127() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_127() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_368() {\n    if (jj_scan_token(STATIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_368() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void testHashCode() {\n    assertEquals(a.hashCode(), a.hashCode());\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 });\n    assertEquals(a.hashCode(), aPrime.hashCode());\n}", "methodAfter": "public void testHashCode() {\n    assertEquals(a.hashCode(), a.hashCode());\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 }, Integer.MAX_VALUE);\n    assertEquals(a.hashCode(), aPrime.hashCode());\n}"}, {"methodBefore": "private static void getSwitchDataIteratively(LineData data) {\n    for (int i = 0; i < 2000; i++) {\n        Thread.yield();\n        data.getSwitchData(i, new SwitchData(1));\n    }\n}", "methodAfter": "private static void getSwitchDataIteratively(LineData data) {\n    for (int i = 0; i < 2000; i++) {\n        Thread.yield();\n        data.getSwitchData(i, new SwitchData(1, Integer.MAX_VALUE));\n    }\n}"}, {"methodBefore": "public void testEquals() {\n    assertFalse(a.equals(null));\n    assertFalse(a.equals(Integer.valueOf(4)));\n    assertTrue(a.equals(a));\n    assertFalse(a.equals(b));\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 });\n    assertTrue(a.equals(aPrime));\n}", "methodAfter": "public void testEquals() {\n    assertFalse(a.equals(null));\n    assertFalse(a.equals(Integer.valueOf(4)));\n    assertTrue(a.equals(a));\n    assertFalse(a.equals(b));\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 }, Integer.MAX_VALUE);\n    assertTrue(a.equals(aPrime));\n}"}], [{"methodBefore": "public LineData getLineCoverage(int lineNumber) {\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        ClassData classData = ((ClassData) (iter.next()));\n        if (classData.isValidSourceLineNumber(lineNumber)) {\n            return classData.getLineCoverage(lineNumber);\n        }\n    } \n    return null;\n}", "methodAfter": "public LineData getLineCoverage(int lineNumber) {\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            if (classData.isValidSourceLineNumber(lineNumber)) {\n                return classData.getLineCoverage(lineNumber);\n            }\n        } \n    } finally {\n        lock.unlock();\n    }\n    return null;\n}"}, {"methodBefore": "public boolean isValidSourceLineNumber(int lineNumber) {\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        ClassData classData = ((ClassData) (iter.next()));\n        if (classData.isValidSourceLineNumber(lineNumber)) {\n            return true;\n        }\n    } \n    return false;\n}", "methodAfter": "public boolean isValidSourceLineNumber(int lineNumber) {\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            if (classData.isValidSourceLineNumber(lineNumber)) {\n                return true;\n            }\n        } \n    } finally {\n        lock.unlock();\n    }\n    return false;\n}"}], [{"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfValidBranches();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfValidBranches();\n        numberCovered += coverageContainer.getNumberOfCoveredBranches();\n    } \n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}, {"methodBefore": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfCoveredLines();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfValidLines() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfValidLines();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfCoveredBranches();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfValidLines();\n        numberCovered += coverageContainer.getNumberOfCoveredLines();\n    } \n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}], [{"methodBefore": "public XMLReport(ProjectData projectData, File destinationDir, FileFinder finder, ComplexityCalculator complexity) throws IOException {\n    this.complexity = complexity;\n    this.finder = finder;\n    File file = new File(destinationDir, \"coverage.xml\");\n    pw = IOUtil.getPrintWriter(file);\n    try {\n        println(\"<?xml version=\\\"1.0\\\"?>\");\n        println((\"<!DOCTYPE coverage SYSTEM \\\"http://cobertura.sourceforge.net/xml/\" + coverageDTD) + \"\\\">\");\n        println(\"\");\n        double ccn = complexity.getCCNForProject(projectData);\n        int numLinesCovered = projectData.getNumberOfCoveredLines();\n        int numLinesValid = projectData.getNumberOfValidLines();\n        int numBranchesCovered = projectData.getNumberOfCoveredBranches();\n        int numBranchesValid = projectData.getNumberOfValidBranches();\n        println((((((((((((((((((\"<coverage line-rate=\\\"\" + projectData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + projectData.getBranchCoverageRate()) + \"\\\" lines-covered=\\\"\") + numLinesCovered) + \"\\\" lines-valid=\\\"\") + numLinesValid) + \"\\\" branches-covered=\\\"\") + numBranchesCovered) + \"\\\" branches-valid=\\\"\") + numBranchesValid) + \"\\\" complexity=\\\"\") + ccn) + \"\\\" version=\\\"\") + Header.version()) + \"\\\" timestamp=\\\"\") + new Date().getTime()) + \"\\\">\");\n        increaseIndentation();\n        dumpSources();\n        dumpPackages(projectData);\n        decreaseIndentation();\n        println(\"</coverage>\");\n    } finally {\n        pw.close();\n    }\n}", "methodAfter": "public XMLReport(ProjectData projectData, File destinationDir, FileFinder finder, ComplexityCalculator complexity) throws IOException {\n    this.complexity = complexity;\n    this.finder = finder;\n    File file = new File(destinationDir, \"coverage.xml\");\n    setPrintWriter(IOUtil.getPrintWriter(file));\n    try {\n        printHeader();\n        printCoverageElement(projectData, complexity);\n        increaseIndentation();\n        dumpSources();\n        dumpPackages(projectData);\n        decreaseIndentation();\n        println(\"</coverage>\");\n    } finally {\n        close();\n    }\n}"}, {"methodBefore": "public SummaryXMLReport(ProjectData projectData, File destinationDir, FileFinder finder, ComplexityCalculator complexity) throws IOException {\n    File file = new File(destinationDir, \"coverage-summary.xml\");\n    pw = IOUtil.getPrintWriter(file);\n    try {\n        println(\"<?xml version=\\\"1.0\\\"?>\");\n        println((\"<!DOCTYPE coverage SYSTEM \\\"http://cobertura.sourceforge.net/xml/\" + XMLReport.coverageDTD) + \"\\\">\");\n        println(\"\");\n        double ccn = complexity.getCCNForProject(projectData);\n        int numLinesCovered = projectData.getNumberOfCoveredLines();\n        int numLinesValid = projectData.getNumberOfValidLines();\n        int numBranchesCovered = projectData.getNumberOfCoveredBranches();\n        int numBranchesValid = projectData.getNumberOfValidBranches();\n        println((((((((((((((((((\"<coverage line-rate=\\\"\" + projectData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + projectData.getBranchCoverageRate()) + \"\\\" lines-covered=\\\"\") + numLinesCovered) + \"\\\" lines-valid=\\\"\") + numLinesValid) + \"\\\" branches-covered=\\\"\") + numBranchesCovered) + \"\\\" branches-valid=\\\"\") + numBranchesValid) + \"\\\" complexity=\\\"\") + ccn) + \"\\\" version=\\\"\") + Header.version()) + \"\\\" timestamp=\\\"\") + new Date().getTime()) + \"\\\">\");\n        increaseIndentation();\n        println(\"<packages />\");\n        decreaseIndentation();\n        println(\"</coverage>\");\n    } finally {\n        pw.close();\n    }\n}", "methodAfter": "public SummaryXMLReport(ProjectData projectData, File destinationDir, FileFinder finder, ComplexityCalculator complexity) throws IOException {\n    File file = new File(destinationDir, \"coverage-summary.xml\");\n    setPrintWriter(IOUtil.getPrintWriter(file));\n    try {\n        printHeader();\n        printCoverageElement(projectData, complexity);\n        increaseIndentation();\n        println(\"<packages />\");\n        decreaseIndentation();\n        println(\"</coverage>\");\n    } finally {\n        close();\n    }\n}"}], [{"methodBefore": "private void generateSourceFiles() {\n    Iterator iter = projectData.getSourceFiles().iterator();\n    while (iter.hasNext()) {\n        SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n        try {\n            generateSourceFile(sourceFileData);\n        } catch (IOException e) {\n            logger.info(((\"Could not generate HTML file for source file \" + sourceFileData.getName()) + \": \") + e.getLocalizedMessage());\n        }\n    } \n}", "methodAfter": "private void generateSourceFiles() {\n    Iterator iter = projectData.getSourceFiles().iterator();\n    while (iter.hasNext()) {\n        SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n        try {\n            generateSourceFile(sourceFileData);\n        } catch (IOException e) {\n            LOGGER.info(((\"Could not generate HTML file for source file \" + sourceFileData.getName()) + \": \") + e.getLocalizedMessage());\n        }\n    } \n}"}, {"methodBefore": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        logger.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(sourceFileData.getPackageName() + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<p>\");\n        out.println(\"<table cellspacing=\\\"0\\\" cellpadding=\\\"0\\\" class=\\\"src\\\">\");\n        BufferedReader br = null;\n        try {\n            File sourceFile = finder.findFile(sourceFileData.getName());\n            br = new BufferedReader(new FileReader(sourceFile));\n            String lineStr;\n            JavaToHtml javaToHtml = new JavaToHtml();\n            int lineNumber = 1;\n            while ((lineStr = br.readLine()) != null) {\n                out.println(\"<tr>\");\n                if (sourceFileData.isValidSourceLineNumber(lineNumber)) {\n                    long numberOfHits = sourceFileData.getHitCount(lineNumber);\n                    out.println((\"  <td class=\\\"numLineCover\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    if (numberOfHits > 0) {\n                        out.println((\"  <td class=\\\"nbHitsCovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                    } else {\n                        out.println((\"  <td class=\\\"nbHitsUncovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\"><span class=\\\"srcUncovered\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</span></pre></td>\");\n                    }\n                } else {\n                    out.println((\"  <td class=\\\"numLine\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    out.println(\"  <td class=\\\"nbHits\\\">&nbsp;</td>\");\n                    out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                }\n                out.println(\"</tr>\");\n                lineNumber++;\n            } \n        } finally {\n            if (br != null) {\n                br.close();\n            }\n        }\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Reports generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        LOGGER.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(sourceFileData.getPackageName() + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<p>\");\n        out.println(\"<table cellspacing=\\\"0\\\" cellpadding=\\\"0\\\" class=\\\"src\\\">\");\n        BufferedReader br = null;\n        try {\n            File sourceFile = finder.findFile(sourceFileData.getName());\n            br = new BufferedReader(new FileReader(sourceFile));\n            String lineStr;\n            JavaToHtml javaToHtml = new JavaToHtml();\n            int lineNumber = 1;\n            while ((lineStr = br.readLine()) != null) {\n                out.println(\"<tr>\");\n                if (sourceFileData.isValidSourceLineNumber(lineNumber)) {\n                    long numberOfHits = sourceFileData.getHitCount(lineNumber);\n                    out.println((\"  <td class=\\\"numLineCover\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    if (numberOfHits > 0) {\n                        out.println((\"  <td class=\\\"nbHitsCovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                    } else {\n                        out.println((\"  <td class=\\\"nbHitsUncovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\"><span class=\\\"srcUncovered\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</span></pre></td>\");\n                    }\n                } else {\n                    out.println((\"  <td class=\\\"numLine\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    out.println(\"  <td class=\\\"nbHits\\\">&nbsp;</td>\");\n                    out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                }\n                out.println(\"</tr>\");\n                lineNumber++;\n            } \n        } finally {\n            if (br != null) {\n                br.close();\n            }\n        }\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Reports generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Throwable {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes, ignoreTrivial);\n                    cr.accept(cv, 0);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}", "methodAfter": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Throwable {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes, ignoreMethodAnnotations, ignoreTrivial);\n                    cr.accept(cv, 0);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}"}, {"methodBefore": "private void addInstrumentationToSingleClass(File file) throws Throwable {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes, ignoreTrivial);\n        cr.accept(cv, 0);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        inputStream = IOUtil.closeInputStream(inputStream);\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        outputStream = IOUtil.closeOutputStream(outputStream);\n    }\n}", "methodAfter": "private void addInstrumentationToSingleClass(File file) throws Throwable {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes, ignoreMethodAnnotations, ignoreTrivial);\n        cr.accept(cv, 0);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        inputStream = IOUtil.closeInputStream(inputStream);\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        outputStream = IOUtil.closeOutputStream(outputStream);\n    }\n}"}, {"methodBefore": "public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n    MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);\n    if (!instrument) {\n        return mv;\n    }\n    return mv == null ? null : new FirstPassMethodInstrumenter(classData, mv, this.myName, this.superName, access, name, desc, signature, exceptions, ignoreRegexs, ignoreBranchesRegexs, ignoreTrivial);\n}", "methodAfter": "public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n    MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);\n    if (!instrument) {\n        return mv;\n    }\n    return mv == null ? null : new FirstPassMethodInstrumenter(classData, mv, this.myName, this.superName, access, name, desc, signature, exceptions, ignoreRegexs, ignoreBranchesRegexs, ignoreMethodAnnotations, ignoreTrivial);\n}"}], [{"methodBefore": "private File getBaseDirectory() {\n    return baseDirectory;\n}", "methodAfter": "private String getBaseDirectory() {\n    return baseDirectory;\n}"}, {"methodBefore": "public File getBaseDirectory() {\n    return baseDirectory;\n}", "methodAfter": "public String getBaseDirectory() {\n    return baseDirectory;\n}"}], [{"methodBefore": "long getHits() {\n    return hits;\n}", "methodAfter": "public long getHits() {\n    return hits;\n}"}, {"methodBefore": "int getLineNumber() {\n    return lineNumber;\n}", "methodAfter": "public int getLineNumber() {\n    return lineNumber;\n}"}], [{"methodBefore": "public SortedSet getSourceFiles() {\n    SortedSet sourceFiles = new TreeSet();\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        sourceFiles.addAll(packageData.getChildren());\n    } \n    return sourceFiles;\n}", "methodAfter": "public SortedSet getSourceFiles() {\n    SortedSet sourceFiles = new TreeSet();\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        sourceFiles.addAll(packageData.getSourceFiles());\n    } \n    return sourceFiles;\n}"}, {"methodBefore": "private void dumpSourceFiles(PackageData packageData) {\n    println(\"<classes>\");\n    increaseIndentation();\n    Iterator it = packageData.getChildren().iterator();\n    while (it.hasNext()) {\n        dumpClasses(((SourceFileData) (it.next())));\n    } \n    decreaseIndentation();\n    println(\"</classes>\");\n}", "methodAfter": "private void dumpSourceFiles(PackageData packageData) {\n    println(\"<classes>\");\n    increaseIndentation();\n    Iterator it = packageData.getSourceFiles().iterator();\n    while (it.hasNext()) {\n        dumpClasses(((SourceFileData) (it.next())));\n    } \n    decreaseIndentation();\n    println(\"</classes>\");\n}"}], [{"methodBefore": "private void dumpPackage(PackageData packageData) {\n    logger.debug(\"Dumping package \" + packageData.getName());\n    double ccn = Util.getCCN(new File(sourceDirectory, packageData.getSourceFileName()), false);\n    println(((((((((\"<package name=\\\"\" + packageData.getName()) + \"\\\" line-rate=\\\"\") + packageData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + packageData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpSourceFiles(packageData);\n    decreaseIndentation();\n    println(\"</package>\");\n}", "methodAfter": "private void dumpPackage(PackageData packageData) {\n    logger.debug(\"Dumping package \" + packageData.getName());\n    double ccn = Util.getCCN(finder.findFile(packageData.getSourceFileName()), false);\n    println(((((((((\"<package name=\\\"\" + packageData.getName()) + \"\\\" line-rate=\\\"\") + packageData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + packageData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpSourceFiles(packageData);\n    decreaseIndentation();\n    println(\"</package>\");\n}"}, {"methodBefore": "private void dumpClass(ClassData classData) {\n    logger.debug(\"Dumping class \" + classData.getName());\n    double ccn = Util.getCCN(new File(sourceDirectory, classData.getSourceFileName()), false);\n    println(((((((((((\"<class name=\\\"\" + classData.getName()) + \"\\\" filename=\\\"\") + classData.getSourceFileName()) + \"\\\" line-rate=\\\"\") + classData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + classData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpMethods(classData);\n    dumpLines(classData);\n    decreaseIndentation();\n    println(\"</class>\");\n}", "methodAfter": "private void dumpClass(ClassData classData) {\n    logger.debug(\"Dumping class \" + classData.getName());\n    double ccn = Util.getCCN(finder.findFile(classData.getSourceFileName()), false);\n    println(((((((((((\"<class name=\\\"\" + classData.getName()) + \"\\\" filename=\\\"\") + classData.getSourceFileName()) + \"\\\" line-rate=\\\"\") + classData.getLineCoverageRate()) + \"\\\" branch-rate=\\\"\") + classData.getBranchCoverageRate()) + \"\\\" complexity=\\\"\") + ccn) + \"\\\"\") + \">\");\n    increaseIndentation();\n    dumpMethods(classData);\n    dumpLines(classData);\n    decreaseIndentation();\n    println(\"</class>\");\n}"}], [{"methodBefore": "private final boolean jj_3R_323() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_361() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_123() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_133() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_185() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_173() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_119() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_129() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_357() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_254() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_402() {\n    if (jj_3R_413()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_406() {\n    if (jj_3R_413()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_329() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_367() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_257() {\n    if (jj_3R_262()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_241() {\n    if (jj_3R_262()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_118() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_128() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_400() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_417() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_122() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_132() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_183() {\n    if (jj_3R_193()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_171() {\n    if (jj_3R_193()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_117() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_127() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_333() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_371() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_116() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_126() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_337() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_375() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_334() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_372() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_331() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_369() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_120() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_130() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_322() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_352() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_321() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_351() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_121() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_131() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_316() {\n    if (jj_scan_token(EXTENDS)) {\n        return true;\n    }\n    if (jj_3R_325()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_316() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_340() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_93()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_340() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void addInstrumentationToArchive(ZipInputStream archive, ZipOutputStream output) throws Exception {\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (isClass(entry)) {\n                ClassReader cr = new ClassReader(entryBytes);\n                ClassWriter cw = new ClassWriter(true);\n                ClassInstrumenter cv = new ClassInstrumenter(this.projectData, cw, this.ignoreRegexs);\n                cr.accept(cv, false);\n                if (cv.isInstrumented()) {\n                    logger.debug(\"Putting instrumeted entry: \" + entry.getName());\n                    entryBytes = cw.toByteArray();\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry);\n            throw e;\n        }\n        output.flush();\n    } \n}", "methodAfter": "private void addInstrumentationToArchive(ZipInputStream archive, ZipOutputStream output) throws Exception {\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (isClass(entry)) {\n                ClassReader cr = new ClassReader(entryBytes);\n                ClassWriter cw = new ClassWriter(true);\n                ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes);\n                cr.accept(cv, false);\n                if (cv.isInstrumented()) {\n                    logger.debug(\"Putting instrumeted entry: \" + entry.getName());\n                    entryBytes = cw.toByteArray();\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry);\n            throw e;\n        }\n        output.flush();\n    } \n}"}, {"methodBefore": "private void addInstrumentationToSingleClass(File file) {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(true);\n        cv = new ClassInstrumenter(this.projectData, cw, this.ignoreRegexs);\n        cr.accept(cv, false);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (IOException e) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), e);\n        return;\n    } finally {\n        if (outputStream != null) {\n            try {\n                outputStream.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}", "methodAfter": "private void addInstrumentationToSingleClass(File file) {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(true);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegexes);\n        cr.accept(cv, false);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (IOException e) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), e);\n        return;\n    } finally {\n        if (outputStream != null) {\n            try {\n                outputStream.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}"}], [{"methodBefore": "public int getMinBranchPercentage() {\n    return minBranchPercentage;\n}", "methodAfter": "public double getMinBranchPercentage() {\n    return minBranchPercentage;\n}"}, {"methodBefore": "public int getMinLinePercentage() {\n    return minLinePercentage;\n}", "methodAfter": "public double getMinLinePercentage() {\n    return minLinePercentage;\n}"}], [{"methodBefore": "private void parseArguments(String[] args) {\n    Collection<Pattern> ignoreRegexes = new Vector<Pattern>();\n    coberturaInstrumenter.setIgnoreRegexes(ignoreRegexes);\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    List<CoberturaFile> filePaths = new ArrayList<CoberturaFile>();\n    String baseDir = null;\n    boolean threadsafeRigorous = false;\n    boolean ignoreTrivial = false;\n    boolean failOnError = false;\n    Set<String> ignoreMethodAnnotations = new HashSet<String>();\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--basedir\")) {\n            baseDir = args[++i];\n        } else if (args[i].equals(\"--datafile\")) {\n            dataFile = new File(args[++i]);\n        } else if (args[i].equals(\"--destination\")) {\n            destinationDirectory = new File(args[++i]);\n            coberturaInstrumenter.setDestinationDirectory(destinationDirectory);\n        } else if (args[i].equals(\"--ignore\")) {\n            RegexUtil.addRegex(ignoreRegexes, args[++i]);\n        } else if (args[i].equals(\"--ignoreMethodAnnotation\")) {\n            ignoreMethodAnnotations.add(args[++i]);\n        } else if (args[i].equals(\"--ignoreTrivial\")) {\n            ignoreTrivial = true;\n        } else if (args[i].equals(\"--includeClasses\")) {\n            classPattern.addIncludeClassesRegex(args[++i]);\n        } else if (args[i].equals(\"--excludeClasses\")) {\n            classPattern.addExcludeClassesRegex(args[++i]);\n        } else if (args[i].equals(\"--failOnError\")) {\n            failOnError = true;\n            logger.setFailOnError(true);\n        } else if (args[i].equals(\"--threadsafeRigorous\")) {\n            threadsafeRigorous = true;\n        } else {\n            filePaths.add(new CoberturaFile(baseDir, args[i]));\n        }\n    }\n    coberturaInstrumenter.setIgnoreTrivial(ignoreTrivial);\n    coberturaInstrumenter.setIgnoreMethodAnnotations(ignoreMethodAnnotations);\n    coberturaInstrumenter.setThreadsafeRigorous(threadsafeRigorous);\n    coberturaInstrumenter.setFailOnError(failOnError);\n    ProjectData projectData;\n    projectData = (dataFile.isFile()) ? CoverageDataFileHandler.loadCoverageData(dataFile) : new ProjectData();\n    coberturaInstrumenter.setProjectData(projectData);\n    logger.info((((\"Instrumenting \" + filePaths.size()) + \" \") + (filePaths.size() == 1 ? \"file\" : \"files\")) + (destinationDirectory != null ? \" to \" + destinationDirectory.getAbsoluteFile() : \"\"));\n    Iterator<CoberturaFile> iter = filePaths.iterator();\n    while (iter.hasNext()) {\n        CoberturaFile coberturaFile = iter.next();\n        if (coberturaFile.isArchive()) {\n            addInstrumentationToArchive(coberturaFile);\n        } else {\n            addInstrumentation(coberturaFile);\n        }\n    } \n    CoverageDataFileHandler.saveCoverageData(projectData, dataFile);\n}", "methodAfter": "private void parseArguments(String[] args) {\n    Collection<Pattern> ignoreRegexes = new Vector<Pattern>();\n    coberturaInstrumenter.setIgnoreRegexes(ignoreRegexes);\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    List<CoberturaFile> filePaths = new ArrayList<CoberturaFile>();\n    String baseDir = null;\n    boolean threadsafeRigorous = false;\n    boolean ignoreTrivial = false;\n    boolean failOnError = false;\n    Set<String> ignoreMethodAnnotations = new HashSet<String>();\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--basedir\")) {\n            baseDir = args[++i];\n        } else if (args[i].equals(\"--datafile\")) {\n            dataFile = new File(args[++i]);\n        } else if (args[i].equals(\"--destination\")) {\n            destinationDirectory = new File(args[++i]);\n            coberturaInstrumenter.setDestinationDirectory(destinationDirectory);\n        } else if (args[i].equals(\"--ignore\")) {\n            RegexUtil.addRegex(ignoreRegexes, args[++i]);\n        } else if (args[i].equals(\"--ignoreMethodAnnotation\")) {\n            ignoreMethodAnnotations.add(args[++i]);\n        } else if (args[i].equals(\"--ignoreTrivial\")) {\n            ignoreTrivial = true;\n        } else if (args[i].equals(\"--includeClasses\")) {\n            classPattern.addIncludeClassesRegex(args[++i]);\n        } else if (args[i].equals(\"--excludeClasses\")) {\n            classPattern.addExcludeClassesRegex(args[++i]);\n        } else if (args[i].equals(\"--failOnError\")) {\n            failOnError = true;\n            logger.setFailOnError(true);\n        } else if (args[i].equals(\"--threadsafeRigorous\")) {\n            threadsafeRigorous = true;\n        } else if (args[i].equals(\"--auxClasspath\")) {\n            addElementsToJVM(args[++i]);\n        } else {\n            filePaths.add(new CoberturaFile(baseDir, args[i]));\n        }\n    }\n    coberturaInstrumenter.setIgnoreTrivial(ignoreTrivial);\n    coberturaInstrumenter.setIgnoreMethodAnnotations(ignoreMethodAnnotations);\n    coberturaInstrumenter.setThreadsafeRigorous(threadsafeRigorous);\n    coberturaInstrumenter.setFailOnError(failOnError);\n    ProjectData projectData;\n    projectData = (dataFile.isFile()) ? CoverageDataFileHandler.loadCoverageData(dataFile) : new ProjectData();\n    coberturaInstrumenter.setProjectData(projectData);\n    logger.info((((\"Instrumenting \" + filePaths.size()) + \" \") + (filePaths.size() == 1 ? \"file\" : \"files\")) + (destinationDirectory != null ? \" to \" + destinationDirectory.getAbsoluteFile() : \"\"));\n    Iterator<CoberturaFile> iter = filePaths.iterator();\n    while (iter.hasNext()) {\n        CoberturaFile coberturaFile = iter.next();\n        if (coberturaFile.isArchive()) {\n            addInstrumentationToArchive(coberturaFile);\n        } else {\n            addInstrumentation(coberturaFile);\n        }\n    } \n    CoverageDataFileHandler.saveCoverageData(projectData, dataFile);\n}"}, {"methodBefore": "private void parseArguments(String[] args) {\n    Collection<Pattern> ignoreRegexes = new Vector<Pattern>();\n    coberturaInstrumenter.setIgnoreRegexes(ignoreRegexes);\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    List<CoberturaFile> filePaths = new ArrayList<CoberturaFile>();\n    String baseDir = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--basedir\")) {\n            baseDir = args[++i];\n        } else if (args[i].equals(\"--datafile\")) {\n            dataFile = new File(args[++i]);\n        } else if (args[i].equals(\"--destination\")) {\n            destinationDirectory = new File(args[++i]);\n            coberturaInstrumenter.setDestinationDirectory(destinationDirectory);\n        } else if (args[i].equals(\"--ignore\")) {\n            RegexUtil.addRegex(ignoreRegexes, args[++i]);\n        } else if (args[i].equals(\"--includeClasses\")) {\n            classPattern.addIncludeClassesRegex(args[++i]);\n        } else if (args[i].equals(\"--excludeClasses\")) {\n            classPattern.addExcludeClassesRegex(args[++i]);\n        } else {\n            filePaths.add(new CoberturaFile(baseDir, args[i]));\n        }\n    }\n    ProjectData projectData;\n    projectData = (dataFile.isFile()) ? CoverageDataFileHandler.loadCoverageData(dataFile) : new ProjectData();\n    coberturaInstrumenter.setProjectData(projectData);\n    System.out.println((((\"Instrumenting \" + filePaths.size()) + \" \") + (filePaths.size() == 1 ? \"file\" : \"files\")) + (destinationDirectory != null ? \" to \" + destinationDirectory.getAbsoluteFile() : \"\"));\n    Iterator<CoberturaFile> iter = filePaths.iterator();\n    while (iter.hasNext()) {\n        CoberturaFile coberturaFile = iter.next();\n        if (coberturaFile.isArchive()) {\n            addInstrumentationToArchive(coberturaFile);\n        } else {\n            addInstrumentation(coberturaFile);\n        }\n    } \n    CoverageDataFileHandler.saveCoverageData(projectData, dataFile);\n}", "methodAfter": "private void parseArguments(String[] args) {\n    Collection<Pattern> ignoreRegexes = new Vector<Pattern>();\n    coberturaInstrumenter.setIgnoreRegexes(ignoreRegexes);\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    List<CoberturaFile> filePaths = new ArrayList<CoberturaFile>();\n    String baseDir = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--basedir\")) {\n            baseDir = args[++i];\n        } else if (args[i].equals(\"--datafile\")) {\n            dataFile = new File(args[++i]);\n        } else if (args[i].equals(\"--destination\")) {\n            destinationDirectory = new File(args[++i]);\n            coberturaInstrumenter.setDestinationDirectory(destinationDirectory);\n        } else if (args[i].equals(\"--ignore\")) {\n            RegexUtil.addRegex(ignoreRegexes, args[++i]);\n        } else if (args[i].equals(\"--includeClasses\")) {\n            classPattern.addIncludeClassesRegex(args[++i]);\n        } else if (args[i].equals(\"--excludeClasses\")) {\n            classPattern.addExcludeClassesRegex(args[++i]);\n        } else if (args[i].equals(\"--failOnError\")) {\n            logger.setFailOnError(true);\n        } else {\n            filePaths.add(new CoberturaFile(baseDir, args[i]));\n        }\n    }\n    ProjectData projectData;\n    projectData = (dataFile.isFile()) ? CoverageDataFileHandler.loadCoverageData(dataFile) : new ProjectData();\n    coberturaInstrumenter.setProjectData(projectData);\n    System.out.println((((\"Instrumenting \" + filePaths.size()) + \" \") + (filePaths.size() == 1 ? \"file\" : \"files\")) + (destinationDirectory != null ? \" to \" + destinationDirectory.getAbsoluteFile() : \"\"));\n    Iterator<CoberturaFile> iter = filePaths.iterator();\n    while (iter.hasNext()) {\n        CoberturaFile coberturaFile = iter.next();\n        if (coberturaFile.isArchive()) {\n            addInstrumentationToArchive(coberturaFile);\n        } else {\n            addInstrumentation(coberturaFile);\n        }\n    } \n    CoverageDataFileHandler.saveCoverageData(projectData, dataFile);\n}"}], [{"methodBefore": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    PackageData packageData = ((PackageData) (obj));\n    return super.equals(obj) && this.name.equals(packageData.name);\n}", "methodAfter": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    PackageData packageData = ((PackageData) (obj));\n    getBothLocks(packageData);\n    try {\n        return super.equals(obj) && this.name.equals(packageData.name);\n    } finally {\n        lock.unlock();\n        packageData.lock.unlock();\n    }\n}"}, {"methodBefore": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    SourceFileData sourceFileData = ((SourceFileData) (obj));\n    return super.equals(obj) && this.name.equals(sourceFileData.name);\n}", "methodAfter": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    SourceFileData sourceFileData = ((SourceFileData) (obj));\n    getBothLocks(sourceFileData);\n    try {\n        return super.equals(obj) && this.name.equals(sourceFileData.name);\n    } finally {\n        lock.unlock();\n        sourceFileData.lock.unlock();\n    }\n}"}], [{"methodBefore": "public boolean containsInstrumentationInfo() {\n    return this.containsInstrumentationInfo;\n}", "methodAfter": "public boolean containsInstrumentationInfo() {\n    lock.lock();\n    try {\n        return this.containsInstrumentationInfo;\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public void setContainsInstrumentationInfo() {\n    this.containsInstrumentationInfo = true;\n}", "methodAfter": "public void setContainsInstrumentationInfo() {\n    lock.lock();\n    try {\n        this.containsInstrumentationInfo = true;\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_254() {\n    if (jj_3R_261()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_248() {\n    if (jj_3R_268()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_407() {\n    if (jj_3R_182()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_405() {\n    if (jj_3R_189()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_221() {\n    if (jj_3R_239()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_209() {\n    if (jj_3R_223()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_155() {\n    if (jj_3R_178()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_451() {\n    if (jj_3R_454()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_293() {\n    if (jj_3R_326()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_246() {\n    if (jj_3R_266()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_292() {\n    if (jj_3R_326()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_247() {\n    if (jj_3R_267()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_381() {\n    if (jj_3R_387()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_453() {\n    if (jj_3R_454()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_369() {\n    if (jj_3R_261()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_249() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "long getHits() {\n    return hits;\n}", "methodAfter": "public long getHits() {\n    return hits;\n}"}, {"methodBefore": "boolean isBranch() {\n    return isBranch;\n}", "methodAfter": "public boolean isBranch() {\n    return isBranch;\n}"}], [{"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    for (Iterator i = branches.values().iterator(); i.hasNext(); number += ((LineData) (i.next())).getNumberOfValidBranches());\n    return number;\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        for (Iterator i = branches.values().iterator(); i.hasNext(); number += ((LineData) (i.next())).getNumberOfValidBranches());\n        return number;\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    for (Iterator i = branches.values().iterator(); i.hasNext(); number += ((LineData) (i.next())).getNumberOfCoveredBranches());\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        for (Iterator i = branches.values().iterator(); i.hasNext(); number += ((LineData) (i.next())).getNumberOfCoveredBranches());\n        return number;\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_123() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_133() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_121() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_131() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public ReportTask() {\n    super(\"net.sourceforge.cobertura.reporting.Main\");\n}", "methodAfter": "public ReportTask() {\n    super(Main.class.getCanonicalName());\n}"}, {"methodBefore": "public CheckTask() {\n    super(\"net.sourceforge.cobertura.check.Main\");\n}", "methodAfter": "public CheckTask() {\n    super(Main.class.getCanonicalName());\n}"}], [{"methodBefore": "public void merge(CoverageData coverageData) {\n    LineData lineData = ((LineData) (coverageData));\n    getBothLocks(lineData);\n    try {\n        this.hits += lineData.hits;\n        if (lineData.jumps != null) {\n            if (this.jumps == null) {\n                this.jumps = lineData.jumps;\n            } else {\n                for (int i = Math.min(this.jumps.size(), lineData.jumps.size()) - 1; i >= 0; i--) {\n                    ((JumpData) (this.jumps.get(i))).merge(((JumpData) (lineData.jumps.get(i))));\n                }\n                for (int i = Math.min(this.jumps.size(), lineData.jumps.size()); i < lineData.jumps.size(); i++) {\n                    this.jumps.add(lineData.jumps.get(i));\n                }\n            }\n        }\n        if (lineData.switches != null) {\n            if (this.switches == null) {\n                this.switches = lineData.switches;\n            } else {\n                for (int i = Math.min(this.switches.size(), lineData.switches.size()) - 1; i >= 0; i--) {\n                    ((SwitchData) (this.switches.get(i))).merge(((SwitchData) (lineData.switches.get(i))));\n                }\n                for (int i = Math.min(this.switches.size(), lineData.switches.size()); i < lineData.switches.size(); i++) {\n                    this.switches.add(lineData.switches.get(i));\n                }\n            }\n        }\n        if (lineData.methodName != null) {\n            this.methodName = lineData.methodName;\n        }\n        if (lineData.methodDescriptor != null) {\n            this.methodDescriptor = lineData.methodDescriptor;\n        }\n    } finally {\n        lock.unlock();\n        lineData.lock.unlock();\n    }\n}", "methodAfter": "public synchronized void merge(CoverageData coverageData) {\n    LineData lineData = ((LineData) (coverageData));\n    try {\n        this.hits += lineData.hits;\n        if (lineData.jumps != null) {\n            if (this.jumps == null) {\n                this.jumps = lineData.jumps;\n            } else {\n                for (int i = Math.min(this.jumps.size(), lineData.jumps.size()) - 1; i >= 0; i--) {\n                    ((JumpData) (this.jumps.get(i))).merge(((JumpData) (lineData.jumps.get(i))));\n                }\n                for (int i = Math.min(this.jumps.size(), lineData.jumps.size()); i < lineData.jumps.size(); i++) {\n                    this.jumps.add(lineData.jumps.get(i));\n                }\n            }\n        }\n        if (lineData.switches != null) {\n            if (this.switches == null) {\n                this.switches = lineData.switches;\n            } else {\n                for (int i = Math.min(this.switches.size(), lineData.switches.size()) - 1; i >= 0; i--) {\n                    ((SwitchData) (this.switches.get(i))).merge(((SwitchData) (lineData.switches.get(i))));\n                }\n                for (int i = Math.min(this.switches.size(), lineData.switches.size()); i < lineData.switches.size(); i++) {\n                    this.switches.add(lineData.switches.get(i));\n                }\n            }\n        }\n        if (lineData.methodName != null) {\n            this.methodName = lineData.methodName;\n        }\n        if (lineData.methodDescriptor != null) {\n            this.methodDescriptor = lineData.methodDescriptor;\n        }\n    } finally {\n    }\n}"}, {"methodBefore": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    LineData lineData = ((LineData) (obj));\n    getBothLocks(lineData);\n    try {\n        return (((((this.hits == lineData.hits) && ((this.jumps == lineData.jumps) || ((this.jumps != null) && this.jumps.equals(lineData.jumps)))) && ((this.switches == lineData.switches) || ((this.switches != null) && this.switches.equals(lineData.switches)))) && (this.lineNumber == lineData.lineNumber)) && this.methodDescriptor.equals(lineData.methodDescriptor)) && this.methodName.equals(lineData.methodName);\n    } finally {\n        lock.unlock();\n        lineData.lock.unlock();\n    }\n}", "methodAfter": "public synchronized boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    LineData lineData = ((LineData) (obj));\n    try {\n        return (((((this.hits == lineData.hits) && ((this.jumps == lineData.jumps) || ((this.jumps != null) && this.jumps.equals(lineData.jumps)))) && ((this.switches == lineData.switches) || ((this.switches != null) && this.switches.equals(lineData.switches)))) && (this.lineNumber == lineData.lineNumber)) && this.methodDescriptor.equals(lineData.methodDescriptor)) && this.methodName.equals(lineData.methodName);\n    } finally {\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_139() {\n    if (jj_3R_166()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_396() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_228() {\n    if (jj_3R_246()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_197() {\n    if (jj_3R_212()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_368() {\n    if (jj_3R_260()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_245() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_266() {\n    if (jj_3R_275()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_256() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_224() {\n    if (jj_3R_242()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_429() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void merge(CoverageData coverageData) {\n    LineData lineData = ((LineData) (coverageData));\n    getBothLocks(lineData);\n    try {\n        this.hits += lineData.hits;\n        if (lineData.jumps != null) {\n            if (this.jumps == null) {\n                this.jumps = lineData.jumps;\n            } else {\n                for (int i = Math.min(this.jumps.size(), lineData.jumps.size()) - 1; i >= 0; i--) {\n                    ((JumpData) (this.jumps.get(i))).merge(((JumpData) (lineData.jumps.get(i))));\n                }\n                for (int i = Math.min(this.jumps.size(), lineData.jumps.size()); i < lineData.jumps.size(); i++) {\n                    this.jumps.add(lineData.jumps.get(i));\n                }\n            }\n        }\n        if (lineData.switches != null) {\n            if (this.switches == null) {\n                this.switches = lineData.switches;\n            } else {\n                for (int i = Math.min(this.switches.size(), lineData.switches.size()) - 1; i >= 0; i--) {\n                    ((SwitchData) (this.switches.get(i))).merge(((SwitchData) (lineData.switches.get(i))));\n                }\n                for (int i = Math.min(this.switches.size(), lineData.switches.size()); i < lineData.switches.size(); i++) {\n                    this.switches.add(lineData.switches.get(i));\n                }\n            }\n        }\n        if (lineData.methodName != null) {\n            this.methodName = lineData.methodName;\n        }\n        if (lineData.methodDescriptor != null) {\n            this.methodDescriptor = lineData.methodDescriptor;\n        }\n    } finally {\n        lock.unlock();\n        lineData.lock.unlock();\n    }\n}", "methodAfter": "public synchronized void merge(CoverageData coverageData) {\n    LineData lineData = ((LineData) (coverageData));\n    try {\n        this.hits += lineData.hits;\n        if (lineData.jumps != null) {\n            if (this.jumps == null) {\n                this.jumps = lineData.jumps;\n            } else {\n                for (int i = Math.min(this.jumps.size(), lineData.jumps.size()) - 1; i >= 0; i--) {\n                    ((JumpData) (this.jumps.get(i))).merge(((JumpData) (lineData.jumps.get(i))));\n                }\n                for (int i = Math.min(this.jumps.size(), lineData.jumps.size()); i < lineData.jumps.size(); i++) {\n                    this.jumps.add(lineData.jumps.get(i));\n                }\n            }\n        }\n        if (lineData.switches != null) {\n            if (this.switches == null) {\n                this.switches = lineData.switches;\n            } else {\n                for (int i = Math.min(this.switches.size(), lineData.switches.size()) - 1; i >= 0; i--) {\n                    ((SwitchData) (this.switches.get(i))).merge(((SwitchData) (lineData.switches.get(i))));\n                }\n                for (int i = Math.min(this.switches.size(), lineData.switches.size()); i < lineData.switches.size(); i++) {\n                    this.switches.add(lineData.switches.get(i));\n                }\n            }\n        }\n        if (lineData.methodName != null) {\n            this.methodName = lineData.methodName;\n        }\n        if (lineData.methodDescriptor != null) {\n            this.methodDescriptor = lineData.methodDescriptor;\n        }\n    } finally {\n    }\n}"}, {"methodBefore": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    LineData lineData = ((LineData) (obj));\n    getBothLocks(lineData);\n    try {\n        return (((((this.hits == lineData.hits) && ((this.jumps == lineData.jumps) || ((this.jumps != null) && this.jumps.equals(lineData.jumps)))) && ((this.switches == lineData.switches) || ((this.switches != null) && this.switches.equals(lineData.switches)))) && (this.lineNumber == lineData.lineNumber)) && this.methodDescriptor.equals(lineData.methodDescriptor)) && this.methodName.equals(lineData.methodName);\n    } finally {\n        lock.unlock();\n        lineData.lock.unlock();\n    }\n}", "methodAfter": "public synchronized boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (!obj.getClass().equals(this.getClass()))) {\n        return false;\n    }\n    LineData lineData = ((LineData) (obj));\n    try {\n        return (((((this.hits == lineData.hits) && ((this.jumps == lineData.jumps) || ((this.jumps != null) && this.jumps.equals(lineData.jumps)))) && ((this.switches == lineData.switches) || ((this.switches != null) && this.switches.equals(lineData.switches)))) && (this.lineNumber == lineData.lineNumber)) && this.methodDescriptor.equals(lineData.methodDescriptor)) && this.methodName.equals(lineData.methodName);\n    } finally {\n    }\n}"}], [{"methodBefore": "public boolean isCovered() {\n    lock.lock();\n    try {\n        return (getHits() > 0) && ((getNumberOfValidBranches() == 0) || ((1.0 - getBranchCoverageRate()) < 1.0E-4));\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized boolean isCovered() {\n    try {\n        return (getHits() > 0) && ((getNumberOfValidBranches() == 0) || ((1.0 - getBranchCoverageRate()) < 1.0E-4));\n    } finally {\n    }\n}"}, {"methodBefore": "public boolean hasBranch() {\n    lock.lock();\n    try {\n        return (jumps != null) || (switches != null);\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized boolean hasBranch() {\n    try {\n        return (jumps != null) || (switches != null);\n    } finally {\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_118() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_128() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_337() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_375() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_117() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_127() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_331() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_369() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_334() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_372() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_123() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_133() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_119() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_129() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_121() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_131() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_321() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_351() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_116() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_126() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_322() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_352() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_333() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_371() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_257() {\n    if (jj_3R_262()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_241() {\n    if (jj_3R_262()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_323() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_361() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_402() {\n    if (jj_3R_413()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_406() {\n    if (jj_3R_413()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_400() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_417() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_183() {\n    if (jj_3R_193()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_171() {\n    if (jj_3R_193()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_185() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_173() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_329() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_367() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean addInstrumentationToArchive(CoberturaFile file, InputStream archive, OutputStream output) throws Exception {\n    ZipInputStream zis = null;\n    ZipOutputStream zos = null;\n    try {\n        zis = new ZipInputStream(archive);\n        zos = new ZipOutputStream(output);\n        return addInstrumentationToArchive(file, zis, zos);\n    } finally {\n        zis = ((ZipInputStream) (IOUtil.closeInputStream(zis)));\n        zos = ((ZipOutputStream) (IOUtil.closeOutputStream(zos)));\n    }\n}", "methodAfter": "private boolean addInstrumentationToArchive(CoberturaFile file, InputStream archive, OutputStream output) throws Throwable {\n    ZipInputStream zis = null;\n    ZipOutputStream zos = null;\n    try {\n        zis = new ZipInputStream(archive);\n        zos = new ZipOutputStream(output);\n        return addInstrumentationToArchive(file, zis, zos);\n    } finally {\n        zis = ((ZipInputStream) (IOUtil.closeInputStream(zis)));\n        zos = ((ZipOutputStream) (IOUtil.closeOutputStream(zos)));\n    }\n}"}, {"methodBefore": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Exception {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n                    cr.accept(cv, 0);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}", "methodAfter": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Throwable {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n                    cr.accept(cv, 0);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}"}], [{"methodBefore": "private final boolean jj_3R_378() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_378() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_100()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3_7() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_85()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_7() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_88()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(AT)) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(\"<thead>\");\n        out.println(\"<tr>\");\n        out.println(\"  <td class=\\\"heading\\\">Package</td>\");\n        out.println(\"  <td class=\\\"heading\\\"># Classes</td>\");\n        out.println(generateCommonTableColumns());\n        out.println(\"</tr>\");\n        out.println(\"</thead>\");\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"LocalizedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        out.println(\"</p>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<p>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeaderForClasses());\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"LocalizedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n            out.println(\"</p>\");\n        }\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Report generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(\"<thead>\");\n        out.println(\"<tr>\");\n        out.println(\"  <td class=\\\"heading\\\">Package</td>\");\n        out.println(\"  <td class=\\\"heading\\\"># Classes</td>\");\n        out.println(generateCommonTableColumns());\n        out.println(\"</tr>\");\n        out.println(\"</thead>\");\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        out.println(\"</p>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<p>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeaderForClasses());\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n            out.println(\"</p>\");\n        }\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Report generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "public int hashCode() {\n    return this.children.size();\n}", "methodAfter": "public int hashCode() {\n    lock.lock();\n    try {\n        return this.children.size();\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getLines() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getLines() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public int getNumberOfChildren() {\n    return this.children.size();\n}", "methodAfter": "public int getNumberOfChildren() {\n    lock.lock();\n    try {\n        return this.children.size();\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getClasses() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getClasses() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getClasses() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getClasses() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getPackages() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getPackages() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public boolean contains(String name) {\n    return this.children.containsKey(name);\n}", "methodAfter": "public boolean contains(String name) {\n    lock.lock();\n    try {\n        return this.children.containsKey(name);\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public boolean contains(String name) {\n    return this.children.containsKey(name);\n}", "methodAfter": "public boolean contains(String name) {\n    lock.lock();\n    try {\n        return this.children.containsKey(name);\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_160() {\n    if (jj_3R_180()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_160() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_409() {\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_409() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public boolean isValidSourceLineNumber(int lineNumber) {\n    return lines.containsKey(new Integer(lineNumber));\n}", "methodAfter": "public boolean isValidSourceLineNumber(int lineNumber) {\n    return children.containsKey(new Integer(lineNumber));\n}"}, {"methodBefore": "private LineData getLineData(int lineNumber) {\n    return ((LineData) (lines.get(new Integer(lineNumber))));\n}", "methodAfter": "private LineData getLineData(int lineNumber) {\n    return ((LineData) (children.get(new Integer(lineNumber))));\n}"}, {"methodBefore": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = lines.values().iterator();\n    while (iter.hasNext()) {\n        LineData next = ((LineData) (iter.next()));\n        if (methodNameAndDescriptor.equals(next.getMethodName() + next.getMethodDescriptor())) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    if (total == 0) {\n        return 1.0;\n    }\n    return ((double) (hits)) / total;\n}", "methodAfter": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = children.values().iterator();\n    while (iter.hasNext()) {\n        LineData next = ((LineData) (iter.next()));\n        if (methodNameAndDescriptor.equals(next.getMethodName() + next.getMethodDescriptor())) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    if (total == 0) {\n        return 1.0;\n    }\n    return ((double) (hits)) / total;\n}"}, {"methodBefore": "public void addLine(int lineNumber, String methodName, String methodDescriptor) {\n    LineData lineData = getLineData(lineNumber);\n    if (lineData == null) {\n        lineData = new LineData(lineNumber);\n        lines.put(new Integer(lineNumber), lineData);\n    }\n    lineData.setMethodNameAndDescriptor(methodName, methodDescriptor);\n    methodNamesAndDescriptors.add(methodName + methodDescriptor);\n}", "methodAfter": "public void addLine(int lineNumber, String methodName, String methodDescriptor) {\n    LineData lineData = getLineData(lineNumber);\n    if (lineData == null) {\n        lineData = new LineData(lineNumber);\n        children.put(new Integer(lineNumber), lineData);\n    }\n    lineData.setMethodNameAndDescriptor(methodName, methodDescriptor);\n    methodNamesAndDescriptors.add(methodName + methodDescriptor);\n}"}], [{"methodBefore": "private final boolean jj_3R_418() {\n    if (jj_3R_423()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_418() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_138() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_138() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_369() {\n    if (jj_3R_261()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_249() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_254() {\n    if (jj_3R_261()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_248() {\n    if (jj_3R_268()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private static boolean trySocket(InetSocketAddress address) {\n    boolean success = false;\n    Socket socket = null;\n    try {\n        socket = new Socket();\n        socket.connect(address);\n        success = true;\n    } catch (ConnectException e) {\n    } catch (Throwable e) {\n        e.printStackTrace();\n    } finally {\n        if ((socket != null) || (!socket.isClosed())) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return success;\n}", "methodAfter": "private static boolean trySocket(InetSocketAddress address) {\n    boolean success = false;\n    Socket socket = null;\n    try {\n        socket = new Socket();\n        socket.connect(address);\n        success = true;\n    } catch (ConnectException e) {\n    } catch (Throwable e) {\n        e.printStackTrace();\n    } finally {\n        if ((socket != null) && (!socket.isClosed())) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return success;\n}"}, {"methodBefore": "private void closeSocket(ServerSocket socket) {\n    try {\n        if ((socket != null) || socket.isClosed()) {\n            socket.close();\n        }\n    } catch (Throwable t) {\n        t.printStackTrace(System.err);\n    }\n}", "methodAfter": "private void closeSocket(ServerSocket socket) {\n    try {\n        if ((socket != null) && socket.isClosed()) {\n            socket.close();\n        }\n    } catch (Throwable t) {\n        t.printStackTrace(System.err);\n    }\n}"}], [{"methodBefore": "public static void saveGlobalProjectData() {\n    ProjectData projectDataToSave = globalProjectData;\n    globalProjectData = new ProjectData();\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n    }\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    FileLocker fileLocker = new FileLocker(dataFile);\n    if (fileLocker.lock()) {\n        ProjectData datafileProjectData = loadCoverageDataFromDatafile(dataFile);\n        if (datafileProjectData == null) {\n            datafileProjectData = projectDataToSave;\n        } else {\n            datafileProjectData.merge(projectDataToSave);\n        }\n        CoverageDataFileHandler.saveCoverageData(datafileProjectData, dataFile);\n    }\n    fileLocker.release();\n}", "methodAfter": "public static void saveGlobalProjectData() {\n    ProjectData projectDataToSave = null;\n    globalProjectDataLock.lock();\n    try {\n        projectDataToSave = globalProjectData;\n        globalProjectData = new ProjectData();\n    } finally {\n        globalProjectDataLock.unlock();\n    }\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n    }\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    FileLocker fileLocker = new FileLocker(dataFile);\n    if (fileLocker.lock()) {\n        ProjectData datafileProjectData = loadCoverageDataFromDatafile(dataFile);\n        if (datafileProjectData == null) {\n            datafileProjectData = projectDataToSave;\n        } else {\n            datafileProjectData.merge(projectDataToSave);\n        }\n        CoverageDataFileHandler.saveCoverageData(datafileProjectData, dataFile);\n    }\n    fileLocker.release();\n}"}, {"methodBefore": "public static void saveGlobalProjectData() {\n    ProjectData projectDataToSave = new ProjectData();\n    TouchCollector.applyTouchesOnProjectData(projectDataToSave);\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    synchronized(dataFile.getPath().intern()) {\n        FileLocker fileLocker = new FileLocker(dataFile);\n        try {\n            if (fileLocker.lock()) {\n                ProjectData datafileProjectData = loadCoverageDataFromDatafile(dataFile);\n                if (datafileProjectData == null) {\n                    datafileProjectData = projectDataToSave;\n                } else {\n                    datafileProjectData.merge(projectDataToSave);\n                }\n                CoverageDataFileHandler.saveCoverageData(datafileProjectData, dataFile);\n            }\n        } finally {\n            fileLocker.release();\n        }\n    }\n}", "methodAfter": "public static void saveGlobalProjectData() {\n    ProjectData projectDataToSave = null;\n    globalProjectDataLock.lock();\n    try {\n        projectDataToSave = getGlobalProjectData();\n        globalProjectData = new ProjectData();\n    } finally {\n        globalProjectDataLock.unlock();\n    }\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n    }\n    TouchCollector.applyTouchesOnProjectData(projectDataToSave);\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    synchronized(dataFile.getPath().intern()) {\n        FileLocker fileLocker = new FileLocker(dataFile);\n        try {\n            if (fileLocker.lock()) {\n                ProjectData datafileProjectData = loadCoverageDataFromDatafile(dataFile);\n                if (datafileProjectData == null) {\n                    datafileProjectData = projectDataToSave;\n                } else {\n                    datafileProjectData.merge(projectDataToSave);\n                }\n                CoverageDataFileHandler.saveCoverageData(datafileProjectData, dataFile);\n            }\n        } finally {\n            fileLocker.release();\n        }\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_122() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_132() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_357() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_254() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_120() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_130() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "protected Java getJava() {\n    if (java == null) {\n        java = ((Java) (getProject().createTask(\"java\")));\n        java.setTaskName(getTaskName());\n        java.setClassname(getClassName());\n        java.setFork(true);\n        java.setDir(getProject().getBaseDir());\n        if (maxMemory != null) {\n            java.setJvmargs(\"-Xmx\" + maxMemory);\n        }\n        if (forkedJVMDebugPort > 0) {\n            java.setJvmargs(\"-Xdebug\");\n            java.setJvmargs((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n        }\n        if (getClass().getClassLoader() instanceof AntClassLoader) {\n            String classpath = ((AntClassLoader) (getClass().getClassLoader())).getClasspath();\n            createClasspath().setPath(StringUtil.replaceAll(classpath, \"%20\", \" \"));\n        } else if (getClass().getClassLoader() instanceof URLClassLoader) {\n            URL[] earls = ((URLClassLoader) (getClass().getClassLoader())).getURLs();\n            for (int i = 0; i < earls.length; i++) {\n                String classpath = new File(earls[i].getFile()).getAbsolutePath();\n                createClasspath().setPath(StringUtil.replaceAll(classpath, \"%20\", \" \"));\n            }\n        }\n    }\n    return java;\n}", "methodAfter": "protected Java getJava() {\n    if (java == null) {\n        java = ((Java) (getProject().createTask(\"java\")));\n        java.setTaskName(getTaskName());\n        java.setClassname(getClassName());\n        java.setFork(true);\n        java.setFailonerror(failOnError);\n        java.setDir(getProject().getBaseDir());\n        if (maxMemory != null) {\n            java.setJvmargs(\"-Xmx\" + maxMemory);\n        }\n        if (forkedJVMDebugPort > 0) {\n            java.setJvmargs(\"-Xdebug\");\n            java.setJvmargs((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n        }\n        if (getClass().getClassLoader() instanceof AntClassLoader) {\n            String classpath = ((AntClassLoader) (getClass().getClassLoader())).getClasspath();\n            createClasspath().setPath(StringUtil.replaceAll(classpath, \"%20\", \" \"));\n        } else if (getClass().getClassLoader() instanceof URLClassLoader) {\n            URL[] earls = ((URLClassLoader) (getClass().getClassLoader())).getURLs();\n            for (int i = 0; i < earls.length; i++) {\n                String classpath = new File(earls[i].getFile()).getAbsolutePath();\n                createClasspath().setPath(StringUtil.replaceAll(classpath, \"%20\", \" \"));\n            }\n        }\n    }\n    return java;\n}"}, {"methodBefore": "private static void runTestAntScript(String testName, String target) throws IOException {\n    Java java = new Java();\n    java.setProject(project);\n    java.setTaskName(\"java\");\n    java.setClassname(\"org.apache.tools.ant.launch.Launcher\");\n    java.setFork(true);\n    AntUtil.transferCoberturaDataFileProperty(java);\n    if (forkedJVMDebugPort > 0) {\n        java.createJvmarg().setValue(\"-Xdebug\");\n        java.createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    java.createArg().setValue(\"-f\");\n    java.createArg().setValue(BASEDIR + \"/build.xml\");\n    java.createArg().setValue(target);\n    java.setFailonerror(true);\n    File output = Util.createTemporaryTextFile(\"cobertura-test\");\n    java.setOutput(output);\n    Path classpath = new Path(TestUtils.project);\n    PathElement pathElement = classpath.new PathElement();\n    pathElement.setPath(System.getProperty(\"java.class.path\"));\n    classpath.add(TestUtils.getCoberturaDefaultClasspath());\n    classpath.add(pathElement);\n    java.setClasspath(classpath);\n    try {\n        java.executeJava();\n    } finally {\n        if (output.exists()) {\n            System.out.println((((\"\\n\\n\\nOutput from Ant for \" + testName) + \" test:\\n----------------------------------------\\n\") + Util.getText(output)) + \"----------------------------------------\");\n            output.delete();\n        }\n    }\n}", "methodAfter": "private static void runTestAntScript(String testName, String target) throws IOException {\n    Java java = new Java();\n    java.setProject(project);\n    java.setTaskName(\"java\");\n    java.setClassname(\"org.apache.tools.ant.launch.Launcher\");\n    java.setFork(true);\n    AntUtil.transferCoberturaDataFileProperty(java);\n    if (forkedJVMDebugPort > 0) {\n        java.createJvmarg().setValue(\"-Xdebug\");\n        java.createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    java.createArg().setValue(\"-f\");\n    java.createArg().setValue(BASEDIR + \"/build.xml\");\n    java.createArg().setValue(target);\n    java.setFailonerror(true);\n    File output = Util.createTemporaryTextFile(\"cobertura-test\");\n    java.setOutput(output);\n    java.setFailonerror(true);\n    Path classpath = new Path(TestUtils.project);\n    PathElement pathElement = classpath.new PathElement();\n    pathElement.setPath(System.getProperty(\"java.class.path\"));\n    classpath.add(TestUtils.getCoberturaDefaultClasspath());\n    classpath.add(pathElement);\n    java.setClasspath(classpath);\n    try {\n        java.executeJava();\n    } finally {\n        if (output.exists()) {\n            System.out.println((((\"\\n\\n\\nOutput from Ant for \" + testName) + \" test:\\n----------------------------------------\\n\") + Util.getText(output)) + \"----------------------------------------\");\n            output.delete();\n        }\n    }\n}"}], [{"methodBefore": "private void addInstrumentationToArchive(ZipInputStream archive, ZipOutputStream output) throws Exception {\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (isClass(entry)) {\n                ClassReader cr = new ClassReader(entryBytes);\n                ClassWriter cw = new ClassWriter(true);\n                ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegex);\n                cr.accept(cv, false);\n                if (cv.isInstrumented()) {\n                    logger.debug(\"Putting instrumeted entry: \" + entry.getName());\n                    entryBytes = cw.toByteArray();\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry);\n            throw e;\n        }\n        output.flush();\n    } \n}", "methodAfter": "private void addInstrumentationToArchive(ZipInputStream archive, ZipOutputStream output) throws Exception {\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (isClass(entry)) {\n                ClassReader cr = new ClassReader(entryBytes);\n                ClassWriter cw = new ClassWriter(true);\n                ClassInstrumenter cv = new ClassInstrumenter(this.projectData, cw, this.ignoreRegexs);\n                cr.accept(cv, false);\n                if (cv.isInstrumented()) {\n                    logger.debug(\"Putting instrumeted entry: \" + entry.getName());\n                    entryBytes = cw.toByteArray();\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry);\n            throw e;\n        }\n        output.flush();\n    } \n}"}, {"methodBefore": "private void addInstrumentationToSingleClass(File file) {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(true);\n        cv = new ClassInstrumenter(projectData, cw, ignoreRegex);\n        cr.accept(cv, false);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (IOException e) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), e);\n        return;\n    } finally {\n        if (outputStream != null) {\n            try {\n                outputStream.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}", "methodAfter": "private void addInstrumentationToSingleClass(File file) {\n    logger.debug(\"Instrumenting class \" + file.getAbsolutePath());\n    InputStream inputStream = null;\n    ClassWriter cw;\n    ClassInstrumenter cv;\n    try {\n        inputStream = new FileInputStream(file);\n        ClassReader cr = new ClassReader(inputStream);\n        cw = new ClassWriter(true);\n        cv = new ClassInstrumenter(this.projectData, cw, this.ignoreRegexs);\n        cr.accept(cv, false);\n    } catch (Throwable t) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), t);\n        return;\n    } finally {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n    OutputStream outputStream = null;\n    try {\n        if (cv.isInstrumented()) {\n            File outputFile;\n            if (destinationDirectory == null) {\n                outputFile = file;\n            } else {\n                outputFile = new File(destinationDirectory, cv.getClassName().replace('.', File.separatorChar) + \".class\");\n            }\n            File parentFile = outputFile.getParentFile();\n            if (parentFile != null) {\n                parentFile.mkdirs();\n            }\n            byte[] instrumentedClass = cw.toByteArray();\n            outputStream = new FileOutputStream(outputFile);\n            outputStream.write(instrumentedClass);\n        }\n    } catch (IOException e) {\n        logger.warn(\"Unable to instrument file \" + file.getAbsolutePath(), e);\n        return;\n    } finally {\n        if (outputStream != null) {\n            try {\n                outputStream.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_289() {\n    if (jj_3R_133()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_287() {\n    if (jj_3R_290()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_228() {\n    if (jj_3R_246()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_197() {\n    if (jj_3R_212()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_266() {\n    if (jj_3R_275()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_256() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_269() {\n    if (jj_3R_279()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_252() {\n    if (jj_3R_272()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_231() {\n    if (jj_3R_249()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_210() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_208() {\n    if (jj_3R_206()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_204() {\n    if (jj_3R_217()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_139() {\n    if (jj_3R_166()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_396() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_226() {\n    if (jj_3R_244()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_426() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_368() {\n    if (jj_3R_260()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_245() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_224() {\n    if (jj_3R_242()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_429() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public int getNumberOfValidBranches() {\n    int ret = 0;\n    lock.lock();\n    try {\n        if (jumps != null) {\n            for (int i = jumps.size() - 1; i >= 0; i--) {\n                ret += ((JumpData) (jumps.get(i))).getNumberOfValidBranches();\n            }\n        }\n        if (switches != null) {\n            for (int i = switches.size() - 1; i >= 0; i--) {\n                ret += ((SwitchData) (switches.get(i))).getNumberOfValidBranches();\n            }\n        }\n        return ret;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized int getNumberOfValidBranches() {\n    int ret = 0;\n    try {\n        if (jumps != null) {\n            for (int i = jumps.size() - 1; i >= 0; i--) {\n                ret += ((JumpData) (jumps.get(i))).getNumberOfValidBranches();\n            }\n        }\n        if (switches != null) {\n            for (int i = switches.size() - 1; i >= 0; i--) {\n                ret += ((SwitchData) (switches.get(i))).getNumberOfValidBranches();\n            }\n        }\n        return ret;\n    } finally {\n    }\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int ret = 0;\n    lock.lock();\n    try {\n        if (jumps != null) {\n            for (int i = jumps.size() - 1; i >= 0; i--) {\n                ret += ((JumpData) (jumps.get(i))).getNumberOfCoveredBranches();\n            }\n        }\n        if (switches != null) {\n            for (int i = switches.size() - 1; i >= 0; i--) {\n                ret += ((SwitchData) (switches.get(i))).getNumberOfCoveredBranches();\n            }\n        }\n        return ret;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public synchronized int getNumberOfCoveredBranches() {\n    int ret = 0;\n    try {\n        if (jumps != null) {\n            for (int i = jumps.size() - 1; i >= 0; i--) {\n                ret += ((JumpData) (jumps.get(i))).getNumberOfCoveredBranches();\n            }\n        }\n        if (switches != null) {\n            for (int i = switches.size() - 1; i >= 0; i--) {\n                ret += ((SwitchData) (switches.get(i))).getNumberOfCoveredBranches();\n            }\n        }\n        return ret;\n    } finally {\n    }\n}"}], [{"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreBranchesRegexs.size(); i++) {\n            IgnoreBranches ignoreBranchesRegex = ((IgnoreBranches) (ignoreBranchesRegexs.get(i)));\n            builder.addArg(\"--ignoreBranches\", ignoreBranchesRegex.getRegex());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (failOnError) {\n            builder.addArg(\"--failOnError\");\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreBranchesRegexs.size(); i++) {\n            IgnoreBranches ignoreBranchesRegex = ((IgnoreBranches) (ignoreBranchesRegexs.get(i)));\n            builder.addArg(\"--ignoreBranches\", ignoreBranchesRegex.getRegex());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (ignoreTrivial) {\n            builder.addArg(\"--ignoreTrivial\");\n        }\n        if (failOnError) {\n            builder.addArg(\"--failOnError\");\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}"}, {"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreBranchesRegexs.size(); i++) {\n            IgnoreBranches ignoreBranchesRegex = ((IgnoreBranches) (ignoreBranchesRegexs.get(i)));\n            builder.addArg(\"--ignoreBranches\", ignoreBranchesRegex.getRegex());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < ignoreBranchesRegexs.size(); i++) {\n            IgnoreBranches ignoreBranchesRegex = ((IgnoreBranches) (ignoreBranchesRegexs.get(i)));\n            builder.addArg(\"--ignoreBranches\", ignoreBranchesRegex.getRegex());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (failOnError) {\n            builder.addArg(\"--failOnError\");\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}"}], [{"methodBefore": "SwitchData getSwitchData(int switchNumber, SwitchData data) {\n    lock.lock();\n    try {\n        if (switches == null) {\n            switches = new ArrayList();\n        }\n        if (switches.size() < switchNumber) {\n            for (int i = switches.size(); i < switchNumber; switches.add(new SwitchData(i++)));\n        }\n        if (switches.size() == switchNumber) {\n            if (data != null) {\n                switches.add(data);\n            } else {\n                switches.add(new SwitchData(switchNumber));\n            }\n        }\n        return ((SwitchData) (switches.get(switchNumber)));\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "synchronized SwitchData getSwitchData(int switchNumber, SwitchData data) {\n    try {\n        if (switches == null) {\n            switches = new ArrayList();\n        }\n        if (switches.size() < switchNumber) {\n            for (int i = switches.size(); i < switchNumber; switches.add(new SwitchData(i++)));\n        }\n        if (switches.size() == switchNumber) {\n            if (data != null) {\n                switches.add(data);\n            } else {\n                switches.add(new SwitchData(switchNumber));\n            }\n        }\n        return ((SwitchData) (switches.get(switchNumber)));\n    } finally {\n    }\n}"}, {"methodBefore": "JumpData getJumpData(int jumpNumber) {\n    lock.lock();\n    try {\n        if (jumps == null) {\n            jumps = new ArrayList();\n        }\n        if (jumps.size() <= jumpNumber) {\n            for (int i = jumps.size(); i <= jumpNumber; jumps.add(new JumpData(i++)));\n        }\n        return ((JumpData) (jumps.get(jumpNumber)));\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "synchronized JumpData getJumpData(int jumpNumber) {\n    try {\n        if (jumps == null) {\n            jumps = new ArrayList();\n        }\n        if (jumps.size() <= jumpNumber) {\n            for (int i = jumps.size(); i <= jumpNumber; jumps.add(new JumpData(i++)));\n        }\n        return ((JumpData) (jumps.get(jumpNumber)));\n    } finally {\n    }\n}"}], [{"methodBefore": "public void assignCounterIds() {\n    AtomicInteger idGenerator = new AtomicInteger(0);\n    for (List<TouchPointDescriptor> tpd : currentLine2touchPoints.values()) {\n        for (TouchPointDescriptor t : tpd) {\n            t.assignCounters(idGenerator);\n        }\n    }\n    maxCounterId = idGenerator.get();\n}", "methodAfter": "public void assignCounterIds() {\n    AtomicInteger idGenerator = new AtomicInteger(0);\n    for (List<TouchPointDescriptor> tpd : line2touchPoints.values()) {\n        for (TouchPointDescriptor t : tpd) {\n            t.assignCounters(idGenerator);\n        }\n    }\n    maxCounterId = idGenerator.get();\n}"}, {"methodBefore": "public void unregisterLine(int eventId, int currentLine) {\n    if (alreadyRegisteredEvents.add(eventId)) {\n        blockedLines.add(currentLine);\n        List<TouchPointDescriptor> res = currentLine2touchPoints.get(currentLine);\n        if (res != null) {\n            Iterator<TouchPointDescriptor> iter = res.iterator();\n            while (iter.hasNext()) {\n                TouchPointDescriptor desc = iter.next();\n                if (desc instanceof LineTouchPointDescriptor) {\n                    iter.remove();\n                    eventId2touchPointDescriptor.remove(desc.getEventId());\n                    eventId2label.remove(desc.getEventId());\n                }\n            } \n        }\n    }\n}", "methodAfter": "public void unregisterLine(int eventId, int currentLine) {\n    if (alreadyRegisteredEvents.add(eventId)) {\n        blockedLines.add(currentLine);\n        List<TouchPointDescriptor> res = line2touchPoints.get(currentLine);\n        if (res != null) {\n            Iterator<TouchPointDescriptor> iter = res.iterator();\n            while (iter.hasNext()) {\n                TouchPointDescriptor desc = iter.next();\n                if (desc instanceof LineTouchPointDescriptor) {\n                    iter.remove();\n                    eventId2touchPointDescriptor.remove(desc.getEventId());\n                    eventId2label.remove(desc.getEventId());\n                }\n            } \n        }\n    }\n}"}, {"methodBefore": "public List<TouchPointDescriptor> getTouchPointsInLineOrder() {\n    LinkedList<TouchPointDescriptor> res = new LinkedList<TouchPointDescriptor>();\n    for (List<TouchPointDescriptor> tpd : currentLine2touchPoints.values()) {\n        for (TouchPointDescriptor t : tpd) {\n            if (tpd instanceof LineTouchPointDescriptor) {\n                res.add(t);\n            }\n        }\n        for (TouchPointDescriptor t : tpd) {\n            if (!(tpd instanceof LineTouchPointDescriptor)) {\n                res.add(t);\n            }\n        }\n    }\n    return res;\n}", "methodAfter": "public List<TouchPointDescriptor> getTouchPointsInLineOrder() {\n    LinkedList<TouchPointDescriptor> res = new LinkedList<TouchPointDescriptor>();\n    for (List<TouchPointDescriptor> tpd : line2touchPoints.values()) {\n        for (TouchPointDescriptor t : tpd) {\n            if (tpd instanceof LineTouchPointDescriptor) {\n                res.add(t);\n            }\n        }\n        for (TouchPointDescriptor t : tpd) {\n            if (!(tpd instanceof LineTouchPointDescriptor)) {\n                res.add(t);\n            }\n        }\n    }\n    return res;\n}"}], [{"methodBefore": "private final boolean jj_3R_376() {\n    if (jj_3R_364()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_376() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_360() {\n    if (jj_3R_279()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_360() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public static void saveGlobalProjectData() {\n    ProjectData projectDataToSave = null;\n    globalProjectDataLock.lock();\n    try {\n        projectDataToSave = globalProjectData;\n        globalProjectData = new ProjectData();\n    } finally {\n        globalProjectDataLock.unlock();\n    }\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n    }\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    FileLocker fileLocker = new FileLocker(dataFile);\n    if (fileLocker.lock()) {\n        ProjectData datafileProjectData = loadCoverageDataFromDatafile(dataFile);\n        if (datafileProjectData == null) {\n            datafileProjectData = projectDataToSave;\n        } else {\n            datafileProjectData.merge(projectDataToSave);\n        }\n        CoverageDataFileHandler.saveCoverageData(datafileProjectData, dataFile);\n    }\n    fileLocker.release();\n}", "methodAfter": "public static void saveGlobalProjectData() {\n    ProjectData projectDataToSave = null;\n    globalProjectDataLock.lock();\n    try {\n        projectDataToSave = globalProjectData;\n        globalProjectData = new ProjectData();\n    } finally {\n        globalProjectDataLock.unlock();\n    }\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n    }\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    FileLocker fileLocker = new FileLocker(dataFile);\n    try {\n        if (fileLocker.lock()) {\n            ProjectData datafileProjectData = loadCoverageDataFromDatafile(dataFile);\n            if (datafileProjectData == null) {\n                datafileProjectData = projectDataToSave;\n            } else {\n                datafileProjectData.merge(projectDataToSave);\n            }\n            CoverageDataFileHandler.saveCoverageData(datafileProjectData, dataFile);\n        }\n    } finally {\n        fileLocker.release();\n        fileLocker.delete();\n    }\n}"}, {"methodBefore": "public static void saveGlobalProjectData() {\n    ProjectData projectDataToSave = null;\n    globalProjectDataLock.lock();\n    try {\n        projectDataToSave = globalProjectData;\n        globalProjectData = new ProjectData();\n    } finally {\n        globalProjectDataLock.unlock();\n    }\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n    }\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    FileLocker fileLocker = new FileLocker(dataFile);\n    try {\n        if (fileLocker.lock()) {\n            ProjectData datafileProjectData = loadCoverageDataFromDatafile(dataFile);\n            if (datafileProjectData == null) {\n                datafileProjectData = projectDataToSave;\n            } else {\n                datafileProjectData.merge(projectDataToSave);\n            }\n            CoverageDataFileHandler.saveCoverageData(datafileProjectData, dataFile);\n        }\n    } finally {\n        fileLocker.release();\n    }\n}", "methodAfter": "public static void saveGlobalProjectData() {\n    ProjectData projectDataToSave = null;\n    globalProjectDataLock.lock();\n    try {\n        projectDataToSave = globalProjectData;\n        globalProjectData = new ProjectData();\n    } finally {\n        globalProjectDataLock.unlock();\n    }\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n    }\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    synchronized(dataFile.getPath().intern()) {\n        FileLocker fileLocker = new FileLocker(dataFile);\n        try {\n            if (fileLocker.lock()) {\n                ProjectData datafileProjectData = loadCoverageDataFromDatafile(dataFile);\n                if (datafileProjectData == null) {\n                    datafileProjectData = projectDataToSave;\n                } else {\n                    datafileProjectData.merge(projectDataToSave);\n                }\n                CoverageDataFileHandler.saveCoverageData(datafileProjectData, dataFile);\n            }\n        } finally {\n            fileLocker.release();\n        }\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_153() {\n    if (jj_3R_177()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_385() {\n    if (jj_3R_407()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_139() {\n    if (jj_3R_166()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_396() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_79() {\n    if (jj_3R_131()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_436() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_292() {\n    if (jj_3R_326()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_247() {\n    if (jj_3R_267()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_293() {\n    if (jj_3R_326()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_246() {\n    if (jj_3R_266()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3_51() {\n    if (jj_3R_127()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_54() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3_53() {\n    if (jj_3R_127()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_32() {\n    if (jj_3R_112()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_313() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_213() {\n    if (jj_3R_227()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_327() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_322() {\n    if (jj_3R_356()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private final boolean jj_3R_393() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_93() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_97() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_91() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "String getMethodName() {\n    return methodName;\n}", "methodAfter": "public String getMethodName() {\n    return methodName;\n}"}, {"methodBefore": "int getLineNumber() {\n    return lineNumber;\n}", "methodAfter": "public int getLineNumber() {\n    return lineNumber;\n}"}, {"methodBefore": "long getHits() {\n    return hits;\n}", "methodAfter": "public long getHits() {\n    return hits;\n}"}, {"methodBefore": "String getMethodDescriptor() {\n    return methodDescriptor;\n}", "methodAfter": "public String getMethodDescriptor() {\n    return methodDescriptor;\n}"}, {"methodBefore": "boolean isBranch() {\n    return isBranch;\n}", "methodAfter": "public boolean isBranch() {\n    return isBranch;\n}"}], [{"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (toDir != null) {\n            builder.addArg(\"--destination\", toDir.getAbsolutePath());\n        }\n        for (int i = 0; i < ignoreRegexs.size(); i++) {\n            Ignore ignoreRegex = ((Ignore) (ignoreRegexs.get(i)));\n            builder.addArg(\"--ignore\", ignoreRegex.getRegex());\n        }\n        for (int i = 0; i < includeClassesRegexs.size(); i++) {\n            IncludeClasses includeClassesRegex = ((IncludeClasses) (includeClassesRegexs.get(i)));\n            builder.addArg(\"--includeClasses\", includeClassesRegex.getRegex());\n        }\n        for (int i = 0; i < excludeClassesRegexs.size(); i++) {\n            ExcludeClasses excludeClassesRegex = ((ExcludeClasses) (excludeClassesRegexs.get(i)));\n            builder.addArg(\"--excludeClasses\", excludeClassesRegex.getRegex());\n        }\n        if (instrumentationClasspath != null) {\n            processInstrumentationClasspath();\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if ((forkedJVMDebugPort != null) && (forkedJVMDebugPort.intValue() > 0)) {\n        getJava().createJvmarg().setValue(\"-Xdebug\");\n        getJava().createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    builder.dispose();\n}"}, {"methodBefore": "private static void runTestAntScript(String testName, String target) throws IOException {\n    Java task = new Java();\n    task.setTaskName(\"java\");\n    task.setProject(new Project());\n    task.init();\n    task.setClassname(\"org.apache.tools.ant.launch.Launcher\");\n    task.setFork(true);\n    InstrumentTask.transferCoberturaDataFileProperty(task);\n    task.createArg().setValue(\"-f\");\n    task.createArg().setValue(BASEDIR + \"/build.xml\");\n    task.createArg().setValue(target);\n    task.setFailonerror(true);\n    File outputFile = Util.createTemporaryTextFile(\"cobertura-test\");\n    task.setOutput(outputFile);\n    Path classpath = task.createClasspath();\n    PathElement pathElement = classpath.createPathElement();\n    pathElement.setPath(System.getProperty(\"java.class.path\"));\n    try {\n        task.execute();\n    } finally {\n        if (outputFile.exists()) {\n            System.out.println((((\"\\n\\n\\nOutput from Ant for \" + testName) + \" test:\\n----------------------------------------\\n\") + Util.getText(outputFile)) + \"----------------------------------------\");\n            outputFile.delete();\n        }\n    }\n}", "methodAfter": "private static void runTestAntScript(String testName, String target) throws IOException {\n    Java task = new Java();\n    task.setTaskName(\"java\");\n    task.setProject(new Project());\n    task.init();\n    task.setClassname(\"org.apache.tools.ant.launch.Launcher\");\n    task.setFork(true);\n    AntUtil.transferCoberturaDataFileProperty(task);\n    task.createArg().setValue(\"-f\");\n    task.createArg().setValue(BASEDIR + \"/build.xml\");\n    task.createArg().setValue(target);\n    task.setFailonerror(true);\n    File outputFile = Util.createTemporaryTextFile(\"cobertura-test\");\n    task.setOutput(outputFile);\n    Path classpath = task.createClasspath();\n    PathElement pathElement = classpath.createPathElement();\n    pathElement.setPath(System.getProperty(\"java.class.path\"));\n    try {\n        task.execute();\n    } finally {\n        if (outputFile.exists()) {\n            System.out.println((((\"\\n\\n\\nOutput from Ant for \" + testName) + \" test:\\n----------------------------------------\\n\") + Util.getText(outputFile)) + \"----------------------------------------\");\n            outputFile.delete();\n        }\n    }\n}"}], [{"methodBefore": "public boolean isValidSourceLineNumber(int lineNumber) {\n    return children.containsKey(new Integer(lineNumber));\n}", "methodAfter": "public boolean isValidSourceLineNumber(int lineNumber) {\n    lock.lock();\n    try {\n        return children.containsKey(Integer.valueOf(lineNumber));\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public boolean hasBranch(int lineNumber) {\n    return branches.containsKey(new Integer(lineNumber));\n}", "methodAfter": "public boolean hasBranch(int lineNumber) {\n    lock.lock();\n    try {\n        return branches.containsKey(Integer.valueOf(lineNumber));\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private final boolean jj_3R_231() {\n    if (jj_3R_249()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_210() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_140() {\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_104() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public double getLineCoverageRate(String methodNameAndSignature) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = lines.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndSignature)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}", "methodAfter": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = lines.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndDescriptor)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}"}, {"methodBefore": "public double getBranchCoverageRate(String methodNameAndSignature) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = conditionals.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndSignature)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}", "methodAfter": "public double getBranchCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = conditionals.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndDescriptor)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}"}], [{"methodBefore": "private final boolean jj_3R_316() {\n    if (jj_scan_token(EXTENDS)) {\n        return true;\n    }\n    if (jj_3R_325()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_316() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3R_340() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_93()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_340() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void addLineSwitch(int lineNumber, int switchNumber, int min, int max) {\n    LineData lineData = getLineData(lineNumber);\n    if (lineData != null) {\n        lineData.addSwitch(switchNumber, min, max);\n        this.branches.put(new Integer(lineNumber), lineData);\n    }\n}", "methodAfter": "public void addLineSwitch(int lineNumber, int switchNumber, int min, int max) {\n    lock.lock();\n    try {\n        LineData lineData = getLineData(lineNumber);\n        if (lineData != null) {\n            lineData.addSwitch(switchNumber, min, max);\n            this.branches.put(Integer.valueOf(lineNumber), lineData);\n        }\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public void addLineSwitch(int lineNumber, int switchNumber, int[] keys) {\n    LineData lineData = getLineData(lineNumber);\n    if (lineData != null) {\n        lineData.addSwitch(switchNumber, keys);\n        this.branches.put(new Integer(lineNumber), lineData);\n    }\n}", "methodAfter": "public void addLineSwitch(int lineNumber, int switchNumber, int[] keys) {\n    lock.lock();\n    try {\n        LineData lineData = getLineData(lineNumber);\n        if (lineData != null) {\n            lineData.addSwitch(switchNumber, keys);\n            this.branches.put(Integer.valueOf(lineNumber), lineData);\n        }\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private static void runTestAntScript(String testName, String target) throws IOException {\n    Java java = new Java();\n    java.setProject(project);\n    java.setTaskName(\"java\");\n    java.setClassname(\"org.apache.tools.ant.launch.Launcher\");\n    java.setFork(true);\n    AntUtil.transferCoberturaDataFileProperty(java);\n    if (forkedJVMDebugPort > 0) {\n        java.createJvmarg().setValue(\"-Xdebug\");\n        java.createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    java.createArg().setValue(\"-f\");\n    java.createArg().setValue(BASEDIR + \"/build.xml\");\n    java.createArg().setValue(target);\n    java.setFailonerror(true);\n    File output = Util.createTemporaryTextFile(\"cobertura-test\");\n    java.setOutput(output);\n    Path classpath = new Path(TestUtils.project);\n    PathElement pathElement = classpath.new PathElement();\n    pathElement.setPath(System.getProperty(\"java.class.path\"));\n    classpath.add(TestUtils.getCoberturaDefaultClasspath());\n    classpath.add(pathElement);\n    java.setClasspath(classpath);\n    try {\n        java.executeJava();\n    } finally {\n        if (output.exists()) {\n            System.out.println((((\"\\n\\n\\nOutput from Ant for \" + testName) + \" test:\\n----------------------------------------\\n\") + Util.getText(output)) + \"----------------------------------------\");\n            output.delete();\n        }\n    }\n}", "methodAfter": "private static void runTestAntScript(String testName, String target) throws IOException {\n    Java java = new Java();\n    java.setProject(project);\n    java.setTaskName(\"java\");\n    java.setClassname(\"org.apache.tools.ant.launch.Launcher\");\n    java.setFork(true);\n    AntUtil.transferCoberturaDataFileProperty(java);\n    if (forkedJVMDebugPort > 0) {\n        java.createJvmarg().setValue(\"-Xdebug\");\n        java.createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    java.createArg().setValue(\"-f\");\n    java.createArg().setValue(BASEDIR + \"/build.xml\");\n    java.createArg().setValue(target);\n    java.setFailonerror(true);\n    File output = Util.createTemporaryTextFile(\"cobertura-test\");\n    java.setOutput(output);\n    java.setFailonerror(true);\n    Path classpath = new Path(TestUtils.project);\n    PathElement pathElement = classpath.new PathElement();\n    pathElement.setPath(System.getProperty(\"java.class.path\"));\n    classpath.add(TestUtils.getCoberturaDefaultClasspath());\n    classpath.add(pathElement);\n    java.setClasspath(classpath);\n    try {\n        java.executeJava();\n    } finally {\n        if (output.exists()) {\n            System.out.println((((\"\\n\\n\\nOutput from Ant for \" + testName) + \" test:\\n----------------------------------------\\n\") + Util.getText(output)) + \"----------------------------------------\");\n            output.delete();\n        }\n    }\n}"}, {"methodBefore": "protected Java getJava() {\n    if (java == null) {\n        java = ((Java) (getProject().createTask(\"java\")));\n        java.setTaskName(getTaskName());\n        java.setClassname(getClassName());\n        java.setFork(true);\n        java.setDir(getProject().getBaseDir());\n        if (maxMemory != null) {\n            java.setJvmargs(\"-Xmx\" + maxMemory);\n        }\n        if (forkedJVMDebugPort > 0) {\n            java.setJvmargs(\"-Xdebug\");\n            java.setJvmargs((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n        }\n        if (getClass().getClassLoader() instanceof AntClassLoader) {\n            String classpath = ((AntClassLoader) (getClass().getClassLoader())).getClasspath();\n            createClasspath().setPath(StringUtil.replaceAll(classpath, \"%20\", \" \"));\n        } else if (getClass().getClassLoader() instanceof URLClassLoader) {\n            URL[] earls = ((URLClassLoader) (getClass().getClassLoader())).getURLs();\n            for (int i = 0; i < earls.length; i++) {\n                String classpath = new File(earls[i].getFile()).getAbsolutePath();\n                createClasspath().setPath(StringUtil.replaceAll(classpath, \"%20\", \" \"));\n            }\n        }\n    }\n    return java;\n}", "methodAfter": "protected Java getJava() {\n    if (java == null) {\n        java = ((Java) (getProject().createTask(\"java\")));\n        java.setTaskName(getTaskName());\n        java.setClassname(getClassName());\n        java.setFork(true);\n        java.setFailonerror(failOnError);\n        java.setDir(getProject().getBaseDir());\n        if (maxMemory != null) {\n            java.setJvmargs(\"-Xmx\" + maxMemory);\n        }\n        if (forkedJVMDebugPort > 0) {\n            java.setJvmargs(\"-Xdebug\");\n            java.setJvmargs((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n        }\n        if (getClass().getClassLoader() instanceof AntClassLoader) {\n            String classpath = ((AntClassLoader) (getClass().getClassLoader())).getClasspath();\n            createClasspath().setPath(StringUtil.replaceAll(classpath, \"%20\", \" \"));\n        } else if (getClass().getClassLoader() instanceof URLClassLoader) {\n            URL[] earls = ((URLClassLoader) (getClass().getClassLoader())).getURLs();\n            for (int i = 0; i < earls.length; i++) {\n                String classpath = new File(earls[i].getFile()).getAbsolutePath();\n                createClasspath().setPath(StringUtil.replaceAll(classpath, \"%20\", \" \"));\n            }\n        }\n    }\n    return java;\n}"}], [{"methodBefore": "private final boolean jj_3R_409() {\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_409() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private final boolean jj_3_20() {\n    if (jj_3R_96()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_20() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public String getMethodName() {\n    return methodName;\n}", "methodAfter": "public String getMethodName() {\n    lock.lock();\n    try {\n        return methodName;\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public String getMethodDescriptor() {\n    return methodDescriptor;\n}", "methodAfter": "public String getMethodDescriptor() {\n    lock.lock();\n    try {\n        return methodDescriptor;\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_396() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_297() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_133() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_136() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_103() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_152()) {\n        jj_scanpos = xsp;\n        if (jj_3R_153()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_104() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_152()) {\n        jj_scanpos = xsp;\n        if (jj_3R_153()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_352() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_350() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_62() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_60() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_234() {\n    if (jj_3R_258()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_235() {\n    if (jj_3R_258()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_367() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_364() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_126() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_355() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_30() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_29() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_178() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_177() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_44() {\n    if (jj_3R_119()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_37() {\n    if (jj_3R_119()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_360() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_363() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_396() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_297() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_139() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_142() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_174() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_175() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_367() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_364() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_275() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_278() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_133() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_136() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_173() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_174() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_410() {\n    if (jj_3R_416()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_409() {\n    if (jj_3R_416()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_299() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_404() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_359() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_354() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_351() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_378() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_249() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_247() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_103() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_152()) {\n        jj_scanpos = xsp;\n        if (jj_3R_153()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_104() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_152()) {\n        jj_scanpos = xsp;\n        if (jj_3R_153()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_252() {\n    if (jj_3R_272()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_250() {\n    if (jj_3R_272()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_139() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_142() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_172() {\n    if (jj_3R_194()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_169() {\n    if (jj_3R_194()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_250() {\n    if (jj_3R_270()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_248() {\n    if (jj_3R_270()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_365() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_362() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_346() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_349() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_172() {\n    if (jj_3R_194()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_169() {\n    if (jj_3R_194()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_374() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_377() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_174() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_175() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_178() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_177() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_365() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_362() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_393() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_396() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_247() {\n    if (jj_3R_267()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_245() {\n    if (jj_3R_267()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_347() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_379() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_245() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_242() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_36() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_scan_token(THIS)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_35() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_scan_token(THIS)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_352() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_350() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_32() {\n    if (jj_3R_112()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_26() {\n    if (jj_3R_112()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_393() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_396() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_254() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_252() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_126() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_355() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_410() {\n    if (jj_3R_416()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_409() {\n    if (jj_3R_416()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_359() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_354() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_188() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_447() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_251() {\n    if (jj_3R_271()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_249() {\n    if (jj_3R_271()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_351() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_378() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_380() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_383() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_27() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_108() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_188() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_447() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_30() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_29() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_27() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_108() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_44() {\n    if (jj_3R_119()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_37() {\n    if (jj_3R_119()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_132() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_135() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_275() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_278() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_234() {\n    if (jj_3R_258()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_235() {\n    if (jj_3R_258()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_253() {\n    if (jj_3R_273()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_251() {\n    if (jj_3R_273()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_62() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_60() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_380() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_383() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_252() {\n    if (jj_3R_272()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_250() {\n    if (jj_3R_272()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_346() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_349() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_250() {\n    if (jj_3R_270()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_248() {\n    if (jj_3R_270()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_245() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_242() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_254() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_252() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_36() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_scan_token(THIS)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_35() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_scan_token(THIS)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_360() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_363() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_449() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_455() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_417() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_420() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_247() {\n    if (jj_3R_267()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_245() {\n    if (jj_3R_267()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_132() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_135() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_449() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_455() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_249() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_247() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_210() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_461() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_374() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_377() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_32() {\n    if (jj_3R_112()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_26() {\n    if (jj_3R_112()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_251() {\n    if (jj_3R_271()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_249() {\n    if (jj_3R_271()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_417() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_420() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_210() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_461() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_299() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_404() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_347() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_379() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_173() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_174() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_253() {\n    if (jj_3R_273()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_251() {\n    if (jj_3R_273()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean addInstrumentationToArchive(CoberturaFile file, InputStream archive, OutputStream output) throws Exception {\n    ZipInputStream zis = null;\n    ZipOutputStream zos = null;\n    try {\n        zis = new ZipInputStream(archive);\n        zos = new ZipOutputStream(output);\n        return addInstrumentationToArchive(file, zis, zos);\n    } finally {\n        zis = ((ZipInputStream) (IOUtil.closeInputStream(zis)));\n        zos = ((ZipOutputStream) (IOUtil.closeOutputStream(zos)));\n    }\n}", "methodAfter": "private boolean addInstrumentationToArchive(CoberturaFile file, InputStream archive, OutputStream output) throws Throwable {\n    ZipInputStream zis = null;\n    ZipOutputStream zos = null;\n    try {\n        zis = new ZipInputStream(archive);\n        zos = new ZipOutputStream(output);\n        return addInstrumentationToArchive(file, zis, zos);\n    } finally {\n        zis = ((ZipInputStream) (IOUtil.closeInputStream(zis)));\n        zos = ((ZipOutputStream) (IOUtil.closeOutputStream(zos)));\n    }\n}"}, {"methodBefore": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Exception {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n                    cr.accept(cv, 0);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}", "methodAfter": "private boolean addInstrumentationToArchive(CoberturaFile file, ZipInputStream archive, ZipOutputStream output) throws Throwable {\n    boolean modified = false;\n    ZipEntry entry;\n    while ((entry = archive.getNextEntry()) != null) {\n        try {\n            String entryName = entry.getName();\n            if (ArchiveUtil.isSignatureFile(entry.getName())) {\n                continue;\n            }\n            ZipEntry outputEntry = new ZipEntry(entry.getName());\n            outputEntry.setComment(entry.getComment());\n            outputEntry.setExtra(entry.getExtra());\n            outputEntry.setTime(entry.getTime());\n            output.putNextEntry(outputEntry);\n            byte[] entryBytes = IOUtil.createByteArrayFromInputStream(archive);\n            if (classPattern.isSpecified() && ArchiveUtil.isArchive(entryName)) {\n                Archive archiveObj = new Archive(file, entryBytes);\n                addInstrumentationToArchive(archiveObj);\n                if (archiveObj.isModified()) {\n                    modified = true;\n                    entryBytes = archiveObj.getBytes();\n                    outputEntry.setTime(System.currentTimeMillis());\n                }\n            } else if (isClass(entry) && classPattern.matches(entryName)) {\n                try {\n                    ClassReader cr = new ClassReader(entryBytes);\n                    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                    ClassInstrumenter cv = new ClassInstrumenter(projectData, cw, ignoreRegexes, ignoreBranchesRegexes);\n                    cr.accept(cv, 0);\n                    if (cv.isInstrumented()) {\n                        logger.debug(\"Putting instrumented entry: \" + entry.getName());\n                        entryBytes = cw.toByteArray();\n                        modified = true;\n                        outputEntry.setTime(System.currentTimeMillis());\n                    }\n                } catch (Throwable t) {\n                    if (entry.getName().endsWith(\"_Stub.class\")) {\n                        logger.debug(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    } else {\n                        logger.warn(\"Problems instrumenting archive entry: \" + entry.getName(), t);\n                    }\n                }\n            }\n            output.write(entryBytes);\n            output.closeEntry();\n            archive.closeEntry();\n        } catch (Exception e) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), e);\n        } catch (Throwable t) {\n            logger.warn(\"Problems with archive entry: \" + entry.getName(), t);\n        }\n        output.flush();\n    } \n    return modified;\n}"}, {"methodBefore": "private void addInstrumentationToArchive(CoberturaFile archive) {\n    logger.debug(\"Instrumenting archive \" + archive.getAbsolutePath());\n    File outputFile = null;\n    ZipInputStream input = null;\n    ZipOutputStream output = null;\n    boolean modified = false;\n    try {\n        try {\n            input = new ZipInputStream(new FileInputStream(archive));\n        } catch (FileNotFoundException e) {\n            logger.warn(\"Cannot open archive file: \" + archive.getAbsolutePath(), e);\n            return;\n        }\n        try {\n            if (destinationDirectory != null) {\n                outputFile = new File(destinationDirectory, archive.getPathname());\n            } else {\n                outputFile = File.createTempFile(\"CoberturaInstrumentedArchive\", \"jar\");\n                outputFile.deleteOnExit();\n            }\n            output = new ZipOutputStream(new FileOutputStream(outputFile));\n        } catch (IOException e) {\n            logger.warn(\"Cannot open file for instrumented archive: \" + archive.getAbsolutePath(), e);\n            return;\n        }\n        try {\n            modified = addInstrumentationToArchive(archive, input, output);\n        } catch (Exception e) {\n            logger.warn(\"Cannot instrument archive: \" + archive.getAbsolutePath(), e);\n            return;\n        }\n    } finally {\n        input = ((ZipInputStream) (IOUtil.closeInputStream(input)));\n        output = ((ZipOutputStream) (IOUtil.closeOutputStream(output)));\n    }\n    if (modified && (destinationDirectory == null)) {\n        try {\n            logger.debug(((\"Moving \" + outputFile.getAbsolutePath()) + \" to \") + archive.getAbsolutePath());\n            IOUtil.moveFile(outputFile, archive);\n        } catch (IOException e) {\n            logger.warn(\"Cannot instrument archive: \" + archive.getAbsolutePath(), e);\n            return;\n        }\n    }\n    if ((destinationDirectory != null) && (!modified)) {\n        outputFile.delete();\n    }\n}", "methodAfter": "private void addInstrumentationToArchive(CoberturaFile archive) {\n    logger.debug(\"Instrumenting archive \" + archive.getAbsolutePath());\n    File outputFile = null;\n    ZipInputStream input = null;\n    ZipOutputStream output = null;\n    boolean modified = false;\n    try {\n        try {\n            input = new ZipInputStream(new FileInputStream(archive));\n        } catch (FileNotFoundException e) {\n            logger.warn(\"Cannot open archive file: \" + archive.getAbsolutePath(), e);\n            return;\n        }\n        try {\n            if (destinationDirectory != null) {\n                outputFile = new File(destinationDirectory, archive.getPathname());\n            } else {\n                outputFile = File.createTempFile(\"CoberturaInstrumentedArchive\", \"jar\");\n                outputFile.deleteOnExit();\n            }\n            output = new ZipOutputStream(new FileOutputStream(outputFile));\n        } catch (IOException e) {\n            logger.warn(\"Cannot open file for instrumented archive: \" + archive.getAbsolutePath(), e);\n            return;\n        }\n        try {\n            modified = addInstrumentationToArchive(archive, input, output);\n        } catch (Throwable e) {\n            logger.warn(\"Cannot instrument archive: \" + archive.getAbsolutePath(), e);\n            return;\n        }\n    } finally {\n        input = ((ZipInputStream) (IOUtil.closeInputStream(input)));\n        output = ((ZipOutputStream) (IOUtil.closeOutputStream(output)));\n    }\n    if (modified && (destinationDirectory == null)) {\n        try {\n            logger.debug(((\"Moving \" + outputFile.getAbsolutePath()) + \" to \") + archive.getAbsolutePath());\n            IOUtil.moveFile(outputFile, archive);\n        } catch (IOException e) {\n            logger.warn(\"Cannot instrument archive: \" + archive.getAbsolutePath(), e);\n            return;\n        }\n    }\n    if ((destinationDirectory != null) && (!modified)) {\n        outputFile.delete();\n    }\n}"}, {"methodBefore": "private void addInstrumentationToArchive(Archive archive) throws Exception {\n    InputStream in = null;\n    ByteArrayOutputStream out = null;\n    try {\n        in = archive.getInputStream();\n        out = new ByteArrayOutputStream();\n        boolean modified = addInstrumentationToArchive(archive.getCoberturaFile(), in, out);\n        if (modified) {\n            out.flush();\n            byte[] bytes = out.toByteArray();\n            archive.setModifiedBytes(bytes);\n        }\n    } finally {\n        in = IOUtil.closeInputStream(in);\n        out = ((ByteArrayOutputStream) (IOUtil.closeOutputStream(out)));\n    }\n}", "methodAfter": "private void addInstrumentationToArchive(Archive archive) throws Throwable {\n    InputStream in = null;\n    ByteArrayOutputStream out = null;\n    try {\n        in = archive.getInputStream();\n        out = new ByteArrayOutputStream();\n        boolean modified = addInstrumentationToArchive(archive.getCoberturaFile(), in, out);\n        if (modified) {\n            out.flush();\n            byte[] bytes = out.toByteArray();\n            archive.setModifiedBytes(bytes);\n        }\n    } finally {\n        in = IOUtil.closeInputStream(in);\n        out = ((ByteArrayOutputStream) (IOUtil.closeOutputStream(out)));\n    }\n}"}], [{"methodBefore": "public CoverageData getChild(String name) {\n    return ((CoverageData) (this.children.get(name)));\n}", "methodAfter": "public CoverageData getChild(String name) {\n    lock.lock();\n    try {\n        return ((CoverageData) (this.children.get(name)));\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public ClassData getClassData(String name) {\n    return ((ClassData) (this.classes.get(name)));\n}", "methodAfter": "public ClassData getClassData(String name) {\n    lock.lock();\n    try {\n        return ((ClassData) (this.classes.get(name)));\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfValidBranches();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfValidLines() {\n    int number = 0;\n    Iterator iter = this.children.values().iterator();\n    while (iter.hasNext()) {\n        CoverageData coverageContainer = ((CoverageData) (iter.next()));\n        number += coverageContainer.getNumberOfValidLines();\n    } \n    return number;\n}", "methodAfter": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}], [{"methodBefore": "public void execute() throws BuildException {\n    Header.print(System.out);\n    getJava().createArg().setValue(\"--format\");\n    getJava().createArg().setValue(format);\n    if (dataFile != null) {\n        getJava().createArg().setValue(\"--datafile\");\n        getJava().createArg().setValue(dataFile);\n    }\n    getJava().createArg().setValue(\"--destination\");\n    getJava().createArg().setValue(destDir.toString());\n    getJava().createArg().setValue(\"--source\");\n    getJava().createArg().setValue(src.toString());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException();\n    }\n}", "methodAfter": "public void execute() throws BuildException {\n    Header.print(System.out);\n    getJava().createArg().setValue(\"--format\");\n    getJava().createArg().setValue(format);\n    if (dataFile != null) {\n        getJava().createArg().setValue(\"--datafile\");\n        getJava().createArg().setValue(dataFile);\n    }\n    getJava().createArg().setValue(\"--destination\");\n    getJava().createArg().setValue(destDir.toString());\n    getJava().createArg().setValue(\"--source\");\n    getJava().createArg().setValue(src.toString());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error generating report. See messages above.\");\n    }\n}"}, {"methodBefore": "public void execute() throws BuildException {\n    initArgs();\n    if (dataFile != null) {\n        addArg(\"--datafile\");\n        addArg(dataFile);\n    }\n    if (toDir != null) {\n        addArg(\"--destination\");\n        addArg(toDir.toString());\n    }\n    if (ignoreRegex != null) {\n        addArg(\"--ignore\");\n        addArg(ignoreRegex.getRegex());\n    }\n    Set filenames = new HashSet();\n    Iterator iter = fileSets.iterator();\n    while (iter.hasNext()) {\n        FileSet fileSet = ((FileSet) (iter.next()));\n        addArg(\"--basedir\");\n        addArg(baseDir(fileSet));\n        filenames.addAll(Arrays.asList(getFilenames(fileSet)));\n    } \n    addFilenames(((String[]) (filenames.toArray(new String[filenames.size()]))));\n    saveArgs();\n    if (getJava().executeJava() != 0) {\n        throw new BuildException();\n    }\n    unInitArgs();\n}", "methodAfter": "public void execute() throws BuildException {\n    initArgs();\n    if (dataFile != null) {\n        addArg(\"--datafile\");\n        addArg(dataFile);\n    }\n    if (toDir != null) {\n        addArg(\"--destination\");\n        addArg(toDir.toString());\n    }\n    if (ignoreRegex != null) {\n        addArg(\"--ignore\");\n        addArg(ignoreRegex.getRegex());\n    }\n    Set filenames = new HashSet();\n    Iterator iter = fileSets.iterator();\n    while (iter.hasNext()) {\n        FileSet fileSet = ((FileSet) (iter.next()));\n        addArg(\"--basedir\");\n        addArg(baseDir(fileSet));\n        filenames.addAll(Arrays.asList(getFilenames(fileSet)));\n    } \n    addFilenames(((String[]) (filenames.toArray(new String[filenames.size()]))));\n    saveArgs();\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error instrumenting classes. See messages above.\");\n    }\n    unInitArgs();\n}"}], [{"methodBefore": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(cv2, EXPAND_FRAMES);\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}", "methodAfter": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(cv2, EXPAND_FRAMES);\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}"}, {"methodBefore": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(new CheckClassAdapter(cv2), SKIP_FRAMES);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        CheckClassAdapter.verify(new ClassReader(cw2.toByteArray()), false, pw);\n        logger.debug(sw.toString());\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}", "methodAfter": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new CoberturaClassWriter(ClassWriter.COMPUTE_FRAMES);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(new CheckClassAdapter(cv2), SKIP_FRAMES);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        CheckClassAdapter.verify(new ClassReader(cw2.toByteArray()), false, pw);\n        logger.debug(sw.toString());\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}"}], [{"methodBefore": "public Set getMethodNamesAndDescriptors() {\n    return methodNamesAndDescriptors;\n}", "methodAfter": "public Set getMethodNamesAndDescriptors() {\n    lock.lock();\n    try {\n        return methodNamesAndDescriptors;\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public String getMethodName() {\n    return methodName;\n}", "methodAfter": "public String getMethodName() {\n    lock.lock();\n    try {\n        return methodName;\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public String getMethodDescriptor() {\n    return methodDescriptor;\n}", "methodAfter": "public String getMethodDescriptor() {\n    lock.lock();\n    try {\n        return methodDescriptor;\n    } finally {\n        lock.unlock();\n    }\n}"}]]