[[{"methodBefore": "protected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = getAnnotation(method);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}", "methodAfter": "protected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) {\n    Test annotation = method.getAnnotation(Test.class);\n    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;\n}"}, {"methodBefore": "protected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(getAnnotation(method));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}", "methodAfter": "protected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) {\n    long timeout = getTimeout(method.getAnnotation(Test.class));\n    return timeout > 0 ? new FailOnTimeout(next, timeout) : next;\n}"}], [{"methodBefore": "public static void assertEquals(String message, double expected, double actual, double delta) {\n    if (Double.compare(expected, actual) == 0) {\n        return;\n    }\n    if (!(Math.abs(expected - actual) <= delta)) {\n        failNotEquals(message, new Double(expected), new Double(actual));\n    }\n}", "methodAfter": "public static void assertEquals(String message, double expected, double actual, double delta) {\n    if (doubleIsDifferent(expected, actual, delta)) {\n        failNotEquals(message, new Double(expected), new Double(actual));\n    }\n}"}, {"methodBefore": "public static void assertEquals(String message, float expected, float actual, float delta) {\n    if (Float.compare(expected, actual) == 0) {\n        return;\n    }\n    if (!(Math.abs(expected - actual) <= delta)) {\n        failNotEquals(message, new Float(expected), new Float(actual));\n    }\n}", "methodAfter": "public static void assertEquals(String message, float expected, float actual, float delta) {\n    if (floatIsDifferent(expected, actual, delta)) {\n        failNotEquals(message, new Float(expected), new Float(actual));\n    }\n}"}], [{"methodBefore": "@Test\npublic void arraysDifferAtElement0withMessage() {\n    try {\n        assertEquals(\"message\", new Object[]{ true }, new Object[]{ false });\n    } catch (AssertionError exception) {\n        assertEquals(\"message: arrays first differed at element [0]; expected:<true> but was:<false>\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void arraysDifferAtElement0withMessage() {\n    try {\n        assertArrayEquals(\"message\", new Object[]{ true }, new Object[]{ false });\n    } catch (AssertionError exception) {\n        assertEquals(\"message: arrays first differed at element [0]; expected:<true> but was:<false>\", exception.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void arraysDifferAtElement1withMessage() {\n    try {\n        assertEquals(\"message\", new Object[]{ true, true }, new Object[]{ true, false });\n        fail();\n    } catch (AssertionError exception) {\n        assertEquals(\"message: arrays first differed at element [1]; expected:<true> but was:<false>\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void arraysDifferAtElement1withMessage() {\n    try {\n        assertArrayEquals(\"message\", new Object[]{ true, true }, new Object[]{ true, false });\n        fail();\n    } catch (AssertionError exception) {\n        assertEquals(\"message: arrays first differed at element [1]; expected:<true> but was:<false>\", exception.getMessage());\n    }\n}"}], [{"methodBefore": "public long getTimeout() {\n    Test annotation = fMethod.getAnnotation(Test.class);\n    long timeout = annotation.timeout();\n    return timeout;\n}", "methodAfter": "public long getTimeout() {\n    Test annotation = fMethod.getAnnotation(Test.class);\n    if (annotation == null) {\n        return 0;\n    }\n    long timeout = annotation.timeout();\n    return timeout;\n}"}, {"methodBefore": "public String getName() {\n    return fClass.getName();\n}", "methodAfter": "public String getName() {\n    if (fClass == null) {\n        return \"null\";\n    }\n    return fClass.getName();\n}"}], [{"methodBefore": "protected Frame createUI(String suiteName) {\n    Frame frame = new Frame(\"JUnit\");\n    Image icon = loadFrameIcon();\n    if (icon != null) {\n        frame.setIconImage(icon);\n    }\n    frame.setLayout(new BorderLayout(0, 0));\n    frame.setBackground(SystemColor.control);\n    final Frame finalFrame = frame;\n    frame.addWindowListener(new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n            finalFrame.dispose();\n            System.exit(0);\n        }\n    });\n    MenuBar mb = new MenuBar();\n    createMenus(mb);\n    frame.setMenuBar(mb);\n    Label suiteLabel = new Label(\"Test class name:\");\n    fSuiteField = new TextField(suiteName != null ? suiteName : \"\");\n    fSuiteField.selectAll();\n    fSuiteField.requestFocus();\n    fSuiteField.setFont(PLAIN_FONT);\n    fSuiteField.setColumns(40);\n    fSuiteField.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    fSuiteField.addTextListener(new TextListener() {\n        public void textValueChanged(TextEvent e) {\n            fRun.setEnabled(fSuiteField.getText().length() > 0);\n            fStatusLine.setText(\"\");\n        }\n    });\n    fRun = new Button(\"Run\");\n    fRun.setEnabled(false);\n    fRun.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    boolean useLoader = useReloadingTestSuiteLoader();\n    fUseLoadingRunner = new Checkbox(\"Reload classes every run\", useLoader);\n    if (inVAJava()) {\n        fUseLoadingRunner.setVisible(false);\n    }\n    fProgressIndicator = new ProgressBar();\n    fNumberOfErrors = new Label(\"0000\", Label.RIGHT);\n    fNumberOfErrors.setText(\"0\");\n    fNumberOfErrors.setFont(PLAIN_FONT);\n    fNumberOfFailures = new Label(\"0000\", Label.RIGHT);\n    fNumberOfFailures.setText(\"0\");\n    fNumberOfFailures.setFont(PLAIN_FONT);\n    fNumberOfRuns = new Label(\"0000\", Label.RIGHT);\n    fNumberOfRuns.setText(\"0\");\n    fNumberOfRuns.setFont(PLAIN_FONT);\n    Panel numbersPanel = new Panel(new FlowLayout());\n    numbersPanel.add(new Label(\"Runs:\"));\n    numbersPanel.add(fNumberOfRuns);\n    numbersPanel.add(new Label(\"   Errors:\"));\n    numbersPanel.add(fNumberOfErrors);\n    numbersPanel.add(new Label(\"   Failures:\"));\n    numbersPanel.add(fNumberOfFailures);\n    Label failureLabel = new Label(\"Errors and Failures:\");\n    fFailureList = new List(5);\n    fFailureList.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n            failureSelected();\n        }\n    });\n    fRerunButton = new Button(\"Run\");\n    fRerunButton.setEnabled(false);\n    fRerunButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            rerun();\n        }\n    });\n    Panel failedPanel = new Panel(new GridLayout(0, 1, 0, 2));\n    failedPanel.add(fRerunButton);\n    fTraceArea = new TextArea();\n    fTraceArea.setRows(5);\n    fTraceArea.setColumns(60);\n    fStatusLine = new TextField();\n    fStatusLine.setFont(PLAIN_FONT);\n    fStatusLine.setEditable(false);\n    fStatusLine.setForeground(Color.red);\n    fQuitButton = new Button(\"Exit\");\n    fQuitButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    fLogo = new Logo();\n    Panel panel = new Panel(new GridBagLayout());\n    addGrid(panel, suiteLabel, 0, 0, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fSuiteField, 0, 1, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fRun, 2, 1, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fLogo, 2, 3, 1, GridBagConstraints.NONE, 0.0, GridBagConstraints.NORTH);\n    addGrid(panel, numbersPanel, 0, 4, 2, GridBagConstraints.NONE, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, failureLabel, 0, 5, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fFailureList, 0, 6, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, failedPanel, 2, 6, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fTraceArea, 0, 7, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fStatusLine, 0, 8, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.CENTER);\n    addGrid(panel, fQuitButton, 2, 8, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    frame.add(panel, BorderLayout.CENTER);\n    frame.pack();\n    return frame;\n}", "methodAfter": "protected Frame createUI(String suiteName) {\n    Frame frame = new Frame(\"JUnit\");\n    Image icon = loadFrameIcon();\n    if (icon != null) {\n        frame.setIconImage(icon);\n    }\n    frame.setLayout(new BorderLayout(0, 0));\n    frame.setBackground(SystemColor.control);\n    final Frame finalFrame = frame;\n    frame.addWindowListener(new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n            finalFrame.dispose();\n            System.exit(0);\n        }\n    });\n    MenuBar mb = new MenuBar();\n    createMenus(mb);\n    frame.setMenuBar(mb);\n    Label suiteLabel = new Label(\"Test class name:\");\n    fSuiteField = new TextField(suiteName != null ? suiteName : \"\");\n    fSuiteField.selectAll();\n    fSuiteField.requestFocus();\n    fSuiteField.setFont(PLAIN_FONT);\n    fSuiteField.setColumns(40);\n    fSuiteField.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    fSuiteField.addTextListener(new TextListener() {\n        public void textValueChanged(TextEvent e) {\n            fRun.setEnabled(fSuiteField.getText().length() > 0);\n            fStatusLine.setText(\"\");\n        }\n    });\n    fRun = new Button(\"Run\");\n    fRun.setEnabled(false);\n    fRun.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    boolean useLoader = useReloadingTestSuiteLoader();\n    fUseLoadingRunner = new Checkbox(\"Reload classes every run\", useLoader);\n    if (inVAJava()) {\n        fUseLoadingRunner.setVisible(false);\n    }\n    fProgressIndicator = new ProgressBar();\n    fNumberOfErrors = new Label(\"0000\", Label.RIGHT);\n    fNumberOfErrors.setText(\"0\");\n    fNumberOfErrors.setFont(PLAIN_FONT);\n    fNumberOfFailures = new Label(\"0000\", Label.RIGHT);\n    fNumberOfFailures.setText(\"0\");\n    fNumberOfFailures.setFont(PLAIN_FONT);\n    fNumberOfRuns = new Label(\"0000\", Label.RIGHT);\n    fNumberOfRuns.setText(\"0\");\n    fNumberOfRuns.setFont(PLAIN_FONT);\n    Panel numbersPanel = new Panel(new FlowLayout());\n    numbersPanel.add(new Label(\"Runs:\"));\n    numbersPanel.add(fNumberOfRuns);\n    numbersPanel.add(new Label(\"   Errors:\"));\n    numbersPanel.add(fNumberOfErrors);\n    numbersPanel.add(new Label(\"   Failures:\"));\n    numbersPanel.add(fNumberOfFailures);\n    Label failureLabel = new Label(\"Errors and Failures:\");\n    fFailureList = new List(5);\n    fFailureList.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n            failureSelected();\n        }\n    });\n    fRerunButton = new Button(\"Run\");\n    fRerunButton.setEnabled(false);\n    fRerunButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            rerun();\n        }\n    });\n    Panel failedPanel = new Panel(new GridLayout(0, 1, 0, 2));\n    failedPanel.add(fRerunButton);\n    fTraceArea = new TextArea();\n    fTraceArea.setRows(5);\n    fTraceArea.setColumns(60);\n    fStatusLine = new TextField();\n    fStatusLine.setFont(PLAIN_FONT);\n    fStatusLine.setEditable(false);\n    fStatusLine.setForeground(Color.red);\n    fQuitButton = new Button(\"Exit\");\n    fQuitButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    fLogo = new Logo();\n    Panel panel = new Panel(new GridBagLayout());\n    addGrid(panel, suiteLabel, 0, 0, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fSuiteField, 0, 1, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fRun, 2, 1, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fLogo, 2, 3, 1, GridBagConstraints.NONE, 0.0, GridBagConstraints.NORTH);\n    addGrid(panel, numbersPanel, 0, 4, 2, GridBagConstraints.NONE, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, failureLabel, 0, 5, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fFailureList, 0, 6, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, failedPanel, 2, 6, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fTraceArea, 0, 7, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fStatusLine, 0, 8, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.CENTER);\n    addGrid(panel, fQuitButton, 2, 8, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    frame.add(panel, BorderLayout.CENTER);\n    frame.pack();\n    return frame;\n}"}, {"methodBefore": "protected JFrame createUI(String suiteName) {\n    JFrame frame = createFrame(\"JUnit\");\n    JMenuBar mb = new JMenuBar();\n    createMenus(mb);\n    frame.setJMenuBar(mb);\n    JLabel suiteLabel = new JLabel(\"Test class name:\");\n    fSuiteCombo = createSuiteCombo();\n    fRun = createRunButton();\n    frame.getRootPane().setDefaultButton(fRun);\n    Component browseButton = createBrowseButton();\n    fUseLoadingRunner = createUseLoaderCheckBox();\n    fProgressIndicator = new ProgressBar();\n    fCounterPanel = createCounterPanel();\n    JLabel failureLabel = new JLabel(\"Errors and Failures:\");\n    fFailures = new DefaultListModel();\n    fTestViewTab = createTestRunViews();\n    JPanel failedPanel = createFailedPanel();\n    fFailureView = createFailureDetailView();\n    JScrollPane tracePane = new JScrollPane(fFailureView.getComponent(), JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n    fStatusLine = createStatusLine();\n    fQuitButton = createQuitButton();\n    fLogo = createLogo();\n    JPanel panel = new JPanel(new GridBagLayout());\n    addGrid(panel, suiteLabel, 0, 0, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fSuiteCombo, 0, 1, 1, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, browseButton, 1, 1, 1, GridBagConstraints.NONE, 0.0, GridBagConstraints.WEST);\n    addGrid(panel, fRun, 2, 1, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fUseLoadingRunner, 0, 2, 3, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, new JSeparator(), 0, 3, 3, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fProgressIndicator, 0, 4, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fLogo, 2, 4, 1, GridBagConstraints.NONE, 0.0, GridBagConstraints.NORTH);\n    addGrid(panel, fCounterPanel, 0, 5, 2, GridBagConstraints.NONE, 0.0, GridBagConstraints.CENTER);\n    JSplitPane splitter = new JSplitPane(JSplitPane.VERTICAL_SPLIT, fTestViewTab, tracePane);\n    addGrid(panel, splitter, 0, 6, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, failedPanel, 2, 6, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.NORTH);\n    addGrid(panel, fStatusLine, 0, 8, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.CENTER);\n    addGrid(panel, fQuitButton, 2, 8, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    frame.setContentPane(panel);\n    frame.pack();\n    frame.setLocation(200, 200);\n    return frame;\n}", "methodAfter": "protected JFrame createUI(String suiteName) {\n    JFrame frame = createFrame(\"JUnit\");\n    JMenuBar mb = new JMenuBar();\n    createMenus(mb);\n    frame.setJMenuBar(mb);\n    JLabel suiteLabel = new JLabel(\"Test class name:\");\n    fSuiteCombo = createSuiteCombo();\n    fRun = createRunButton();\n    frame.getRootPane().setDefaultButton(fRun);\n    Component browseButton = createBrowseButton();\n    fUseLoadingRunner = createUseLoaderCheckBox();\n    fProgressIndicator = new ProgressBar();\n    fCounterPanel = createCounterPanel();\n    JLabel failureLabel = new JLabel(\"Errors and Failures:\");\n    fFailures = new DefaultListModel();\n    fTestViewTab = createTestRunViews();\n    JPanel failedPanel = createFailedPanel();\n    fFailureView = createFailureDetailView();\n    JScrollPane tracePane = new JScrollPane(fFailureView.getComponent(), JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n    fStatusLine = createStatusLine();\n    fQuitButton = createQuitButton();\n    fLogo = createLogo();\n    JPanel panel = new JPanel(new GridBagLayout());\n    addGrid(panel, suiteLabel, 0, 0, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fSuiteCombo, 0, 1, 1, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, browseButton, 1, 1, 1, GridBagConstraints.NONE, 0.0, GridBagConstraints.WEST);\n    addGrid(panel, fRun, 2, 1, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fUseLoadingRunner, 0, 2, 3, GridBagConstraints.NONE, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, new JSeparator(), 0, 3, 3, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fProgressIndicator, 0, 4, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fLogo, 2, 4, 1, GridBagConstraints.NONE, 0.0, GridBagConstraints.NORTH);\n    addGrid(panel, fCounterPanel, 0, 5, 2, GridBagConstraints.NONE, 0.0, GridBagConstraints.CENTER);\n    JSplitPane splitter = new JSplitPane(JSplitPane.VERTICAL_SPLIT, fTestViewTab, tracePane);\n    addGrid(panel, splitter, 0, 6, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, failedPanel, 2, 6, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.NORTH);\n    addGrid(panel, fStatusLine, 0, 8, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.CENTER);\n    addGrid(panel, fQuitButton, 2, 8, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    frame.setContentPane(panel);\n    frame.pack();\n    frame.setLocation(200, 200);\n    return frame;\n}"}], [{"methodBefore": "public void testExceptionSubclass() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assert result.wasSuccessful();\n}", "methodAfter": "public void testExceptionSubclass() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assertTrue(result.wasSuccessful());\n}"}, {"methodBefore": "public void testRunningErrorInTestSetup() {\n    TestCase test = new TestCase(\"failure\") {\n        public void runTest() {\n            fail();\n        }\n    };\n    TestSetup wrapper = new TestSetup(test);\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assert !result.wasSuccessful();\n}", "methodAfter": "public void testRunningErrorInTestSetup() {\n    TestCase test = new TestCase(\"failure\") {\n        public void runTest() {\n            fail();\n        }\n    };\n    TestSetup wrapper = new TestSetup(test);\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assertTrue(!result.wasSuccessful());\n}"}, {"methodBefore": "public void testExceptionTest() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assert result.wasSuccessful();\n}", "methodAfter": "public void testExceptionTest() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assertTrue(result.wasSuccessful());\n}"}], [{"methodBefore": "public void addFirstListener(RunListener listener) {\n    fListeners.add(0, listener);\n}", "methodAfter": "public void addFirstListener(RunListener listener) {\n    synchronized(fListenersLock) {\n        fListeners.add(0, listener);\n    }\n}"}, {"methodBefore": "public void removeListener(RunListener listener) {\n    fListeners.remove(listener);\n}", "methodAfter": "public void removeListener(RunListener listener) {\n    synchronized(fListenersLock) {\n        fListeners.remove(listener);\n    }\n}"}, {"methodBefore": "public void addListener(RunListener listener) {\n    fListeners.add(listener);\n}", "methodAfter": "public void addListener(RunListener listener) {\n    synchronized(fListenersLock) {\n        fListeners.add(listener);\n    }\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return statement(base);\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    return statement(base);\n}"}], [{"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "public void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}"}, {"methodBefore": "public Test getTest() {\n    return fTest;\n}", "methodAfter": "private Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "protected List<T> getFilteredChildren() {\n    ArrayList<T> filtered = new ArrayList<T>();\n    for (T each : getChildren()) {\n        if (shouldRun(each)) {\n            try {\n                filterChild(each);\n                sortChild(each);\n                filtered.add(each);\n            } catch (NoTestsRemainException e) {\n            }\n        }\n    }\n    Collections.sort(filtered, comparator());\n    return filtered;\n}", "methodAfter": "private List<T> getFilteredChildren() {\n    ArrayList<T> filtered = new ArrayList<T>();\n    for (T each : getChildren()) {\n        if (shouldRun(each)) {\n            try {\n                filterChild(each);\n                sortChild(each);\n                filtered.add(each);\n            } catch (NoTestsRemainException e) {\n            }\n        }\n    }\n    Collections.sort(filtered, comparator());\n    return filtered;\n}"}, {"methodBefore": "public void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}"}, {"methodBefore": "public boolean isShadowedBy(FrameworkMethod each) {\n    if (!each.getName().equals(getName())) {\n        return false;\n    }\n    if (each.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < each.getParameterTypes().length; i++) {\n        if (!each.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "methodAfter": "private boolean isShadowedBy(FrameworkMethod each) {\n    if (!each.getName().equals(getName())) {\n        return false;\n    }\n    if (each.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < each.getParameterTypes().length; i++) {\n        if (!each.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}"}, {"methodBefore": "protected void validateFields(List<Throwable> errors) {\n    for (FrameworkField each : ruleFields()) {\n        validateRuleField(each.getField(), errors);\n    }\n}", "methodAfter": "private void validateFields(List<Throwable> errors) {\n    for (FrameworkField each : ruleFields()) {\n        validateRuleField(each.getField(), errors);\n    }\n}"}, {"methodBefore": "public Assignments(List<PotentialAssignment> assigned, List<ParameterSignature> unassigned, TestClass testClass) {\n    fUnassigned = unassigned;\n    fAssigned = assigned;\n    fClass = testClass;\n}", "methodAfter": "private Assignments(List<PotentialAssignment> assigned, List<ParameterSignature> unassigned, TestClass testClass) {\n    fUnassigned = unassigned;\n    fAssigned = assigned;\n    fClass = testClass;\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "public Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFailureUponUnknownOption() throws Exception {\n    String unknownOption = \"--unknown-option\";\n    jUnitCommandLineParser.parseOptions(new String[]{ unknownOption });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError: \"), containsString(CommandLineParserError.class.getName()), containsString(unknownOption)));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnknownOption() throws Exception {\n    String unknownOption = \"--unknown-option\";\n    jUnitCommandLineParser.parseOptions(new String[]{ unknownOption });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError:\"), containsString(CommandLineParserError.class.getName()), containsString(unknownOption)));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\" });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError: \"), containsString(CommandLineParserError.class.getName()), containsString(\"--filter value not specified\")));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\" });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError:\"), containsString(CommandLineParserError.class.getName()), containsString(\"--filter value not specified\")));\n}"}], [{"methodBefore": "public void addError(Test test, Throwable t) {\n    getWriter().print(\"E\");\n}", "methodAfter": "public void addError(Test test, Throwable e) {\n    getWriter().print(\"E\");\n}"}, {"methodBefore": "public abstract void testFailed(int status, Test test, Throwable t);", "methodAfter": "public abstract void testFailed(int status, Test test, Throwable e);"}, {"methodBefore": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable e) {\n}"}], [{"methodBefore": "public static String id() {\n    return \"4.6-SNAPSHOT-20080908-1523\";\n}", "methodAfter": "public static String id() {\n    return \"4.5\";\n}"}, {"methodBefore": "public static String id() {\n    return \"4.5-SNAPSHOT-20080722-1051\";\n}", "methodAfter": "public static String id() {\n    return \"4.5\";\n}"}], [{"methodBefore": "public void testComparisonErrorOverlapingMatches2() {\n    String failure = new ComparisonCompactor(0, \"abcdde\", \"abcde\").compact(null);\n    assertEquals(\"expected:<...[d]...> but was:<...[]...>\", failure);\n}", "methodAfter": "public void testComparisonErrorOverlappingMatches2() {\n    String failure = new ComparisonCompactor(0, \"abcdde\", \"abcde\").compact(null);\n    assertEquals(\"expected:<...[d]...> but was:<...[]...>\", failure);\n}"}, {"methodBefore": "public void testComparisonErrorOverlapingMatches() {\n    String failure = new ComparisonCompactor(0, \"abc\", \"abbc\").compact(null);\n    assertEquals(\"expected:<...[]...> but was:<...[b]...>\", failure);\n}", "methodAfter": "public void testComparisonErrorOverlappingMatches() {\n    String failure = new ComparisonCompactor(0, \"abc\", \"abbc\").compact(null);\n    assertEquals(\"expected:<...[]...> but was:<...[b]...>\", failure);\n}"}], [{"methodBefore": "@Override\npublic void testRunStarted(Description description) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testRunStarted(description);\n    }\n}", "methodAfter": "@Override\npublic void testRunStarted(Description description) throws Exception {\n    synchronized(monitor) {\n        listener.testRunStarted(description);\n    }\n}"}, {"methodBefore": "@Override\npublic void testFinished(Description description) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testFinished(description);\n    }\n}", "methodAfter": "@Override\npublic void testFinished(Description description) throws Exception {\n    synchronized(monitor) {\n        listener.testFinished(description);\n    }\n}"}, {"methodBefore": "@Override\npublic void testRunFinished(Result result) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testRunFinished(result);\n    }\n}", "methodAfter": "@Override\npublic void testRunFinished(Result result) throws Exception {\n    synchronized(monitor) {\n        listener.testRunFinished(result);\n    }\n}"}, {"methodBefore": "@Override\npublic void testAssumptionFailure(Failure failure) {\n    synchronized(fMonitor) {\n        fListener.testAssumptionFailure(failure);\n    }\n}", "methodAfter": "@Override\npublic void testAssumptionFailure(Failure failure) {\n    synchronized(monitor) {\n        listener.testAssumptionFailure(failure);\n    }\n}"}, {"methodBefore": "@Override\npublic void testFailure(Failure failure) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testFailure(failure);\n    }\n}", "methodAfter": "@Override\npublic void testFailure(Failure failure) throws Exception {\n    synchronized(monitor) {\n        listener.testFailure(failure);\n    }\n}"}, {"methodBefore": "@Override\npublic void testStarted(Description description) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testStarted(description);\n    }\n}", "methodAfter": "@Override\npublic void testStarted(Description description) throws Exception {\n    synchronized(monitor) {\n        listener.testStarted(description);\n    }\n}"}, {"methodBefore": "@Override\npublic void testIgnored(Description description) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testIgnored(description);\n    }\n}", "methodAfter": "@Override\npublic void testIgnored(Description description) throws Exception {\n    synchronized(monitor) {\n        listener.testIgnored(description);\n    }\n}"}], [{"methodBefore": "public Object[] getMethodArguments(boolean nullsOk, Object target) throws CouldNotGenerateValueException {\n    return getActualValues(nullsOk, getOnlyConstructor().getParameterTypes().length, fAssigned.size());\n}", "methodAfter": "public Object[] getMethodArguments(boolean nullsOk, Object target) throws CouldNotGenerateValueException {\n    return getActualValues(nullsOk, fConstructorParameterCount, fAssigned.size());\n}"}, {"methodBefore": "public Object[] getConstructorArguments(boolean nullsOk) throws CouldNotGenerateValueException {\n    return getActualValues(nullsOk, 0, getOnlyConstructor().getParameterTypes().length);\n}", "methodAfter": "public Object[] getConstructorArguments(boolean nullsOk) throws CouldNotGenerateValueException {\n    return getActualValues(nullsOk, 0, fConstructorParameterCount);\n}"}], [{"methodBefore": "@Override\nprotected NotificationStrategy chain(final TestMethod method, Object test) {\n    Link next = invoke(method, test);\n    next = ignoreViolatedAssumptions(next);\n    next = possiblyExpectingExceptions(method, next);\n    return notifying(method, next);\n}", "methodAfter": "@Override\nprotected Notifier chain(final TestMethod method, Object test) {\n    Statement next = invoke(method, test);\n    next = ignoreViolatedAssumptions(next);\n    next = possiblyExpectingExceptions(method, next);\n    return notifying(method, next);\n}"}, {"methodBefore": "protected NotificationStrategy chain(TestMethod method, Object test) {\n    Link link = invoke(method, test);\n    link = possiblyExpectingExceptions(method, link);\n    link = withPotentialTimeout(method, link);\n    link = withBefores(method, test, link);\n    link = ignoreViolatedAssumptions(link);\n    link = withAfters(method, test, link);\n    return notifying(method, link);\n}", "methodAfter": "protected Notifier chain(TestMethod method, Object test) {\n    Statement link = invoke(method, test);\n    link = possiblyExpectingExceptions(method, link);\n    link = withPotentialTimeout(method, link);\n    link = withBefores(method, test, link);\n    link = ignoreViolatedAssumptions(link);\n    link = withAfters(method, test, link);\n    return notifying(method, link);\n}"}], [{"methodBefore": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method, getTestClass());\n}"}, {"methodBefore": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method, getTestClass());\n}"}], [{"methodBefore": "@Test\npublic void failWithHelpfulMessageForProtectedClassRule() {\n    assertClassHasFailureMessage(TestWithProtectedClassRule.class, \"The @ClassRule 'temporaryFolder' must be public.\");\n}", "methodAfter": "@Test\npublic void failWithHelpfulMessageForProtectedClassRule() {\n    assertClassHasFailureMessage(TestWithProtectedClassRule.class, 2, \"The @ClassRule 'temporaryFolder' must be public.\");\n}"}, {"methodBefore": "@Test\npublic void failWithHelpfulMessageForNonStaticClassRule() {\n    assertClassHasFailureMessage(TestWithNonStaticClassRule.class, \"The @ClassRule 'temporaryFolder' must be static.\");\n}", "methodAfter": "@Test\npublic void failWithHelpfulMessageForNonStaticClassRule() {\n    assertClassHasFailureMessage(TestWithNonStaticClassRule.class, 2, \"The @ClassRule 'temporaryFolder' must be static.\");\n}"}], [{"methodBefore": "public void testComparisonErrorWithNullArgument2() {\n    ComparisonFailure failure = new ComparisonFailure(null, null, \"a\");\n    assertEquals(\"expected:<null> but was:<a>\", failure.getMessage());\n}", "methodAfter": "public void testComparisonErrorWithExpectedNull() {\n    ComparisonFailure failure = new ComparisonFailure(null, null, \"a\");\n    assertEquals(\"expected:<null> but was:<a>\", failure.getMessage());\n}"}, {"methodBefore": "public void testComparisonErrorWithNullArgument() {\n    ComparisonFailure failure = new ComparisonFailure(null, \"a\", null);\n    assertEquals(\"expected:<a> but was:<null>\", failure.getMessage());\n}", "methodAfter": "public void testComparisonErrorWithActualNull() {\n    ComparisonFailure failure = new ComparisonFailure(null, \"a\", null);\n    assertEquals(\"expected:<a> but was:<null>\", failure.getMessage());\n}"}], [{"methodBefore": "public void testInheritedTests() {\n    TestSuite suite = new TestSuite(InheritedTestCase.class);\n    suite.run(fResult);\n    assert fResult.wasSuccessful();\n    assertEquals(2, fResult.runCount());\n}", "methodAfter": "public void testInheritedTests() {\n    TestSuite suite = new TestSuite(InheritedTestCase.class);\n    suite.run(fResult);\n    assertTrue(fResult.wasSuccessful());\n    assertEquals(2, fResult.runCount());\n}"}, {"methodBefore": "public void testExceptionSubclass() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assert result.wasSuccessful();\n}", "methodAfter": "public void testExceptionSubclass() {\n    ExceptionTestCase test = new ThrowExceptionTestCase(\"test\", IndexOutOfBoundsException.class);\n    TestResult result = test.run();\n    assertEquals(1, result.runCount());\n    assertTrue(result.wasSuccessful());\n}"}], [{"methodBefore": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable e) {\n}"}, {"methodBefore": "public abstract void testFailed(int status, Test test, Throwable t);", "methodAfter": "public abstract void testFailed(int status, Test test, Throwable e);"}, {"methodBefore": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable e) {\n}"}], [{"methodBefore": "@Override\npublic void evaluate() throws Throwable {\n    throw fError;\n}", "methodAfter": "@Override\npublic void evaluate() throws Throwable {\n    throw error;\n}"}, {"methodBefore": "public Fail(Throwable e) {\n    fError = e;\n}", "methodAfter": "public Fail(Throwable e) {\n    error = e;\n}"}], [{"methodBefore": "protected Link ignoreViolatedAssumptions(Link next) {\n    return new IgnoringViolatedAssumptions(next);\n}", "methodAfter": "protected Link ignoreViolatedAssumptions(Link next) {\n    return new IgnoreViolatedAssumptions(next);\n}"}, {"methodBefore": "protected Link ignoreViolatedAssumptions(Link next) {\n    return new IgnoreViolatedAssumptions(next);\n}", "methodAfter": "protected Link ignoreViolatedAssumptions(Link next) {\n    return new IgnoringViolatedAssumptions(next);\n}"}], [{"methodBefore": "protected void runFailed(String message) {\n    System.out.println(message);\n    System.exit(-1);\n}", "methodAfter": "protected void runFailed(String message) {\n    System.err.println(message);\n    System.exit(-1);\n}"}, {"methodBefore": "protected TestResult start(String[] args) throws Exception {\n    String testCase = \"\";\n    boolean wait = false;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-wait\")) {\n            wait = true;\n        } else if (args[i].equals(\"-c\")) {\n            testCase = extractClassName(args[++i]);\n        } else if (args[i].equals(\"-v\")) {\n            System.out.println((\"JUnit \" + Version.id()) + \" by Kent Beck and Erich Gamma\");\n        } else {\n            testCase = args[i];\n        }\n    }\n    if (testCase.equals(\"\")) {\n        throw new Exception(\"Usage: TestRunner [-wait] testCaseName, where name is the name of the TestCase class\");\n    }\n    try {\n        Test suite = getTest(testCase);\n        return doRun(suite, wait);\n    } catch (Exception e) {\n        throw new Exception(\"Could not create and run test suite: \" + e);\n    }\n}", "methodAfter": "protected TestResult start(String[] args) throws Exception {\n    String testCase = \"\";\n    boolean wait = false;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-wait\")) {\n            wait = true;\n        } else if (args[i].equals(\"-c\")) {\n            testCase = extractClassName(args[++i]);\n        } else if (args[i].equals(\"-v\")) {\n            System.err.println((\"JUnit \" + Version.id()) + \" by Kent Beck and Erich Gamma\");\n        } else {\n            testCase = args[i];\n        }\n    }\n    if (testCase.equals(\"\")) {\n        throw new Exception(\"Usage: TestRunner [-wait] testCaseName, where name is the name of the TestCase class\");\n    }\n    try {\n        Test suite = getTest(testCase);\n        return doRun(suite, wait);\n    } catch (Exception e) {\n        throw new Exception(\"Could not create and run test suite: \" + e);\n    }\n}"}, {"methodBefore": "public static void main(String[] args) {\n    TestRunner aTestRunner = new TestRunner();\n    try {\n        TestResult r = aTestRunner.start(args);\n        if (!r.wasSuccessful()) {\n            System.exit(-1);\n        }\n        System.exit(0);\n    } catch (Exception e) {\n        System.out.println(e.getMessage());\n        System.exit(-2);\n    }\n}", "methodAfter": "public static void main(String[] args) {\n    TestRunner aTestRunner = new TestRunner();\n    try {\n        TestResult r = aTestRunner.start(args);\n        if (!r.wasSuccessful()) {\n            System.exit(-1);\n        }\n        System.exit(0);\n    } catch (Exception e) {\n        System.err.println(e.getMessage());\n        System.exit(-2);\n    }\n}"}], [{"methodBefore": "private Exception createTimeoutException(Thread thread) {\n    StackTraceElement[] stackTrace = thread.getStackTrace();\n    final Thread stuckThread = (fLookForStuckThread) ? getStuckThread(thread) : null;\n    Exception currThreadException = new TestTimedOutException(fTimeout, fTimeUnit);\n    if (stackTrace != null) {\n        currThreadException.setStackTrace(stackTrace);\n        thread.interrupt();\n    }\n    if (stuckThread != null) {\n        Exception stuckThreadException = new Exception(\"Appears to be stuck in thread \" + stuckThread.getName());\n        stuckThreadException.setStackTrace(getStackTrace(stuckThread));\n        return new MultipleFailureException(Arrays.<Throwable>asList(currThreadException, stuckThreadException));\n    } else {\n        return currThreadException;\n    }\n}", "methodAfter": "private Exception createTimeoutException(Thread thread) {\n    StackTraceElement[] stackTrace = thread.getStackTrace();\n    final Thread stuckThread = (lookForStuckThread) ? getStuckThread(thread) : null;\n    Exception currThreadException = new TestTimedOutException(timeout, timeUnit);\n    if (stackTrace != null) {\n        currThreadException.setStackTrace(stackTrace);\n        thread.interrupt();\n    }\n    if (stuckThread != null) {\n        Exception stuckThreadException = new Exception(\"Appears to be stuck in thread \" + stuckThread.getName());\n        stuckThreadException.setStackTrace(getStackTrace(stuckThread));\n        return new MultipleFailureException(Arrays.<Throwable>asList(currThreadException, stuckThreadException));\n    } else {\n        return currThreadException;\n    }\n}"}, {"methodBefore": "public Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fTimeout, fTimeUnit, fLookForStuckThread);\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, timeout, timeUnit, lookForStuckThread);\n}"}], [{"methodBefore": "@Override\npublic void testFailure(Failure failure) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testFailure(failure);\n    }\n}", "methodAfter": "@Override\npublic void testFailure(Failure failure) throws Exception {\n    synchronized(monitor) {\n        listener.testFailure(failure);\n    }\n}"}, {"methodBefore": "@Override\npublic void testAssumptionFailure(Failure failure) {\n    synchronized(fMonitor) {\n        fListener.testAssumptionFailure(failure);\n    }\n}", "methodAfter": "@Override\npublic void testAssumptionFailure(Failure failure) {\n    synchronized(monitor) {\n        listener.testAssumptionFailure(failure);\n    }\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    suite.addTestSuite(FloatAssertTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertionFailedErrorTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    suite.addTestSuite(FloatAssertTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    return suite;\n}"}], [{"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "public MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}", "methodAfter": "private MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}"}], [{"methodBefore": "public abstract void testFailed(int status, Test test, Throwable t);", "methodAfter": "public abstract void testFailed(int status, Test test, Throwable e);"}, {"methodBefore": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable e) {\n}"}, {"methodBefore": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable e) {\n}"}], [{"methodBefore": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    return Description.createTestDescription(fTestClass.getJavaClass(), testName(method), method.getMethod().getAnnotations());\n}", "methodAfter": "@Override\nprotected Description describeChild(FrameworkMethod method) {\n    return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getMethod().getAnnotations());\n}"}, {"methodBefore": "public Object createTest() throws Exception {\n    return fTestClass.getConstructor().newInstance();\n}", "methodAfter": "public Object createTest() throws Exception {\n    return getTestClass().getConstructor().newInstance();\n}"}, {"methodBefore": "protected void collectInitializationErrors(List<Throwable> errors) {\n    fTestClass.validateMethodsForDefaultRunner(errors);\n}", "methodAfter": "protected void collectInitializationErrors(List<Throwable> errors) {\n    getTestClass().validateMethodsForDefaultRunner(errors);\n}"}, {"methodBefore": "protected List<FrameworkMethod> computeTestMethods() {\n    return fTestClass.getTestMethods();\n}", "methodAfter": "protected List<FrameworkMethod> computeTestMethods() {\n    return getTestClass().getTestMethods();\n}"}, {"methodBefore": "private Object[] computeParams() throws Exception {\n    try {\n        return fParameters.get(fParameterSetNumber);\n    } catch (ClassCastException e) {\n        throw new Exception(String.format(\"%s.%s() must return a Collection of arrays.\", fTestClass.getName(), getParametersMethod().getName()));\n    }\n}", "methodAfter": "private Object[] computeParams() throws Exception {\n    try {\n        return fParameters.get(fParameterSetNumber);\n    } catch (ClassCastException e) {\n        throw new Exception(String.format(\"%s.%s() must return a Collection of arrays.\", getTestClass().getName(), getParametersMethod().getName()));\n    }\n}"}], [{"methodBefore": "public static Filter createFilter(String filterFactoryFqcn, FilterFactoryParams params) throws FilterFactoryNotCreatedException {\n    FilterFactory filterFactory = createFilterFactory(filterFactoryFqcn);\n    return filterFactory.createFilter(params);\n}", "methodAfter": "public static Filter createFilter(String filterFactoryFqcn, FilterFactoryParams params) throws FilterFactory.FilterNotCreatedException {\n    FilterFactory filterFactory = createFilterFactory(filterFactoryFqcn);\n    return filterFactory.createFilter(params);\n}"}, {"methodBefore": "public static Filter createFilter(Class<? extends FilterFactory> filterFactoryClass, FilterFactoryParams params) throws FilterFactoryNotCreatedException {\n    FilterFactory filterFactory = createFilterFactory(filterFactoryClass);\n    return filterFactory.createFilter(params);\n}", "methodAfter": "public static Filter createFilter(Class<? extends FilterFactory> filterFactoryClass, FilterFactoryParams params) throws FilterFactory.FilterNotCreatedException {\n    FilterFactory filterFactory = createFilterFactory(filterFactoryClass);\n    return filterFactory.createFilter(params);\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    suite.addTestSuite(TextRunnerSingleMethodTest.class);\n    suite.addTestSuite(TextRunnerTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(ResultTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    suite.addTestSuite(TextRunnerSingleMethodTest.class);\n    suite.addTestSuite(TextRunnerTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    suite.addTestSuite(FloatAssertTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertionFailedErrorTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    suite.addTestSuite(FloatAssertTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(ExtensionTest.class);\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(ExceptionTestCaseTest.class);\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(ActiveTestTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(RepeatedTestTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(ExtensionTest.class);\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(ExceptionTestCaseTest.class);\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(ActiveTestTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(RepeatedTestTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    suite.addTestSuite(FloatAssertTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    suite.addTestSuite(TextRunnerSingleMethodTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}], [{"methodBefore": "public List<TestMethod> getTestMethods() {\n    return getAnnotatedMethods(Test.class);\n}", "methodAfter": "public List<FrameworkMethod> getTestMethods() {\n    return getAnnotatedMethods(Test.class);\n}"}, {"methodBefore": "protected List<TestMethod> computeTestMethods() {\n    return fTestClass.getTestMethods();\n}", "methodAfter": "protected List<FrameworkMethod> computeTestMethods() {\n    return fTestClass.getTestMethods();\n}"}, {"methodBefore": "public void validateInstanceMethods(List<Throwable> errors) {\n    validateMethods(After.class, false, errors);\n    validateMethods(Before.class, false, errors);\n    validateMethods(Test.class, false, errors);\n    List<TestMethod> methods = getAnnotatedMethods(Test.class);\n    if (methods.size() == 0) {\n        errors.add(new Exception(\"No runnable methods\"));\n    }\n}", "methodAfter": "public void validateInstanceMethods(List<Throwable> errors) {\n    validateMethods(After.class, false, errors);\n    validateMethods(Before.class, false, errors);\n    validateMethods(Test.class, false, errors);\n    List<FrameworkMethod> methods = getAnnotatedMethods(Test.class);\n    if (methods.size() == 0) {\n        errors.add(new Exception(\"No runnable methods\"));\n    }\n}"}, {"methodBefore": "public abstract List<TestMethod> getBefores();", "methodAfter": "public abstract List<FrameworkMethod> getBefores();"}, {"methodBefore": "@Override\npublic List<TestMethod> getBefores() {\n    return getAnnotatedMethods(BeforeClass.class);\n}", "methodAfter": "@Override\npublic List<FrameworkMethod> getBefores() {\n    return getAnnotatedMethods(BeforeClass.class);\n}"}, {"methodBefore": "@Override\npublic List<TestMethod> getAfters() {\n    return getAnnotatedMethods(AfterClass.class);\n}", "methodAfter": "@Override\npublic List<FrameworkMethod> getAfters() {\n    return getAnnotatedMethods(AfterClass.class);\n}"}, {"methodBefore": "@Override\nprotected List<TestMethod> getChildren() {\n    return fTestMethods;\n}", "methodAfter": "@Override\nprotected List<FrameworkMethod> getChildren() {\n    return fTestMethods;\n}"}, {"methodBefore": "public abstract List<TestMethod> getAfters();", "methodAfter": "public abstract List<FrameworkMethod> getAfters();"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    for (TestMethod method : fTestMethods) {\n        runChild(method, notifier);\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    for (FrameworkMethod method : fTestMethods) {\n        runChild(method, notifier);\n    }\n}"}], [{"methodBefore": "public File newFile(String fileName) throws IOException {\n    File file = new File(getRoot(), fileName);\n    if (!file.createNewFile()) {\n        throw new IllegalStateException((\"a file with the name \\'\" + fileName) + \"\\' already exists in the test folder\");\n    }\n    return file;\n}", "methodAfter": "public File newFile(String fileName) throws IOException {\n    File file = new File(getRoot(), fileName);\n    if (!file.createNewFile()) {\n        throw new IllegalArgumentException((\"a file with the name \\'\" + fileName) + \"\\' already exists in the test folder\");\n    }\n    return file;\n}"}, {"methodBefore": "public File newFile(String fileName) throws IOException {\n    File file = new File(getRoot(), fileName);\n    if (!file.createNewFile()) {\n        throw new IllegalArgumentException((\"a file with the name \\'\" + fileName) + \"\\' already exists in the test folder\");\n    }\n    return file;\n}", "methodAfter": "public File newFile(String fileName) throws IOException {\n    File file = new File(getRoot(), fileName);\n    if (!file.createNewFile()) {\n        throw new IOException((\"a file with the name \\'\" + fileName) + \"\\' already exists in the test folder\");\n    }\n    return file;\n}"}], [{"methodBefore": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass);\n}", "methodAfter": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass, fConstructorParameterCount);\n}"}, {"methodBefore": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(fContext, assigned, fUnassigned.subList(1, fUnassigned.size()));\n}", "methodAfter": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(fContext, assigned, fUnassigned.subList(1, fUnassigned.size()), fTarget);\n}"}, {"methodBefore": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass, fConstructorParameterCount);\n}", "methodAfter": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass, fConstructorParameterCount, fNullsOk);\n}"}], [{"methodBefore": "private static String getPreference(String key) {\n    return fPreferences.getProperty(key);\n}", "methodAfter": "public static String getPreference(String key) {\n    return fPreferences.getProperty(key);\n}"}, {"methodBefore": "private static boolean isArray(Object expected) {\n    return (expected != null) && expected.getClass().isArray();\n}", "methodAfter": "public static boolean isArray(Object expected) {\n    return (expected != null) && expected.getClass().isArray();\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFilter() throws Exception {\n    Filter filter = filterFactoryFactory.createFilter(FilterFactoryFactoryTest.FilterFactoryStub.class, new NoFilterFactoryParams());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilter() throws Exception {\n    Filter filter = filterFactoryFactory.createFilter(FilterFactoryFactoryTest.FilterFactoryStub.class, new FilterFactoryParams(createSuiteDescription(testName.getMethodName())));\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFilter() throws Exception {\n    Filter filter = FilterFactories.createFilter(FilterFactoriesTest.FilterFactoryStub.class, new FilterFactoryParams(\"\"));\n    assertThat(filter, instanceOf(FilterFactoriesTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilter() throws Exception {\n    Filter filter = FilterFactories.createFilter(FilterFactoriesTest.FilterFactoryStub.class, new FilterFactoryParams(Description.createSuiteDescription(testName.getMethodName()), \"\"));\n    assertThat(filter, instanceOf(FilterFactoriesTest.DummyFilter.class));\n}"}], [{"methodBefore": "public void expectMessage(Matcher<String> matcher) {\n    fMatcher.andHasMessage(matcher);\n}", "methodAfter": "public void expectMessage(Matcher<String> matcher) {\n    fMatcher.andAlsoHasMessage(matcher);\n}"}, {"methodBefore": "public void expect(Matcher<?> matcher) {\n    fMatcher.and(matcher);\n}", "methodAfter": "public void expect(Matcher<?> matcher) {\n    fMatcher.andAlso(matcher);\n}"}], [{"methodBefore": "WasRun(String name) {\n    super(name);\n}", "methodAfter": "public WasRun(String name) {\n    super(name);\n}"}, {"methodBefore": "TestCase() {\n    fName = null;\n}", "methodAfter": "public TestCase() {\n    fName = null;\n}"}], [{"methodBefore": "public FilterFactoryParams(String args) {\n    this.args = args;\n}", "methodAfter": "public FilterFactoryParams(String args) {\n    if (args == null) {\n        throw new NullPointerException();\n    }\n    this.args = args;\n}"}, {"methodBefore": "public static void fail(String message) {\n    throw new AssertionFailedError(message);\n}", "methodAfter": "public static void fail(String message) {\n    if (message == null) {\n        throw new AssertionFailedError();\n    }\n    throw new AssertionFailedError(message);\n}"}], [{"methodBefore": "private RunnerBuilder suiteMethodBuilder() {\n    if (fCanUseSuiteMethod) {\n        return new SuiteMethodBuilder();\n    }\n    return new NullBuilder();\n}", "methodAfter": "protected RunnerBuilder suiteMethodBuilder() {\n    if (fCanUseSuiteMethod) {\n        return new SuiteMethodBuilder();\n    }\n    return new NullBuilder();\n}"}, {"methodBefore": "private Annotation[] classAnnotations() {\n    return fTestClass.getJavaClass().getAnnotations();\n}", "methodAfter": "protected Annotation[] classAnnotations() {\n    return fTestClass.getJavaClass().getAnnotations();\n}"}, {"methodBefore": "private Statement possiblyExpectingExceptions(TestAnnotation annotation, Statement next) {\n    return annotation.expectsException() ? new ExpectException(next, annotation.getExpectedException()) : next;\n}", "methodAfter": "protected Statement possiblyExpectingExceptions(TestAnnotation annotation, Statement next) {\n    return annotation.expectsException() ? new ExpectException(next, annotation.getExpectedException()) : next;\n}"}, {"methodBefore": "public Object createTest() throws Exception {\n    return getTestClass().getConstructor().newInstance();\n}", "methodAfter": "protected Object createTest() throws Exception {\n    return getTestClass().getConstructor().newInstance();\n}"}], [{"methodBefore": "public void addFirstListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot add a null listener\");\n    }\n    fListeners.add(0, wrapIfNotThreadSafe(listener));\n}", "methodAfter": "public void addFirstListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot add a null listener\");\n    }\n    listeners.add(0, wrapIfNotThreadSafe(listener));\n}"}, {"methodBefore": "SafeNotifier() {\n    this(fListeners);\n}", "methodAfter": "SafeNotifier() {\n    this(listeners);\n}"}, {"methodBefore": "public void addListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot add a null listener\");\n    }\n    fListeners.add(wrapIfNotThreadSafe(listener));\n}", "methodAfter": "public void addListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot add a null listener\");\n    }\n    listeners.add(wrapIfNotThreadSafe(listener));\n}"}, {"methodBefore": "public void removeListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot remove a null listener\");\n    }\n    fListeners.remove(wrapIfNotThreadSafe(listener));\n}", "methodAfter": "public void removeListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot remove a null listener\");\n    }\n    listeners.remove(wrapIfNotThreadSafe(listener));\n}"}, {"methodBefore": "public void fireTestFailure(Failure failure) {\n    fireTestFailures(fListeners, asList(failure));\n}", "methodAfter": "public void fireTestFailure(Failure failure) {\n    fireTestFailures(listeners, asList(failure));\n}"}], [{"methodBefore": "public Suite(Class<?> klass) throws InitializationError {\n    this(klass, getAnnotatedClasses(klass));\n}", "methodAfter": "public Suite(Class<?> klass) throws InitializationError {\n    this(klass, getAnnotatedClasses(klass));\n    validate();\n}"}, {"methodBefore": "protected ParentRunner(Class<?> testClass) {\n    fTestClass = new TestClass(testClass);\n}", "methodAfter": "protected ParentRunner(Class<?> testClass) throws InitializationError {\n    fTestClass = new TestClass(testClass);\n    validate();\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFilter() throws Exception {\n    Filter filter = filterFactoryFactory.createFilter(FilterFactoryFactoryTest.FilterFactoryStub.class, new NoFilterFactoryParams());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilter() throws Exception {\n    Filter filter = filterFactoryFactory.createFilter(FilterFactoryFactoryTest.FilterFactoryStub.class, new FilterFactoryParams(createSuiteDescription(testName.getMethodName())));\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec(FilterFactoryFactoryTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec(createSuiteDescription(testName.getMethodName()), FilterFactoryFactoryTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}"}], [{"methodBefore": "@Test\npublic void failedAssumptionsMeanPassing() {\n    Result result = JUnitCore.runClasses(AssumptionTest.HasFailingAssumption.class);\n    assertThat(result.getRunCount(), is(1));\n    assertThat(result.getIgnoreCount(), is(0));\n    assertThat(result.getFailureCount(), is(0));\n}", "methodAfter": "@Test\npublic void failedAssumptionsMeanIgnored() {\n    Result result = JUnitCore.runClasses(AssumptionTest.HasFailingAssumption.class);\n    assertThat(result.getRunCount(), is(0));\n    assertThat(result.getIgnoreCount(), is(1));\n    assertThat(result.getFailureCount(), is(0));\n}"}, {"methodBefore": "@Test\npublic void failedAssumptionsMeanIgnored() {\n    Result result = JUnitCore.runClasses(AssumptionTest.HasFailingAssumption.class);\n    assertThat(result.getRunCount(), is(0));\n    assertThat(result.getIgnoreCount(), is(1));\n    assertThat(result.getFailureCount(), is(0));\n}", "methodAfter": "@Test\npublic void failedAssumptionsMeanPassing() {\n    Result result = JUnitCore.runClasses(AssumptionTest.HasFailingAssumption.class);\n    assertThat(result.getRunCount(), is(1));\n    assertThat(result.getIgnoreCount(), is(0));\n    assertThat(result.getFailureCount(), is(0));\n}"}], [{"methodBefore": "public static Request classWithoutSuiteMethod(Class<?> newTestClass) {\n    return new ClassRequest(newTestClass, false);\n}", "methodAfter": "public static Request classWithoutSuiteMethod(Class<?> newTestClass) {\n    return new ClassRequest(newTestClass, newSuiteBuilder(), false);\n}"}, {"methodBefore": "public static Request aClass(Class<?> clazz) {\n    return new ClassRequest(clazz);\n}", "methodAfter": "public static Request aClass(Class<?> clazz) {\n    return new ClassRequest(clazz, newSuiteBuilder());\n}"}], [{"methodBefore": "@Test\npublic void ignoreExceptionsFromDataPointMethods() {\n    assertThat(testResult(WithDataPointMethod.HasUglyDataPointMethod.class), isSuccessful());\n}", "methodAfter": "@Test\npublic void shouldFailFromExceptionsInSingleDataPointMethods() {\n    assertThat(testResult(WithDataPointMethod.HasFailingSingleDataPointMethod.class), not(isSuccessful()));\n}"}, {"methodBefore": "@Test\npublic void shouldFilterNull() {\n    assertThat(testResult(WithExtendedParameterSources.ShouldFilterNull.class), isSuccessful());\n}", "methodAfter": "@Test\npublic void ShouldRejectTheoriesWithOnlyDisallowedNullData() {\n    assertThat(testResult(WithExtendedParameterSources.ShouldRejectTheoriesWithOnlyDisallowedNullData.class), not(isSuccessful()));\n}"}], [{"methodBefore": "TestCase() {\n    fName = null;\n}", "methodAfter": "public TestCase() {\n    fName = null;\n}"}, {"methodBefore": "FailureList(List<Failure> failures) {\n    this.failures = failures;\n}", "methodAfter": "public FailureList(List<Failure> failures) {\n    this.failures = failures;\n}"}, {"methodBefore": "WasRun(String name) {\n    super(name);\n}", "methodAfter": "public WasRun(String name) {\n    super(name);\n}"}], [{"methodBefore": "protected void runFailed(String message) {\n    System.out.println(message);\n    System.exit(-1);\n}", "methodAfter": "protected void runFailed(String message) {\n    System.err.println(message);\n    System.exit(-1);\n}"}, {"methodBefore": "public static void main(String[] args) {\n    TestRunner aTestRunner = new TestRunner();\n    try {\n        TestResult r = aTestRunner.start(args);\n        if (!r.wasSuccessful()) {\n            System.exit(-1);\n        }\n        System.exit(0);\n    } catch (Exception e) {\n        System.out.println(e.getMessage());\n        System.exit(-2);\n    }\n}", "methodAfter": "public static void main(String[] args) {\n    TestRunner aTestRunner = new TestRunner();\n    try {\n        TestResult r = aTestRunner.start(args);\n        if (!r.wasSuccessful()) {\n            System.exit(-1);\n        }\n        System.exit(0);\n    } catch (Exception e) {\n        System.err.println(e.getMessage());\n        System.exit(-2);\n    }\n}"}], [{"methodBefore": "public static void savePreferences() throws IOException {\n    FileOutputStream fos = new FileOutputStream(getPreferencesFile());\n    try {\n        getPreferences().save(fos, \"\");\n    } finally {\n        fos.close();\n    }\n}", "methodAfter": "public static void savePreferences() throws IOException {\n    FileOutputStream fos = new FileOutputStream(getPreferencesFile());\n    try {\n        getPreferences().store(fos, \"\");\n    } finally {\n        fos.close();\n    }\n}"}, {"methodBefore": "public static void savePreferences() throws IOException {\n    FileOutputStream fos = new FileOutputStream(getPreferencesFile());\n    try {\n        getPreferences().store(fos, \"\");\n    } finally {\n        fos.close();\n    }\n}", "methodAfter": "public static void savePreferences() throws IOException {\n    FileOutputStream fos = new FileOutputStream(getPreferencesFile());\n    try {\n        getPreferences().save(fos, \"\");\n    } finally {\n        fos.close();\n    }\n}"}], [{"methodBefore": "public PrintableResult(Result result) {\n    this.result = result;\n}", "methodAfter": "private PrintableResult(Result result) {\n    this.result = result;\n}"}, {"methodBefore": "public String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}", "methodAfter": "private String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}], [{"methodBefore": "public abstract List<TestMethod> getBefores();", "methodAfter": "public abstract List<FrameworkMethod> getBefores();"}, {"methodBefore": "public abstract List<TestMethod> getAfters();", "methodAfter": "public abstract List<FrameworkMethod> getAfters();"}], [{"methodBefore": "public void testTearDownSetupFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void setUp() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assert !fails.fTornDown;\n}", "methodAfter": "public void testTearDownSetupFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void setUp() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assertTrue(!fails.fTornDown);\n}"}, {"methodBefore": "public void testRunAndTearDownFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void tearDown() {\n            super.tearDown();\n            throw new Error();\n        }\n\n        protected void runTest() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assert fails.fTornDown;\n}", "methodAfter": "public void testRunAndTearDownFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void tearDown() {\n            super.tearDown();\n            throw new Error();\n        }\n\n        protected void runTest() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assertTrue(fails.fTornDown);\n}"}, {"methodBefore": "public void testTearDownAfterError() {\n    TornDown fails = new TornDown(\"fails\");\n    verifyError(fails);\n    assert fails.fTornDown;\n}", "methodAfter": "public void testTearDownAfterError() {\n    TornDown fails = new TornDown(\"fails\");\n    verifyError(fails);\n    assertTrue(fails.fTornDown);\n}"}], [{"methodBefore": "public Class load(String suiteClassName) throws ClassNotFoundException {\n    TestCaseClassLoader loader = new TestCaseClassLoader();\n    return loader.loadClass(suiteClassName, true);\n}", "methodAfter": "public Class load(String suiteClassName) throws ClassNotFoundException {\n    return createLoader().loadClass(suiteClassName, true);\n}"}, {"methodBefore": "public Class reload(Class aClass) throws ClassNotFoundException {\n    TestCaseClassLoader loader = new TestCaseClassLoader();\n    return loader.loadClass(aClass.getName(), true);\n}", "methodAfter": "public Class reload(Class aClass) throws ClassNotFoundException {\n    return createLoader().loadClass(aClass.getName(), true);\n}"}], [{"methodBefore": "public File newFile(String fileName) throws IOException {\n    File file = new File(getRoot(), fileName);\n    if (!file.createNewFile()) {\n        throw new IllegalArgumentException((\"a file with the name \\'\" + fileName) + \"\\' already exists in the test folder\");\n    }\n    return file;\n}", "methodAfter": "public File newFile(String fileName) throws IOException {\n    File file = new File(getRoot(), fileName);\n    if (!file.createNewFile()) {\n        throw new IOException((\"a file with the name \\'\" + fileName) + \"\\' already exists in the test folder\");\n    }\n    return file;\n}"}, {"methodBefore": "public File newFile(String fileName) throws IOException {\n    File file = new File(getRoot(), fileName);\n    if (!file.createNewFile()) {\n        throw new IllegalStateException((\"a file with the name \\'\" + fileName) + \"\\' already exists in the test folder\");\n    }\n    return file;\n}", "methodAfter": "public File newFile(String fileName) throws IOException {\n    File file = new File(getRoot(), fileName);\n    if (!file.createNewFile()) {\n        throw new IllegalArgumentException((\"a file with the name \\'\" + fileName) + \"\\' already exists in the test folder\");\n    }\n    return file;\n}"}], [{"methodBefore": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append((getTestHeader() + \": \") + fThrownException.getMessage());\n    return sb.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    return (getTestHeader() + \": \") + fThrownException.getMessage();\n}"}, {"methodBefore": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append((fFailedTest + \": \") + fThrownException.getMessage());\n    return sb.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    return (fFailedTest + \": \") + fThrownException.getMessage();\n}"}], [{"methodBefore": "@Test\npublic void preferRecentlyFailed() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = MaxCore.createFresh();\n    max.run(request);\n    List<Description> tests = max.sort(request);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, tests.get(0));\n}", "methodAfter": "@Test\npublic void preferRecentlyFailed() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = MaxCore.createFresh();\n    max.run(request);\n    List<Description> tests = max.sortedLeavesForTest(request);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, tests.get(0));\n}"}, {"methodBefore": "@Test\npublic void preferFast() {\n    Request request = Request.aClass(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore max = MaxCore.createFresh();\n    max.run(request);\n    Description thing = max.sort(request).get(1);\n    assertEquals(Description.createTestDescription(MaxStarterTest.TwoUnEqualTests.class, \"slow\"), thing);\n}", "methodAfter": "@Test\npublic void preferFast() {\n    Request request = Request.aClass(MaxStarterTest.TwoUnEqualTests.class);\n    MaxCore max = MaxCore.createFresh();\n    max.run(request);\n    Description thing = max.sortedLeavesForTest(request).get(1);\n    assertEquals(Description.createTestDescription(MaxStarterTest.TwoUnEqualTests.class, \"slow\"), thing);\n}"}, {"methodBefore": "@Test\npublic void twoTestsNotRunComeBackInRandomOrder() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = MaxCore.createFresh();\n    List<Description> things = max.sort(request);\n    Description succeed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"succeed\");\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertTrue(things.contains(succeed));\n    assertTrue(things.contains(dontSucceed));\n    assertEquals(2, things.size());\n}", "methodAfter": "@Test\npublic void twoTestsNotRunComeBackInRandomOrder() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = MaxCore.createFresh();\n    List<Description> things = max.sortedLeavesForTest(request);\n    Description succeed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"succeed\");\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertTrue(things.contains(succeed));\n    assertTrue(things.contains(dontSucceed));\n    assertEquals(2, things.size());\n}"}], [{"methodBefore": "@Override\npublic Filter createFilter(Class<?>[] categories) throws ClassNotFoundException {\n    return new Categories.CategoryFilter.ExcludesAny(categories);\n}", "methodAfter": "@Override\npublic Filter createFilter(Class<?>[] categories) {\n    return new ExcludesAny(categories);\n}"}, {"methodBefore": "@Override\npublic Filter createFilter(Class<?>[] categories) throws FilterNotCreatedException {\n    return new Categories.CategoryFilter.IncludesAny(categories);\n}", "methodAfter": "@Override\npublic Filter createFilter(Class<?>[] categories) {\n    return new IncludesAny(categories);\n}"}], [{"methodBefore": "public void testTestAndTeardownFailure() throws Exception {\n    JUnitCore core = new JUnitCore();\n    Result runner = core.run(AnnotationTest.TestAndTeardownFailureTest.class);\n    assertEquals(1, runner.getRunCount());\n    assertEquals(2, runner.getFailureCount());\n    assertThat(runner.getFailures().toString(), both(containsString(\"hereAfter\")).and(containsString(\"inTest\")));\n}", "methodAfter": "public void testTestAndTeardownFailure() throws Exception {\n    JUnitCore core = new JUnitCore();\n    Result runner = core.run(AnnotationTest.TestAndTeardownFailureTest.class);\n    assertEquals(1, runner.getRunCount());\n    assertEquals(2, runner.getFailureCount());\n    assertThat(runner.getFailures().toString(), CoreMatchers.<String>both(containsString(\"hereAfter\")).and(containsString(\"inTest\")));\n}"}, {"methodBefore": "@Parameters\npublic static Collection<Object[]> testsWithEventMatcher() {\n    return asList(new Object[][]{ new Object[]{ ExpectedExceptionTest.EmptyTestExpectingNoException.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithExpectedType.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithExpectedPartOfMessage.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithWrongType.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: an instance of java.lang.NullPointerException\")) }, new Object[]{ ExpectedExceptionTest.HasWrongMessage.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message a string containing \\\"expectedMessage\\\"\\n\" + \"     but: was <java.lang.IllegalArgumentException: actualMessage>\")) }, new Object[]{ ExpectedExceptionTest.ThrowNoExceptionButExpectExceptionWithType.class, hasSingleFailureWithMessage(\"Expected test to throw an instance of java.lang.NullPointerException\") }, new Object[]{ ExpectedExceptionTest.WronglyExpectsExceptionMessage.class, hasSingleFailure() }, new Object[]{ ExpectedExceptionTest.ExpectsSubstring.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ExpectsSubstringNullMessage.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message a string containing \\\"anything!\\\"\")) }, new Object[]{ ExpectedExceptionTest.ExpectsMessageMatcher.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ExpectedMessageMatcherFails.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message \\\"Wrong start\\\"\")) }, new Object[]{ ExpectedExceptionTest.ExpectsMatcher.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedAssumptionViolatedException.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowAssumptionViolatedExceptionButExpectOtherType.class, hasSingleFailure() }, new Object[]{ ExpectedExceptionTest.ThrowAssumptionViolatedExceptionButExpectOtherType.class, hasSingleFailureWithMessage(containsString(\"Stacktrace was: org.junit.internal.AssumptionViolatedException\")) }, new Object[]{ ExpectedExceptionTest.ViolateAssumptionAndExpectException.class, hasSingleAssumptionFailure() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedAssertionError.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowUnexpectedAssertionError.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: an instance of java.lang.NullPointerException\")) }, new Object[]{ ExpectedExceptionTest.FailAndDontHandleAssertinErrors.class, hasSingleFailureWithMessage(ARBITRARY_MESSAGE) }, new Object[]{ ExpectedExceptionTest.ExpectsMultipleMatchers.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: (an instance of java.lang.IllegalArgumentException and exception with message a string containing \\\"Ack!\\\")\")) }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithMatchingCause.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedNullCause.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowUnexpectedCause.class, hasSingleFailureWithMessage(allOf(startsWith(\"\\nExpected: (\"), containsString(\"exception with cause is <java.lang.NullPointerException: expected cause>\"), containsString(\"Stacktrace was: java.lang.IllegalArgumentException: Ack!\"), containsString(\"Caused by: java.lang.NullPointerException: an unexpected cause\"))) } });\n}", "methodAfter": "@Parameters\npublic static Collection<Object[]> testsWithEventMatcher() {\n    return asList(new Object[][]{ new Object[]{ ExpectedExceptionTest.EmptyTestExpectingNoException.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithExpectedType.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithExpectedPartOfMessage.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithWrongType.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: an instance of java.lang.NullPointerException\")) }, new Object[]{ ExpectedExceptionTest.HasWrongMessage.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message a string containing \\\"expectedMessage\\\"\\n\" + \"     but: was <java.lang.IllegalArgumentException: actualMessage>\")) }, new Object[]{ ExpectedExceptionTest.ThrowNoExceptionButExpectExceptionWithType.class, hasSingleFailureWithMessage(\"Expected test to throw an instance of java.lang.NullPointerException\") }, new Object[]{ ExpectedExceptionTest.WronglyExpectsExceptionMessage.class, hasSingleFailure() }, new Object[]{ ExpectedExceptionTest.ExpectsSubstring.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ExpectsSubstringNullMessage.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message a string containing \\\"anything!\\\"\")) }, new Object[]{ ExpectedExceptionTest.ExpectsMessageMatcher.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ExpectedMessageMatcherFails.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message \\\"Wrong start\\\"\")) }, new Object[]{ ExpectedExceptionTest.ExpectsMatcher.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedAssumptionViolatedException.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowAssumptionViolatedExceptionButExpectOtherType.class, hasSingleFailure() }, new Object[]{ ExpectedExceptionTest.ThrowAssumptionViolatedExceptionButExpectOtherType.class, hasSingleFailureWithMessage(containsString(\"Stacktrace was: org.junit.internal.AssumptionViolatedException\")) }, new Object[]{ ExpectedExceptionTest.ViolateAssumptionAndExpectException.class, hasSingleAssumptionFailure() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedAssertionError.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowUnexpectedAssertionError.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: an instance of java.lang.NullPointerException\")) }, new Object[]{ ExpectedExceptionTest.FailAndDontHandleAssertinErrors.class, hasSingleFailureWithMessage(ARBITRARY_MESSAGE) }, new Object[]{ ExpectedExceptionTest.ExpectsMultipleMatchers.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: (an instance of java.lang.IllegalArgumentException and exception with message a string containing \\\"Ack!\\\")\")) }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithMatchingCause.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedNullCause.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowUnexpectedCause.class, hasSingleFailureWithMessage(CoreMatchers.<String>allOf(startsWith(\"\\nExpected: (\"), containsString(\"exception with cause is <java.lang.NullPointerException: expected cause>\"), containsString(\"Stacktrace was: java.lang.IllegalArgumentException: Ack!\"), containsString(\"Caused by: java.lang.NullPointerException: an unexpected cause\"))) } });\n}"}], [{"methodBefore": "@Test\npublic void theoryAnnotationsAreRetained() throws Exception {\n    assertThat(new TestClass(UnsuccessfulWithDataPointFields.HasATheory.class).getAnnotatedMethods(Theory.class).size(), is(1));\n}", "methodAfter": "@Test\npublic void theoryAnnotationsAreRetained() throws Exception {\n    assertThat(new TestClass(UnsuccessfulWithDataPointFields.HasAFailingTheory.class).getAnnotatedMethods(Theory.class).size(), is(1));\n}"}, {"methodBefore": "@Test\npublic void theoryClassMethodsShowUp() throws Exception {\n    assertThat(new Theories(UnsuccessfulWithDataPointFields.HasATheory.class).getDescription().getChildren().size(), is(1));\n}", "methodAfter": "@Test\npublic void theoryClassMethodsShowUp() throws Exception {\n    assertThat(new Theories(UnsuccessfulWithDataPointFields.HasAFailingTheory.class).getDescription().getChildren().size(), is(1));\n}"}], [{"methodBefore": "@Test\npublic void dataPointsArrayFieldMayContainNullValue() throws SecurityException, NoSuchMethodException {\n    List<PotentialAssignment> valueSources = new AllMembersSupplier(new TestClass(AllMembersSupplierTest.HasDataPointsFieldWithNullValue.class)).getValueSources(ParameterSignature.signatures(AllMembersSupplierTest.HasDataPointsFieldWithNullValue.class.getConstructor(Object.class)).get(0));\n    assertThat(valueSources.size(), is(2));\n}", "methodAfter": "@Test\npublic void dataPointsArrayFieldMayContainNullValue() throws Throwable {\n    List<PotentialAssignment> valueSources = allMemberValuesFor(AllMembersSupplierTest.HasDataPointsFieldWithNullValue.class, Object.class);\n    assertThat(valueSources.size(), is(2));\n}"}, {"methodBefore": "@Test\npublic void dataPointsAnnotationMeansTreatAsArrayOnly() throws SecurityException, NoSuchMethodException {\n    List<PotentialAssignment> valueSources = new AllMembersSupplier(new TestClass(AllMembersSupplierTest.HasDataPoints.class)).getValueSources(ParameterSignature.signatures(AllMembersSupplierTest.HasDataPoints.class.getConstructor(Object.class)).get(0));\n    assertThat(valueSources.size(), is(2));\n}", "methodAfter": "@Test\npublic void dataPointsAnnotationMeansTreatAsArrayOnly() throws Throwable {\n    List<PotentialAssignment> valueSources = allMemberValuesFor(AllMembersSupplierTest.HasDataPoints.class, Object.class);\n    assertThat(valueSources.size(), is(2));\n}"}], [{"methodBefore": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method, getTestClass());\n}"}, {"methodBefore": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method, getTestClass());\n}"}, {"methodBefore": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method, getTestClass());\n}"}, {"methodBefore": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method, getTestClass());\n}"}], [{"methodBefore": "public void fireTestStarted(final Description description) throws StoppedByUserException {\n    if (fPleaseStop) {\n        throw new StoppedByUserException();\n    }\n    new SafeNotifier() {\n        @Override\n        protected void notifyListener(RunListener each) throws Exception {\n            each.testStarted(description);\n        }\n    }.run();\n}", "methodAfter": "public void fireTestStarted(final Description description) throws StoppedByUserException {\n    if (pleaseStop) {\n        throw new StoppedByUserException();\n    }\n    new SafeNotifier() {\n        @Override\n        protected void notifyListener(RunListener each) throws Exception {\n            each.testStarted(description);\n        }\n    }.run();\n}"}, {"methodBefore": "public void pleaseStop() {\n    fPleaseStop = true;\n}", "methodAfter": "public void pleaseStop() {\n    pleaseStop = true;\n}"}], [{"methodBefore": "private void starting() {\n    fStartNanos = currentNanoTime();\n}", "methodAfter": "private void starting() {\n    startNanos = currentNanoTime();\n}"}, {"methodBefore": "@Override\nprotected final void starting(Description description) {\n    startTime = System.nanoTime();\n}", "methodAfter": "@Override\nprotected final void starting(Description description) {\n    startNanos = System.nanoTime();\n}"}], [{"methodBefore": "@Override\nprotected boolean matchesSafely(T item) {\n    return fMatcher.matches(item.getCause());\n}", "methodAfter": "@Override\nprotected boolean matchesSafely(T item) {\n    return matcher.matches(item.getCause());\n}"}, {"methodBefore": "@Override\nprotected boolean matchesSafely(T item) {\n    return fMatcher.matches(item.getMessage());\n}", "methodAfter": "@Override\nprotected boolean matchesSafely(T item) {\n    return matcher.matches(item.getMessage());\n}"}], [{"methodBefore": "public boolean isIgnored() {\n    return fMethod.getAnnotation(Ignore.class) != null;\n}", "methodAfter": "public boolean isIgnored() {\n    return getMethod().getAnnotation(Ignore.class) != null;\n}"}, {"methodBefore": "public long getTimeout() {\n    Test annotation = fMethod.getAnnotation(Test.class);\n    if (annotation == null) {\n        return 0;\n    }\n    long timeout = annotation.timeout();\n    return timeout;\n}", "methodAfter": "public long getTimeout() {\n    Test annotation = getMethod().getAnnotation(Test.class);\n    if (annotation == null) {\n        return 0;\n    }\n    long timeout = annotation.timeout();\n    return timeout;\n}"}], [{"methodBefore": "@Test\npublic void shouldThrowException() throws Exception {\n    FilterFactoryParams params = new FilterFactoryParams(\"NonExistentFilter\");\n    expectedException.expect(FilterNotCreatedException.class);\n    categoryFilterFactory.createFilter(params);\n}", "methodAfter": "@Test\npublic void shouldThrowException() throws Exception {\n    FilterFactoryParams params = new FilterFactoryParams(createSuiteDescription(testName.getMethodName()), \"NonExistentFilter\");\n    expectedException.expect(FilterNotCreatedException.class);\n    categoryFilterFactory.createFilter(params);\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFilter() throws Exception {\n    FilterFactoryParams params = new FilterFactoryParams(CategoryFilterFactoryTest.CategoryFilterFactoryStub.class.getName());\n    Filter filter = categoryFilterFactory.createFilter(params);\n    assertThat(filter, instanceOf(CategoryFilterFactoryTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilter() throws Exception {\n    FilterFactoryParams params = new FilterFactoryParams(createSuiteDescription(testName.getMethodName()), CategoryFilterFactoryTest.CategoryFilterFactoryStub.class.getName());\n    Filter filter = categoryFilterFactory.createFilter(params);\n    assertThat(filter, instanceOf(CategoryFilterFactoryTest.DummyFilter.class));\n}"}], [{"methodBefore": "public Runner apply(Runner runner) throws NoTestsRemainException {\n    if (runner instanceof Filterable) {\n        Filterable filterable = ((Filterable) (runner));\n        filterable.filter(this);\n    }\n    return runner;\n}", "methodAfter": "public void apply(Runner runner) throws NoTestsRemainException {\n    if (runner instanceof Filterable) {\n        Filterable filterable = ((Filterable) (runner));\n        filterable.filter(this);\n    }\n}"}, {"methodBefore": "private T filterChild(T child) throws NoTestsRemainException {\n    if (fFilter != null) {\n        fFilter.apply(child);\n    }\n    return child;\n}", "methodAfter": "private void filterChild(T child) throws NoTestsRemainException {\n    if (fFilter != null) {\n        fFilter.apply(child);\n    }\n}"}], [{"methodBefore": "protected Collection<Field> getSingleDataPointFields(ParameterSignature sig) {\n    List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoint.class);\n    Collection<Field> validFields = new ArrayList<Field>();\n    for (FrameworkField frameworkField : fields) {\n        validFields.add(frameworkField.getField());\n    }\n    return validFields;\n}", "methodAfter": "protected Collection<Field> getSingleDataPointFields(ParameterSignature sig) {\n    List<FrameworkField> fields = clazz.getAnnotatedFields(DataPoint.class);\n    Collection<Field> validFields = new ArrayList<Field>();\n    for (FrameworkField frameworkField : fields) {\n        validFields.add(frameworkField.getField());\n    }\n    return validFields;\n}"}, {"methodBefore": "public boolean isPublic() {\n    return Modifier.isPublic(fClass.getModifiers());\n}", "methodAfter": "public boolean isPublic() {\n    return Modifier.isPublic(clazz.getModifiers());\n}"}, {"methodBefore": "protected Collection<FrameworkMethod> getSingleDataPointMethods(ParameterSignature sig) {\n    return fClass.getAnnotatedMethods(DataPoint.class);\n}", "methodAfter": "protected Collection<FrameworkMethod> getSingleDataPointMethods(ParameterSignature sig) {\n    return clazz.getAnnotatedMethods(DataPoint.class);\n}"}, {"methodBefore": "public AllMembersSupplier(TestClass type) {\n    fClass = type;\n}", "methodAfter": "public AllMembersSupplier(TestClass type) {\n    clazz = type;\n}"}, {"methodBefore": "protected Collection<Field> getDataPointsFields(ParameterSignature sig) {\n    List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoints.class);\n    Collection<Field> validFields = new ArrayList<Field>();\n    for (FrameworkField frameworkField : fields) {\n        validFields.add(frameworkField.getField());\n    }\n    return validFields;\n}", "methodAfter": "protected Collection<Field> getDataPointsFields(ParameterSignature sig) {\n    List<FrameworkField> fields = clazz.getAnnotatedFields(DataPoints.class);\n    Collection<Field> validFields = new ArrayList<Field>();\n    for (FrameworkField frameworkField : fields) {\n        validFields.add(frameworkField.getField());\n    }\n    return validFields;\n}"}, {"methodBefore": "private ParameterSupplier getSupplier(ParameterSignature unassigned) throws Exception {\n    ParametersSuppliedBy annotation = unassigned.findDeepAnnotation(ParametersSuppliedBy.class);\n    if (annotation != null) {\n        return buildParameterSupplierFromClass(annotation.value());\n    } else {\n        return new AllMembersSupplier(fClass);\n    }\n}", "methodAfter": "private ParameterSupplier getSupplier(ParameterSignature unassigned) throws Exception {\n    ParametersSuppliedBy annotation = unassigned.findDeepAnnotation(ParametersSuppliedBy.class);\n    if (annotation != null) {\n        return buildParameterSupplierFromClass(annotation.value());\n    } else {\n        return new AllMembersSupplier(clazz);\n    }\n}"}, {"methodBefore": "private ParameterSupplier buildParameterSupplierFromClass(Class<? extends ParameterSupplier> cls) throws Exception {\n    Constructor<?>[] supplierConstructors = cls.getConstructors();\n    for (Constructor<?> constructor : supplierConstructors) {\n        Class<?>[] parameterTypes = constructor.getParameterTypes();\n        if ((parameterTypes.length == 1) && parameterTypes[0].equals(TestClass.class)) {\n            return ((ParameterSupplier) (constructor.newInstance(fClass)));\n        }\n    }\n    return cls.newInstance();\n}", "methodAfter": "private ParameterSupplier buildParameterSupplierFromClass(Class<? extends ParameterSupplier> cls) throws Exception {\n    Constructor<?>[] supplierConstructors = cls.getConstructors();\n    for (Constructor<?> constructor : supplierConstructors) {\n        Class<?>[] parameterTypes = constructor.getParameterTypes();\n        if ((parameterTypes.length == 1) && parameterTypes[0].equals(TestClass.class)) {\n            return ((ParameterSupplier) (constructor.newInstance(clazz)));\n        }\n    }\n    return cls.newInstance();\n}"}, {"methodBefore": "private int getConstructorParameterCount() {\n    List<ParameterSignature> signatures = ParameterSignature.signatures(fClass.getOnlyConstructor());\n    int constructorParameterCount = signatures.size();\n    return constructorParameterCount;\n}", "methodAfter": "private int getConstructorParameterCount() {\n    List<ParameterSignature> signatures = ParameterSignature.signatures(clazz.getOnlyConstructor());\n    int constructorParameterCount = signatures.size();\n    return constructorParameterCount;\n}"}, {"methodBefore": "protected Collection<FrameworkMethod> getDataPointsMethods(ParameterSignature sig) {\n    return fClass.getAnnotatedMethods(DataPoints.class);\n}", "methodAfter": "protected Collection<FrameworkMethod> getDataPointsMethods(ParameterSignature sig) {\n    return clazz.getAnnotatedMethods(DataPoints.class);\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testDisplayName\"));\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    return suite;\n}"}], [{"methodBefore": "public String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}", "methodAfter": "private String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}"}, {"methodBefore": "public String compact(String message) {\n    if (((fExpected == null) || (fActual == null)) || areStringsEqual()) {\n        return Assert.format(message, fExpected, fActual);\n    }\n    findCommonPrefix();\n    findCommonSuffix();\n    String expected = compactString(fExpected);\n    String actual = compactString(fActual);\n    return Assert.format(message, expected, actual);\n}", "methodAfter": "private String compact(String message) {\n    if (((fExpected == null) || (fActual == null)) || areStringsEqual()) {\n        return Assert.format(message, fExpected, fActual);\n    }\n    findCommonPrefix();\n    findCommonSuffix();\n    String expected = compactString(fExpected);\n    String actual = compactString(fActual);\n    return Assert.format(message, expected, actual);\n}"}], [{"methodBefore": "@After\npublic void after() {\n    watchedLog += \"after \";\n}", "methodAfter": "@After\npublic void after() {\n    watchedLog.append(\"after \");\n}"}, {"methodBefore": "@Before\npublic void before() {\n    watchedLog += \"before \";\n}", "methodAfter": "@Before\npublic void before() {\n    watchedLog.append(\"before \");\n}"}], [{"methodBefore": "private Description describeCause(Throwable child) {\n    return Description.createTestDescription(fTestClass, \"initializationError\");\n}", "methodAfter": "private Description describeCause(Throwable child) {\n    return Description.createTestDescription(testClass, \"initializationError\");\n}"}, {"methodBefore": "public TestClass getTestClass() {\n    return fTestClass;\n}", "methodAfter": "public TestClass getTestClass() {\n    return testClass;\n}"}, {"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = testClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}, {"methodBefore": "protected Annotation[] getRunnerAnnotations() {\n    return fTestClass.getAnnotations();\n}", "methodAfter": "protected Annotation[] getRunnerAnnotations() {\n    return testClass.getAnnotations();\n}"}, {"methodBefore": "public final TestClass getTestClass() {\n    return fTestClass;\n}", "methodAfter": "public final TestClass getTestClass() {\n    return testClass;\n}"}, {"methodBefore": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}", "methodAfter": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = testClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}"}, {"methodBefore": "protected String getName() {\n    return fTestClass.getName();\n}", "methodAfter": "protected String getName() {\n    return testClass.getName();\n}"}, {"methodBefore": "private TestClass getTestClass() {\n    return fTestClass;\n}", "methodAfter": "private TestClass getTestClass() {\n    return testClass;\n}"}], [{"methodBefore": "@Override\nprotected List<Method> getAfters() {\n    return fTestClass.getAnnotatedMethods(After.class);\n}", "methodAfter": "@Override\npublic List<Method> getAfters() {\n    return fTestClass.getAnnotatedMethods(After.class);\n}"}, {"methodBefore": "@Override\nprotected List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}", "methodAfter": "@Override\npublic List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}"}], [{"methodBefore": "public void testNoTestCaseClass() {\n    Test t = new TestSuite(NoTestCaseClass.class);\n    t.run(fResult);\n    assertEquals(1, fResult.runCount());\n    assert !fResult.wasSuccessful();\n}", "methodAfter": "public void testNoTestCaseClass() {\n    Test t = new TestSuite(NoTestCaseClass.class);\n    t.run(fResult);\n    assertEquals(1, fResult.runCount());\n    assertTrue(!fResult.wasSuccessful());\n}"}, {"methodBefore": "public void testInheritedTests() {\n    TestSuite suite = new TestSuite(InheritedTestCase.class);\n    suite.run(fResult);\n    assert fResult.wasSuccessful();\n    assertEquals(2, fResult.runCount());\n}", "methodAfter": "public void testInheritedTests() {\n    TestSuite suite = new TestSuite(InheritedTestCase.class);\n    suite.run(fResult);\n    assertTrue(fResult.wasSuccessful());\n    assertEquals(2, fResult.runCount());\n}"}], [{"methodBefore": "@Override\npublic void testRunFinished(Result result) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testRunFinished(result);\n    }\n}", "methodAfter": "@Override\npublic void testRunFinished(Result result) throws Exception {\n    synchronized(monitor) {\n        listener.testRunFinished(result);\n    }\n}"}, {"methodBefore": "@Override\npublic void testFinished(Description description) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testFinished(description);\n    }\n}", "methodAfter": "@Override\npublic void testFinished(Description description) throws Exception {\n    synchronized(monitor) {\n        listener.testFinished(description);\n    }\n}"}], [{"methodBefore": "@Test\npublic void twoTestsNotRunComeBackInRandomOrder() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = MaxCore.createFresh();\n    List<Description> things = max.sort(request);\n    Description succeed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"succeed\");\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertTrue(things.contains(succeed));\n    assertTrue(things.contains(dontSucceed));\n    assertEquals(2, things.size());\n}", "methodAfter": "@Test\npublic void twoTestsNotRunComeBackInRandomOrder() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = MaxCore.createFresh();\n    List<Description> things = max.sortedLeavesForTest(request);\n    Description succeed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"succeed\");\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertTrue(things.contains(succeed));\n    assertTrue(things.contains(dontSucceed));\n    assertEquals(2, things.size());\n}"}, {"methodBefore": "@Test\npublic void preferRecentlyFailed() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = MaxCore.createFresh();\n    max.run(request);\n    List<Description> tests = max.sort(request);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, tests.get(0));\n}", "methodAfter": "@Test\npublic void preferRecentlyFailed() {\n    Request request = Request.aClass(MaxStarterTest.TwoTests.class);\n    MaxCore max = MaxCore.createFresh();\n    max.run(request);\n    List<Description> tests = max.sortedLeavesForTest(request);\n    Description dontSucceed = Description.createTestDescription(MaxStarterTest.TwoTests.class, \"dontSucceed\");\n    assertEquals(dontSucceed, tests.get(0));\n}"}], [{"methodBefore": "@Test\npublic void assertEmptyDoesNotThrowForEmptyList() throws Throwable {\n    MultipleFailureException.assertEmpty(Collections.<Throwable>emptyList());\n}", "methodAfter": "@Test\npublic void assertEmptyDoesNotThrowForEmptyList() throws Exception {\n    MultipleFailureException.assertEmpty(Collections.<Throwable>emptyList());\n}"}, {"methodBefore": "@Test\npublic void assertEmptyThrowsMutipleFailureExceptionForManyThrowables() throws Throwable {\n    List<Throwable> errors = new ArrayList<Throwable>();\n    errors.add(new ExpectedException(\"basil\"));\n    errors.add(new RuntimeException(\"garlic\"));\n    try {\n        MultipleFailureException.assertEmpty(errors);\n        fail();\n    } catch (MultipleFailureException expected) {\n        assertThat(expected.getFailures(), equalTo(errors));\n        assertTrue(expected.getMessage().startsWith(\"There were 2 errors:\\n\"));\n        assertTrue(expected.getMessage().contains(\"ExpectedException(basil)\\n\"));\n        assertTrue(expected.getMessage().contains(\"RuntimeException(garlic)\"));\n    }\n}", "methodAfter": "@Test\npublic void assertEmptyThrowsMutipleFailureExceptionForManyThrowables() throws Exception {\n    List<Throwable> errors = new ArrayList<Throwable>();\n    errors.add(new ExpectedException(\"basil\"));\n    errors.add(new RuntimeException(\"garlic\"));\n    try {\n        MultipleFailureException.assertEmpty(errors);\n        fail();\n    } catch (MultipleFailureException expected) {\n        assertThat(expected.getFailures(), equalTo(errors));\n        assertTrue(expected.getMessage().startsWith(\"There were 2 errors:\\n\"));\n        assertTrue(expected.getMessage().contains(\"ExpectedException(basil)\\n\"));\n        assertTrue(expected.getMessage().contains(\"RuntimeException(garlic)\"));\n    }\n}"}, {"methodBefore": "@Test\npublic void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination() throws NoSuchMethodException {\n    Method beforeClass = CategoryValidatorTest.CategoryTest.class.getMethod(\"methodWithCategory\");\n    List<Throwable> errors = new CategoryValidator().validateAnnotatedMethod(beforeClass);\n    assertThat(errors.size(), is(0));\n}", "methodAfter": "@Test\npublic void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination() throws NoSuchMethodException {\n    Method beforeClass = CategoryValidatorTest.CategoryTest.class.getMethod(\"methodWithCategory\");\n    List<Exception> errors = new CategoryValidator().validateAnnotatedMethod(beforeClass);\n    assertThat(errors.size(), is(0));\n}"}], [{"methodBefore": "protected Collection<Field> getDataPointsFields(ParameterSignature sig) {\n    List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoints.class);\n    Collection<Field> validFields = new ArrayList<Field>();\n    for (FrameworkField frameworkField : fields) {\n        validFields.add(frameworkField.getField());\n    }\n    return validFields;\n}", "methodAfter": "protected Collection<Field> getDataPointsFields(ParameterSignature sig) {\n    List<FrameworkField> fields = clazz.getAnnotatedFields(DataPoints.class);\n    Collection<Field> validFields = new ArrayList<Field>();\n    for (FrameworkField frameworkField : fields) {\n        validFields.add(frameworkField.getField());\n    }\n    return validFields;\n}"}, {"methodBefore": "protected Collection<Field> getSingleDataPointFields(ParameterSignature sig) {\n    List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoint.class);\n    Collection<Field> validFields = new ArrayList<Field>();\n    for (FrameworkField frameworkField : fields) {\n        validFields.add(frameworkField.getField());\n    }\n    return validFields;\n}", "methodAfter": "protected Collection<Field> getSingleDataPointFields(ParameterSignature sig) {\n    List<FrameworkField> fields = clazz.getAnnotatedFields(DataPoint.class);\n    Collection<Field> validFields = new ArrayList<Field>();\n    for (FrameworkField frameworkField : fields) {\n        validFields.add(frameworkField.getField());\n    }\n    return validFields;\n}"}], [{"methodBefore": "public void testAssertEqualsNaNFails() {\n    try {\n        assertEquals(1.234, Double.NaN, 1.0E-5);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}", "methodAfter": "public void testAssertEqualsNaNFails() {\n    try {\n        assertEquals(1.234, Double.NaN, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}, {"methodBefore": "public void testAssertNaNEqualsFails() {\n    try {\n        assertEquals(Double.NaN, 1.234, 1.0E-5);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}", "methodAfter": "public void testAssertNaNEqualsFails() {\n    try {\n        assertEquals(Double.NaN, 1.234, 0.0);\n    } catch (AssertionFailedError e) {\n        return;\n    }\n    fail();\n}"}], [{"methodBefore": "public Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}], [{"methodBefore": "@Override\nprotected List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}", "methodAfter": "@Override\npublic List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}"}, {"methodBefore": "protected PrintStream getWriter() {\n    return fWriter;\n}", "methodAfter": "public PrintStream getWriter() {\n    return fWriter;\n}"}], [{"methodBefore": "@Test\npublic void ignoreExceptionsFromDataPointMethods() {\n    assertThat(failures(WithDataPointMethod.HasUglyDataPointMethod.class), empty());\n}", "methodAfter": "@Test\npublic void ignoreExceptionsFromDataPointMethods() {\n    assertThat(testResult(WithDataPointMethod.HasUglyDataPointMethod.class), isSuccessful());\n}"}, {"methodBefore": "@Test\npublic void pickUpDataPointMethods() {\n    assertThat(failures(WithDataPointMethod.HasDataPointMethod.class), empty());\n}", "methodAfter": "@Test\npublic void pickUpDataPointMethods() {\n    assertThat(testResult(WithDataPointMethod.HasDataPointMethod.class), isSuccessful());\n}"}], [{"methodBefore": "public static String getFilteredTrace(Throwable t) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    t.printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    String trace = buffer.toString();\n    return BaseTestRunner.filterStack(trace);\n}", "methodAfter": "public static String getFilteredTrace(Throwable t) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    t.printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    String trace = buffer.toString();\n    return BaseTestRunner.getFilteredTrace(trace);\n}"}, {"methodBefore": "public void testFilter() {\n    assertEquals(fFiltered, BaseTestRunner.filterStack(fUnfiltered));\n}", "methodAfter": "public void testFilter() {\n    assertEquals(fFiltered, BaseTestRunner.getFilteredTrace(fUnfiltered));\n}"}], [{"methodBefore": "@Override\npublic void checkPermission(Permission perm) {\n}", "methodAfter": "@Override\npublic void checkPermission(Permission perm) {\n    if (originalSecurityManager != null) {\n        originalSecurityManager.checkPermission(perm);\n    }\n}"}, {"methodBefore": "@Override\npublic void checkPermission(Permission perm, Object context) {\n}", "methodAfter": "@Override\npublic void checkPermission(Permission perm, Object context) {\n    if (originalSecurityManager != null) {\n        originalSecurityManager.checkPermission(perm, context);\n    }\n}"}], [{"methodBefore": "protected JCheckBox createUseLoaderCheckBox() {\n    boolean useLoader = useReloadingTestSuiteLoader();\n    JCheckBox box = new JCheckBox(\"Reload classes every run\", useLoader);\n    box.setToolTipText(\"Use a custom class loader to reload the classes for every run\");\n    return box;\n}", "methodAfter": "protected JCheckBox createUseLoaderCheckBox() {\n    boolean useLoader = useReloadingTestSuiteLoader();\n    JCheckBox box = new JCheckBox(\"Reload classes every run\", useLoader);\n    box.setToolTipText(\"Use a custom class loader to reload the classes for every run\");\n    if (inVAJava()) {\n        box.setVisible(false);\n    }\n    return box;\n}"}, {"methodBefore": "protected Frame createUI(String suiteName) {\n    Frame frame = new Frame(\"JUnit\");\n    Image icon = loadFrameIcon();\n    if (icon != null) {\n        frame.setIconImage(icon);\n    }\n    frame.setLayout(new BorderLayout(0, 0));\n    frame.setBackground(SystemColor.control);\n    final Frame finalFrame = frame;\n    frame.addWindowListener(new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n            finalFrame.dispose();\n            System.exit(0);\n        }\n    });\n    MenuBar mb = new MenuBar();\n    createMenus(mb);\n    frame.setMenuBar(mb);\n    Label suiteLabel = new Label(\"Test class name:\");\n    fSuiteField = new TextField(suiteName != null ? suiteName : \"\");\n    fSuiteField.selectAll();\n    fSuiteField.requestFocus();\n    fSuiteField.setFont(PLAIN_FONT);\n    fSuiteField.setColumns(40);\n    fSuiteField.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    fSuiteField.addTextListener(new TextListener() {\n        public void textValueChanged(TextEvent e) {\n            fRun.setEnabled(fSuiteField.getText().length() > 0);\n            fStatusLine.setText(\"\");\n        }\n    });\n    fRun = new Button(\"Run\");\n    fRun.setEnabled(false);\n    fRun.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    boolean useLoader = useReloadingTestSuiteLoader();\n    fUseLoadingRunner = new Checkbox(\"Reload classes every run\", useLoader);\n    fProgressIndicator = new ProgressBar();\n    fNumberOfErrors = new Label(\"0000\", Label.RIGHT);\n    fNumberOfErrors.setText(\"0\");\n    fNumberOfErrors.setFont(PLAIN_FONT);\n    fNumberOfFailures = new Label(\"0000\", Label.RIGHT);\n    fNumberOfFailures.setText(\"0\");\n    fNumberOfFailures.setFont(PLAIN_FONT);\n    fNumberOfRuns = new Label(\"0000\", Label.RIGHT);\n    fNumberOfRuns.setText(\"0\");\n    fNumberOfRuns.setFont(PLAIN_FONT);\n    Panel numbersPanel = new Panel(new FlowLayout());\n    numbersPanel.add(new Label(\"Runs:\"));\n    numbersPanel.add(fNumberOfRuns);\n    numbersPanel.add(new Label(\"   Errors:\"));\n    numbersPanel.add(fNumberOfErrors);\n    numbersPanel.add(new Label(\"   Failures:\"));\n    numbersPanel.add(fNumberOfFailures);\n    Label failureLabel = new Label(\"Errors and Failures:\");\n    fFailureList = new List(5);\n    fFailureList.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n            failureSelected();\n        }\n    });\n    fRerunButton = new Button(\"Run\");\n    fRerunButton.setEnabled(false);\n    fRerunButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            rerun();\n        }\n    });\n    Panel failedPanel = new Panel(new GridLayout(0, 1, 0, 2));\n    failedPanel.add(fRerunButton);\n    fTraceArea = new TextArea();\n    fTraceArea.setRows(5);\n    fTraceArea.setColumns(60);\n    fStatusLine = new TextField();\n    fStatusLine.setFont(PLAIN_FONT);\n    fStatusLine.setEditable(false);\n    fStatusLine.setForeground(Color.red);\n    fQuitButton = new Button(\"Exit\");\n    fQuitButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    fLogo = new Logo();\n    Panel panel = new Panel(new GridBagLayout());\n    addGrid(panel, suiteLabel, 0, 0, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fSuiteField, 0, 1, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fRun, 2, 1, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fLogo, 2, 3, 1, GridBagConstraints.NONE, 0.0, GridBagConstraints.NORTH);\n    addGrid(panel, numbersPanel, 0, 4, 2, GridBagConstraints.NONE, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, failureLabel, 0, 5, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fFailureList, 0, 6, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, failedPanel, 2, 6, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fTraceArea, 0, 7, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fStatusLine, 0, 8, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.CENTER);\n    addGrid(panel, fQuitButton, 2, 8, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    frame.add(panel, BorderLayout.CENTER);\n    frame.pack();\n    return frame;\n}", "methodAfter": "protected Frame createUI(String suiteName) {\n    Frame frame = new Frame(\"JUnit\");\n    Image icon = loadFrameIcon();\n    if (icon != null) {\n        frame.setIconImage(icon);\n    }\n    frame.setLayout(new BorderLayout(0, 0));\n    frame.setBackground(SystemColor.control);\n    final Frame finalFrame = frame;\n    frame.addWindowListener(new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n            finalFrame.dispose();\n            System.exit(0);\n        }\n    });\n    MenuBar mb = new MenuBar();\n    createMenus(mb);\n    frame.setMenuBar(mb);\n    Label suiteLabel = new Label(\"Test class name:\");\n    fSuiteField = new TextField(suiteName != null ? suiteName : \"\");\n    fSuiteField.selectAll();\n    fSuiteField.requestFocus();\n    fSuiteField.setFont(PLAIN_FONT);\n    fSuiteField.setColumns(40);\n    fSuiteField.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    fSuiteField.addTextListener(new TextListener() {\n        public void textValueChanged(TextEvent e) {\n            fRun.setEnabled(fSuiteField.getText().length() > 0);\n            fStatusLine.setText(\"\");\n        }\n    });\n    fRun = new Button(\"Run\");\n    fRun.setEnabled(false);\n    fRun.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    boolean useLoader = useReloadingTestSuiteLoader();\n    fUseLoadingRunner = new Checkbox(\"Reload classes every run\", useLoader);\n    if (inVAJava()) {\n        fUseLoadingRunner.setVisible(false);\n    }\n    fProgressIndicator = new ProgressBar();\n    fNumberOfErrors = new Label(\"0000\", Label.RIGHT);\n    fNumberOfErrors.setText(\"0\");\n    fNumberOfErrors.setFont(PLAIN_FONT);\n    fNumberOfFailures = new Label(\"0000\", Label.RIGHT);\n    fNumberOfFailures.setText(\"0\");\n    fNumberOfFailures.setFont(PLAIN_FONT);\n    fNumberOfRuns = new Label(\"0000\", Label.RIGHT);\n    fNumberOfRuns.setText(\"0\");\n    fNumberOfRuns.setFont(PLAIN_FONT);\n    Panel numbersPanel = new Panel(new FlowLayout());\n    numbersPanel.add(new Label(\"Runs:\"));\n    numbersPanel.add(fNumberOfRuns);\n    numbersPanel.add(new Label(\"   Errors:\"));\n    numbersPanel.add(fNumberOfErrors);\n    numbersPanel.add(new Label(\"   Failures:\"));\n    numbersPanel.add(fNumberOfFailures);\n    Label failureLabel = new Label(\"Errors and Failures:\");\n    fFailureList = new List(5);\n    fFailureList.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n            failureSelected();\n        }\n    });\n    fRerunButton = new Button(\"Run\");\n    fRerunButton.setEnabled(false);\n    fRerunButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            rerun();\n        }\n    });\n    Panel failedPanel = new Panel(new GridLayout(0, 1, 0, 2));\n    failedPanel.add(fRerunButton);\n    fTraceArea = new TextArea();\n    fTraceArea.setRows(5);\n    fTraceArea.setColumns(60);\n    fStatusLine = new TextField();\n    fStatusLine.setFont(PLAIN_FONT);\n    fStatusLine.setEditable(false);\n    fStatusLine.setForeground(Color.red);\n    fQuitButton = new Button(\"Exit\");\n    fQuitButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    fLogo = new Logo();\n    Panel panel = new Panel(new GridBagLayout());\n    addGrid(panel, suiteLabel, 0, 0, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fSuiteField, 0, 1, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fRun, 2, 1, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fLogo, 2, 3, 1, GridBagConstraints.NONE, 0.0, GridBagConstraints.NORTH);\n    addGrid(panel, numbersPanel, 0, 4, 2, GridBagConstraints.NONE, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, failureLabel, 0, 5, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fFailureList, 0, 6, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, failedPanel, 2, 6, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fTraceArea, 0, 7, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fStatusLine, 0, 8, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.CENTER);\n    addGrid(panel, fQuitButton, 2, 8, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    frame.add(panel, BorderLayout.CENTER);\n    frame.pack();\n    return frame;\n}"}], [{"methodBefore": "public ExpectedException handleAssertionErrors() {\n    handleAssertionErrors = true;\n    return this;\n}", "methodAfter": "@Deprecated\npublic ExpectedException handleAssertionErrors() {\n    return this;\n}"}, {"methodBefore": "public ExpectedException handleAssumptionViolatedExceptions() {\n    handleAssumptionViolatedExceptions = true;\n    return this;\n}", "methodAfter": "@Deprecated\npublic ExpectedException handleAssumptionViolatedExceptions() {\n    return this;\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(ExtensionTest.class);\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(ExceptionTestCaseTest.class);\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(ActiveTestTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(RepeatedTestTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(ExtensionTest.class);\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(ExceptionTestCaseTest.class);\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(ActiveTestTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(RepeatedTestTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}], [{"methodBefore": "protected String getName() {\n    return getTestClass().getName();\n}", "methodAfter": "protected String getName() {\n    return fTestClass.getName();\n}"}, {"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}, {"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}, {"methodBefore": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}", "methodAfter": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}"}, {"methodBefore": "protected Description methodDescription(TestMethod method) {\n    return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getMethod().getAnnotations());\n}", "methodAfter": "protected Description methodDescription(TestMethod method) {\n    return Description.createTestDescription(fTestClass.getJavaClass(), testName(method), method.getMethod().getAnnotations());\n}"}, {"methodBefore": "protected Object createTest() throws Exception {\n    return getTestClass().getConstructor().newInstance();\n}", "methodAfter": "protected Object createTest() throws Exception {\n    return fTestClass.getConstructor().newInstance();\n}"}, {"methodBefore": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}", "methodAfter": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}"}], [{"methodBefore": "List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}", "methodAfter": "@Override\nprotected List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}"}, {"methodBefore": "List<Method> getAfters() {\n    return fTestClass.getAnnotatedMethods(After.class);\n}", "methodAfter": "@Override\nprotected List<Method> getAfters() {\n    return fTestClass.getAnnotatedMethods(After.class);\n}"}], [{"methodBefore": "public AssumptionViolatedException(String assumption, Throwable t) {\n    this(assumption, false, t, null);\n}", "methodAfter": "public AssumptionViolatedException(String assumption, Throwable e) {\n    this(assumption, false, e, null);\n}"}, {"methodBefore": "public static void assumeNoException(String message, Throwable t) {\n    assumeThat(message, t, nullValue());\n}", "methodAfter": "public static void assumeNoException(String message, Throwable e) {\n    assumeThat(message, e, nullValue());\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    suite.addTestSuite(TextRunnerSingleMethodTest.class);\n    suite.addTestSuite(TextRunnerTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(ResultTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    suite.addTestSuite(TextRunnerSingleMethodTest.class);\n    suite.addTestSuite(TextRunnerTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    suite.addTestSuite(FloatAssertTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    suite.addTestSuite(TextRunnerSingleMethodTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    suite.addTestSuite(FloatAssertTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertionFailedErrorTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    suite.addTestSuite(FloatAssertTest.class);\n    return suite;\n}"}], [{"methodBefore": "@Override\nprotected void describeMismatchSafely(T item, Description description) {\n    description.appendText(\"cause \");\n    matcher.describeMismatch(item.getCause(), description);\n}", "methodAfter": "@Override\nprotected void describeMismatchSafely(T item, Description description) {\n    description.appendText(\"cause \");\n    causeMatcher.describeMismatch(item.getCause(), description);\n}"}, {"methodBefore": "public void describeTo(Description description) {\n    description.appendText(\"exception with cause \");\n    description.appendDescriptionOf(matcher);\n}", "methodAfter": "public void describeTo(Description description) {\n    description.appendText(\"exception with cause \");\n    description.appendDescriptionOf(causeMatcher);\n}"}, {"methodBefore": "@Override\nprotected boolean matchesSafely(T item) {\n    return matcher.matches(item.getCause());\n}", "methodAfter": "@Override\nprotected boolean matchesSafely(T item) {\n    return causeMatcher.matches(item.getCause());\n}"}], [{"methodBefore": "public void test() {\n    fail();\n}", "methodAfter": "public void runTest() {\n    fail();\n}"}, {"methodBefore": "public void success() {\n}", "methodAfter": "public void runTest() {\n}"}], [{"methodBefore": "public void addError(Test test, Throwable t) {\n    Failure failure = new Failure(asDescription(test), t);\n    fNotifier.fireTestFailure(failure);\n}", "methodAfter": "public void addError(Test test, Throwable e) {\n    Failure failure = new Failure(asDescription(test), e);\n    fNotifier.fireTestFailure(failure);\n}"}, {"methodBefore": "public static void assumeNoException(Throwable t) {\n    assumeThat(t, nullValue());\n}", "methodAfter": "public static void assumeNoException(Throwable e) {\n    assumeThat(e, nullValue());\n}"}, {"methodBefore": "public static String getFilteredTrace(Throwable t) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    t.printStackTrace(writer);\n    String trace = stringWriter.toString();\n    return BaseTestRunner.getFilteredTrace(trace);\n}", "methodAfter": "public static String getFilteredTrace(Throwable e) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    e.printStackTrace(writer);\n    String trace = stringWriter.toString();\n    return BaseTestRunner.getFilteredTrace(trace);\n}"}, {"methodBefore": "public CouldNotGenerateValueException(Throwable t) {\n    super(t);\n}", "methodAfter": "public CouldNotGenerateValueException(Throwable e) {\n    super(e);\n}"}, {"methodBefore": "private static String exceptionToString(Throwable t) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    t.printStackTrace(writer);\n    return stringWriter.toString();\n}", "methodAfter": "private static String exceptionToString(Throwable e) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    e.printStackTrace(writer);\n    return stringWriter.toString();\n}"}, {"methodBefore": "public static void assumeNoException(String message, Throwable t) {\n    assumeThat(message, t, nullValue());\n}", "methodAfter": "public static void assumeNoException(String message, Throwable e) {\n    assumeThat(message, e, nullValue());\n}"}, {"methodBefore": "public AssumptionViolatedException(String assumption, Throwable t) {\n    this(assumption, false, t, null);\n}", "methodAfter": "public AssumptionViolatedException(String assumption, Throwable e) {\n    this(assumption, false, e, null);\n}"}], [{"methodBefore": "public int getFailureCount() {\n    return fFailures.size();\n}", "methodAfter": "public int getFailureCount() {\n    return failures.size();\n}"}, {"methodBefore": "@Override\npublic void testFailure(Failure failure) throws Exception {\n    fFailures.add(failure);\n}", "methodAfter": "@Override\npublic void testFailure(Failure failure) throws Exception {\n    failures.add(failure);\n}"}, {"methodBefore": "public List<Failure> getFailures() {\n    return fFailures;\n}", "methodAfter": "public List<Failure> getFailures() {\n    return failures;\n}"}], [{"methodBefore": "public static void assertEquals(String message, String expected, String actual) {\n    if ((expected == null) && (actual == null)) {\n        return;\n    }\n    if ((expected != null) && expected.equals(actual)) {\n        return;\n    }\n    throw new ComparisonFailure(message, expected, actual);\n}", "methodAfter": "public static void assertEquals(String message, String expected, String actual) {\n    if ((expected == null) && (actual == null)) {\n        return;\n    }\n    if ((expected != null) && expected.equals(actual)) {\n        return;\n    }\n    String cleanMessage = (message == null) ? \"\" : message;\n    throw new ComparisonFailure(cleanMessage, expected, actual);\n}"}, {"methodBefore": "public static void assertEquals(String message, Object expected, Object actual) {\n    if ((expected == null) && (actual == null)) {\n        return;\n    }\n    if ((expected != null) && expected.equals(actual)) {\n        return;\n    }\n    if ((expected instanceof String) && (actual instanceof String)) {\n        throw new ComparisonFailure(message, ((String) (expected)), ((String) (actual)));\n    } else {\n        failNotEquals(message, expected, actual);\n    }\n}", "methodAfter": "public static void assertEquals(String message, Object expected, Object actual) {\n    if ((expected == null) && (actual == null)) {\n        return;\n    }\n    if ((expected != null) && expected.equals(actual)) {\n        return;\n    }\n    if ((expected instanceof String) && (actual instanceof String)) {\n        String cleanMessage = (message == null) ? \"\" : message;\n        throw new ComparisonFailure(cleanMessage, ((String) (expected)), ((String) (actual)));\n    } else {\n        failNotEquals(message, expected, actual);\n    }\n}"}], [{"methodBefore": "public List<Throwable> validateAnnotatedField(Field field) {\n    return Collections.emptyList();\n}", "methodAfter": "public List<Exception> validateAnnotatedField(Field field) {\n    return NO_VALIDATION_ERRORS;\n}"}, {"methodBefore": "public List<Throwable> validateAnnotatedClass(Class<?> type) {\n    return Collections.emptyList();\n}", "methodAfter": "public List<Exception> validateAnnotatedClass(Class<?> type) {\n    return NO_VALIDATION_ERRORS;\n}"}, {"methodBefore": "public List<Throwable> validateAnnotatedMethod(Method method) {\n    return Collections.emptyList();\n}", "methodAfter": "public List<Exception> validateAnnotatedMethod(Method method) {\n    return NO_VALIDATION_ERRORS;\n}"}], [{"methodBefore": "private void stopping() {\n    fEndNanos = System.nanoTime();\n}", "methodAfter": "private void stopping() {\n    fEndNanos = currentNanoTime();\n}"}, {"methodBefore": "private void starting() {\n    fStartNanos = System.nanoTime();\n}", "methodAfter": "private void starting() {\n    fStartNanos = currentNanoTime();\n}"}], [{"methodBefore": "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        addMultipleFailureException(((MultipleFailureException) (targetException)));\n    } else {\n        fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n    }\n}", "methodAfter": "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        addMultipleFailureException(((MultipleFailureException) (targetException)));\n    } else {\n        notifier.fireTestFailure(new Failure(description, targetException));\n    }\n}"}, {"methodBefore": "public void addFailedAssumption(AssumptionViolatedException e) {\n    fNotifier.fireTestAssumptionFailed(new Failure(fDescription, e));\n}", "methodAfter": "public void addFailedAssumption(AssumptionViolatedException e) {\n    notifier.fireTestAssumptionFailed(new Failure(description, e));\n}"}], [{"methodBefore": "@Override\npublic Description getDescription() {\n    return Description.createSuiteDescription(fTestClass);\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    return Description.createSuiteDescription(clazz);\n}"}, {"methodBefore": "public IgnoredClassRunner(Class<?> testClass) {\n    fTestClass = testClass;\n}", "methodAfter": "public IgnoredClassRunner(Class<?> testClass) {\n    clazz = testClass;\n}"}], [{"methodBefore": "public IMoney addMoneyBag(MoneyBag s) {\n    return new MoneyBag(s, this).simplify();\n}", "methodAfter": "public IMoney addMoneyBag(MoneyBag s) {\n    return MoneyBag.create(s, this);\n}"}, {"methodBefore": "public IMoney addMoney(Money m) {\n    return new MoneyBag(m, this).simplify();\n}", "methodAfter": "public IMoney addMoney(Money m) {\n    return MoneyBag.create(m, this);\n}"}], [{"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedSingleFieldDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedSingleFieldDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single value\"));\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedSingleMethodDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single method value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedSingleMethodDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single method value\"));\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    Filter filter = FilterFactories.createFilterFromFilterSpec(createSuiteDescription(testName.getMethodName()), FilterFactoriesTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoriesTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    Filter filter = FilterFactories.createFilterFromFilterSpec(createSuiteRequest(), FilterFactoriesTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoriesTest.DummyFilter.class));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFilterWithArguments() throws Exception {\n    Filter filter = FilterFactories.createFilterFromFilterSpec(createSuiteDescription(testName.getMethodName()), (ExcludeCategories.class.getName() + \"=\") + FilterFactoriesTest.DummyCategory.class.getName());\n    assertThat(filter.describe(), startsWith(\"excludes \"));\n}", "methodAfter": "@Test\npublic void shouldCreateFilterWithArguments() throws Exception {\n    Filter filter = FilterFactories.createFilterFromFilterSpec(createSuiteRequest(), (ExcludeCategories.class.getName() + \"=\") + FilterFactoriesTest.DummyCategory.class.getName());\n    assertThat(filter.describe(), startsWith(\"excludes \"));\n}"}], [{"methodBefore": "public FrameworkMethod(Method method) {\n    fMethod = method;\n}", "methodAfter": "public FrameworkMethod(Method method) {\n    if (method == null) {\n        throw new NullPointerException(\"FrameworkMethod cannot be created without an underlying method.\");\n    }\n    fMethod = method;\n}"}, {"methodBefore": "FrameworkField(Field field) {\n    fField = field;\n}", "methodAfter": "FrameworkField(Field field) {\n    if (field == null) {\n        throw new NullPointerException(\"FrameworkField cannot be created without an underlying field.\");\n    }\n    fField = field;\n}"}, {"methodBefore": "public ErrorReportingRunner(Class<?> testClass, Throwable cause) {\n    fTestClass = testClass;\n    fCauses = getCauses(cause);\n}", "methodAfter": "public ErrorReportingRunner(Class<?> testClass, Throwable cause) {\n    if (testClass == null) {\n        throw new NullPointerException(\"Test class cannot be null\");\n    }\n    fTestClass = testClass;\n    fCauses = getCauses(cause);\n}"}], [{"methodBefore": "public abstract boolean isStatic();", "methodAfter": "public boolean isStatic() {\n    return Modifier.isStatic(getModifiers());\n}"}, {"methodBefore": "public abstract boolean isPublic();", "methodAfter": "public boolean isPublic() {\n    return Modifier.isPublic(getModifiers());\n}"}], [{"methodBefore": "@Test\npublic void stopEndlessStatement() throws Throwable {\n    InfiniteLoopStatement infiniteLoop = new InfiniteLoopStatement();\n    FailOnTimeout infiniteLoopTimeout = new FailOnTimeout(infiniteLoop, TIMEOUT);\n    try {\n        infiniteLoopTimeout.evaluate();\n    } catch (Exception timeoutException) {\n        sleep(20);\n        int firstCount = InfiniteLoopStatement.COUNT;\n        sleep(20);\n        assertTrue(\"Thread has not been stopped.\", firstCount == InfiniteLoopStatement.COUNT);\n    }\n}", "methodAfter": "@Test\npublic void stopEndlessStatement() throws Throwable {\n    InfiniteLoopStatement infiniteLoop = new InfiniteLoopStatement();\n    FailOnTimeout infiniteLoopTimeout = builder().withTimeout(TIMEOUT, MILLISECONDS).build(infiniteLoop);\n    try {\n        infiniteLoopTimeout.evaluate();\n    } catch (Exception timeoutException) {\n        sleep(20);\n        int firstCount = InfiniteLoopStatement.COUNT;\n        sleep(20);\n        assertTrue(\"Thread has not been stopped.\", firstCount == InfiniteLoopStatement.COUNT);\n    }\n}"}, {"methodBefore": "@Test\npublic void stackTraceContainsRealCauseOfTimeout() throws Throwable {\n    StuckStatement stuck = new StuckStatement();\n    FailOnTimeout stuckTimeout = new FailOnTimeout(stuck, TIMEOUT);\n    try {\n        stuckTimeout.evaluate();\n        fail(\"Expected timeout exception\");\n    } catch (Exception timeoutException) {\n        StackTraceElement[] stackTrace = timeoutException.getStackTrace();\n        boolean stackTraceContainsTheRealCauseOfTheTimeout = false;\n        boolean stackTraceContainsOtherThanTheRealCauseOfTheTimeout = false;\n        for (StackTraceElement element : stackTrace) {\n            String methodName = element.getMethodName();\n            if (\"theRealCauseOfTheTimeout\".equals(methodName)) {\n                stackTraceContainsTheRealCauseOfTheTimeout = true;\n            }\n            if (\"notTheRealCauseOfTheTimeout\".equals(methodName)) {\n                stackTraceContainsOtherThanTheRealCauseOfTheTimeout = true;\n            }\n        }\n        assertTrue(\"Stack trace does not contain the real cause of the timeout\", stackTraceContainsTheRealCauseOfTheTimeout);\n        assertFalse(\"Stack trace contains other than the real cause of the timeout, which can be very misleading\", stackTraceContainsOtherThanTheRealCauseOfTheTimeout);\n    }\n}", "methodAfter": "@Test\npublic void stackTraceContainsRealCauseOfTimeout() throws Throwable {\n    StuckStatement stuck = new StuckStatement();\n    FailOnTimeout stuckTimeout = builder().withTimeout(TIMEOUT, MILLISECONDS).build(stuck);\n    try {\n        stuckTimeout.evaluate();\n        fail(\"Expected timeout exception\");\n    } catch (Exception timeoutException) {\n        StackTraceElement[] stackTrace = timeoutException.getStackTrace();\n        boolean stackTraceContainsTheRealCauseOfTheTimeout = false;\n        boolean stackTraceContainsOtherThanTheRealCauseOfTheTimeout = false;\n        for (StackTraceElement element : stackTrace) {\n            String methodName = element.getMethodName();\n            if (\"theRealCauseOfTheTimeout\".equals(methodName)) {\n                stackTraceContainsTheRealCauseOfTheTimeout = true;\n            }\n            if (\"notTheRealCauseOfTheTimeout\".equals(methodName)) {\n                stackTraceContainsOtherThanTheRealCauseOfTheTimeout = true;\n            }\n        }\n        assertTrue(\"Stack trace does not contain the real cause of the timeout\", stackTraceContainsTheRealCauseOfTheTimeout);\n        assertFalse(\"Stack trace contains other than the real cause of the timeout, which can be very misleading\", stackTraceContainsOtherThanTheRealCauseOfTheTimeout);\n    }\n}"}], [{"methodBefore": "@Test\npublic void failedAssumptionsMeanIgnored() {\n    Result result = JUnitCore.runClasses(AssumptionTest.HasFailingAssumption.class);\n    assertThat(result.getRunCount(), is(0));\n    assertThat(result.getIgnoreCount(), is(1));\n    assertThat(result.getFailureCount(), is(0));\n}", "methodAfter": "@Test\npublic void failedAssumptionsMeanPassing() {\n    Result result = JUnitCore.runClasses(AssumptionTest.HasFailingAssumption.class);\n    assertThat(result.getRunCount(), is(1));\n    assertThat(result.getIgnoreCount(), is(0));\n    assertThat(result.getFailureCount(), is(0));\n}"}, {"methodBefore": "@Test\npublic void failedAssumptionsMeanPassing() {\n    Result result = JUnitCore.runClasses(AssumptionTest.HasFailingAssumption.class);\n    assertThat(result.getRunCount(), is(1));\n    assertThat(result.getIgnoreCount(), is(0));\n    assertThat(result.getFailureCount(), is(0));\n}", "methodAfter": "@Test\npublic void failedAssumptionsMeanIgnored() {\n    Result result = JUnitCore.runClasses(AssumptionTest.HasFailingAssumption.class);\n    assertThat(result.getRunCount(), is(0));\n    assertThat(result.getIgnoreCount(), is(1));\n    assertThat(result.getFailureCount(), is(0));\n}"}], [{"methodBefore": "public void endTest(Test test) {\n    fNotifier.fireTestFinished(asDescription(test));\n}", "methodAfter": "public void endTest(Test test) {\n    notifier.fireTestFinished(asDescription(test));\n}"}, {"methodBefore": "public void startTest(Test test) {\n    fNotifier.fireTestStarted(asDescription(test));\n}", "methodAfter": "public void startTest(Test test) {\n    notifier.fireTestStarted(asDescription(test));\n}"}], [{"methodBefore": "@Override\npublic String toString() {\n    return fField.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    return field.toString();\n}"}, {"methodBefore": "public Object get(Object target) throws IllegalArgumentException, IllegalAccessException {\n    return fField.get(target);\n}", "methodAfter": "public Object get(Object target) throws IllegalArgumentException, IllegalAccessException {\n    return field.get(target);\n}"}], [{"methodBefore": "public FrameworkMethod(Method method) {\n    fMethod = method;\n}", "methodAfter": "public FrameworkMethod(Method method) {\n    if (method == null) {\n        throw new NullPointerException(\"FrameworkMethod cannot be created without an underlying method.\");\n    }\n    fMethod = method;\n}"}, {"methodBefore": "FrameworkField(Field field) {\n    fField = field;\n}", "methodAfter": "FrameworkField(Field field) {\n    if (field == null) {\n        throw new NullPointerException(\"FrameworkField cannot be created without an underlying field.\");\n    }\n    fField = field;\n}"}], [{"methodBefore": "public int getFailureCount() {\n    return fFailures.size();\n}", "methodAfter": "public int getFailureCount() {\n    return failures.size();\n}"}, {"methodBefore": "public List<Failure> getFailures() {\n    return fFailures;\n}", "methodAfter": "public List<Failure> getFailures() {\n    return failures;\n}"}], [{"methodBefore": "public File newFolder(String folderName) {\n    File file = new File(folder, folderName);\n    file.mkdir();\n    return file;\n}", "methodAfter": "public File newFolder(String folderName) {\n    File file = new File(getRoot(), folderName);\n    file.mkdir();\n    return file;\n}"}, {"methodBefore": "public File newFile(String fileName) throws IOException {\n    File file = new File(folder, fileName);\n    file.createNewFile();\n    return file;\n}", "methodAfter": "public File newFile(String fileName) throws IOException {\n    File file = new File(getRoot(), fileName);\n    file.createNewFile();\n    return file;\n}"}], [{"methodBefore": "private Description describeCause(Throwable child) {\n    return Description.createTestDescription(testClass, \"initializationError\");\n}", "methodAfter": "private Description describeCause(Throwable child) {\n    return Description.createTestDescription(classNames, \"initializationError\");\n}"}, {"methodBefore": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(testClass);\n    for (Throwable each : causes) {\n        description.addChild(describeCause(each));\n    }\n    return description;\n}", "methodAfter": "@Override\npublic Description getDescription() {\n    Description description = Description.createSuiteDescription(classNames);\n    for (Throwable each : causes) {\n        description.addChild(describeCause(each));\n    }\n    return description;\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return statement(base);\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    return statement(base);\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return statement(base);\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    return statement(base);\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}"}], [{"methodBefore": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass, fConstructorParameterCount);\n}", "methodAfter": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass, fConstructorParameterCount, fNullsOk);\n}"}, {"methodBefore": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass);\n}", "methodAfter": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass, fConstructorParameterCount);\n}"}, {"methodBefore": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(fContext, assigned, fUnassigned.subList(1, fUnassigned.size()));\n}", "methodAfter": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(fContext, assigned, fUnassigned.subList(1, fUnassigned.size()), fTarget);\n}"}], [{"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement link) {\n    return new RunBefores(link, new TestMethod(getTestClass()), target);\n}", "methodAfter": "protected Statement withBefores(FrameworkMethod method, Object target, Statement link) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return new RunBefores(link, befores, target);\n}"}, {"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement link) {\n    return new RunAfters(link, new TestMethod(getTestClass()), target);\n}", "methodAfter": "protected Statement withAfters(FrameworkMethod method, Object target, Statement link) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return new RunAfters(link, afters, target);\n}"}], [{"methodBefore": "public void testTestAndTeardownFailure() throws Exception {\n    JUnitCore core = new JUnitCore();\n    Result runner = core.run(AnnotationTest.TestAndTeardownFailureTest.class);\n    assertEquals(1, runner.getRunCount());\n    assertEquals(2, runner.getFailureCount());\n    assertThat(runner.getFailures().toString(), both(containsString(\"hereAfter\")).and(containsString(\"inTest\")));\n}", "methodAfter": "public void testTestAndTeardownFailure() throws Exception {\n    JUnitCore core = new JUnitCore();\n    Result runner = core.run(AnnotationTest.TestAndTeardownFailureTest.class);\n    assertEquals(1, runner.getRunCount());\n    assertEquals(2, runner.getFailureCount());\n    assertThat(runner.getFailures().toString(), CoreMatchers.<String>both(containsString(\"hereAfter\")).and(containsString(\"inTest\")));\n}"}, {"methodBefore": "@Parameters\npublic static Collection<Object[]> testsWithEventMatcher() {\n    return asList(new Object[][]{ new Object[]{ ExpectedExceptionTest.EmptyTestExpectingNoException.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithExpectedType.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithExpectedPartOfMessage.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithWrongType.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: an instance of java.lang.NullPointerException\")) }, new Object[]{ ExpectedExceptionTest.HasWrongMessage.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message a string containing \\\"expectedMessage\\\"\\n\" + \"     but: was <java.lang.IllegalArgumentException: actualMessage>\")) }, new Object[]{ ExpectedExceptionTest.ThrowNoExceptionButExpectExceptionWithType.class, hasSingleFailureWithMessage(\"Expected test to throw an instance of java.lang.NullPointerException\") }, new Object[]{ ExpectedExceptionTest.WronglyExpectsExceptionMessage.class, hasSingleFailure() }, new Object[]{ ExpectedExceptionTest.ExpectsSubstring.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ExpectsSubstringNullMessage.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message a string containing \\\"anything!\\\"\")) }, new Object[]{ ExpectedExceptionTest.ExpectsMessageMatcher.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ExpectedMessageMatcherFails.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message \\\"Wrong start\\\"\")) }, new Object[]{ ExpectedExceptionTest.ExpectsMatcher.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedAssumptionViolatedException.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowAssumptionViolatedExceptionButExpectOtherType.class, hasSingleFailure() }, new Object[]{ ExpectedExceptionTest.ThrowAssumptionViolatedExceptionButExpectOtherType.class, hasSingleFailureWithMessage(containsString(\"Stacktrace was: org.junit.internal.AssumptionViolatedException\")) }, new Object[]{ ExpectedExceptionTest.ViolateAssumptionAndExpectException.class, hasSingleAssumptionFailure() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedAssertionError.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowUnexpectedAssertionError.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: an instance of java.lang.NullPointerException\")) }, new Object[]{ ExpectedExceptionTest.FailAndDontHandleAssertinErrors.class, hasSingleFailureWithMessage(ARBITRARY_MESSAGE) }, new Object[]{ ExpectedExceptionTest.ExpectsMultipleMatchers.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: (an instance of java.lang.IllegalArgumentException and exception with message a string containing \\\"Ack!\\\")\")) }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithMatchingCause.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedNullCause.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowUnexpectedCause.class, hasSingleFailureWithMessage(allOf(startsWith(\"\\nExpected: (\"), containsString(\"exception with cause is <java.lang.NullPointerException: expected cause>\"), containsString(\"Stacktrace was: java.lang.IllegalArgumentException: Ack!\"), containsString(\"Caused by: java.lang.NullPointerException: an unexpected cause\"))) } });\n}", "methodAfter": "@Parameters\npublic static Collection<Object[]> testsWithEventMatcher() {\n    return asList(new Object[][]{ new Object[]{ ExpectedExceptionTest.EmptyTestExpectingNoException.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithExpectedType.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithExpectedPartOfMessage.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithWrongType.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: an instance of java.lang.NullPointerException\")) }, new Object[]{ ExpectedExceptionTest.HasWrongMessage.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message a string containing \\\"expectedMessage\\\"\\n\" + \"     but: was <java.lang.IllegalArgumentException: actualMessage>\")) }, new Object[]{ ExpectedExceptionTest.ThrowNoExceptionButExpectExceptionWithType.class, hasSingleFailureWithMessage(\"Expected test to throw an instance of java.lang.NullPointerException\") }, new Object[]{ ExpectedExceptionTest.WronglyExpectsExceptionMessage.class, hasSingleFailure() }, new Object[]{ ExpectedExceptionTest.ExpectsSubstring.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ExpectsSubstringNullMessage.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message a string containing \\\"anything!\\\"\")) }, new Object[]{ ExpectedExceptionTest.ExpectsMessageMatcher.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ExpectedMessageMatcherFails.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: exception with message \\\"Wrong start\\\"\")) }, new Object[]{ ExpectedExceptionTest.ExpectsMatcher.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedAssumptionViolatedException.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowAssumptionViolatedExceptionButExpectOtherType.class, hasSingleFailure() }, new Object[]{ ExpectedExceptionTest.ThrowAssumptionViolatedExceptionButExpectOtherType.class, hasSingleFailureWithMessage(containsString(\"Stacktrace was: org.junit.internal.AssumptionViolatedException\")) }, new Object[]{ ExpectedExceptionTest.ViolateAssumptionAndExpectException.class, hasSingleAssumptionFailure() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedAssertionError.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowUnexpectedAssertionError.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: an instance of java.lang.NullPointerException\")) }, new Object[]{ ExpectedExceptionTest.FailAndDontHandleAssertinErrors.class, hasSingleFailureWithMessage(ARBITRARY_MESSAGE) }, new Object[]{ ExpectedExceptionTest.ExpectsMultipleMatchers.class, hasSingleFailureWithMessage(startsWith(\"\\nExpected: (an instance of java.lang.IllegalArgumentException and exception with message a string containing \\\"Ack!\\\")\")) }, new Object[]{ ExpectedExceptionTest.ThrowExceptionWithMatchingCause.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowExpectedNullCause.class, everyTestRunSuccessful() }, new Object[]{ ExpectedExceptionTest.ThrowUnexpectedCause.class, hasSingleFailureWithMessage(CoreMatchers.<String>allOf(startsWith(\"\\nExpected: (\"), containsString(\"exception with cause is <java.lang.NullPointerException: expected cause>\"), containsString(\"Stacktrace was: java.lang.IllegalArgumentException: Ack!\"), containsString(\"Caused by: java.lang.NullPointerException: an unexpected cause\"))) } });\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFailureUponUncreatedFilter() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + JUnitCommandLineParserTest.FilterFactoryStub.class.getName() });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError: \"), containsString(FilterNotCreatedException.class.getName()), containsString(\"stub\")));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUncreatedFilter() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + JUnitCommandLineParserTest.FilterFactoryStub.class.getName() });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError:\"), containsString(FilterNotCreatedException.class.getName()), containsString(\"stub\")));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n    String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + nonExistentFilterFactory });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError: \"), containsString(FilterFactoryNotCreatedException.class.getName()), containsString(nonExistentFilterFactory)));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n    String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + nonExistentFilterFactory });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError:\"), containsString(FilterFactoryNotCreatedException.class.getName()), containsString(nonExistentFilterFactory)));\n}"}], [{"methodBefore": "@Override\npublic Filter createFilter(Class<?>[] categories) throws FilterNotCreatedException {\n    return new Categories.CategoryFilter.IncludesAny(categories);\n}", "methodAfter": "@Override\npublic Filter createFilter(Class<?>[] categories) {\n    return new IncludesAny(categories);\n}"}, {"methodBefore": "@Override\npublic Filter createFilter(Class<?>[] categories) throws ClassNotFoundException {\n    return new Categories.CategoryFilter.ExcludesAny(categories);\n}", "methodAfter": "@Override\npublic Filter createFilter(Class<?>[] categories) {\n    return new ExcludesAny(categories);\n}"}], [{"methodBefore": "@Override\npublic void evaluate() throws Throwable {\n    throw fError;\n}", "methodAfter": "@Override\npublic void evaluate() throws Throwable {\n    throw error;\n}"}, {"methodBefore": "public Fail(Throwable e) {\n    fError = e;\n}", "methodAfter": "public Fail(Throwable e) {\n    error = e;\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec(FilterFactoryFactoryTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec(createSuiteDescription(testName.getMethodName()), FilterFactoryFactoryTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoryFactoryTest.DummyFilter.class));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFilterWithArguments() throws Exception {\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec((ExcludeCategories.class.getName() + \"=\") + FilterFactoryFactoryTest.DummyCategory.class.getName());\n    assertThat(filter.describe(), startsWith(\"excludes \"));\n}", "methodAfter": "@Test\npublic void shouldCreateFilterWithArguments() throws Exception {\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec(createSuiteDescription(testName.getMethodName()), (ExcludeCategories.class.getName() + \"=\") + FilterFactoryFactoryTest.DummyCategory.class.getName());\n    assertThat(filter.describe(), startsWith(\"excludes \"));\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            wasRun = true;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "NoGenericTypeParametersValidator(Method method) {\n    this.fMethod = method;\n}", "methodAfter": "NoGenericTypeParametersValidator(Method method) {\n    this.method = method;\n}"}, {"methodBefore": "private MethodParameterValue(FrameworkMethod dataPointMethod) {\n    fMethod = dataPointMethod;\n}", "methodAfter": "private MethodParameterValue(FrameworkMethod dataPointMethod) {\n    method = dataPointMethod;\n}"}], [{"methodBefore": "public void testSetupErrorDontTearDown() {\n    WasRun test = new WasRun(\"\");\n    TornDown wrapper = new TornDown(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assert !wrapper.fTornDown;\n}", "methodAfter": "public void testSetupErrorDontTearDown() {\n    WasRun test = new WasRun(\"\");\n    TornDown wrapper = new TornDown(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assertTrue(!wrapper.fTornDown);\n}"}, {"methodBefore": "public void testTearDownSetupFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void setUp() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assert !fails.fTornDown;\n}", "methodAfter": "public void testTearDownSetupFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void setUp() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assertTrue(!fails.fTornDown);\n}"}], [{"methodBefore": "public void testBagSimpleAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(7, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.add(f14CHF));\n}", "methodAfter": "public void testBagSimpleAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n    assertEquals(expected, fMB1.add(f14CHF));\n}"}, {"methodBefore": "public void testBagNegate() {\n    Money bag[] = new Money[]{ new Money(-12, \"CHF\"), new Money(-7, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.negate());\n}", "methodAfter": "public void testBagNegate() {\n    IMoney expected = MoneyBag.create(new Money(-12, \"CHF\"), new Money(-7, \"USD\"));\n    assertEquals(expected, fMB1.negate());\n}"}, {"methodBefore": "public void testBagSubtract() {\n    Money bag[] = new Money[]{ new Money(-2, \"CHF\"), new Money(-14, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.subtract(fMB2));\n}", "methodAfter": "public void testBagSubtract() {\n    IMoney expected = MoneyBag.create(new Money(-2, \"CHF\"), new Money(-14, \"USD\"));\n    assertEquals(expected, fMB1.subtract(fMB2));\n}"}, {"methodBefore": "public void testBagSumAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(28, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.add(fMB2));\n}", "methodAfter": "public void testBagSumAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(28, \"USD\"));\n    assertEquals(expected, fMB1.add(fMB2));\n}"}, {"methodBefore": "public void testBagMultiply() {\n    Money bag[] = new Money[]{ new Money(24, \"CHF\"), new Money(14, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.multiply(2));\n    assertEquals(fMB1, fMB1.multiply(1));\n    assertTrue(fMB1.multiply(0).isZero());\n}", "methodAfter": "public void testBagMultiply() {\n    IMoney expected = MoneyBag.create(new Money(24, \"CHF\"), new Money(14, \"USD\"));\n    assertEquals(expected, fMB1.multiply(2));\n    assertEquals(fMB1, fMB1.multiply(1));\n    assertTrue(fMB1.multiply(0).isZero());\n}"}, {"methodBefore": "public void testSimpleBagAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(7, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, f14CHF.add(fMB1));\n}", "methodAfter": "public void testSimpleBagAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n    assertEquals(expected, f14CHF.add(fMB1));\n}"}], [{"methodBefore": "public void fireTestFinished() {\n    fNotifier.fireTestFinished(fDescription);\n}", "methodAfter": "public void fireTestFinished() {\n    notifier.fireTestFinished(description);\n}"}, {"methodBefore": "public void fireTestIgnored() {\n    fNotifier.fireTestIgnored(fDescription);\n}", "methodAfter": "public void fireTestIgnored() {\n    notifier.fireTestIgnored(description);\n}"}, {"methodBefore": "public void fireTestStarted() {\n    fNotifier.fireTestStarted(fDescription);\n}", "methodAfter": "public void fireTestStarted() {\n    notifier.fireTestStarted(description);\n}"}], [{"methodBefore": "protected void assertValid(List<Throwable> errors) throws InitializationError {\n    if (!errors.isEmpty()) {\n        throw new InitializationError(errors);\n    }\n}", "methodAfter": "protected final void assertValid(List<Throwable> errors) throws InitializationError {\n    if (!errors.isEmpty()) {\n        throw new InitializationError(errors);\n    }\n}"}, {"methodBefore": "protected TestClass getTestClass() {\n    return fTestClass;\n}", "methodAfter": "protected final TestClass getTestClass() {\n    return fTestClass;\n}"}], [{"methodBefore": "public Object[] getMethodArguments() throws CouldNotGenerateValueException {\n    return getActualValues(getConstructorParameterCount(), fAssigned.size());\n}", "methodAfter": "public Object[] getMethodArguments() throws CouldNotGenerateValueException {\n    return getActualValues(getConstructorParameterCount(), assigned.size());\n}"}, {"methodBefore": "public Object[] getAllArguments() throws CouldNotGenerateValueException {\n    return getActualValues(0, fAssigned.size());\n}", "methodAfter": "public Object[] getAllArguments() throws CouldNotGenerateValueException {\n    return getActualValues(0, assigned.size());\n}"}, {"methodBefore": "public Object[] getActualValues(int start, int stop) throws CouldNotGenerateValueException {\n    Object[] values = new Object[stop - start];\n    for (int i = start; i < stop; i++) {\n        values[i - start] = fAssigned.get(i).getValue();\n    }\n    return values;\n}", "methodAfter": "public Object[] getActualValues(int start, int stop) throws CouldNotGenerateValueException {\n    Object[] values = new Object[stop - start];\n    for (int i = start; i < stop; i++) {\n        values[i - start] = assigned.get(i).getValue();\n    }\n    return values;\n}"}], [{"methodBefore": "private static void failNotEquals(String message, Object expected, Object actual) {\n    throw new ComparisonFailure(message, expected.toString(), actual.toString());\n}", "methodAfter": "private static void failNotEquals(String message, Object expected, Object actual) {\n    throw new ComparisonFailure(message, expected == null ? \"null\" : expected.toString(), actual == null ? \"null\" : actual.toString());\n}"}, {"methodBefore": "private static void failNotEquals(String message, Object expected, Object actual) {\n    throw new ComparisonFailure(message, expected == null ? \"null\" : expected.toString(), actual == null ? \"null\" : actual.toString());\n}", "methodAfter": "private static void failNotEquals(String message, Object expected, Object actual) {\n    throw new ComparisonFailure(message, expected.toString(), actual.toString());\n}"}], [{"methodBefore": "FilterFactory createFilterFactory(Class<? extends FilterFactory> filterFactoryClass) throws FilterFactoryNotCreatedException {\n    try {\n        return filterFactoryClass.getConstructor().newInstance();\n    } catch (Exception e) {\n        throw new FilterFactoryNotCreatedException(e.getMessage());\n    }\n}", "methodAfter": "FilterFactory createFilterFactory(Class<? extends FilterFactory> filterFactoryClass) throws FilterFactoryNotCreatedException {\n    try {\n        return filterFactoryClass.getConstructor().newInstance();\n    } catch (Exception e) {\n        throw new FilterFactoryNotCreatedException(e);\n    }\n}"}, {"methodBefore": "@Override\npublic Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n    try {\n        return createFilter(parseCategories(params.getArgs()));\n    } catch (ClassNotFoundException e) {\n        throw new FilterNotCreatedException(e.getMessage());\n    }\n}", "methodAfter": "@Override\npublic Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n    try {\n        return createFilter(parseCategories(params.getArgs()));\n    } catch (ClassNotFoundException e) {\n        throw new FilterNotCreatedException(e);\n    }\n}"}, {"methodBefore": "FilterFactory createFilterFactory(String filterFactoryFqcn) throws FilterFactoryNotCreatedException {\n    Class<? extends FilterFactory> filterFactoryClass;\n    try {\n        filterFactoryClass = ClassUtil.getClass(filterFactoryFqcn).asSubclass(FilterFactory.class);\n    } catch (Exception e) {\n        throw new FilterFactoryNotCreatedException(e.getMessage());\n    }\n    return createFilterFactory(filterFactoryClass);\n}", "methodAfter": "FilterFactory createFilterFactory(String filterFactoryFqcn) throws FilterFactoryNotCreatedException {\n    Class<? extends FilterFactory> filterFactoryClass;\n    try {\n        filterFactoryClass = ClassUtil.getClass(filterFactoryFqcn).asSubclass(FilterFactory.class);\n    } catch (Exception e) {\n        throw new FilterFactoryNotCreatedException(e);\n    }\n    return createFilterFactory(filterFactoryClass);\n}"}], [{"methodBefore": "public void testBagMultiply() {\n    Money bag[] = new Money[]{ new Money(24, \"CHF\"), new Money(14, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.multiply(2));\n    assertEquals(fMB1, fMB1.multiply(1));\n    assertTrue(fMB1.multiply(0).isZero());\n}", "methodAfter": "public void testBagMultiply() {\n    IMoney expected = MoneyBag.create(new Money(24, \"CHF\"), new Money(14, \"USD\"));\n    assertEquals(expected, fMB1.multiply(2));\n    assertEquals(fMB1, fMB1.multiply(1));\n    assertTrue(fMB1.multiply(0).isZero());\n}"}, {"methodBefore": "public void testBagSimpleAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(7, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.add(f14CHF));\n}", "methodAfter": "public void testBagSimpleAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n    assertEquals(expected, fMB1.add(f14CHF));\n}"}, {"methodBefore": "public void testBagSubtract() {\n    Money bag[] = new Money[]{ new Money(-2, \"CHF\"), new Money(-14, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.subtract(fMB2));\n}", "methodAfter": "public void testBagSubtract() {\n    IMoney expected = MoneyBag.create(new Money(-2, \"CHF\"), new Money(-14, \"USD\"));\n    assertEquals(expected, fMB1.subtract(fMB2));\n}"}, {"methodBefore": "public void testSimpleBagAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(7, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, f14CHF.add(fMB1));\n}", "methodAfter": "public void testSimpleBagAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n    assertEquals(expected, f14CHF.add(fMB1));\n}"}, {"methodBefore": "public void testBagSumAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(28, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.add(fMB2));\n}", "methodAfter": "public void testBagSumAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(28, \"USD\"));\n    assertEquals(expected, fMB1.add(fMB2));\n}"}, {"methodBefore": "public void testBagNegate() {\n    Money bag[] = new Money[]{ new Money(-12, \"CHF\"), new Money(-7, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.negate());\n}", "methodAfter": "public void testBagNegate() {\n    IMoney expected = MoneyBag.create(new Money(-12, \"CHF\"), new Money(-7, \"USD\"));\n    assertEquals(expected, fMB1.negate());\n}"}], [{"methodBefore": "public static void assumeNoException(Throwable t) {\n    assumeThat(t, nullValue());\n}", "methodAfter": "public static void assumeNoException(Throwable e) {\n    assumeThat(e, nullValue());\n}"}, {"methodBefore": "public static void assumeNoException(String message, Throwable t) {\n    assumeThat(message, t, nullValue());\n}", "methodAfter": "public static void assumeNoException(String message, Throwable e) {\n    assumeThat(message, e, nullValue());\n}"}], [{"methodBefore": "public void testTearDownSetupFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void setUp() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assert !fails.fTornDown;\n}", "methodAfter": "public void testTearDownSetupFails() {\n    TornDown fails = new TornDown(\"fails\") {\n        protected void setUp() {\n            throw new Error();\n        }\n    };\n    verifyError(fails);\n    assertTrue(!fails.fTornDown);\n}"}, {"methodBefore": "public void testSetupErrorDontTearDown() {\n    WasRun test = new WasRun(\"\");\n    TornDown wrapper = new TornDown(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assert !wrapper.fTornDown;\n}", "methodAfter": "public void testSetupErrorDontTearDown() {\n    WasRun test = new WasRun(\"\");\n    TornDown wrapper = new TornDown(test) {\n        public void setUp() {\n            fail();\n        }\n    };\n    TestResult result = new TestResult();\n    wrapper.run(result);\n    assertTrue(!wrapper.fTornDown);\n}"}], [{"methodBefore": "public List<PotentialAssignment> potentialsForNextUnassigned() throws InstantiationException, IllegalAccessException {\n    ParameterSignature unassigned = nextUnassigned();\n    return getSupplier(unassigned).getValueSources(unassigned);\n}", "methodAfter": "public List<PotentialAssignment> potentialsForNextUnassigned() throws ReflectiveOperationException {\n    ParameterSignature unassigned = nextUnassigned();\n    return getSupplier(unassigned).getValueSources(unassigned);\n}"}, {"methodBefore": "private GuesserQueue createGuesserQueue(Assignments incomplete) throws InstantiationException, IllegalAccessException {\n    ParameterSignature nextUnassigned = incomplete.nextUnassigned();\n    if (nextUnassigned.hasAnnotation(Stub.class)) {\n        GuesserQueue queue = new GuesserQueue();\n        queue.add(new Guesser<Object>(nextUnassigned.getType()));\n        return queue;\n    }\n    return GuesserQueue.forSingleValues(incomplete.potentialsForNextUnassigned());\n}", "methodAfter": "private GuesserQueue createGuesserQueue(Assignments incomplete) throws ReflectiveOperationException {\n    ParameterSignature nextUnassigned = incomplete.nextUnassigned();\n    if (nextUnassigned.hasAnnotation(Stub.class)) {\n        GuesserQueue queue = new GuesserQueue();\n        queue.add(new Guesser<Object>(nextUnassigned.getType()));\n        return queue;\n    }\n    return GuesserQueue.forSingleValues(incomplete.potentialsForNextUnassigned());\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    suite.addTestSuite(FloatAssertTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    suite.addTestSuite(TextRunnerSingleMethodTest.class);\n    suite.addTestSuite(TextRunnerTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(ResultTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    suite.addTestSuite(TextRunnerSingleMethodTest.class);\n    suite.addTestSuite(TextRunnerTest.class);\n    return suite;\n}"}], [{"methodBefore": "@Override\npublic List<TestMethod> getBefores() {\n    return getAnnotatedMethods(BeforeClass.class);\n}", "methodAfter": "@Override\npublic List<FrameworkMethod> getBefores() {\n    return getAnnotatedMethods(BeforeClass.class);\n}"}, {"methodBefore": "@Override\npublic List<TestMethod> getAfters() {\n    return getAnnotatedMethods(AfterClass.class);\n}", "methodAfter": "@Override\npublic List<FrameworkMethod> getAfters() {\n    return getAnnotatedMethods(AfterClass.class);\n}"}], [{"methodBefore": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}, {"methodBefore": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final Runner runner, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(runner, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}, {"methodBefore": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    collator.process(callable);\n}", "methodAfter": "@Override\nprotected void runChild(final FrameworkMethod method, final RunNotifier notifier) {\n    Callable<Object> callable = new Callable<Object>() {\n        public Object call() throws Exception {\n            superRunChild(method, notifier);\n            return null;\n        }\n    };\n    fCollator.process(callable);\n}"}, {"methodBefore": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : collator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "methodAfter": "@Override\npublic void run(RunNotifier notifier) {\n    super.run(notifier);\n    for (Future<Object> each : fCollator.results) {\n        try {\n            each.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}], [{"methodBefore": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : eachClass.getDeclaredMethods()) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod), fMethodsForAnnotations);\n        }\n        for (Field eachField : eachClass.getDeclaredFields()) {\n            addToAnnotationLists(new FrameworkField(eachField), fFieldsForAnnotations);\n        }\n    }\n}", "methodAfter": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod), fMethodsForAnnotations);\n        }\n        for (Field eachField : eachClass.getDeclaredFields()) {\n            addToAnnotationLists(new FrameworkField(eachField), fFieldsForAnnotations);\n        }\n    }\n}"}, {"methodBefore": "public List<Method> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    List<Method> results = new ArrayList<Method>();\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        Method[] methods = eachClass.getDeclaredMethods();\n        for (Method eachMethod : methods) {\n            Annotation annotation = eachMethod.getAnnotation(annotationClass);\n            if ((annotation != null) && (!isShadowed(eachMethod, results))) {\n                results.add(eachMethod);\n            }\n        }\n    }\n    if (runsTopToBottom(annotationClass)) {\n        Collections.reverse(results);\n    }\n    return results;\n}", "methodAfter": "public List<Method> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    List<Method> results = new ArrayList<Method>();\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        Method[] methods = MethodSorter.getDeclaredMethods(eachClass);\n        for (Method eachMethod : methods) {\n            Annotation annotation = eachMethod.getAnnotation(annotationClass);\n            if ((annotation != null) && (!isShadowed(eachMethod, results))) {\n                results.add(eachMethod);\n            }\n        }\n    }\n    if (runsTopToBottom(annotationClass)) {\n        Collections.reverse(results);\n    }\n    return results;\n}"}, {"methodBefore": "private void addTestsFromTestCase(final Class<?> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}", "methodAfter": "private void addTestsFromTestCase(final Class<?> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : MethodSorter.getDeclaredMethods(superClass)) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}"}], [{"methodBefore": "private Object[] computeParams() throws Exception {\n    try {\n        return fParameters.get(fParameterSetNumber);\n    } catch (ClassCastException e) {\n        throw new Exception(String.format(\"%s.%s() must return a Collection of arrays.\", fTestClass.getName(), getParametersMethod().getName()));\n    }\n}", "methodAfter": "private Object[] computeParams() throws Exception {\n    try {\n        return fParameters.get(fParameterSetNumber);\n    } catch (ClassCastException e) {\n        throw new Exception(String.format(\"%s.%s() must return a Collection of arrays.\", getTestClass().getName(), getParametersMethod().getName()));\n    }\n}"}, {"methodBefore": "private Object[] computeParams() throws Exception {\n    try {\n        return fParameterList.get(fParameterSetNumber);\n    } catch (ClassCastException e) {\n        throw new Exception(String.format(\"%s.%s() must return a Collection of arrays.\", getTestClass().getName(), getParametersMethod(fTestClass).getName()));\n    }\n}", "methodAfter": "private Object[] computeParams() throws Exception {\n    try {\n        return fParameterList.get(fParameterSetNumber);\n    } catch (ClassCastException e) {\n        throw new Exception(String.format(\"%s.%s() must return a Collection of arrays.\", getTestClass().getName(), getParametersMethod(getTestClass()).getName()));\n    }\n}"}], [{"methodBefore": "protected void runWithCompleteAssignment(final Assignments complete) throws Throwable {\n    new BlockJUnit4ClassRunner(getTestClass().getJavaClass()) {\n        @Override\n        protected void collectInitializationErrors(List<Throwable> errors) {\n        }\n\n        @Override\n        public Statement methodBlock(FrameworkMethod method) {\n            final Statement statement = super.methodBlock(method);\n            return new Statement() {\n                @Override\n                public void evaluate() throws Throwable {\n                    try {\n                        statement.evaluate();\n                        handleDataPointSuccess();\n                    } catch (AssumptionViolatedException e) {\n                        handleAssumptionViolation(e);\n                    } catch (Throwable e) {\n                        reportParameterizedError(e, complete.getArgumentStrings(nullsOk()));\n                    }\n                }\n            };\n        }\n\n        @Override\n        protected Statement methodInvoker(FrameworkMethod method, Object test) {\n            return methodCompletesWithParameters(method, complete, test);\n        }\n\n        @Override\n        public Object createTest() throws Exception {\n            Object[] params = complete.getConstructorArguments();\n            if (!nullsOk()) {\n                Assume.assumeNotNull(params);\n            }\n            return getTestClass().getOnlyConstructor().newInstance(params);\n        }\n    }.methodBlock(fTestMethod).evaluate();\n}", "methodAfter": "protected void runWithCompleteAssignment(final Assignments complete) throws Throwable {\n    new BlockJUnit4ClassRunner(getTestClass().getJavaClass()) {\n        @Override\n        protected void collectInitializationErrors(List<Throwable> errors) {\n        }\n\n        @Override\n        public Statement methodBlock(FrameworkMethod method) {\n            final Statement statement = super.methodBlock(method);\n            return new Statement() {\n                @Override\n                public void evaluate() throws Throwable {\n                    try {\n                        statement.evaluate();\n                        handleDataPointSuccess();\n                    } catch (AssumptionViolatedException e) {\n                        handleAssumptionViolation(e);\n                    } catch (Throwable e) {\n                        reportParameterizedError(e, complete.getArgumentStrings(nullsOk()));\n                    }\n                }\n            };\n        }\n\n        @Override\n        protected Statement methodInvoker(FrameworkMethod method, Object test) {\n            return methodCompletesWithParameters(method, complete, test);\n        }\n\n        @Override\n        public Object createTest() throws Exception {\n            Object[] params = complete.getConstructorArguments();\n            if (!nullsOk()) {\n                Assume.assumeNotNull(params);\n            }\n            return getTestClass().getOnlyConstructor().newInstance(params);\n        }\n    }.methodBlock(testMethod).evaluate();\n}"}, {"methodBefore": "private boolean nullsOk() {\n    Theory annotation = fTestMethod.getMethod().getAnnotation(Theory.class);\n    if (annotation == null) {\n        return false;\n    }\n    return annotation.nullsAccepted();\n}", "methodAfter": "private boolean nullsOk() {\n    Theory annotation = testMethod.getMethod().getAnnotation(Theory.class);\n    if (annotation == null) {\n        return false;\n    }\n    return annotation.nullsAccepted();\n}"}], [{"methodBefore": "List<Method> getAfters() {\n    return fTestClass.getAnnotatedMethods(After.class);\n}", "methodAfter": "@Override\nprotected List<Method> getAfters() {\n    return fTestClass.getAnnotatedMethods(After.class);\n}"}, {"methodBefore": "List<Method> getBefores() {\n    return getAnnotatedMethods(BeforeClass.class);\n}", "methodAfter": "@Override\nprotected List<Method> getBefores() {\n    return getAnnotatedMethods(BeforeClass.class);\n}"}, {"methodBefore": "List<Method> getAfters() {\n    return getAnnotatedMethods(AfterClass.class);\n}", "methodAfter": "@Override\nprotected List<Method> getAfters() {\n    return getAnnotatedMethods(AfterClass.class);\n}"}, {"methodBefore": "List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}", "methodAfter": "@Override\nprotected List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}"}], [{"methodBefore": "@Test\npublic void runsEveryTestOfArray() {\n    Result result = JUnitCore.runClasses(ParameterizedTestTest.FibonacciTestWithArray.class);\n    assertEquals(7, result.getRunCount());\n}", "methodAfter": "@Test\npublic void runsEveryTestOfArray() {\n    Result result = JUnitCore.runClasses(ParameterizedTestTest.AdditionTestWithArray.class);\n    assertEquals(4, result.getRunCount());\n}"}, {"methodBefore": "@Test\npublic void countsRuns() {\n    Result result = JUnitCore.runClasses(ParameterizedTestTest.FibonacciTest.class);\n    assertEquals(7, result.getRunCount());\n}", "methodAfter": "@Test\npublic void countsRuns() {\n    Result result = JUnitCore.runClasses(ParameterizedTestTest.AdditionTest.class);\n    assertEquals(4, result.getRunCount());\n}"}, {"methodBefore": "@Test\npublic void countBeforeRun() throws Exception {\n    Runner runner = Request.aClass(ParameterizedTestTest.FibonacciTest.class).getRunner();\n    assertEquals(7, runner.testCount());\n}", "methodAfter": "@Test\npublic void countBeforeRun() throws Exception {\n    Runner runner = Request.aClass(ParameterizedTestTest.AdditionTest.class).getRunner();\n    assertEquals(4, runner.testCount());\n}"}], [{"methodBefore": "public Comparator<Method> getComparator() {\n    return fComparator;\n}", "methodAfter": "public Comparator<Method> getComparator() {\n    return comparator;\n}"}, {"methodBefore": "private MethodSorters(Comparator<Method> comparator) {\n    this.fComparator = comparator;\n}", "methodAfter": "private MethodSorters(Comparator<Method> comparator) {\n    this.comparator = comparator;\n}"}], [{"methodBefore": "public abstract boolean isStatic();", "methodAfter": "public boolean isStatic() {\n    return Modifier.isStatic(getModifiers());\n}"}, {"methodBefore": "public abstract boolean isPublic();", "methodAfter": "public boolean isPublic() {\n    return Modifier.isPublic(getModifiers());\n}"}], [{"methodBefore": "private void invokeValidatorsOnMethods(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n        }\n    }\n}", "methodAfter": "private void invokeValidatorsOnMethods(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        if (validateWithAnnotation != null) {\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n            }\n        }\n    }\n}"}, {"methodBefore": "private void invokeValidatorsOnFields(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        for (FrameworkField frameworkField : annotationMap.get(annotationType)) {\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedField(frameworkField.getField()));\n        }\n    }\n}", "methodAfter": "private void invokeValidatorsOnFields(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        if (validateWithAnnotation != null) {\n            for (FrameworkField frameworkField : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedField(frameworkField.getField()));\n            }\n        }\n    }\n}"}], [{"methodBefore": "@Override\npublic String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}", "methodAfter": "public String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}"}, {"methodBefore": "protected void setUp() {\n    fResult = new TestResult();\n    fResult.addListener(this);\n    fStartCount = 0;\n    fEndCount = 0;\n    fFailureCount = 0;\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fResult = new TestResult();\n    fResult.addListener(this);\n    fStartCount = 0;\n    fEndCount = 0;\n    fFailureCount = 0;\n}"}, {"methodBefore": "public String toString() {\n    return ((getName() + \"(\") + getClass().getName()) + \")\";\n}", "methodAfter": "@Override\npublic String toString() {\n    return ((getName() + \"(\") + getClass().getName()) + \")\";\n}"}, {"methodBefore": "public void run(final TestResult result) {\n    Protectable p = new Protectable() {\n        public void protect() throws Exception {\n            setUp();\n            basicRun(result);\n            tearDown();\n        }\n    };\n    result.runProtected(this, p);\n}", "methodAfter": "@Override\npublic void run(final TestResult result) {\n    Protectable p = new Protectable() {\n        public void protect() throws Exception {\n            setUp();\n            basicRun(result);\n            tearDown();\n        }\n    };\n    result.runProtected(this, p);\n}"}, {"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "public String getName() {\n    return fMethod.getName();\n}", "methodAfter": "@Override\npublic String getName() {\n    return fMethod.getName();\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}"}, {"methodBefore": "public void run(TestResult result) {\n    fActiveTestDeathCount = 0;\n    super.run(result);\n    waitUntilFinished();\n}", "methodAfter": "@Override\npublic void run(TestResult result) {\n    fActiveTestDeathCount = 0;\n    super.run(result);\n    waitUntilFinished();\n}"}, {"methodBefore": "public boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}"}, {"methodBefore": "public void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}"}, {"methodBefore": "public void testEnded(String testName) {\n}", "methodAfter": "@Override\npublic void testEnded(String testName) {\n}"}, {"methodBefore": "public String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String getTrace() {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    getException().printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    return buffer.toString();\n}"}, {"methodBefore": "protected void setUp() {\n    fValue1 = 2;\n    fValue2 = 3;\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fValue1 = 2;\n    fValue2 = 3;\n}"}, {"methodBefore": "public String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((((\"[\" + amount()) + \" \") + currency()) + \"]\");\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((((\"[\" + amount()) + \" \") + currency()) + \"]\");\n    return buffer.toString();\n}"}, {"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}"}, {"methodBefore": "@Override\npublic String getTestHeader() {\n    return fDescription.getDisplayName();\n}", "methodAfter": "public String getTestHeader() {\n    return fDescription.getDisplayName();\n}"}, {"methodBefore": "public void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}"}, {"methodBefore": "public void run(TestResult result) {\n    for (int i = 0; i < fTimesRepeat; i++) {\n        if (result.shouldStop()) {\n            break;\n        }\n        super.run(result);\n    }\n}", "methodAfter": "@Override\npublic void run(TestResult result) {\n    for (int i = 0; i < fTimesRepeat; i++) {\n        if (result.shouldStop()) {\n            break;\n        }\n        super.run(result);\n    }\n}"}, {"methodBefore": "public String toString() {\n    return fTest.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    return fTest.toString();\n}"}, {"methodBefore": "@Override\nprotected void validate(MethodValidator methodValidator) {\n    methodValidator.validateStaticMethods();\n    methodValidator.validateInstanceMethods();\n}", "methodAfter": "protected void validate(MethodValidator methodValidator) {\n    methodValidator.validateStaticMethods();\n    methodValidator.validateInstanceMethods();\n}"}, {"methodBefore": "public void testStarted(String testName) {\n}", "methodAfter": "@Override\npublic void testStarted(String testName) {\n}"}, {"methodBefore": "protected void runTest() {\n    fWasRun = true;\n}", "methodAfter": "@Override\nprotected void runTest() {\n    fWasRun = true;\n}"}, {"methodBefore": "public void runTest() {\n}", "methodAfter": "@Override\npublic void runTest() {\n}"}, {"methodBefore": "protected void tearDown() {\n    fTornDown = true;\n}", "methodAfter": "@Override\nprotected void tearDown() {\n    fTornDown = true;\n}"}, {"methodBefore": "protected void runFailed(String message) {\n    System.err.println(message);\n    System.exit(FAILURE_EXIT);\n}", "methodAfter": "@Override\nprotected void runFailed(String message) {\n    System.err.println(message);\n    System.exit(FAILURE_EXIT);\n}"}, {"methodBefore": "public String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((fFailedTest + \": \") + fThrownException.getMessage());\n    return buffer.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append((fFailedTest + \": \") + fThrownException.getMessage());\n    return buffer.toString();\n}"}, {"methodBefore": "public void testCase() {\n}", "methodAfter": "@Override\npublic void testCase() {\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(runner.getDescription())) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(runner.getDescription())) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}"}, {"methodBefore": "protected void setUp() {\n    StringWriter swin = new StringWriter();\n    PrintWriter pwin = new PrintWriter(swin);\n    pwin.println(\"junit.framework.AssertionFailedError\");\n    pwin.println(\"\tat junit.framework.Assert.fail(Assert.java:144)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:19)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:26)\");\n    pwin.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwin.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    pwin.println(\"\tat java.lang.reflect.Method.invoke(Native Method)\");\n    pwin.println(\"\tat junit.framework.TestCase.runTest(TestCase.java:156)\");\n    pwin.println(\"\tat junit.framework.TestCase.runBare(TestCase.java:130)\");\n    pwin.println(\"\tat junit.framework.TestResult$1.protect(TestResult.java:100)\");\n    pwin.println(\"\tat junit.framework.TestResult.runProtected(TestResult.java:118)\");\n    pwin.println(\"\tat junit.framework.TestResult.run(TestResult.java:103)\");\n    pwin.println(\"\tat junit.framework.TestCase.run(TestCase.java:121)\");\n    pwin.println(\"\tat junit.framework.TestSuite.runTest(TestSuite.java:157)\");\n    pwin.println(\"\tat junit.framework.TestSuite.run(TestSuite.java, Compiled Code)\");\n    pwin.println(\"\tat junit.swingui.TestRunner$17.run(TestRunner.java:669)\");\n    fUnfiltered = swin.toString();\n    StringWriter swout = new StringWriter();\n    PrintWriter pwout = new PrintWriter(swout);\n    pwout.println(\"junit.framework.AssertionFailedError\");\n    pwout.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwout.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    fFiltered = swout.toString();\n}", "methodAfter": "@Override\nprotected void setUp() {\n    StringWriter swin = new StringWriter();\n    PrintWriter pwin = new PrintWriter(swin);\n    pwin.println(\"junit.framework.AssertionFailedError\");\n    pwin.println(\"\tat junit.framework.Assert.fail(Assert.java:144)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:19)\");\n    pwin.println(\"\tat junit.framework.Assert.assert(Assert.java:26)\");\n    pwin.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwin.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    pwin.println(\"\tat java.lang.reflect.Method.invoke(Native Method)\");\n    pwin.println(\"\tat junit.framework.TestCase.runTest(TestCase.java:156)\");\n    pwin.println(\"\tat junit.framework.TestCase.runBare(TestCase.java:130)\");\n    pwin.println(\"\tat junit.framework.TestResult$1.protect(TestResult.java:100)\");\n    pwin.println(\"\tat junit.framework.TestResult.runProtected(TestResult.java:118)\");\n    pwin.println(\"\tat junit.framework.TestResult.run(TestResult.java:103)\");\n    pwin.println(\"\tat junit.framework.TestCase.run(TestCase.java:121)\");\n    pwin.println(\"\tat junit.framework.TestSuite.runTest(TestSuite.java:157)\");\n    pwin.println(\"\tat junit.framework.TestSuite.run(TestSuite.java, Compiled Code)\");\n    pwin.println(\"\tat junit.swingui.TestRunner$17.run(TestRunner.java:669)\");\n    fUnfiltered = swin.toString();\n    StringWriter swout = new StringWriter();\n    PrintWriter pwout = new PrintWriter(swout);\n    pwout.println(\"junit.framework.AssertionFailedError\");\n    pwout.println(\"\tat MyTest.f(MyTest.java:13)\");\n    pwout.println(\"\tat MyTest.testStackTrace(MyTest.java:8)\");\n    fFiltered = swout.toString();\n}"}, {"methodBefore": "public void runTest() {\n    fail();\n}", "methodAfter": "@Override\npublic void runTest() {\n    fail();\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(describeChild(runner))) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<Runner> iter = fRunners.iterator(); iter.hasNext();) {\n        Runner runner = iter.next();\n        if (filter.shouldRun(describeChild(runner))) {\n            filter.apply(runner);\n        } else {\n            iter.remove();\n        }\n    }\n}"}, {"methodBefore": "public void testEnded(String testName) {\n}", "methodAfter": "@Override\npublic void testEnded(String testName) {\n}"}, {"methodBefore": "protected void collectInitializationErrors(List<Throwable> errors) {\n    getTestClass().validateMethodsForDefaultRunner(errors);\n}", "methodAfter": "@Override\nprotected void collectInitializationErrors(List<Throwable> errors) {\n    getTestClass().validateMethodsForDefaultRunner(errors);\n}"}, {"methodBefore": "public String getMessage() {\n    return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n}", "methodAfter": "@Override\npublic String getMessage() {\n    return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n}"}, {"methodBefore": "public boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "methodAfter": "@Override\npublic boolean isShadowedBy(FrameworkMethod other) {\n    if (!other.getName().equals(getName())) {\n        return false;\n    }\n    if (other.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < other.getParameterTypes().length; i++) {\n        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}"}, {"methodBefore": "public void setUp() {\n    output = new ByteArrayOutputStream();\n    runner = new TestRunner(new TestResultPrinter(new PrintStream(output)));\n}", "methodAfter": "@Override\npublic void setUp() {\n    output = new ByteArrayOutputStream();\n    runner = new TestRunner(new TestResultPrinter(new PrintStream(output)));\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}", "methodAfter": "@Override\npublic Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}"}, {"methodBefore": "public String getName() {\n    return getField().getName();\n}", "methodAfter": "@Override\npublic String getName() {\n    return getField().getName();\n}"}, {"methodBefore": "public void testStarted(String testName) {\n}", "methodAfter": "@Override\npublic void testStarted(String testName) {\n}"}, {"methodBefore": "public boolean isStatic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isStatic(modifiers);\n}", "methodAfter": "@Override\npublic boolean isStatic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isStatic(modifiers);\n}"}, {"methodBefore": "protected void setUp() {\n    fResult = new TestResult();\n}", "methodAfter": "@Override\nprotected void setUp() {\n    fResult = new TestResult();\n}"}, {"methodBefore": "public void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<FrameworkMethod> iter = fTestMethods.iterator(); iter.hasNext();) {\n        FrameworkMethod method = iter.next();\n        if (!filter.shouldRun(describeChild(method))) {\n            iter.remove();\n        }\n    }\n    if (fTestMethods.isEmpty()) {\n        throw new NoTestsRemainException();\n    }\n}", "methodAfter": "@Override\npublic void filter(Filter filter) throws NoTestsRemainException {\n    for (Iterator<FrameworkMethod> iter = fTestMethods.iterator(); iter.hasNext();) {\n        FrameworkMethod method = iter.next();\n        if (!filter.shouldRun(describeChild(method))) {\n            iter.remove();\n        }\n    }\n    if (fTestMethods.isEmpty()) {\n        throw new NoTestsRemainException();\n    }\n}"}, {"methodBefore": "public boolean isPublic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isPublic(modifiers);\n}", "methodAfter": "@Override\npublic boolean isPublic() {\n    int modifiers = fField.getModifiers();\n    return Modifier.isPublic(modifiers);\n}"}, {"methodBefore": "protected void runFailed(String message) {\n}", "methodAfter": "@Override\nprotected void runFailed(String message) {\n}"}, {"methodBefore": "public boolean equals(Object anObject) {\n    if (isZero()) {\n        if (anObject instanceof IMoney) {\n            return ((IMoney) (anObject)).isZero();\n        }\n    }\n    if (anObject instanceof Money) {\n        Money aMoney = ((Money) (anObject));\n        return aMoney.currency().equals(currency()) && (amount() == aMoney.amount());\n    }\n    return false;\n}", "methodAfter": "@Override\npublic boolean equals(Object anObject) {\n    if (isZero()) {\n        if (anObject instanceof IMoney) {\n            return ((IMoney) (anObject)).isZero();\n        }\n    }\n    if (anObject instanceof Money) {\n        Money aMoney = ((Money) (anObject));\n        return aMoney.currency().equals(currency()) && (amount() == aMoney.amount());\n    }\n    return false;\n}"}, {"methodBefore": "public String getTestHeader() {\n    return fDescription.getDisplayName();\n}", "methodAfter": "@Override\npublic String getTestHeader() {\n    return fDescription.getDisplayName();\n}"}, {"methodBefore": "public String toString() {\n    if (getName() != null) {\n        return getName();\n    }\n    return super.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    if (getName() != null) {\n        return getName();\n    }\n    return super.toString();\n}"}, {"methodBefore": "protected void setUp() {\n    f12CHF = new Money(12, \"CHF\");\n    f14CHF = new Money(14, \"CHF\");\n    f7USD = new Money(7, \"USD\");\n    f21USD = new Money(21, \"USD\");\n    fMB1 = MoneyBag.create(f12CHF, f7USD);\n    fMB2 = MoneyBag.create(f14CHF, f21USD);\n}", "methodAfter": "@Override\nprotected void setUp() {\n    f12CHF = new Money(12, \"CHF\");\n    f14CHF = new Money(14, \"CHF\");\n    f7USD = new Money(7, \"USD\");\n    f21USD = new Money(21, \"USD\");\n    fMB1 = MoneyBag.create(f12CHF, f7USD);\n    fMB2 = MoneyBag.create(f14CHF, f21USD);\n}"}, {"methodBefore": "protected String elapsedTimeAsString(long runTime) {\n    return \"0\";\n}", "methodAfter": "@Override\nprotected String elapsedTimeAsString(long runTime) {\n    return \"0\";\n}"}], [{"methodBefore": "@Override\npublic Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n    throw new FilterNotCreatedException(\"not implemented\");\n}", "methodAfter": "@Override\npublic Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n    throw new FilterNotCreatedException(new Exception(\"not implemented\"));\n}"}, {"methodBefore": "@Override\npublic Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n    throw new FilterNotCreatedException(\"stub\");\n}", "methodAfter": "@Override\npublic Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n    throw new FilterNotCreatedException(new Exception(\"stub\"));\n}"}], [{"methodBefore": "@Test\npublic void getMethodsNullSorterSuper() {\n    List<String> expected = Arrays.asList(new String[]{ SUPER_METHOD });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Super.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void testMethodsNullSorterSuper() {\n    List<String> expected = Arrays.asList(new String[]{ SUPER_METHOD });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Super.class, expected);\n    assertEquals(expected, actual);\n}"}, {"methodBefore": "@Test\npublic void getMethodsNullSorterSub() {\n    List<String> expected = Arrays.asList(new String[]{ SUB_METHOD });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Sub.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void testMethodsNullSorterSub() {\n    List<String> expected = Arrays.asList(new String[]{ SUB_METHOD });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Sub.class, expected);\n    assertEquals(expected, actual);\n}"}], [{"methodBefore": "protected List<TestMethod> computeTestMethods() {\n    return fTestClass.getTestMethods();\n}", "methodAfter": "protected List<FrameworkMethod> computeTestMethods() {\n    return fTestClass.getTestMethods();\n}"}, {"methodBefore": "@Override\nprotected List<TestMethod> getChildren() {\n    return fTestMethods;\n}", "methodAfter": "@Override\nprotected List<FrameworkMethod> getChildren() {\n    return fTestMethods;\n}"}], [{"methodBefore": "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        addMultipleFailureException(((MultipleFailureException) (targetException)));\n    } else {\n        fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n    }\n}", "methodAfter": "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        addMultipleFailureException(((MultipleFailureException) (targetException)));\n    } else {\n        notifier.fireTestFailure(new Failure(description, targetException));\n    }\n}"}, {"methodBefore": "public void addFailedAssumption(AssumptionViolatedException e) {\n    fNotifier.fireTestAssumptionFailed(new Failure(fDescription, e));\n}", "methodAfter": "public void addFailedAssumption(AssumptionViolatedException e) {\n    notifier.fireTestAssumptionFailed(new Failure(description, e));\n}"}], [{"methodBefore": "public void printDefect(TestFailure booBoo, int count) {\n}", "methodAfter": "public void printDefect(TestFailure failure, int count) {\n}"}, {"methodBefore": "protected void printDefectHeader(TestFailure booBoo, int count) {\n}", "methodAfter": "protected void printDefectHeader(TestFailure failure, int count) {\n}"}], [{"methodBefore": "@Override\npublic void testRunStarted(Description description) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testRunStarted(description);\n    }\n}", "methodAfter": "@Override\npublic void testRunStarted(Description description) throws Exception {\n    synchronized(monitor) {\n        listener.testRunStarted(description);\n    }\n}"}, {"methodBefore": "@Override\npublic void testStarted(Description description) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testStarted(description);\n    }\n}", "methodAfter": "@Override\npublic void testStarted(Description description) throws Exception {\n    synchronized(monitor) {\n        listener.testStarted(description);\n    }\n}"}], [{"methodBefore": "public static void assertEquals(String message, double expected, double actual, double delta) {\n    if (Double.compare(expected, actual) == 0) {\n        return;\n    }\n    if (!(Math.abs(expected - actual) <= delta)) {\n        failNotEquals(message, new Double(expected), new Double(actual));\n    }\n}", "methodAfter": "public static void assertEquals(String message, double expected, double actual, double delta) {\n    if (doubleIsDifferent(expected, actual, delta)) {\n        failNotEquals(message, new Double(expected), new Double(actual));\n    }\n}"}, {"methodBefore": "public static void assertEquals(String message, float expected, float actual, float delta) {\n    if (Float.compare(expected, actual) == 0) {\n        return;\n    }\n    if (!(Math.abs(expected - actual) <= delta)) {\n        failNotEquals(message, new Float(expected), new Float(actual));\n    }\n}", "methodAfter": "public static void assertEquals(String message, float expected, float actual, float delta) {\n    if (floatIsDifferent(expected, actual, delta)) {\n        failNotEquals(message, new Float(expected), new Float(actual));\n    }\n}"}], [{"methodBefore": "@Override\npublic List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n    List<PotentialAssignment> list = new ArrayList<PotentialAssignment>();\n    addSinglePointFields(sig, list);\n    addMultiPointFields(sig, list);\n    addSinglePointMethods(sig, list);\n    addMultiPointMethods(sig, list);\n    return list;\n}", "methodAfter": "@Override\npublic List<PotentialAssignment> getValueSources(ParameterSignature sig) throws Throwable {\n    List<PotentialAssignment> list = new ArrayList<PotentialAssignment>();\n    addSinglePointFields(sig, list);\n    addMultiPointFields(sig, list);\n    addSinglePointMethods(sig, list);\n    addMultiPointMethods(sig, list);\n    return list;\n}"}, {"methodBefore": "public abstract List<PotentialAssignment> getValueSources(ParameterSignature sig);", "methodAfter": "public abstract List<PotentialAssignment> getValueSources(ParameterSignature sig) throws Throwable;"}], [{"methodBefore": "public static String id() {\n    return \"3.8\";\n}", "methodAfter": "public static String id() {\n    return \"@version@\";\n}"}, {"methodBefore": "public static String id() {\n    return \"3.7\";\n}", "methodAfter": "public static String id() {\n    return \"@version@\";\n}"}], [{"methodBefore": "public long getTimeout() {\n    Test annotation = fMethod.getAnnotation(Test.class);\n    long timeout = annotation.timeout();\n    return timeout;\n}", "methodAfter": "public long getTimeout() {\n    Test annotation = fMethod.getAnnotation(Test.class);\n    if (annotation == null) {\n        return 0;\n    }\n    long timeout = annotation.timeout();\n    return timeout;\n}"}, {"methodBefore": "public String getName() {\n    return fClass.getName();\n}", "methodAfter": "public String getName() {\n    if (fClass == null) {\n        return \"null\";\n    }\n    return fClass.getName();\n}"}], [{"methodBefore": "static FilterFactory createFilterFactory(Class<? extends FilterFactory> filterFactoryClass) throws FilterFactoryNotCreatedException {\n    try {\n        return filterFactoryClass.getConstructor().newInstance();\n    } catch (Exception e) {\n        throw new FilterFactoryNotCreatedException(e);\n    }\n}", "methodAfter": "static FilterFactory createFilterFactory(Class<? extends FilterFactory> filterFactoryClass) throws FilterFactory.FilterNotCreatedException {\n    try {\n        return filterFactoryClass.getConstructor().newInstance();\n    } catch (Exception e) {\n        throw new FilterNotCreatedException(e);\n    }\n}"}, {"methodBefore": "static FilterFactory createFilterFactory(String filterFactoryFqcn) throws FilterFactoryNotCreatedException {\n    Class<? extends FilterFactory> filterFactoryClass;\n    try {\n        filterFactoryClass = Classes.getClass(filterFactoryFqcn).asSubclass(FilterFactory.class);\n    } catch (Exception e) {\n        throw new FilterFactoryNotCreatedException(e);\n    }\n    return createFilterFactory(filterFactoryClass);\n}", "methodAfter": "static FilterFactory createFilterFactory(String filterFactoryFqcn) throws FilterFactory.FilterNotCreatedException {\n    Class<? extends FilterFactory> filterFactoryClass;\n    try {\n        filterFactoryClass = Classes.getClass(filterFactoryFqcn).asSubclass(FilterFactory.class);\n    } catch (Exception e) {\n        throw new FilterNotCreatedException(e);\n    }\n    return createFilterFactory(filterFactoryClass);\n}"}], [{"methodBefore": "@Test\npublic void memberClassDeepInsideAnnotatedMemberClass_isRunWithParentMemberClassRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class)))));\n}", "methodAfter": "@Test\npublic void memberClassDeepInsideAnnotatedMemberClass_isRunWithParentMemberClassRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class))));\n}"}, {"methodBefore": "@Test\npublic void annotatedMemberClassInsideAnnotatedTopLevelClass_isRunWithOwnRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class)))));\n}", "methodAfter": "@Test\npublic void annotatedMemberClassInsideAnnotatedTopLevelClass_isRunWithOwnRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class))));\n}"}, {"methodBefore": "@Test\npublic void memberClassDeepInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class)))));\n}", "methodAfter": "@Test\npublic void memberClassDeepInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class))));\n}"}], [{"methodBefore": "public void testBagSumAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(28, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.add(fMB2));\n}", "methodAfter": "public void testBagSumAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(28, \"USD\"));\n    assertEquals(expected, fMB1.add(fMB2));\n}"}, {"methodBefore": "public void testBagSimpleAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(7, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.add(f14CHF));\n}", "methodAfter": "public void testBagSimpleAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n    assertEquals(expected, fMB1.add(f14CHF));\n}"}, {"methodBefore": "public void testSimpleBagAdd() {\n    Money bag[] = new Money[]{ new Money(26, \"CHF\"), new Money(7, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, f14CHF.add(fMB1));\n}", "methodAfter": "public void testSimpleBagAdd() {\n    IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n    assertEquals(expected, f14CHF.add(fMB1));\n}"}], [{"methodBefore": "protected void invokeTestMethod(Method method, RunNotifier notifier) {\n    Description description = methodDescription(method);\n    Object test;\n    try {\n        test = createTest();\n    } catch (InvocationTargetException e) {\n        notifier.testAborted(description, e.getCause());\n        return;\n    } catch (Exception e) {\n        notifier.testAborted(description, e);\n        return;\n    }\n    TestMethod testMethod = wrapMethod(method);\n    testMethod.run(new Roadie(notifier, description, test));\n}", "methodAfter": "protected void invokeTestMethod(Method method, RunNotifier notifier) {\n    Description description = methodDescription(method);\n    Object test;\n    try {\n        test = createTest();\n    } catch (InvocationTargetException e) {\n        notifier.testAborted(description, e.getCause());\n        return;\n    } catch (Exception e) {\n        notifier.testAborted(description, e);\n        return;\n    }\n    JUnit4MethodRunner testMethod = wrapMethod(method);\n    testMethod.run(new Roadie(notifier, description, test));\n}"}, {"methodBefore": "@Override\nprotected TestMethod wrapMethod(Method method) {\n    return new StubbedTheoryMethod(method, getTestClass());\n}", "methodAfter": "@Override\nprotected JUnit4MethodRunner wrapMethod(Method method) {\n    return new StubbedTheoryMethod(method, getTestClass());\n}"}], [{"methodBefore": "@Override\npublic Statement childBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method);\n}"}, {"methodBefore": "@Override\npublic Statement childBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method);\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Suite Tests\");\n    suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n    suite.addTest(new SuiteTest(\"testNoTestCases\"));\n    suite.addTest(new SuiteTest(\"testOneTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n    suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n    suite.addTest(new SuiteTest(\"testInheritedTests\"));\n    suite.addTest(new SuiteTest(\"testShadowedTests\"));\n    suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n    suite.addTest(new SuiteTest(\"testDisplayName\"));\n    return suite;\n}"}], [{"methodBefore": "public List<Method> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    List<Method> results = new ArrayList<Method>();\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        Method[] methods = eachClass.getDeclaredMethods();\n        for (Method eachMethod : methods) {\n            Annotation annotation = eachMethod.getAnnotation(annotationClass);\n            if ((annotation != null) && (!isShadowed(eachMethod, results))) {\n                results.add(eachMethod);\n            }\n        }\n    }\n    if (runsTopToBottom(annotationClass)) {\n        Collections.reverse(results);\n    }\n    return results;\n}", "methodAfter": "public List<Method> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    List<Method> results = new ArrayList<Method>();\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        Method[] methods = MethodSorter.getDeclaredMethods(eachClass);\n        for (Method eachMethod : methods) {\n            Annotation annotation = eachMethod.getAnnotation(annotationClass);\n            if ((annotation != null) && (!isShadowed(eachMethod, results))) {\n                results.add(eachMethod);\n            }\n        }\n    }\n    if (runsTopToBottom(annotationClass)) {\n        Collections.reverse(results);\n    }\n    return results;\n}"}, {"methodBefore": "private void addTestsFromTestCase(final Class<?> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}", "methodAfter": "private void addTestsFromTestCase(final Class<?> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning((\"Class \" + theClass.getName()) + \" is not public\"));\n        return;\n    }\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : MethodSorter.getDeclaredMethods(superClass)) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    } \n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}"}, {"methodBefore": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : eachClass.getDeclaredMethods()) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod), fMethodsForAnnotations);\n        }\n        for (Field eachField : eachClass.getDeclaredFields()) {\n            addToAnnotationLists(new FrameworkField(eachField), fFieldsForAnnotations);\n        }\n    }\n}", "methodAfter": "public TestClass(Class<?> klass) {\n    fClass = klass;\n    if ((klass != null) && (klass.getConstructors().length > 1)) {\n        throw new IllegalArgumentException(\"Test class can only have one constructor\");\n    }\n    for (Class<?> eachClass : getSuperClasses(fClass)) {\n        for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {\n            addToAnnotationLists(new FrameworkMethod(eachMethod), fMethodsForAnnotations);\n        }\n        for (Field eachField : eachClass.getDeclaredFields()) {\n            addToAnnotationLists(new FrameworkField(eachField), fFieldsForAnnotations);\n        }\n    }\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    Filter filter = FilterFactories.createFilterFromFilterSpec(createSuiteDescription(testName.getMethodName()), FilterFactoriesTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoriesTest.DummyFilter.class));\n}", "methodAfter": "@Test\npublic void shouldCreateFilterWithNoArguments() throws Exception {\n    Filter filter = FilterFactories.createFilterFromFilterSpec(createSuiteRequest(), FilterFactoriesTest.FilterFactoryStub.class.getName());\n    assertThat(filter, instanceOf(FilterFactoriesTest.DummyFilter.class));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFilterWithArguments() throws Exception {\n    Filter filter = FilterFactories.createFilterFromFilterSpec(createSuiteDescription(testName.getMethodName()), (ExcludeCategories.class.getName() + \"=\") + FilterFactoriesTest.DummyCategory.class.getName());\n    assertThat(filter.describe(), startsWith(\"excludes \"));\n}", "methodAfter": "@Test\npublic void shouldCreateFilterWithArguments() throws Exception {\n    Filter filter = FilterFactories.createFilterFromFilterSpec(createSuiteRequest(), (ExcludeCategories.class.getName() + \"=\") + FilterFactoriesTest.DummyCategory.class.getName());\n    assertThat(filter.describe(), startsWith(\"excludes \"));\n}"}], [{"methodBefore": "public void addFirstListener(RunListener listener) {\n    fListeners.add(0, listener);\n}", "methodAfter": "public void addFirstListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot add a null listener\");\n    }\n    fListeners.add(0, wrapIfNotThreadSafe(listener));\n}"}, {"methodBefore": "public void removeListener(RunListener listener) {\n    fListeners.remove(listener);\n}", "methodAfter": "public void removeListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot remove a null listener\");\n    }\n    fListeners.remove(wrapIfNotThreadSafe(listener));\n}"}, {"methodBefore": "public void addListener(RunListener listener) {\n    fListeners.add(listener);\n}", "methodAfter": "public void addListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot add a null listener\");\n    }\n    fListeners.add(wrapIfNotThreadSafe(listener));\n}"}], [{"methodBefore": "@Test\npublic void shouldReturnNothingIfTheNamedDataPointsAreMissing() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingWrongNamedString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(0, assignedStrings.size());\n}", "methodAfter": "@Test\npublic void shouldReturnNothingIfTheNamedDataPointsAreMissing() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingWrongNamedString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(0, assignedStrings.size());\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingAllNamedStrings\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(4, assignedStrings.size());\n    assertThat(assignedStrings, hasItems(\"named field\", \"named method\", \"named single value\", \"named single method value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingAllNamedStrings\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(4, assignedStrings.size());\n    assertThat(assignedStrings, hasItems(\"named field\", \"named method\", \"named single value\", \"named single method value\"));\n}"}], [{"methodBefore": "@Override\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}", "methodAfter": "@Override\npublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}"}, {"methodBefore": "private static void failNotEquals(String message, Object expected, Object actual) {\n    fail(format(message, expected, actual));\n}", "methodAfter": "public static void failNotEquals(String message, Object expected, Object actual) {\n    fail(format(message, expected, actual));\n}"}], [{"methodBefore": "protected void printDefectHeader(TestFailure booBoo, int count) {\n}", "methodAfter": "protected void printDefectHeader(TestFailure failure, int count) {\n}"}, {"methodBefore": "public void printDefect(TestFailure booBoo, int count) {\n}", "methodAfter": "public void printDefect(TestFailure failure, int count) {\n}"}, {"methodBefore": "protected void printDefectTrace(TestFailure booBoo) {\n}", "methodAfter": "protected void printDefectTrace(TestFailure failure) {\n}"}], [{"methodBefore": "public static List<PotentialAssignment> potentialAssignments(Method method) throws Exception {\n    return Assignments.allUnassigned(method, new TestClass(method.getDeclaringClass())).potentialsForNextUnassigned();\n}", "methodAfter": "public static List<PotentialAssignment> potentialAssignments(Method method) throws Throwable {\n    return Assignments.allUnassigned(method, new TestClass(method.getDeclaringClass())).potentialsForNextUnassigned();\n}"}, {"methodBefore": "private GuesserQueue createGuesserQueue(Assignments incomplete) throws Exception {\n    ParameterSignature nextUnassigned = incomplete.nextUnassigned();\n    if (nextUnassigned.hasAnnotation(Stub.class)) {\n        GuesserQueue queue = new GuesserQueue();\n        queue.add(new Guesser<Object>(nextUnassigned.getType()));\n        return queue;\n    }\n    return GuesserQueue.forSingleValues(incomplete.potentialsForNextUnassigned());\n}", "methodAfter": "private GuesserQueue createGuesserQueue(Assignments incomplete) throws Throwable {\n    ParameterSignature nextUnassigned = incomplete.nextUnassigned();\n    if (nextUnassigned.hasAnnotation(Stub.class)) {\n        GuesserQueue queue = new GuesserQueue();\n        queue.add(new Guesser<Object>(nextUnassigned.getType()));\n        return queue;\n    }\n    return GuesserQueue.forSingleValues(incomplete.potentialsForNextUnassigned());\n}"}, {"methodBefore": "public List<PotentialAssignment> potentialsForNextUnassigned() throws Exception {\n    ParameterSignature unassigned = nextUnassigned();\n    return getSupplier(unassigned).getValueSources(unassigned);\n}", "methodAfter": "public List<PotentialAssignment> potentialsForNextUnassigned() throws Throwable {\n    ParameterSignature unassigned = nextUnassigned();\n    return getSupplier(unassigned).getValueSources(unassigned);\n}"}], [{"methodBefore": "@Override\npublic Statement chain(final TestMethod method) {\n    return new TheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement childBlock(final TestMethod method) {\n    return new TheoryAnchor(method);\n}"}, {"methodBefore": "@Override\npublic Statement chain(TestMethod method) {\n    return new StubbedTheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement childBlock(TestMethod method) {\n    return new StubbedTheoryAnchor(method);\n}"}], [{"methodBefore": "public IMoney addMoney(Money m) {\n    return new MoneyBag(m, this).simplify();\n}", "methodAfter": "public IMoney addMoney(Money m) {\n    return MoneyBag.create(m, this);\n}"}, {"methodBefore": "public IMoney addMoneyBag(MoneyBag s) {\n    return new MoneyBag(s, this).simplify();\n}", "methodAfter": "public IMoney addMoneyBag(MoneyBag s) {\n    return MoneyBag.create(s, this);\n}"}], [{"methodBefore": "@Test\npublic void memberClassInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.class)))));\n}", "methodAfter": "@Test\npublic void memberClassInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.class))));\n}"}, {"methodBefore": "@Test\npublic void annotatedMemberClassInsideAnnotatedTopLevelClass_isRunWithOwnRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class)))));\n}", "methodAfter": "@Test\npublic void annotatedMemberClassInsideAnnotatedTopLevelClass_isRunWithOwnRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class))));\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    return suite;\n}"}], [{"methodBefore": "public void testNoTestCaseClass() {\n    Test t = new TestSuite(NoTestCaseClass.class);\n    t.run(fResult);\n    assertEquals(1, fResult.runCount());\n    assert !fResult.wasSuccessful();\n}", "methodAfter": "public void testNoTestCaseClass() {\n    Test t = new TestSuite(NoTestCaseClass.class);\n    t.run(fResult);\n    assertEquals(1, fResult.runCount());\n    assertTrue(!fResult.wasSuccessful());\n}"}, {"methodBefore": "public void testInheritedTests() {\n    TestSuite suite = new TestSuite(InheritedTestCase.class);\n    suite.run(fResult);\n    assert fResult.wasSuccessful();\n    assertEquals(2, fResult.runCount());\n}", "methodAfter": "public void testInheritedTests() {\n    TestSuite suite = new TestSuite(InheritedTestCase.class);\n    suite.run(fResult);\n    assertTrue(fResult.wasSuccessful());\n    assertEquals(2, fResult.runCount());\n}"}], [{"methodBefore": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), null, testClass.getAnnotations());\n}", "methodAfter": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), testClass.getAnnotations());\n}"}, {"methodBefore": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName());\n}", "methodAfter": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), testClass.getAnnotations());\n}"}], [{"methodBefore": "public Description childlessCopy() {\n    return new Description(fDisplayName, fAnnotations);\n}", "methodAfter": "public Description childlessCopy() {\n    return new Description(fDisplayName, fClazz, fAnnotations);\n}"}, {"methodBefore": "public Description childlessCopy() {\n    return new Description(fDisplayName, fClazz, fAnnotations);\n}", "methodAfter": "public Description childlessCopy() {\n    return new Description(fTestClass, fDisplayName, fAnnotations);\n}"}, {"methodBefore": "public Description childlessCopy() {\n    return new Description(fDisplayName, fAnnotations);\n}", "methodAfter": "public Description childlessCopy() {\n    return new Description(fDisplayName);\n}"}], [{"methodBefore": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append((fFailedTest + \": \") + fThrownException.getMessage());\n    return sb.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    return (fFailedTest + \": \") + fThrownException.getMessage();\n}"}, {"methodBefore": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append((getTestHeader() + \": \") + fThrownException.getMessage());\n    return sb.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    return (getTestHeader() + \": \") + fThrownException.getMessage();\n}"}], [{"methodBefore": "@Override\nprotected void describeMismatchSafely(T item, Description description) {\n    description.appendText(\"cause \");\n    fMatcher.describeMismatch(item.getCause(), description);\n}", "methodAfter": "@Override\nprotected void describeMismatchSafely(T item, Description description) {\n    description.appendText(\"cause \");\n    matcher.describeMismatch(item.getCause(), description);\n}"}, {"methodBefore": "@Override\nprotected void describeMismatchSafely(T item, Description description) {\n    description.appendText(\"message \");\n    fMatcher.describeMismatch(item.getMessage(), description);\n}", "methodAfter": "@Override\nprotected void describeMismatchSafely(T item, Description description) {\n    description.appendText(\"message \");\n    matcher.describeMismatch(item.getMessage(), description);\n}"}], [{"methodBefore": "public void succeeded(Description description) {\n}", "methodAfter": "protected void succeeded(Description description) {\n}"}, {"methodBefore": "public void finished(Description description) {\n}", "methodAfter": "protected void finished(Description description) {\n}"}, {"methodBefore": "public void failed(Throwable e, Description description) {\n}", "methodAfter": "protected void failed(Throwable e, Description description) {\n}"}], [{"methodBefore": "@Test\npublic void onlyUseSpecificDataPointsIfSpecified() throws Exception {\n    List<PotentialAssignment> assignments = potentialAssignments(WithNamedDataPoints.HasSpecificDatapointsParameters.class.getMethod(\"theory\", String.class));\n    assertEquals(5, assignments.size());\n    for (PotentialAssignment assignment : assignments) {\n        assertThat(((String) (assignment.getValue())), containsString(\"expected\"));\n    }\n}", "methodAfter": "@Test\npublic void onlyUseSpecificDataPointsIfSpecified() throws Throwable {\n    List<PotentialAssignment> assignments = potentialAssignments(WithNamedDataPoints.HasSpecificDatapointsParameters.class.getMethod(\"theory\", String.class));\n    assertEquals(5, assignments.size());\n    for (PotentialAssignment assignment : assignments) {\n        assertThat(((String) (assignment.getValue())), containsString(\"expected\"));\n    }\n}"}, {"methodBefore": "private GuesserQueue createGuesserQueue(Assignments incomplete) throws Exception {\n    ParameterSignature nextUnassigned = incomplete.nextUnassigned();\n    if (nextUnassigned.hasAnnotation(Stub.class)) {\n        GuesserQueue queue = new GuesserQueue();\n        queue.add(new Guesser<Object>(nextUnassigned.getType()));\n        return queue;\n    }\n    return GuesserQueue.forSingleValues(incomplete.potentialsForNextUnassigned());\n}", "methodAfter": "private GuesserQueue createGuesserQueue(Assignments incomplete) throws Throwable {\n    ParameterSignature nextUnassigned = incomplete.nextUnassigned();\n    if (nextUnassigned.hasAnnotation(Stub.class)) {\n        GuesserQueue queue = new GuesserQueue();\n        queue.add(new Guesser<Object>(nextUnassigned.getType()));\n        return queue;\n    }\n    return GuesserQueue.forSingleValues(incomplete.potentialsForNextUnassigned());\n}"}, {"methodBefore": "@Test\npublic void ignoreDataPointMethodsWithWrongTypes() throws Exception {\n    assertThat(potentialAssignments(WithDataPointMethod.HasDateMethod.class.getMethod(\"onlyStringsOk\", String.class)).toString(), not(containsString(\"100\")));\n}", "methodAfter": "@Test\npublic void ignoreDataPointMethodsWithWrongTypes() throws Throwable {\n    assertThat(potentialAssignments(WithDataPointMethod.HasDateMethod.class.getMethod(\"onlyStringsOk\", String.class)).toString(), not(containsString(\"100\")));\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedSingleMethodDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single method value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedSingleMethodDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single method value\"));\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedSingleFieldDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedSingleFieldDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single value\"));\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedMethodDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named method\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedMethodDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named method\"));\n}"}, {"methodBefore": "@Test\npublic void shouldPickUpDataPointsFromParameterSupplier() throws Exception {\n    List<PotentialAssignment> assignments = potentialAssignments(WithParameterSupplier.TestClassUsingParameterSupplier.class.getMethod(\"theoryMethod\", String.class));\n    assertEquals(2, assignments.size());\n    assertEquals(DATAPOINTS.get(0), assignments.get(0).getValue());\n    assertEquals(DATAPOINTS.get(1), assignments.get(1).getValue());\n}", "methodAfter": "@Test\npublic void shouldPickUpDataPointsFromParameterSupplier() throws Throwable {\n    List<PotentialAssignment> assignments = potentialAssignments(WithParameterSupplier.TestClassUsingParameterSupplier.class.getMethod(\"theoryMethod\", String.class));\n    assertEquals(2, assignments.size());\n    assertEquals(DATAPOINTS.get(0), assignments.get(0).getValue());\n    assertEquals(DATAPOINTS.get(1), assignments.get(1).getValue());\n}"}, {"methodBefore": "@Test\npublic void shouldReturnNothingIfTheNamedDataPointsAreMissing() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingWrongNamedString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(0, assignedStrings.size());\n}", "methodAfter": "@Test\npublic void shouldReturnNothingIfTheNamedDataPointsAreMissing() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingWrongNamedString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(0, assignedStrings.size());\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingAllNamedStrings\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(4, assignedStrings.size());\n    assertThat(assignedStrings, hasItems(\"named field\", \"named method\", \"named single value\", \"named single method value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingAllNamedStrings\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(4, assignedStrings.size());\n    assertThat(assignedStrings, hasItems(\"named field\", \"named method\", \"named single value\", \"named single method value\"));\n}"}, {"methodBefore": "public List<PotentialAssignment> potentialsForNextUnassigned() throws Exception {\n    ParameterSignature unassigned = nextUnassigned();\n    return getSupplier(unassigned).getValueSources(unassigned);\n}", "methodAfter": "public List<PotentialAssignment> potentialsForNextUnassigned() throws Throwable {\n    ParameterSignature unassigned = nextUnassigned();\n    return getSupplier(unassigned).getValueSources(unassigned);\n}"}, {"methodBefore": "public static List<PotentialAssignment> potentialAssignments(Method method) throws Exception {\n    return Assignments.allUnassigned(method, new TestClass(method.getDeclaringClass())).potentialsForNextUnassigned();\n}", "methodAfter": "public static List<PotentialAssignment> potentialAssignments(Method method) throws Throwable {\n    return Assignments.allUnassigned(method, new TestClass(method.getDeclaringClass())).potentialsForNextUnassigned();\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedFieldDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named field\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedFieldDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named field\"));\n}"}], [{"methodBefore": "@Test\npublic void arraysEqual() {\n    Object element = new Object();\n    Object[] objects1 = new Object[]{ element };\n    Object[] objects2 = new Object[]{ element };\n    assertEquals(objects1, objects2);\n}", "methodAfter": "@Test\npublic void arraysEqual() {\n    Object element = new Object();\n    Object[] objects1 = new Object[]{ element };\n    Object[] objects2 = new Object[]{ element };\n    assertArrayEquals(objects1, objects2);\n}"}, {"methodBefore": "@Test\npublic void arraysEqualWithMessage() {\n    Object element = new Object();\n    Object[] objects1 = new Object[]{ element };\n    Object[] objects2 = new Object[]{ element };\n    assertEquals(\"equal\", objects1, objects2);\n}", "methodAfter": "@Test\npublic void arraysEqualWithMessage() {\n    Object element = new Object();\n    Object[] objects1 = new Object[]{ element };\n    Object[] objects2 = new Object[]{ element };\n    assertArrayEquals(\"equal\", objects1, objects2);\n}"}], [{"methodBefore": "public synchronized void removeListener(TestListener listener) {\n    fListeners.removeElement(listener);\n}", "methodAfter": "public synchronized void removeListener(TestListener listener) {\n    fListeners.remove(listener);\n}"}, {"methodBefore": "public synchronized void addListener(TestListener listener) {\n    fListeners.addElement(listener);\n}", "methodAfter": "public synchronized void addListener(TestListener listener) {\n    fListeners.add(listener);\n}"}], [{"methodBefore": "protected TestResult runSingleMethod(String testCase, String method, boolean wait) throws Exception {\n    Class testClass = loadSuiteClass(testCase);\n    Test test = TestSuite.createTest(testClass, method);\n    return doRun(test, wait);\n}", "methodAfter": "protected TestResult runSingleMethod(String testCase, String method, boolean wait) throws Exception {\n    Class<? extends TestCase> testClass = loadSuiteClass(testCase);\n    Test test = TestSuite.createTest(testClass, method);\n    return doRun(test, wait);\n}"}, {"methodBefore": "public Test getTest(String suiteClassName) {\n    if (suiteClassName.length() <= 0) {\n        clearStatus();\n        return null;\n    }\n    Class testClass = null;\n    try {\n        testClass = loadSuiteClass(suiteClassName);\n    } catch (ClassNotFoundException e) {\n        String clazz = e.getMessage();\n        if (clazz == null) {\n            clazz = suiteClassName;\n        }\n        runFailed((\"Class not found \\\"\" + clazz) + \"\\\"\");\n        return null;\n    } catch (Exception e) {\n        runFailed(\"Error: \" + e.toString());\n        return null;\n    }\n    Method suiteMethod = null;\n    try {\n        suiteMethod = testClass.getMethod(SUITE_METHODNAME, new Class[0]);\n    } catch (Exception e) {\n        clearStatus();\n        return new TestSuite(testClass);\n    }\n    if (!Modifier.isStatic(suiteMethod.getModifiers())) {\n        runFailed(\"Suite() method must be static\");\n        return null;\n    }\n    Test test = null;\n    try {\n        test = ((Test) (suiteMethod.invoke(null, ((Object[]) (new Class[0])))));\n        if (test == null) {\n            return test;\n        }\n    } catch (InvocationTargetException e) {\n        runFailed(\"Failed to invoke suite():\" + e.getTargetException().toString());\n        return null;\n    } catch (IllegalAccessException e) {\n        runFailed(\"Failed to invoke suite():\" + e.toString());\n        return null;\n    }\n    clearStatus();\n    return test;\n}", "methodAfter": "public Test getTest(String suiteClassName) {\n    if (suiteClassName.length() <= 0) {\n        clearStatus();\n        return null;\n    }\n    Class<? extends TestCase> testClass = null;\n    try {\n        testClass = loadSuiteClass(suiteClassName);\n    } catch (ClassNotFoundException e) {\n        String clazz = e.getMessage();\n        if (clazz == null) {\n            clazz = suiteClassName;\n        }\n        runFailed((\"Class not found \\\"\" + clazz) + \"\\\"\");\n        return null;\n    } catch (Exception e) {\n        runFailed(\"Error: \" + e.toString());\n        return null;\n    }\n    Method suiteMethod = null;\n    try {\n        suiteMethod = testClass.getMethod(SUITE_METHODNAME, new Class[0]);\n    } catch (Exception e) {\n        clearStatus();\n        return new TestSuite(testClass);\n    }\n    if (!Modifier.isStatic(suiteMethod.getModifiers())) {\n        runFailed(\"Suite() method must be static\");\n        return null;\n    }\n    Test test = null;\n    try {\n        test = ((Test) (suiteMethod.invoke(null, ((Object[]) (new Class[0])))));\n        if (test == null) {\n            return test;\n        }\n    } catch (InvocationTargetException e) {\n        runFailed(\"Failed to invoke suite():\" + e.getTargetException().toString());\n        return null;\n    } catch (IllegalAccessException e) {\n        runFailed(\"Failed to invoke suite():\" + e.toString());\n        return null;\n    }\n    clearStatus();\n    return test;\n}"}], [{"methodBefore": "FilterFactory createFilterFactory(Class<? extends FilterFactory> filterFactoryClass) throws FilterFactoryNotCreatedException {\n    try {\n        return filterFactoryClass.getConstructor().newInstance();\n    } catch (Exception e) {\n        throw new FilterFactoryNotCreatedException(e.getMessage());\n    }\n}", "methodAfter": "FilterFactory createFilterFactory(Class<? extends FilterFactory> filterFactoryClass) throws FilterFactoryNotCreatedException {\n    try {\n        return filterFactoryClass.getConstructor().newInstance();\n    } catch (Exception e) {\n        throw new FilterFactoryNotCreatedException(e);\n    }\n}"}, {"methodBefore": "@Override\npublic Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n    try {\n        return createFilter(parseCategories(params.getArgs()));\n    } catch (ClassNotFoundException e) {\n        throw new FilterNotCreatedException(e.getMessage());\n    }\n}", "methodAfter": "@Override\npublic Filter createFilter(FilterFactoryParams params) throws FilterNotCreatedException {\n    try {\n        return createFilter(parseCategories(params.getArgs()));\n    } catch (ClassNotFoundException e) {\n        throw new FilterNotCreatedException(e);\n    }\n}"}, {"methodBefore": "FilterFactory createFilterFactory(String filterFactoryFqcn) throws FilterFactoryNotCreatedException {\n    Class<? extends FilterFactory> filterFactoryClass;\n    try {\n        filterFactoryClass = ClassUtil.getClass(filterFactoryFqcn).asSubclass(FilterFactory.class);\n    } catch (Exception e) {\n        throw new FilterFactoryNotCreatedException(e.getMessage());\n    }\n    return createFilterFactory(filterFactoryClass);\n}", "methodAfter": "FilterFactory createFilterFactory(String filterFactoryFqcn) throws FilterFactoryNotCreatedException {\n    Class<? extends FilterFactory> filterFactoryClass;\n    try {\n        filterFactoryClass = ClassUtil.getClass(filterFactoryFqcn).asSubclass(FilterFactory.class);\n    } catch (Exception e) {\n        throw new FilterFactoryNotCreatedException(e);\n    }\n    return createFilterFactory(filterFactoryClass);\n}"}], [{"methodBefore": "public void testBagSubtract() {\n    Money bag[] = new Money[]{ new Money(-2, \"CHF\"), new Money(-14, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.subtract(fMB2));\n}", "methodAfter": "public void testBagSubtract() {\n    IMoney expected = MoneyBag.create(new Money(-2, \"CHF\"), new Money(-14, \"USD\"));\n    assertEquals(expected, fMB1.subtract(fMB2));\n}"}, {"methodBefore": "public void testBagMultiply() {\n    Money bag[] = new Money[]{ new Money(24, \"CHF\"), new Money(14, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.multiply(2));\n    assertEquals(fMB1, fMB1.multiply(1));\n    assertTrue(fMB1.multiply(0).isZero());\n}", "methodAfter": "public void testBagMultiply() {\n    IMoney expected = MoneyBag.create(new Money(24, \"CHF\"), new Money(14, \"USD\"));\n    assertEquals(expected, fMB1.multiply(2));\n    assertEquals(fMB1, fMB1.multiply(1));\n    assertTrue(fMB1.multiply(0).isZero());\n}"}, {"methodBefore": "public void testBagNegate() {\n    Money bag[] = new Money[]{ new Money(-12, \"CHF\"), new Money(-7, \"USD\") };\n    MoneyBag expected = new MoneyBag(bag);\n    assertEquals(expected, fMB1.negate());\n}", "methodAfter": "public void testBagNegate() {\n    IMoney expected = MoneyBag.create(new Money(-12, \"CHF\"), new Money(-7, \"USD\"));\n    assertEquals(expected, fMB1.negate());\n}"}], [{"methodBefore": "@Test\npublic void testAscendingMethodSorter() {\n    List<String> expected = Arrays.asList(new String[]{ ALPHA, BETA, DELTA, EPSILON, GAMMA_VOID, GAMMA_BOOLEAN });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.DummySortWithNameAsc.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void testAscendingMethodSorter() {\n    List<String> expected = Arrays.asList(ALPHA, BETA, DELTA, EPSILON, GAMMA_VOID, GAMMA_BOOLEAN);\n    List<String> actual = getDeclaredMethodNames(MethodSorterTest.DummySortWithNameAsc.class);\n    assertEquals(expected, actual);\n}"}, {"methodBefore": "@Test\npublic void testMethodsNullSorterSelf() {\n    List<String> expected = Arrays.asList(new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.DummySortWithoutAnnotation.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void testMethodsNullSorterSelf() {\n    List<String> expected = Arrays.asList(EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN);\n    List<String> actual = getDeclaredMethodNames(MethodSorterTest.DummySortWithoutAnnotation.class);\n    assertEquals(expected, actual);\n}"}, {"methodBefore": "@Test\npublic void testDefaultMethodSorter() {\n    List<String> expected = Arrays.asList(new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.DummySortWithDefault.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void testDefaultMethodSorter() {\n    List<String> expected = Arrays.asList(EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN);\n    List<String> actual = getDeclaredMethodNames(MethodSorterTest.DummySortWithDefault.class);\n    assertEquals(expected, actual);\n}"}], [{"methodBefore": "public void pleaseStop() {\n    fPleaseStop = true;\n}", "methodAfter": "public void pleaseStop() {\n    pleaseStop = true;\n}"}, {"methodBefore": "public void fireTestStarted(final Description description) throws StoppedByUserException {\n    if (fPleaseStop) {\n        throw new StoppedByUserException();\n    }\n    new SafeNotifier() {\n        @Override\n        protected void notifyListener(RunListener each) throws Exception {\n            each.testStarted(description);\n        }\n    }.run();\n}", "methodAfter": "public void fireTestStarted(final Description description) throws StoppedByUserException {\n    if (pleaseStop) {\n        throw new StoppedByUserException();\n    }\n    new SafeNotifier() {\n        @Override\n        protected void notifyListener(RunListener each) throws Exception {\n            each.testStarted(description);\n        }\n    }.run();\n}"}], [{"methodBefore": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateZeroArgConstructor(List<Throwable> errors) {\n}"}, {"methodBefore": "@Override\nprotected void validateNoArgConstructor(List<Throwable> errors) {\n}", "methodAfter": "@Override\nprotected void validateConstructor(List<Throwable> errors) {\n}"}], [{"methodBefore": "public void addListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot add a null listener\");\n    }\n    fListeners.add(wrapIfNotThreadSafe(listener));\n}", "methodAfter": "public void addListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot add a null listener\");\n    }\n    listeners.add(wrapIfNotThreadSafe(listener));\n}"}, {"methodBefore": "public void addFirstListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot add a null listener\");\n    }\n    fListeners.add(0, wrapIfNotThreadSafe(listener));\n}", "methodAfter": "public void addFirstListener(RunListener listener) {\n    if (listener == null) {\n        throw new NullPointerException(\"Cannot add a null listener\");\n    }\n    listeners.add(0, wrapIfNotThreadSafe(listener));\n}"}], [{"methodBefore": "@Override\npublic void run(final RunNotifier notifier) {\n    EachTestNotifier testNotifier = new EachTestNotifier(notifier, getDescription());\n    try {\n        Statement statement = classBlock(notifier);\n        statement.evaluate();\n    } catch (AssumptionViolatedException e) {\n        testNotifier.addIgnorance(e);\n    } catch (StoppedByUserException e) {\n        throw e;\n    } catch (Throwable e) {\n        testNotifier.addFailure(e);\n    }\n}", "methodAfter": "@Override\npublic void run(final RunNotifier notifier) {\n    EachTestNotifier testNotifier = new EachTestNotifier(notifier, getDescription());\n    try {\n        Statement statement = classBlock(notifier);\n        statement.evaluate();\n    } catch (AssumptionViolatedException e) {\n        testNotifier.addFailedAssumption(e);\n    } catch (StoppedByUserException e) {\n        throw e;\n    } catch (Throwable e) {\n        testNotifier.addFailure(e);\n    }\n}"}, {"methodBefore": "@Override\npublic void run(EachTestNotifier context) {\n    context.fireTestStarted();\n    try {\n        fNext.evaluate();\n    } catch (AssumptionViolatedException e) {\n        context.addIgnorance(e);\n    } catch (Throwable e) {\n        context.addFailure(e);\n    } finally {\n        context.fireTestFinished();\n    }\n}", "methodAfter": "@Override\npublic void run(EachTestNotifier context) {\n    context.fireTestStarted();\n    try {\n        fNext.evaluate();\n    } catch (AssumptionViolatedException e) {\n        context.addFailedAssumption(e);\n    } catch (Throwable e) {\n        context.addFailure(e);\n    } finally {\n        context.fireTestFinished();\n    }\n}"}], [{"methodBefore": "public void testJarClassLoading() throws Exception {\n    URL url = getClass().getResource(\"test.jar\");\n    if (url == null) {\n        return;\n    }\n    String path = url.getFile();\n    TestCaseClassLoader loader = new TestCaseClassLoader(path);\n    Class loadedClass = loader.loadClass(\"junit.tests.runner.LoadedFromJar\", true);\n    Object o = loadedClass.newInstance();\n    Method method = loadedClass.getDeclaredMethod(\"verify\", new Class[0]);\n    method.invoke(o, new Class[0]);\n}", "methodAfter": "public void testJarClassLoading() throws Exception {\n    URL url = getClass().getResource(\"test.jar\");\n    if (url == null) {\n        return;\n    }\n    String path = url.getFile();\n    TestCaseClassLoader loader = new TestCaseClassLoader(path);\n    Class loadedClass = loader.loadClass(\"junit.tests.runner.LoadedFromJar\", true);\n    Object o = loadedClass.newInstance();\n    Method method = loadedClass.getDeclaredMethod(\"verify\", new Class[0]);\n    method.invoke(o, ((Object[]) (new Class[0])));\n}"}, {"methodBefore": "public Test getTest(String suiteClassName) {\n    if (suiteClassName.length() <= 0) {\n        clearStatus();\n        return null;\n    }\n    Class testClass = null;\n    try {\n        testClass = loadSuiteClass(suiteClassName);\n    } catch (ClassNotFoundException e) {\n        String clazz = e.getMessage();\n        if (clazz == null) {\n            clazz = suiteClassName;\n        }\n        runFailed((\"Class not found \\\"\" + clazz) + \"\\\"\");\n        return null;\n    } catch (Exception e) {\n        runFailed(\"Error: \" + e.toString());\n        return null;\n    }\n    Method suiteMethod = null;\n    try {\n        suiteMethod = testClass.getMethod(SUITE_METHODNAME, new Class[0]);\n    } catch (Exception e) {\n        clearStatus();\n        return new TestSuite(testClass);\n    }\n    if (!Modifier.isStatic(suiteMethod.getModifiers())) {\n        runFailed(\"Suite() method must be static\");\n        return null;\n    }\n    Test test = null;\n    try {\n        test = ((Test) (suiteMethod.invoke(null, new Class[0])));\n        if (test == null) {\n            return test;\n        }\n    } catch (InvocationTargetException e) {\n        runFailed(\"Failed to invoke suite():\" + e.getTargetException().toString());\n        return null;\n    } catch (IllegalAccessException e) {\n        runFailed(\"Failed to invoke suite():\" + e.toString());\n        return null;\n    }\n    clearStatus();\n    return test;\n}", "methodAfter": "public Test getTest(String suiteClassName) {\n    if (suiteClassName.length() <= 0) {\n        clearStatus();\n        return null;\n    }\n    Class testClass = null;\n    try {\n        testClass = loadSuiteClass(suiteClassName);\n    } catch (ClassNotFoundException e) {\n        String clazz = e.getMessage();\n        if (clazz == null) {\n            clazz = suiteClassName;\n        }\n        runFailed((\"Class not found \\\"\" + clazz) + \"\\\"\");\n        return null;\n    } catch (Exception e) {\n        runFailed(\"Error: \" + e.toString());\n        return null;\n    }\n    Method suiteMethod = null;\n    try {\n        suiteMethod = testClass.getMethod(SUITE_METHODNAME, new Class[0]);\n    } catch (Exception e) {\n        clearStatus();\n        return new TestSuite(testClass);\n    }\n    if (!Modifier.isStatic(suiteMethod.getModifiers())) {\n        runFailed(\"Suite() method must be static\");\n        return null;\n    }\n    Test test = null;\n    try {\n        test = ((Test) (suiteMethod.invoke(null, ((Object[]) (new Class[0])))));\n        if (test == null) {\n            return test;\n        }\n    } catch (InvocationTargetException e) {\n        runFailed(\"Failed to invoke suite():\" + e.getTargetException().toString());\n        return null;\n    } catch (IllegalAccessException e) {\n        runFailed(\"Failed to invoke suite():\" + e.toString());\n        return null;\n    }\n    clearStatus();\n    return test;\n}"}, {"methodBefore": "public void testClassLoading() throws Exception {\n    TestCaseClassLoader loader = new TestCaseClassLoader();\n    Class loadedClass = loader.loadClass(\"junit.tests.runner.ClassLoaderTest\", true);\n    Object o = loadedClass.newInstance();\n    Method method = loadedClass.getDeclaredMethod(\"verify\", new Class[0]);\n    method.invoke(o, new Class[0]);\n}", "methodAfter": "public void testClassLoading() throws Exception {\n    TestCaseClassLoader loader = new TestCaseClassLoader();\n    Class loadedClass = loader.loadClass(\"junit.tests.runner.ClassLoaderTest\", true);\n    Object o = loadedClass.newInstance();\n    Method method = loadedClass.getDeclaredMethod(\"verify\", new Class[0]);\n    method.invoke(o, ((Object[]) (new Class[0])));\n}"}], [{"methodBefore": "@Test\npublic void arraysActualNullMessage() {\n    try {\n        assertEquals(\"not equal\", new Object[]{ new Object() }, null);\n    } catch (AssertionError exception) {\n        assertEquals(\"not equal: actual array was null\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void arraysActualNullMessage() {\n    try {\n        assertArrayEquals(\"not equal\", new Object[]{ new Object() }, null);\n    } catch (AssertionError exception) {\n        assertEquals(\"not equal: actual array was null\", exception.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void arraysExpectedNullMessage() {\n    try {\n        assertEquals(\"not equal\", null, new Object[]{ new Object() });\n    } catch (AssertionError exception) {\n        assertEquals(\"not equal: expected array was null\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void arraysExpectedNullMessage() {\n    try {\n        assertArrayEquals(\"not equal\", null, new Object[]{ new Object() });\n    } catch (AssertionError exception) {\n        assertEquals(\"not equal: expected array was null\", exception.getMessage());\n    }\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(TestCaseTest.class);\n    suite.addTest(SuiteTest.suite());\n    suite.addTestSuite(TestListenerTest.class);\n    suite.addTestSuite(AssertTest.class);\n    suite.addTestSuite(TestImplementorTest.class);\n    suite.addTestSuite(NoArgTestCaseTest.class);\n    suite.addTestSuite(ComparisonCompactorTest.class);\n    suite.addTestSuite(ComparisonFailureTest.class);\n    suite.addTestSuite(DoublePrecisionAssertTest.class);\n    suite.addTestSuite(FloatAssertTest.class);\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    suite.addTestSuite(TextRunnerSingleMethodTest.class);\n    suite.addTestSuite(TextRunnerTest.class);\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(ResultTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    suite.addTestSuite(TextRunnerSingleMethodTest.class);\n    suite.addTestSuite(TextRunnerTest.class);\n    return suite;\n}"}], [{"methodBefore": "public static void assertNotSame(String message, Object expected, Object actual) {\n    if (expected == actual) {\n        failSame(message);\n    }\n}", "methodAfter": "public static void assertNotSame(String message, Object unexpected, Object actual) {\n    if (unexpected == actual) {\n        failSame(message);\n    }\n}"}, {"methodBefore": "public static void assertNotSame(Object expected, Object actual) {\n    assertNotSame(null, expected, actual);\n}", "methodAfter": "public static void assertNotSame(Object unexpected, Object actual) {\n    assertNotSame(null, unexpected, actual);\n}"}], [{"methodBefore": "public TestSelector(Frame parent, TestCollector testCollector) {\n    super(parent, true);\n    setSize(350, 300);\n    setResizable(false);\n    setLocationRelativeTo(parent);\n    setTitle(\"Test Selector\");\n    Vector list = null;\n    try {\n        parent.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        list = createTestList(testCollector);\n    } finally {\n        parent.setCursor(Cursor.getDefaultCursor());\n    }\n    fList = new JList(list);\n    fList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    fList.setCellRenderer(new TestCellRenderer());\n    fScrolledList = new JScrollPane(fList);\n    fCancel = new JButton(\"Cancel\");\n    fDescription = new JLabel(\"Select the Test class:\");\n    fOk = new JButton(\"OK\");\n    fOk.setEnabled(false);\n    getRootPane().setDefaultButton(fOk);\n    defineLayout();\n    addListeners();\n}", "methodAfter": "public TestSelector(Frame parent, TestCollector testCollector) {\n    super(parent, true);\n    setSize(350, 300);\n    setResizable(false);\n    try {\n        setLocationRelativeTo(parent);\n    } catch (NoSuchMethodError e) {\n        centerWindow(this);\n    }\n    setTitle(\"Test Selector\");\n    Vector list = null;\n    try {\n        parent.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        list = createTestList(testCollector);\n    } finally {\n        parent.setCursor(Cursor.getDefaultCursor());\n    }\n    fList = new JList(list);\n    fList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    fList.setCellRenderer(new TestCellRenderer());\n    fScrolledList = new JScrollPane(fList);\n    fCancel = new JButton(\"Cancel\");\n    fDescription = new JLabel(\"Select the Test class:\");\n    fOk = new JButton(\"OK\");\n    fOk.setEnabled(false);\n    getRootPane().setDefaultButton(fOk);\n    defineLayout();\n    addListeners();\n}"}, {"methodBefore": "public AboutDialog(JFrame parent) {\n    super(parent, true);\n    setResizable(false);\n    getContentPane().setLayout(new GridBagLayout());\n    setSize(330, 138);\n    setTitle(\"About\");\n    setLocationRelativeTo(parent);\n    JButton close = new JButton(\"Close\");\n    close.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            dispose();\n        }\n    });\n    getRootPane().setDefaultButton(close);\n    JLabel label1 = new JLabel(\"JUnit\");\n    label1.setFont(new Font(\"dialog\", Font.PLAIN, 36));\n    JLabel label2 = new JLabel((\"JUnit \" + Version.id()) + \" by Kent Beck and Erich Gamma\");\n    label2.setFont(new Font(\"dialog\", Font.PLAIN, 14));\n    JLabel logo = createLogo();\n    GridBagConstraints constraintsLabel1 = new GridBagConstraints();\n    constraintsLabel1.gridx = 3;\n    constraintsLabel1.gridy = 0;\n    constraintsLabel1.gridwidth = 1;\n    constraintsLabel1.gridheight = 1;\n    constraintsLabel1.anchor = GridBagConstraints.CENTER;\n    getContentPane().add(label1, constraintsLabel1);\n    GridBagConstraints constraintsLabel2 = new GridBagConstraints();\n    constraintsLabel2.gridx = 2;\n    constraintsLabel2.gridy = 1;\n    constraintsLabel2.gridwidth = 2;\n    constraintsLabel2.gridheight = 1;\n    constraintsLabel2.anchor = GridBagConstraints.CENTER;\n    getContentPane().add(label2, constraintsLabel2);\n    GridBagConstraints constraintsButton1 = new GridBagConstraints();\n    constraintsButton1.gridx = 2;\n    constraintsButton1.gridy = 2;\n    constraintsButton1.gridwidth = 2;\n    constraintsButton1.gridheight = 1;\n    constraintsButton1.anchor = GridBagConstraints.CENTER;\n    constraintsButton1.insets = new Insets(8, 0, 8, 0);\n    getContentPane().add(close, constraintsButton1);\n    GridBagConstraints constraintsLogo1 = new GridBagConstraints();\n    constraintsLogo1.gridx = 2;\n    constraintsLogo1.gridy = 0;\n    constraintsLogo1.gridwidth = 1;\n    constraintsLogo1.gridheight = 1;\n    constraintsLogo1.anchor = GridBagConstraints.CENTER;\n    getContentPane().add(logo, constraintsLogo1);\n    addWindowListener(new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n            dispose();\n        }\n    });\n}", "methodAfter": "public AboutDialog(JFrame parent) {\n    super(parent, true);\n    setResizable(false);\n    getContentPane().setLayout(new GridBagLayout());\n    setSize(330, 138);\n    setTitle(\"About\");\n    try {\n        setLocationRelativeTo(parent);\n    } catch (NoSuchMethodError e) {\n        TestSelector.centerWindow(this);\n    }\n    JButton close = new JButton(\"Close\");\n    close.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            dispose();\n        }\n    });\n    getRootPane().setDefaultButton(close);\n    JLabel label1 = new JLabel(\"JUnit\");\n    label1.setFont(new Font(\"dialog\", Font.PLAIN, 36));\n    JLabel label2 = new JLabel((\"JUnit \" + Version.id()) + \" by Kent Beck and Erich Gamma\");\n    label2.setFont(new Font(\"dialog\", Font.PLAIN, 14));\n    JLabel logo = createLogo();\n    GridBagConstraints constraintsLabel1 = new GridBagConstraints();\n    constraintsLabel1.gridx = 3;\n    constraintsLabel1.gridy = 0;\n    constraintsLabel1.gridwidth = 1;\n    constraintsLabel1.gridheight = 1;\n    constraintsLabel1.anchor = GridBagConstraints.CENTER;\n    getContentPane().add(label1, constraintsLabel1);\n    GridBagConstraints constraintsLabel2 = new GridBagConstraints();\n    constraintsLabel2.gridx = 2;\n    constraintsLabel2.gridy = 1;\n    constraintsLabel2.gridwidth = 2;\n    constraintsLabel2.gridheight = 1;\n    constraintsLabel2.anchor = GridBagConstraints.CENTER;\n    getContentPane().add(label2, constraintsLabel2);\n    GridBagConstraints constraintsButton1 = new GridBagConstraints();\n    constraintsButton1.gridx = 2;\n    constraintsButton1.gridy = 2;\n    constraintsButton1.gridwidth = 2;\n    constraintsButton1.gridheight = 1;\n    constraintsButton1.anchor = GridBagConstraints.CENTER;\n    constraintsButton1.insets = new Insets(8, 0, 8, 0);\n    getContentPane().add(close, constraintsButton1);\n    GridBagConstraints constraintsLogo1 = new GridBagConstraints();\n    constraintsLogo1.gridx = 2;\n    constraintsLogo1.gridy = 0;\n    constraintsLogo1.gridwidth = 1;\n    constraintsLogo1.gridheight = 1;\n    constraintsLogo1.anchor = GridBagConstraints.CENTER;\n    getContentPane().add(logo, constraintsLogo1);\n    addWindowListener(new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n            dispose();\n        }\n    });\n}"}], [{"methodBefore": "public Parameterized(Class<?> klass) throws Throwable {\n    super(klass, NO_RUNNERS);\n    ParametersRunnerFactory runnerFactory = getParametersRunnerFactory(klass);\n    Parameters parameters = getParametersMethod().getAnnotation(Parameterized.Parameters.class);\n    fRunners = Collections.unmodifiableList(createRunnersForParameters(allParameters(), parameters.name(), runnerFactory));\n}", "methodAfter": "public Parameterized(Class<?> klass) throws Throwable {\n    super(klass, NO_RUNNERS);\n    ParametersRunnerFactory runnerFactory = getParametersRunnerFactory(klass);\n    Parameters parameters = getParametersMethod().getAnnotation(Parameterized.Parameters.class);\n    runners = Collections.unmodifiableList(createRunnersForParameters(allParameters(), parameters.name(), runnerFactory));\n}"}, {"methodBefore": "@Override\nprotected List<Runner> getChildren() {\n    return fRunners;\n}", "methodAfter": "@Override\nprotected List<Runner> getChildren() {\n    return runners;\n}"}, {"methodBefore": "@Override\nprotected List<Runner> getChildren() {\n    return fRunners;\n}", "methodAfter": "@Override\nprotected List<Runner> getChildren() {\n    return runners;\n}"}], [{"methodBefore": "@Test\npublic void shouldCreateFailureUponUncreatedFilter() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + JUnitCommandLineParserTest.FilterFactoryStub.class.getName() });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError: \"), containsString(FilterNotCreatedException.class.getName()), containsString(\"stub\")));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUncreatedFilter() throws Exception {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + JUnitCommandLineParserTest.FilterFactoryStub.class.getName() });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError:\"), containsString(FilterNotCreatedException.class.getName()), containsString(\"stub\")));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n    String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + nonExistentFilterFactory });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError: \"), containsString(FilterFactoryNotCreatedException.class.getName()), containsString(nonExistentFilterFactory)));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnfoundFilterFactory() throws Exception {\n    String nonExistentFilterFactory = \"NonExistentFilterFactory\";\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter=\" + nonExistentFilterFactory });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError:\"), containsString(FilterFactoryNotCreatedException.class.getName()), containsString(nonExistentFilterFactory)));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\" });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError: \"), containsString(CommandLineParserError.class.getName()), containsString(\"--filter value not specified\")));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue() {\n    jUnitCommandLineParser.parseOptions(new String[]{ \"--filter\" });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError:\"), containsString(CommandLineParserError.class.getName()), containsString(\"--filter value not specified\")));\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFailureUponUnknownOption() throws Exception {\n    String unknownOption = \"--unknown-option\";\n    jUnitCommandLineParser.parseOptions(new String[]{ unknownOption });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError: \"), containsString(CommandLineParserError.class.getName()), containsString(unknownOption)));\n}", "methodAfter": "@Test\npublic void shouldCreateFailureUponUnknownOption() throws Exception {\n    String unknownOption = \"--unknown-option\";\n    jUnitCommandLineParser.parseOptions(new String[]{ unknownOption });\n    Runner runner = jUnitCommandLineParser.createRequest(new Computer()).getRunner();\n    Description description = runner.getDescription().getChildren().get(0);\n    assertThat(description.toString(), allOf(containsString(\"initializationError:\"), containsString(CommandLineParserError.class.getName()), containsString(unknownOption)));\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            count++;\n            base.evaluate();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    return new FailOnTimeout(base, fMillis);\n}"}], [{"methodBefore": "@Test\npublic void testNameAsc() {\n    assertEquals(\"[java.lang.Object alpha(int,double,java.lang.Thread), void beta(int[][]), void delta(), void epsilon(), int gamma(), void gamma(boolean)]\", declaredMethods(MethodSorterTest.DummySortWithNameAsc.class));\n}", "methodAfter": "@Test\npublic void testNameAsc() {\n    String[] expected = new String[]{ ALPHA, BETA, DELTA, EPSILON, GAMMA_VOID, GAMMA_BOOLEAN };\n    assertEquals(Arrays.asList(expected).toString(), declaredMethods(MethodSorterTest.DummySortWithNameAsc.class));\n}"}, {"methodBefore": "@Test\npublic void testDefaultSorter() {\n    assertEquals(\"[void epsilon(), void beta(int[][]), java.lang.Object alpha(int,double,java.lang.Thread), void delta(), int gamma(), void gamma(boolean)]\", declaredMethods(MethodSorterTest.DummySortWithDefault.class));\n}", "methodAfter": "@Test\npublic void testDefaultSorter() {\n    String[] expected = new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN };\n    assertEquals(Arrays.asList(expected).toString(), declaredMethods(MethodSorterTest.DummySortWithDefault.class));\n}"}], [{"methodBefore": "public Suite(RunnerBuilder builder, Class<?>[] classes) throws InitializationError {\n    this(null, builder.runners(classes));\n}", "methodAfter": "public Suite(RunnerBuilder builder, Class<?>[] classes) throws InitializationError {\n    this(null, builder.runners(null, classes));\n}"}, {"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(null, request.getRunner().getDescription(), results);\n    return results;\n}"}], [{"methodBefore": "@Test\npublic void countsRuns() {\n    Result result = JUnitCore.runClasses(ParameterizedTestTest.FibonacciTest.class);\n    assertEquals(7, result.getRunCount());\n}", "methodAfter": "@Test\npublic void countsRuns() {\n    Result result = JUnitCore.runClasses(ParameterizedTestTest.AdditionTest.class);\n    assertEquals(4, result.getRunCount());\n}"}, {"methodBefore": "@Test\npublic void countBeforeRun() throws Exception {\n    Runner runner = Request.aClass(ParameterizedTestTest.FibonacciTest.class).getRunner();\n    assertEquals(7, runner.testCount());\n}", "methodAfter": "@Test\npublic void countBeforeRun() throws Exception {\n    Runner runner = Request.aClass(ParameterizedTestTest.AdditionTest.class).getRunner();\n    assertEquals(4, runner.testCount());\n}"}], [{"methodBefore": "@Test\npublic void arraysActualNullMessage() {\n    try {\n        assertEquals(\"not equal\", new Object[]{ new Object() }, null);\n    } catch (AssertionError exception) {\n        assertEquals(\"not equal: actual array was null\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void arraysActualNullMessage() {\n    try {\n        assertArrayEquals(\"not equal\", new Object[]{ new Object() }, null);\n    } catch (AssertionError exception) {\n        assertEquals(\"not equal: actual array was null\", exception.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void arraysExpectedNullMessage() {\n    try {\n        assertEquals(\"not equal\", null, new Object[]{ new Object() });\n    } catch (AssertionError exception) {\n        assertEquals(\"not equal: expected array was null\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void arraysExpectedNullMessage() {\n    try {\n        assertArrayEquals(\"not equal\", null, new Object[]{ new Object() });\n    } catch (AssertionError exception) {\n        assertEquals(\"not equal: expected array was null\", exception.getMessage());\n    }\n}"}], [{"methodBefore": "@Test\npublic void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime() throws Throwable {\n    thrown.expect(TestFailedOnTimeoutException.class);\n    evaluateWithWaitDuration(0);\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}", "methodAfter": "@Test\npublic void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime() throws Throwable {\n    thrown.expect(TestTimedOutException.class);\n    evaluateWithWaitDuration(0);\n    evaluateWithWaitDuration(TIMEOUT + 50);\n}"}, {"methodBefore": "@Test\npublic void throwsExceptionWithTimeoutValueAndTimeUnitSet() throws Throwable {\n    try {\n        evaluateWithWaitDuration(TIMEOUT + 50);\n        fail(\"No exception was thrown when test timed out\");\n    } catch (TestFailedOnTimeoutException e) {\n        assertEquals(TIMEOUT, e.getTimeout());\n        assertEquals(TimeUnit.MILLISECONDS, e.getTimeUnit());\n    }\n}", "methodAfter": "@Test\npublic void throwsExceptionWithTimeoutValueAndTimeUnitSet() throws Throwable {\n    try {\n        evaluateWithWaitDuration(TIMEOUT + 50);\n        fail(\"No exception was thrown when test timed out\");\n    } catch (TestTimedOutException e) {\n        assertEquals(TIMEOUT, e.getTimeout());\n        assertEquals(TimeUnit.MILLISECONDS, e.getTimeUnit());\n    }\n}"}], [{"methodBefore": "@Before\npublic void before() {\n    watchedLog += \"before \";\n}", "methodAfter": "@Before\npublic void before() {\n    watchedLog.append(\"before \");\n}"}, {"methodBefore": "@After\npublic void after() {\n    watchedLog += \"after \";\n}", "methodAfter": "@After\npublic void after() {\n    watchedLog.append(\"after \");\n}"}], [{"methodBefore": "protected List<Method> getTestMethods() {\n    return fTestClass.getTestMethods();\n}", "methodAfter": "protected List<TestMethod> getTestMethods() {\n    return fTestClass.getTestMethods();\n}"}, {"methodBefore": "protected void runMethods(final RunNotifier notifier) {\n    for (Method method : fTestMethods) {\n        invokeTestMethod(method, notifier);\n    }\n}", "methodAfter": "protected void runMethods(final RunNotifier notifier) {\n    for (TestMethod method : fTestMethods) {\n        invokeTestMethod(method, notifier);\n    }\n}"}], [{"methodBefore": "@Override\npublic void testIgnored(Description description) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testIgnored(description);\n    }\n}", "methodAfter": "@Override\npublic void testIgnored(Description description) throws Exception {\n    synchronized(monitor) {\n        listener.testIgnored(description);\n    }\n}"}, {"methodBefore": "@Override\npublic void testStarted(Description description) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testStarted(description);\n    }\n}", "methodAfter": "@Override\npublic void testStarted(Description description) throws Exception {\n    synchronized(monitor) {\n        listener.testStarted(description);\n    }\n}"}, {"methodBefore": "@Override\npublic void testFinished(Description description) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testFinished(description);\n    }\n}", "methodAfter": "@Override\npublic void testFinished(Description description) throws Exception {\n    synchronized(monitor) {\n        listener.testFinished(description);\n    }\n}"}, {"methodBefore": "@Override\npublic void testRunStarted(Description description) throws Exception {\n    synchronized(fMonitor) {\n        fListener.testRunStarted(description);\n    }\n}", "methodAfter": "@Override\npublic void testRunStarted(Description description) throws Exception {\n    synchronized(monitor) {\n        listener.testRunStarted(description);\n    }\n}"}], [{"methodBefore": "public FilterFactoryParams(String args) {\n    this.args = args;\n}", "methodAfter": "public FilterFactoryParams(String args) {\n    if (args == null) {\n        throw new NullPointerException();\n    }\n    this.args = args;\n}"}, {"methodBefore": "public ErrorReportingRunner(Class<?> testClass, Throwable cause) {\n    fTestClass = testClass;\n    fCauses = getCauses(cause);\n}", "methodAfter": "public ErrorReportingRunner(Class<?> testClass, Throwable cause) {\n    if (testClass == null) {\n        throw new NullPointerException(\"Test class cannot be null\");\n    }\n    fTestClass = testClass;\n    fCauses = getCauses(cause);\n}"}], [{"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement link) {\n    return new RunAfters(link, new TestMethodElement(getTestClass()), target);\n}", "methodAfter": "protected Statement withAfters(FrameworkMethod method, Object target, Statement link) {\n    return new RunAfters(link, new TestMethod(getTestClass()), target);\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement link) {\n    return new RunBefores(link, new TestMethodElement(getTestClass()), target);\n}", "methodAfter": "protected Statement withBefores(FrameworkMethod method, Object target, Statement link) {\n    return new RunBefores(link, new TestMethod(getTestClass()), target);\n}"}], [{"methodBefore": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName());\n}", "methodAfter": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), testClass.getAnnotations());\n}"}, {"methodBefore": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), testClass, testClass.getAnnotations());\n}", "methodAfter": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass, testClass.getName(), testClass.getAnnotations());\n}"}, {"methodBefore": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), testClass.getAnnotations());\n}", "methodAfter": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), null, testClass.getAnnotations());\n}"}, {"methodBefore": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), null, testClass.getAnnotations());\n}", "methodAfter": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), testClass.getAnnotations());\n}"}, {"methodBefore": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), testClass.getAnnotations());\n}", "methodAfter": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), testClass, testClass.getAnnotations());\n}"}], [{"methodBefore": "public AssumptionViolatedException(String assumption) {\n    super(assumption);\n}", "methodAfter": "public AssumptionViolatedException(String message) {\n    super(message);\n}"}, {"methodBefore": "public ExpectedException reportMissingExceptionWithMessage(String providedMessage) {\n    missingExceptionMessage = providedMessage;\n    return this;\n}", "methodAfter": "public ExpectedException reportMissingExceptionWithMessage(String message) {\n    missingExceptionMessage = message;\n    return this;\n}"}], [{"methodBefore": "public void handleAssertionErrors() {\n    handleAssertionErrors = true;\n}", "methodAfter": "public ExpectedException handleAssertionErrors() {\n    handleAssertionErrors = true;\n    return this;\n}"}, {"methodBefore": "public void handleAssumptionViolatedExceptions() {\n    handleAssumptionViolatedExceptions = true;\n}", "methodAfter": "public ExpectedException handleAssumptionViolatedExceptions() {\n    handleAssumptionViolatedExceptions = true;\n    return this;\n}"}], [{"methodBefore": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass);\n}", "methodAfter": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass, fConstructorParameterCount);\n}"}, {"methodBefore": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass, fConstructorParameterCount);\n}", "methodAfter": "public Assignments assignNext(PotentialAssignment source) {\n    List<PotentialAssignment> assigned = new ArrayList<PotentialAssignment>(fAssigned);\n    assigned.add(source);\n    return new Assignments(assigned, fUnassigned.subList(1, fUnassigned.size()), fClass, fConstructorParameterCount, fNullsOk);\n}"}], [{"methodBefore": "public static void assertNotEquals(String message, long unexpected, long actual) {\n    if (unexpected == actual) {\n        failEquals(message, actual);\n    }\n}", "methodAfter": "public static void assertNotEquals(String message, long unexpected, long actual) {\n    if (unexpected == actual) {\n        failEquals(message, Long.valueOf(actual));\n    }\n}"}, {"methodBefore": "public static void assertNotEquals(String message, float unexpected, float actual, float delta) {\n    if (!floatIsDifferent(unexpected, actual, delta)) {\n        failEquals(message, actual);\n    }\n}", "methodAfter": "public static void assertNotEquals(String message, float unexpected, float actual, float delta) {\n    if (!floatIsDifferent(unexpected, actual, delta)) {\n        failEquals(message, Float.valueOf(actual));\n    }\n}"}], [{"methodBefore": "@Test\npublic void countsRuns() {\n    Result result = JUnitCore.runClasses(ParameterizedTestTest.FibonacciTest.class);\n    assertEquals(7, result.getRunCount());\n}", "methodAfter": "@Test\npublic void countsRuns() {\n    Result result = JUnitCore.runClasses(ParameterizedTestTest.AdditionTest.class);\n    assertEquals(4, result.getRunCount());\n}"}, {"methodBefore": "@Test\npublic void runsEveryTestOfArray() {\n    Result result = JUnitCore.runClasses(ParameterizedTestTest.FibonacciTestWithArray.class);\n    assertEquals(7, result.getRunCount());\n}", "methodAfter": "@Test\npublic void runsEveryTestOfArray() {\n    Result result = JUnitCore.runClasses(ParameterizedTestTest.AdditionTestWithArray.class);\n    assertEquals(4, result.getRunCount());\n}"}], [{"methodBefore": "static String format(String message, Object expected, Object actual) {\n    String formatted = \"\";\n    if (message != null) {\n        formatted = message + \" \";\n    }\n    return ((((formatted + \"expected:<\") + expected) + \"> but was:<\") + actual) + \">\";\n}", "methodAfter": "public static String format(String message, Object expected, Object actual) {\n    String formatted = \"\";\n    if (message != null) {\n        formatted = message + \" \";\n    }\n    return ((((formatted + \"expected:<\") + expected) + \"> but was:<\") + actual) + \">\";\n}"}, {"methodBefore": "static IMoney create(IMoney m1, IMoney m2) {\n    MoneyBag result = new MoneyBag();\n    m1.appendTo(result);\n    m2.appendTo(result);\n    return result.simplify();\n}", "methodAfter": "public static IMoney create(IMoney m1, IMoney m2) {\n    MoneyBag result = new MoneyBag();\n    m1.appendTo(result);\n    m2.appendTo(result);\n    return result.simplify();\n}"}], [{"methodBefore": "private void invokeValidatorsOnFields(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        for (FrameworkField frameworkField : annotationMap.get(annotationType)) {\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedField(frameworkField.getField()));\n        }\n    }\n}", "methodAfter": "private void invokeValidatorsOnFields(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        if (validateWithAnnotation != null) {\n            for (FrameworkField frameworkField : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedField(frameworkField.getField()));\n            }\n        }\n    }\n}"}, {"methodBefore": "private void invokeValidatorsOnMethods(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n        }\n    }\n}", "methodAfter": "private void invokeValidatorsOnMethods(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        if (validateWithAnnotation != null) {\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n            }\n        }\n    }\n}"}], [{"methodBefore": "public abstract void testFailed(int status, Test test, Throwable t);", "methodAfter": "public abstract void testFailed(int status, Test test, Throwable e);"}, {"methodBefore": "public void addError(Test test, Throwable t) {\n    getWriter().print(\"E\");\n}", "methodAfter": "public void addError(Test test, Throwable e) {\n    getWriter().print(\"E\");\n}"}, {"methodBefore": "public void addError(Test test, Throwable t) {\n    fErrorCount++;\n}", "methodAfter": "public void addError(Test test, Throwable e) {\n    fErrorCount++;\n}"}, {"methodBefore": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable e) {\n}"}, {"methodBefore": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable e) {\n}"}], [{"methodBefore": "protected Collection<FrameworkMethod> getDataPointsMethods(ParameterSignature sig) {\n    return fClass.getAnnotatedMethods(DataPoints.class);\n}", "methodAfter": "protected Collection<FrameworkMethod> getDataPointsMethods(ParameterSignature sig) {\n    return clazz.getAnnotatedMethods(DataPoints.class);\n}"}, {"methodBefore": "protected Collection<FrameworkMethod> getSingleDataPointMethods(ParameterSignature sig) {\n    return fClass.getAnnotatedMethods(DataPoint.class);\n}", "methodAfter": "protected Collection<FrameworkMethod> getSingleDataPointMethods(ParameterSignature sig) {\n    return clazz.getAnnotatedMethods(DataPoint.class);\n}"}], [{"methodBefore": "@Test\npublic void assertEmptyDoesNotThrowForEmptyList() throws Throwable {\n    MultipleFailureException.assertEmpty(Collections.<Throwable>emptyList());\n}", "methodAfter": "@Test\npublic void assertEmptyDoesNotThrowForEmptyList() throws Exception {\n    MultipleFailureException.assertEmpty(Collections.<Throwable>emptyList());\n}"}, {"methodBefore": "@Test\npublic void assertEmptyThrowsMutipleFailureExceptionForManyThrowables() throws Throwable {\n    List<Throwable> errors = new ArrayList<Throwable>();\n    errors.add(new ExpectedException(\"basil\"));\n    errors.add(new RuntimeException(\"garlic\"));\n    try {\n        MultipleFailureException.assertEmpty(errors);\n        fail();\n    } catch (MultipleFailureException expected) {\n        assertThat(expected.getFailures(), equalTo(errors));\n        assertTrue(expected.getMessage().startsWith(\"There were 2 errors:\\n\"));\n        assertTrue(expected.getMessage().contains(\"ExpectedException(basil)\\n\"));\n        assertTrue(expected.getMessage().contains(\"RuntimeException(garlic)\"));\n    }\n}", "methodAfter": "@Test\npublic void assertEmptyThrowsMutipleFailureExceptionForManyThrowables() throws Exception {\n    List<Throwable> errors = new ArrayList<Throwable>();\n    errors.add(new ExpectedException(\"basil\"));\n    errors.add(new RuntimeException(\"garlic\"));\n    try {\n        MultipleFailureException.assertEmpty(errors);\n        fail();\n    } catch (MultipleFailureException expected) {\n        assertThat(expected.getFailures(), equalTo(errors));\n        assertTrue(expected.getMessage().startsWith(\"There were 2 errors:\\n\"));\n        assertTrue(expected.getMessage().contains(\"ExpectedException(basil)\\n\"));\n        assertTrue(expected.getMessage().contains(\"RuntimeException(garlic)\"));\n    }\n}"}], [{"methodBefore": "public void addError(Test test, Throwable t) {\n    fErrorCount++;\n}", "methodAfter": "public void addError(Test test, Throwable e) {\n    fErrorCount++;\n}"}, {"methodBefore": "@Override\npublic void testFailed(int status, Test test, Throwable t) {\n}", "methodAfter": "@Override\npublic void testFailed(int status, Test test, Throwable e) {\n}"}], [{"methodBefore": "@Override\npublic List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n    List<PotentialAssignment> list = new ArrayList<PotentialAssignment>();\n    addSinglePointFields(sig, list);\n    addMultiPointFields(sig, list);\n    addSinglePointMethods(sig, list);\n    addMultiPointMethods(sig, list);\n    return list;\n}", "methodAfter": "@Override\npublic List<PotentialAssignment> getValueSources(ParameterSignature sig) throws Throwable {\n    List<PotentialAssignment> list = new ArrayList<PotentialAssignment>();\n    addSinglePointFields(sig, list);\n    addMultiPointFields(sig, list);\n    addSinglePointMethods(sig, list);\n    addMultiPointMethods(sig, list);\n    return list;\n}"}, {"methodBefore": "public abstract List<PotentialAssignment> getValueSources(ParameterSignature sig);", "methodAfter": "public abstract List<PotentialAssignment> getValueSources(ParameterSignature sig) throws Throwable;"}], [{"methodBefore": "@Test\npublic void getMethodsNullSorter() throws Exception {\n    assertEquals(\"[void epsilon(), void beta(int[][]), java.lang.Object alpha(int,double,java.lang.Thread), void delta(), int gamma(), void gamma(boolean)]\", declaredMethods(MethodSorterTest.Dummy.class));\n    assertEquals(\"[void testOne()]\", declaredMethods(MethodSorterTest.Super.class));\n    assertEquals(\"[void testTwo()]\", declaredMethods(MethodSorterTest.Sub.class));\n}", "methodAfter": "@Test\npublic void getMethodsNullSorter() throws Exception {\n    String[] expected = new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN };\n    assertEquals(Arrays.asList(expected).toString(), declaredMethods(MethodSorterTest.Dummy.class));\n    assertEquals(\"[void testOne()]\", declaredMethods(MethodSorterTest.Super.class));\n    assertEquals(\"[void testTwo()]\", declaredMethods(MethodSorterTest.Sub.class));\n}"}, {"methodBefore": "@Test\npublic void testNameAsc() {\n    assertEquals(\"[java.lang.Object alpha(int,double,java.lang.Thread), void beta(int[][]), void delta(), void epsilon(), int gamma(), void gamma(boolean)]\", declaredMethods(MethodSorterTest.DummySortWithNameAsc.class));\n}", "methodAfter": "@Test\npublic void testNameAsc() {\n    String[] expected = new String[]{ ALPHA, BETA, DELTA, EPSILON, GAMMA_VOID, GAMMA_BOOLEAN };\n    assertEquals(Arrays.asList(expected).toString(), declaredMethods(MethodSorterTest.DummySortWithNameAsc.class));\n}"}, {"methodBefore": "@Test\npublic void testDefaultSorter() {\n    assertEquals(\"[void epsilon(), void beta(int[][]), java.lang.Object alpha(int,double,java.lang.Thread), void delta(), int gamma(), void gamma(boolean)]\", declaredMethods(MethodSorterTest.DummySortWithDefault.class));\n}", "methodAfter": "@Test\npublic void testDefaultSorter() {\n    String[] expected = new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN };\n    assertEquals(Arrays.asList(expected).toString(), declaredMethods(MethodSorterTest.DummySortWithDefault.class));\n}"}], [{"methodBefore": "protected void validate() throws InitializationError {\n    List<Throwable> errors = new ArrayList<Throwable>();\n    collectInitializationErrors(errors);\n    if (!errors.isEmpty()) {\n        throw new InitializationError(errors);\n    }\n}", "methodAfter": "private void validate() throws InitializationError {\n    List<Throwable> errors = new ArrayList<Throwable>();\n    collectInitializationErrors(errors);\n    if (!errors.isEmpty()) {\n        throw new InitializationError(errors);\n    }\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}], [{"methodBefore": "@Test\npublic void getMethodsNullSorterSelf() {\n    List<String> expected = Arrays.asList(new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Dummy.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void testMethodsNullSorterSelf() {\n    List<String> expected = Arrays.asList(new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Dummy.class, expected);\n    assertEquals(expected, actual);\n}"}, {"methodBefore": "@Test\npublic void getMethodsNullSorterSubset() {\n    List<String> expected = Arrays.asList(new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Dummy.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void getMethodsNullSorterSelf() {\n    List<String> expected = Arrays.asList(new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Dummy.class, expected);\n    assertEquals(expected, actual);\n}"}], [{"methodBefore": "private String nameFor(String namePattern, int index, Object[] parameters) {\n    String finalPattern = namePattern.replaceAll(\"\\\\{index\\\\}\", Integer.toString(index));\n    return format(finalPattern, parameters);\n}", "methodAfter": "private String nameFor(String namePattern, int index, Object[] parameters) {\n    String finalPattern = namePattern.replaceAll(\"\\\\{index\\\\}\", Integer.toString(index));\n    return MessageFormat.format(finalPattern, parameters);\n}"}, {"methodBefore": "private Exception parametersMethodReturnedWrongType() throws Exception {\n    String className = getTestClass().getName();\n    String methodName = getParametersMethod().getName();\n    String message = format(\"{0}.{1}() must return an Iterable of arrays.\", className, methodName);\n    return new Exception(message);\n}", "methodAfter": "private Exception parametersMethodReturnedWrongType() throws Exception {\n    String className = getTestClass().getName();\n    String methodName = getParametersMethod().getName();\n    String message = MessageFormat.format(\"{0}.{1}() must return an Iterable of arrays.\", className, methodName);\n    return new Exception(message);\n}"}], [{"methodBefore": "@Test\npublic void shouldThrowException() throws Exception {\n    FilterFactoryParams params = new FilterFactoryParams(\"NonExistentFilter\");\n    expectedException.expect(FilterNotCreatedException.class);\n    categoryFilterFactory.createFilter(params);\n}", "methodAfter": "@Test\npublic void shouldThrowException() throws Exception {\n    FilterFactoryParams params = new FilterFactoryParams(createSuiteDescription(testName.getMethodName()), \"NonExistentFilter\");\n    expectedException.expect(FilterNotCreatedException.class);\n    categoryFilterFactory.createFilter(params);\n}"}, {"methodBefore": "@Test\npublic void shouldCreateFilterWithArguments() throws Exception {\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec((ExcludeCategories.class.getName() + \"=\") + FilterFactoryFactoryTest.DummyCategory.class.getName());\n    assertThat(filter.describe(), startsWith(\"excludes \"));\n}", "methodAfter": "@Test\npublic void shouldCreateFilterWithArguments() throws Exception {\n    Filter filter = filterFactoryFactory.createFilterFromFilterSpec(createSuiteDescription(testName.getMethodName()), (ExcludeCategories.class.getName() + \"=\") + FilterFactoryFactoryTest.DummyCategory.class.getName());\n    assertThat(filter.describe(), startsWith(\"excludes \"));\n}"}], [{"methodBefore": "public boolean testFinished(final Class<?> testClass) {\n    return finishedTests.contains(testClass.getName());\n}", "methodAfter": "private boolean testFinished(final Class<?> testClass) {\n    return finishedTests.contains(testClass.getName());\n}"}, {"methodBefore": "public boolean testStarted(final Class<?> testClass) {\n    return startedTests.contains(testClass.getName());\n}", "methodAfter": "private boolean testStarted(final Class<?> testClass) {\n    return startedTests.contains(testClass.getName());\n}"}], [{"methodBefore": "public void testFilter() {\n    assertEquals(fFiltered, BaseTestRunner.filterStack(fUnfiltered));\n}", "methodAfter": "public void testFilter() {\n    assertEquals(fFiltered, BaseTestRunner.getFilteredTrace(fUnfiltered));\n}"}, {"methodBefore": "public static String getFilteredTrace(Throwable t) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    t.printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    String trace = buffer.toString();\n    return BaseTestRunner.filterStack(trace);\n}", "methodAfter": "public static String getFilteredTrace(Throwable t) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    t.printStackTrace(writer);\n    StringBuffer buffer = stringWriter.getBuffer();\n    String trace = buffer.toString();\n    return BaseTestRunner.getFilteredTrace(trace);\n}"}], [{"methodBefore": "public static Request classWithoutSuiteMethod(Class<?> newTestClass) {\n    return new ClassRequest(newTestClass, false);\n}", "methodAfter": "public static Request classWithoutSuiteMethod(Class<?> newTestClass) {\n    return new ClassRequest(newTestClass, newSuiteBuilder(), false);\n}"}, {"methodBefore": "public static Request classWithoutSuiteMethod(Class<?> newTestClass) {\n    return new ClassRequest(newTestClass, newSuiteBuilder(), false);\n}", "methodAfter": "public static Request classWithoutSuiteMethod(Class<?> newTestClass) {\n    return new ClassRequest(newTestClass, false);\n}"}], [{"methodBefore": "protected Test getTest() {\n    return fTest;\n}", "methodAfter": "public Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "protected void setLoading(boolean enable) {\n    fLoading = enable;\n}", "methodAfter": "public void setLoading(boolean enable) {\n    fLoading = enable;\n}"}, {"methodBefore": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    statement = withRules(method, test, statement);\n    return statement;\n}", "methodAfter": "public Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    statement = withRules(method, test, statement);\n    return statement;\n}"}, {"methodBefore": "protected final TestClass getTestClass() {\n    return fTestClass;\n}", "methodAfter": "public final TestClass getTestClass() {\n    return fTestClass;\n}"}, {"methodBefore": "private Test getTest() {\n    return fTest;\n}", "methodAfter": "public Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "protected boolean isExcluded(String name) {\n    for (int i = 0; i < fExcluded.size(); i++) {\n        if (name.startsWith(((String) (fExcluded.elementAt(i))))) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "public boolean isExcluded(String name) {\n    for (int i = 0; i < fExcluded.size(); i++) {\n        if (name.startsWith(((String) (fExcluded.elementAt(i))))) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}], [{"methodBefore": "public boolean isIgnored() {\n    return fMethod.getAnnotation(Ignore.class) != null;\n}", "methodAfter": "public boolean isIgnored() {\n    return getMethod().getAnnotation(Ignore.class) != null;\n}"}, {"methodBefore": "protected void invoke(Object target) throws IllegalAccessException, InvocationTargetException {\n    fMethod.invoke(target);\n}", "methodAfter": "protected void invoke(Object target) throws IllegalAccessException, InvocationTargetException {\n    getMethod().invoke(target);\n}"}, {"methodBefore": "public long getTimeout() {\n    Test annotation = fMethod.getAnnotation(Test.class);\n    if (annotation == null) {\n        return 0;\n    }\n    long timeout = annotation.timeout();\n    return timeout;\n}", "methodAfter": "public long getTimeout() {\n    Test annotation = getMethod().getAnnotation(Test.class);\n    if (annotation == null) {\n        return 0;\n    }\n    long timeout = annotation.timeout();\n    return timeout;\n}"}], [{"methodBefore": "public void testComparisonErrorOverlapingMatchesContext() {\n    String failure = new ComparisonCompactor(2, \"abc\", \"abbc\").compact(null);\n    assertEquals(\"expected:<ab[]c> but was:<ab[b]c>\", failure);\n}", "methodAfter": "public void testComparisonErrorOverlappingMatchesContext() {\n    String failure = new ComparisonCompactor(2, \"abc\", \"abbc\").compact(null);\n    assertEquals(\"expected:<ab[]c> but was:<ab[b]c>\", failure);\n}"}, {"methodBefore": "public void testComparisonErrorOverlapingMatches2Context() {\n    String failure = new ComparisonCompactor(2, \"abcdde\", \"abcde\").compact(null);\n    assertEquals(\"expected:<...cd[d]e> but was:<...cd[]e>\", failure);\n}", "methodAfter": "public void testComparisonErrorOverlappingMatches2Context() {\n    String failure = new ComparisonCompactor(2, \"abcdde\", \"abcde\").compact(null);\n    assertEquals(\"expected:<...cd[d]e> but was:<...cd[]e>\", failure);\n}"}], [{"methodBefore": "public void addListener(RunListener listener) {\n    fListeners.add(listener);\n}", "methodAfter": "public void addListener(RunListener listener) {\n    synchronized(fListenersLock) {\n        fListeners.add(listener);\n    }\n}"}, {"methodBefore": "public void addFirstListener(RunListener listener) {\n    fListeners.add(0, listener);\n}", "methodAfter": "public void addFirstListener(RunListener listener) {\n    synchronized(fListenersLock) {\n        fListeners.add(0, listener);\n    }\n}"}], [{"methodBefore": "public int getFailureCount() {\n    return fFailures.size();\n}", "methodAfter": "public int getFailureCount() {\n    return failures.size();\n}"}, {"methodBefore": "@Override\npublic void testFailure(Failure failure) throws Exception {\n    fFailures.add(failure);\n}", "methodAfter": "@Override\npublic void testFailure(Failure failure) throws Exception {\n    failures.add(failure);\n}"}, {"methodBefore": "public List<Failure> getFailures() {\n    return fFailures;\n}", "methodAfter": "public List<Failure> getFailures() {\n    return failures;\n}"}], [{"methodBefore": "public void testError() throws Exception {\n    execTest(\"junit.tests.BogusDude\", -1);\n}", "methodAfter": "public void testError() throws Exception {\n    execTest(\"junit.tests.BogusDude\", false);\n}"}, {"methodBefore": "public void testFailure() throws Exception {\n    execTest(\"junit.tests.Failure\", -1);\n}", "methodAfter": "public void testFailure() throws Exception {\n    execTest(\"junit.tests.Failure\", false);\n}"}], [{"methodBefore": "public void removeListener(RunListener listener) {\n    fListeners.remove(listener);\n}", "methodAfter": "public void removeListener(RunListener listener) {\n    synchronized(fListenersLock) {\n        fListeners.remove(listener);\n    }\n}"}, {"methodBefore": "public void addListener(RunListener listener) {\n    fListeners.add(listener);\n}", "methodAfter": "public void addListener(RunListener listener) {\n    synchronized(fListenersLock) {\n        fListeners.add(listener);\n    }\n}"}], [{"methodBefore": "public static void assertEquals(String message, float expected, float actual, float delta) {\n    if (Float.isInfinite(expected)) {\n        if (!(expected == actual)) {\n            failNotEquals(message, new Float(expected), new Float(actual));\n        }\n    } else if (!(Math.abs(expected - actual) <= delta)) {\n        failNotEquals(message, new Float(expected), new Float(actual));\n    }\n}", "methodAfter": "public static void assertEquals(String message, float expected, float actual, float delta) {\n    if (Float.compare(expected, actual) == 0) {\n        return;\n    }\n    if (!(Math.abs(expected - actual) <= delta)) {\n        failNotEquals(message, new Float(expected), new Float(actual));\n    }\n}"}, {"methodBefore": "public static void assertEquals(String message, double expected, double actual, double delta) {\n    if (Double.isInfinite(expected)) {\n        if (!(expected == actual)) {\n            failNotEquals(message, new Double(expected), new Double(actual));\n        }\n    } else if (!(Math.abs(expected - actual) <= delta)) {\n        failNotEquals(message, new Double(expected), new Double(actual));\n    }\n}", "methodAfter": "public static void assertEquals(String message, double expected, double actual, double delta) {\n    if (Double.compare(expected, actual) == 0) {\n        return;\n    }\n    if (!(Math.abs(expected - actual) <= delta)) {\n        failNotEquals(message, new Double(expected), new Double(actual));\n    }\n}"}], [{"methodBefore": "public Filter createFilter(String filterFactoryFqcn, FilterFactoryParams args) throws FilterNotCreatedException, FilterFactoryNotFoundException {\n    return args.apply(filterFactoryFqcn);\n}", "methodAfter": "public Filter createFilter(String filterFactoryFqcn, FilterFactoryParams args) throws FilterNotCreatedException, FilterFactoryNotCreatedException {\n    return args.apply(filterFactoryFqcn);\n}"}, {"methodBefore": "public Filter createFilter(Class<? extends FilterFactory> filterFactoryClass, FilterFactoryParams args) throws FilterNotCreatedException, FilterFactoryNotFoundException {\n    return createFilter(filterFactoryClass.getName(), args);\n}", "methodAfter": "public Filter createFilter(Class<? extends FilterFactory> filterFactoryClass, FilterFactoryParams args) throws FilterNotCreatedException, FilterFactoryNotCreatedException {\n    return createFilter(filterFactoryClass.getName(), args);\n}"}, {"methodBefore": "public Filter createFilterFromFilterSpec(String filterSpec) throws FilterFactoryNotFoundException, FilterNotCreatedException {\n    String filterFactoryFqcn;\n    FilterFactoryParams args;\n    if (filterSpec.contains(\"=\")) {\n        String[] tuple = filterSpec.split(\"=\", 2);\n        filterFactoryFqcn = tuple[0];\n        args = new FilterFactoryParams.OneArg(tuple[1]);\n    } else {\n        filterFactoryFqcn = filterSpec;\n        args = new FilterFactoryParams.ZeroArg();\n    }\n    return createFilter(filterFactoryFqcn, args);\n}", "methodAfter": "public Filter createFilterFromFilterSpec(String filterSpec) throws FilterFactoryNotCreatedException, FilterNotCreatedException {\n    String filterFactoryFqcn;\n    FilterFactoryParams args;\n    if (filterSpec.contains(\"=\")) {\n        String[] tuple = filterSpec.split(\"=\", 2);\n        filterFactoryFqcn = tuple[0];\n        args = new FilterFactoryParams.OneArg(tuple[1]);\n    } else {\n        filterFactoryFqcn = filterSpec;\n        args = new FilterFactoryParams.ZeroArg();\n    }\n    return createFilter(filterFactoryFqcn, args);\n}"}], [{"methodBefore": "@Test\npublic void testDefaultMethodSorter() {\n    List<String> expected = Arrays.asList(new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.DummySortWithDefault.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void testDefaultMethodSorter() {\n    List<String> expected = Arrays.asList(EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN);\n    List<String> actual = getDeclaredMethodNames(MethodSorterTest.DummySortWithDefault.class);\n    assertEquals(expected, actual);\n}"}, {"methodBefore": "@Test\npublic void testMethodsNullSorterSelf() {\n    List<String> expected = Arrays.asList(new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.DummySortWithoutAnnotation.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void testMethodsNullSorterSelf() {\n    List<String> expected = Arrays.asList(EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN);\n    List<String> actual = getDeclaredMethodNames(MethodSorterTest.DummySortWithoutAnnotation.class);\n    assertEquals(expected, actual);\n}"}], [{"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedMethodDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named method\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedMethodDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named method\"));\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedFieldDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named field\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedFieldDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named field\"));\n}"}], [{"methodBefore": "public void testAssertNull() {\n    assertNull(null);\n}", "methodAfter": "public void testAssertNull() {\n    assertNull(null);\n    try {\n        assertNull(new Object());\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}"}, {"methodBefore": "public void testAssertSame() {\n    Object o = new Object();\n    assertSame(o, o);\n}", "methodAfter": "public void testAssertSame() {\n    Object o = new Object();\n    assertSame(o, o);\n    try {\n        assertSame(new Integer(1), new Integer(1));\n        fail();\n    } catch (AssertionFailedError e) {\n    }\n}"}], [{"methodBefore": "public void startTest(Test test) {\n    fNotifier.fireTestStarted(asDescription(test));\n}", "methodAfter": "public void startTest(Test test) {\n    notifier.fireTestStarted(asDescription(test));\n}"}, {"methodBefore": "public void endTest(Test test) {\n    fNotifier.fireTestFinished(asDescription(test));\n}", "methodAfter": "public void endTest(Test test) {\n    notifier.fireTestFinished(asDescription(test));\n}"}, {"methodBefore": "public void addError(Test test, Throwable e) {\n    Failure failure = new Failure(asDescription(test), e);\n    fNotifier.fireTestFailure(failure);\n}", "methodAfter": "public void addError(Test test, Throwable e) {\n    Failure failure = new Failure(asDescription(test), e);\n    notifier.fireTestFailure(failure);\n}"}, {"methodBefore": "public void addListener(RunListener listener) {\n    fNotifier.addListener(listener);\n}", "methodAfter": "public void addListener(RunListener listener) {\n    notifier.addListener(listener);\n}"}, {"methodBefore": "public void removeListener(RunListener listener) {\n    fNotifier.removeListener(listener);\n}", "methodAfter": "public void removeListener(RunListener listener) {\n    notifier.removeListener(listener);\n}"}], [{"methodBefore": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = fTestClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}", "methodAfter": "protected Statement withAfterClasses(Statement statement) {\n    List<FrameworkMethod> afters = testClass.getAnnotatedMethods(AfterClass.class);\n    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);\n}"}, {"methodBefore": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = fTestClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}", "methodAfter": "protected Statement withBeforeClasses(Statement statement) {\n    List<FrameworkMethod> befores = testClass.getAnnotatedMethods(BeforeClass.class);\n    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);\n}"}], [{"methodBefore": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    new ExactComparisonCriteria().internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    new ExactComparisonCriteria().internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "private static void internalArrayEquals(String message, Object expecteds, Object actuals) throws ArrayComparisonFailure {\n    new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, double[] expecteds, double[] actuals, double delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}, {"methodBefore": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);\n}", "methodAfter": "public static void assertArrayEquals(String message, float[] expecteds, float[] actuals, float delta) throws ArrayComparisonFailure {\n    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);\n}"}], [{"methodBefore": "public Field getField() {\n    return fField;\n}", "methodAfter": "public Field getField() {\n    return field;\n}"}, {"methodBefore": "@Override\nprotected int getModifiers() {\n    return fField.getModifiers();\n}", "methodAfter": "@Override\nprotected int getModifiers() {\n    return field.getModifiers();\n}"}, {"methodBefore": "@Override\npublic String toString() {\n    return fField.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    return field.toString();\n}"}, {"methodBefore": "public Object get(Object target) throws IllegalArgumentException, IllegalAccessException {\n    return fField.get(target);\n}", "methodAfter": "public Object get(Object target) throws IllegalArgumentException, IllegalAccessException {\n    return field.get(target);\n}"}, {"methodBefore": "public Annotation[] getAnnotations() {\n    return fField.getAnnotations();\n}", "methodAfter": "public Annotation[] getAnnotations() {\n    return field.getAnnotations();\n}"}], [{"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement link) {\n    return new RunBefores(link, new TestMethod(getTestClass()), target);\n}", "methodAfter": "protected Statement withBefores(FrameworkMethod method, Object target, Statement link) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return new RunBefores(link, befores, target);\n}"}, {"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement link) {\n    return new RunAfters(link, new TestMethod(getTestClass()), target);\n}", "methodAfter": "protected Statement withAfters(FrameworkMethod method, Object target, Statement link) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return new RunAfters(link, afters, target);\n}"}], [{"methodBefore": "@Test\npublic void arraysDifferAtElement0nullMessage() {\n    try {\n        assertEquals(new Object[]{ true }, new Object[]{ false });\n    } catch (AssertionError exception) {\n        assertEquals(\"arrays first differed at element [0]; expected:<true> but was:<false>\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void arraysDifferAtElement0nullMessage() {\n    try {\n        assertArrayEquals(new Object[]{ true }, new Object[]{ false });\n    } catch (AssertionError exception) {\n        assertEquals(\"arrays first differed at element [0]; expected:<true> but was:<false>\", exception.getMessage());\n    }\n}"}, {"methodBefore": "@Test\npublic void arraysDifferAtElement1nullMessage() {\n    try {\n        assertEquals(new Object[]{ true, true }, new Object[]{ true, false });\n    } catch (AssertionError exception) {\n        assertEquals(\"arrays first differed at element [1]; expected:<true> but was:<false>\", exception.getMessage());\n    }\n}", "methodAfter": "@Test\npublic void arraysDifferAtElement1nullMessage() {\n    try {\n        assertArrayEquals(new Object[]{ true, true }, new Object[]{ true, false });\n    } catch (AssertionError exception) {\n        assertEquals(\"arrays first differed at element [1]; expected:<true> but was:<false>\", exception.getMessage());\n    }\n}"}], [{"methodBefore": "private static void failNotSame(String message, Object expected, Object actual) {\n    String formatted = \"\";\n    if (message != null) {\n        formatted = message + \" \";\n    }\n    fail(((((formatted + \"expected same:<\") + expected) + \"> was not:<\") + actual) + \">\");\n}", "methodAfter": "public static void failNotSame(String message, Object expected, Object actual) {\n    String formatted = \"\";\n    if (message != null) {\n        formatted = message + \" \";\n    }\n    fail(((((formatted + \"expected same:<\") + expected) + \"> was not:<\") + actual) + \">\");\n}"}, {"methodBefore": "private static void failNotEquals(String message, Object expected, Object actual) {\n    fail(format(message, expected, actual));\n}", "methodAfter": "public static void failNotEquals(String message, Object expected, Object actual) {\n    fail(format(message, expected, actual));\n}"}], [{"methodBefore": "@Test\npublic void getMethodsNullSorterSub() {\n    List<String> expected = Arrays.asList(new String[]{ SUB_METHOD });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Sub.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void testMethodsNullSorterSub() {\n    List<String> expected = Arrays.asList(new String[]{ SUB_METHOD });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Sub.class, expected);\n    assertEquals(expected, actual);\n}"}, {"methodBefore": "@Test\npublic void getMethodsNullSorterSuper() {\n    List<String> expected = Arrays.asList(new String[]{ SUPER_METHOD });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Super.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void testMethodsNullSorterSuper() {\n    List<String> expected = Arrays.asList(new String[]{ SUPER_METHOD });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Super.class, expected);\n    assertEquals(expected, actual);\n}"}], [{"methodBefore": "@Test\npublic void eitherPasses() {\n    assertThat(3, either(is(3)).or(is(4)));\n}", "methodAfter": "@Test\npublic void eitherPasses() {\n    assertThat(3, either(is(3)).or(matches(is(4))));\n}"}, {"methodBefore": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(is(Integer.class)).and(is(3)));\n}", "methodAfter": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(is(Integer.class)).and(matches(is(3))));\n}"}, {"methodBefore": "@Test\npublic void eitherPasses() {\n    assertThat(3, either(is(3)).or(is(4)));\n}", "methodAfter": "@Test\npublic void eitherPasses() {\n    assertThat(3, either(is(3)).or(matches(is(4))));\n}"}, {"methodBefore": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(is(Integer.class)).and(is(3)));\n}", "methodAfter": "@Test\npublic void subclassesAreOkInSecondPositionOnly() {\n    assertThat(3, both(is(Integer.class)).and(matches(is(3))));\n}"}], [{"methodBefore": "@AfterClass\npublic static void setUpClass() {\n    fail(OUR_FAILURE_MSG);\n}", "methodAfter": "@AfterClass\npublic static void afterClass() {\n    fail(OUR_FAILURE_MSG);\n}"}, {"methodBefore": "@BeforeClass\npublic static void setUpClass() {\n    fail(OUR_FAILURE_MSG);\n}", "methodAfter": "@BeforeClass\npublic static void beforeClass() {\n    fail(OUR_FAILURE_MSG);\n}"}], [{"methodBefore": "public Description childlessCopy() {\n    return new Description(fDisplayName, fClazz, fAnnotations);\n}", "methodAfter": "public Description childlessCopy() {\n    return new Description(fTestClass, fDisplayName, fAnnotations);\n}"}, {"methodBefore": "public Description childlessCopy() {\n    return new Description(fDisplayName, fAnnotations);\n}", "methodAfter": "public Description childlessCopy() {\n    return new Description(fDisplayName, fClazz, fAnnotations);\n}"}], [{"methodBefore": "public InitializationError(Throwable error) {\n    this(Arrays.asList(error));\n}", "methodAfter": "public InitializationError(Throwable error) {\n    fErrors = Arrays.asList(error);\n}"}, {"methodBefore": "public InitializationError(Throwable error) {\n    fErrors = Arrays.asList(error);\n}", "methodAfter": "public InitializationError(Throwable error) {\n    this(Arrays.asList(error));\n}"}], [{"methodBefore": "public void endTest(Test test) {\n    notifier.fireTestFinished(asDescription(test));\n}", "methodAfter": "public void endTest(Test test) {\n    fNotifier.fireTestFinished(asDescription(test));\n}"}, {"methodBefore": "public void startTest(Test test) {\n    notifier.fireTestStarted(asDescription(test));\n}", "methodAfter": "public void startTest(Test test) {\n    fNotifier.fireTestStarted(asDescription(test));\n}"}], [{"methodBefore": "private static String getPreference(String key) {\n    return fPreferences.getProperty(key);\n}", "methodAfter": "public static String getPreference(String key) {\n    return fPreferences.getProperty(key);\n}"}, {"methodBefore": "private static int getPreference(String key, int dflt) {\n    String value = getPreference(key);\n    int intValue = dflt;\n    if (value == null) {\n        return intValue;\n    }\n    try {\n        intValue = Integer.parseInt(value);\n    } catch (NumberFormatException ne) {\n    }\n    return intValue;\n}", "methodAfter": "public static int getPreference(String key, int dflt) {\n    String value = getPreference(key);\n    int intValue = dflt;\n    if (value == null) {\n        return intValue;\n    }\n    try {\n        intValue = Integer.parseInt(value);\n    } catch (NumberFormatException ne) {\n    }\n    return intValue;\n}"}], [{"methodBefore": "private static String exceptionToString(Throwable t) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    t.printStackTrace(writer);\n    return stringWriter.toString();\n}", "methodAfter": "private static String exceptionToString(Throwable e) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    e.printStackTrace(writer);\n    return stringWriter.toString();\n}"}, {"methodBefore": "public static String getFilteredTrace(Throwable t) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    t.printStackTrace(writer);\n    String trace = stringWriter.toString();\n    return BaseTestRunner.getFilteredTrace(trace);\n}", "methodAfter": "public static String getFilteredTrace(Throwable e) {\n    StringWriter stringWriter = new StringWriter();\n    PrintWriter writer = new PrintWriter(stringWriter);\n    e.printStackTrace(writer);\n    String trace = stringWriter.toString();\n    return BaseTestRunner.getFilteredTrace(trace);\n}"}], [{"methodBefore": "public void addListener(RunListener listener) {\n    fNotifier.addListener(listener);\n}", "methodAfter": "public void addListener(RunListener listener) {\n    notifier.addListener(listener);\n}"}, {"methodBefore": "public void removeListener(RunListener listener) {\n    fNotifier.removeListener(listener);\n}", "methodAfter": "public void removeListener(RunListener listener) {\n    notifier.removeListener(listener);\n}"}], [{"methodBefore": "protected boolean isExcluded(String name) {\n    for (int i = 0; i < fExcluded.size(); i++) {\n        if (name.startsWith(((String) (fExcluded.elementAt(i))))) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "public boolean isExcluded(String name) {\n    for (int i = 0; i < fExcluded.size(); i++) {\n        if (name.startsWith(((String) (fExcluded.elementAt(i))))) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "protected void setLoading(boolean enable) {\n    fLoading = enable;\n}", "methodAfter": "public void setLoading(boolean enable) {\n    fLoading = enable;\n}"}], [{"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedSingleMethodDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single method value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedSingleMethodDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single method value\"));\n}"}, {"methodBefore": "@Test\npublic void shouldReturnNothingIfTheNamedDataPointsAreMissing() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingWrongNamedString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(0, assignedStrings.size());\n}", "methodAfter": "@Test\npublic void shouldReturnNothingIfTheNamedDataPointsAreMissing() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingWrongNamedString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(0, assignedStrings.size());\n}"}, {"methodBefore": "@Test\npublic void shouldPickUpDataPointsFromParameterSupplier() throws Exception {\n    List<PotentialAssignment> assignments = potentialAssignments(WithParameterSupplier.TestClassUsingParameterSupplier.class.getMethod(\"theoryMethod\", String.class));\n    assertEquals(2, assignments.size());\n    assertEquals(DATAPOINTS.get(0), assignments.get(0).getValue());\n    assertEquals(DATAPOINTS.get(1), assignments.get(1).getValue());\n}", "methodAfter": "@Test\npublic void shouldPickUpDataPointsFromParameterSupplier() throws Throwable {\n    List<PotentialAssignment> assignments = potentialAssignments(WithParameterSupplier.TestClassUsingParameterSupplier.class.getMethod(\"theoryMethod\", String.class));\n    assertEquals(2, assignments.size());\n    assertEquals(DATAPOINTS.get(0), assignments.get(0).getValue());\n    assertEquals(DATAPOINTS.get(1), assignments.get(1).getValue());\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedFieldDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named field\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedFieldDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named field\"));\n}"}, {"methodBefore": "@Test\npublic void onlyUseSpecificDataPointsIfSpecified() throws Exception {\n    List<PotentialAssignment> assignments = potentialAssignments(WithNamedDataPoints.HasSpecificDatapointsParameters.class.getMethod(\"theory\", String.class));\n    assertEquals(5, assignments.size());\n    for (PotentialAssignment assignment : assignments) {\n        assertThat(((String) (assignment.getValue())), containsString(\"expected\"));\n    }\n}", "methodAfter": "@Test\npublic void onlyUseSpecificDataPointsIfSpecified() throws Throwable {\n    List<PotentialAssignment> assignments = potentialAssignments(WithNamedDataPoints.HasSpecificDatapointsParameters.class.getMethod(\"theory\", String.class));\n    assertEquals(5, assignments.size());\n    for (PotentialAssignment assignment : assignments) {\n        assertThat(((String) (assignment.getValue())), containsString(\"expected\"));\n    }\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedSingleFieldDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedSingleFieldDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single value\"));\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedMethodDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named method\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedMethodDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named method\"));\n}"}, {"methodBefore": "@Test\npublic void ignoreDataPointMethodsWithWrongTypes() throws Exception {\n    assertThat(potentialAssignments(WithDataPointMethod.HasDateMethod.class.getMethod(\"onlyStringsOk\", String.class)).toString(), not(containsString(\"100\")));\n}", "methodAfter": "@Test\npublic void ignoreDataPointMethodsWithWrongTypes() throws Throwable {\n    assertThat(potentialAssignments(WithDataPointMethod.HasDateMethod.class.getMethod(\"onlyStringsOk\", String.class)).toString(), not(containsString(\"100\")));\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingAllNamedStrings\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(4, assignedStrings.size());\n    assertThat(assignedStrings, hasItems(\"named field\", \"named method\", \"named single value\", \"named single method value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingAllNamedStrings\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(4, assignedStrings.size());\n    assertThat(assignedStrings, hasItems(\"named field\", \"named method\", \"named single value\", \"named single method value\"));\n}"}], [{"methodBefore": "private GuesserQueue createGuesserQueue(Assignments incomplete) throws ReflectiveOperationException {\n    ParameterSignature nextUnassigned = incomplete.nextUnassigned();\n    if (nextUnassigned.hasAnnotation(Stub.class)) {\n        GuesserQueue queue = new GuesserQueue();\n        queue.add(new Guesser<Object>(nextUnassigned.getType()));\n        return queue;\n    }\n    return GuesserQueue.forSingleValues(incomplete.potentialsForNextUnassigned());\n}", "methodAfter": "private GuesserQueue createGuesserQueue(Assignments incomplete) throws Exception {\n    ParameterSignature nextUnassigned = incomplete.nextUnassigned();\n    if (nextUnassigned.hasAnnotation(Stub.class)) {\n        GuesserQueue queue = new GuesserQueue();\n        queue.add(new Guesser<Object>(nextUnassigned.getType()));\n        return queue;\n    }\n    return GuesserQueue.forSingleValues(incomplete.potentialsForNextUnassigned());\n}"}, {"methodBefore": "private ParameterSupplier getSupplier(ParameterSignature unassigned) throws ReflectiveOperationException {\n    ParametersSuppliedBy annotation = unassigned.findDeepAnnotation(ParametersSuppliedBy.class);\n    if (annotation != null) {\n        return buildParameterSupplierFromClass(annotation.value());\n    } else {\n        return new AllMembersSupplier(fClass);\n    }\n}", "methodAfter": "private ParameterSupplier getSupplier(ParameterSignature unassigned) throws Exception {\n    ParametersSuppliedBy annotation = unassigned.findDeepAnnotation(ParametersSuppliedBy.class);\n    if (annotation != null) {\n        return buildParameterSupplierFromClass(annotation.value());\n    } else {\n        return new AllMembersSupplier(fClass);\n    }\n}"}, {"methodBefore": "public List<PotentialAssignment> potentialsForNextUnassigned() throws ReflectiveOperationException {\n    ParameterSignature unassigned = nextUnassigned();\n    return getSupplier(unassigned).getValueSources(unassigned);\n}", "methodAfter": "public List<PotentialAssignment> potentialsForNextUnassigned() throws Exception {\n    ParameterSignature unassigned = nextUnassigned();\n    return getSupplier(unassigned).getValueSources(unassigned);\n}"}], [{"methodBefore": "private void stopping() {\n    endNanos = currentNanoTime();\n}", "methodAfter": "private void stopping() {\n    endNanos = clock.nanoTime();\n}"}, {"methodBefore": "public long runtime(TimeUnit unit) {\n    return unit.convert(currentNanoTime() - startNanos, TimeUnit.NANOSECONDS);\n}", "methodAfter": "public long runtime(TimeUnit unit) {\n    return unit.convert(clock.nanoTime() - startNanos, TimeUnit.NANOSECONDS);\n}"}], [{"methodBefore": "@Before\npublic void before() {\n    watchedLog += \"before \";\n}", "methodAfter": "@Before\npublic void before() {\n    watchedLog.append(\"before \");\n}"}, {"methodBefore": "@After\npublic void after() {\n    watchedLog += \"after \";\n}", "methodAfter": "@After\npublic void after() {\n    watchedLog.append(\"after \");\n}"}], [{"methodBefore": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}, {"methodBefore": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}", "methodAfter": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            starting(description);\n            try {\n                base.evaluate();\n                succeeded(description);\n            } catch (Throwable t) {\n                failed(t, description);\n                throw t;\n            } finally {\n                finished(description);\n            }\n        }\n    };\n}"}], [{"methodBefore": "public static void savePreferences() throws IOException {\n    FileOutputStream fos = new FileOutputStream(getPreferencesFile());\n    try {\n        getPreferences().save(fos, \"\");\n    } finally {\n        fos.close();\n    }\n}", "methodAfter": "public static void savePreferences() throws IOException {\n    FileOutputStream fos = new FileOutputStream(getPreferencesFile());\n    try {\n        getPreferences().store(fos, \"\");\n    } finally {\n        fos.close();\n    }\n}"}, {"methodBefore": "public static void savePreferences() throws IOException {\n    FileOutputStream fos = new FileOutputStream(getPreferencesFile());\n    try {\n        getPreferences().store(fos, \"\");\n    } finally {\n        fos.close();\n    }\n}", "methodAfter": "public static void savePreferences() throws IOException {\n    FileOutputStream fos = new FileOutputStream(getPreferencesFile());\n    try {\n        getPreferences().save(fos, \"\");\n    } finally {\n        fos.close();\n    }\n}"}], [{"methodBefore": "protected JCheckBox createUseLoaderCheckBox() {\n    boolean useLoader = useReloadingTestSuiteLoader();\n    JCheckBox box = new JCheckBox(\"Reload classes every run\", useLoader);\n    box.setToolTipText(\"Use a custom class loader to reload the classes for every run\");\n    return box;\n}", "methodAfter": "protected JCheckBox createUseLoaderCheckBox() {\n    boolean useLoader = useReloadingTestSuiteLoader();\n    JCheckBox box = new JCheckBox(\"Reload classes every run\", useLoader);\n    box.setToolTipText(\"Use a custom class loader to reload the classes for every run\");\n    if (inVAJava()) {\n        box.setVisible(false);\n    }\n    return box;\n}"}, {"methodBefore": "protected Frame createUI(String suiteName) {\n    Frame frame = new Frame(\"JUnit\");\n    Image icon = loadFrameIcon();\n    if (icon != null) {\n        frame.setIconImage(icon);\n    }\n    frame.setLayout(new BorderLayout(0, 0));\n    frame.setBackground(SystemColor.control);\n    final Frame finalFrame = frame;\n    frame.addWindowListener(new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n            finalFrame.dispose();\n            System.exit(0);\n        }\n    });\n    MenuBar mb = new MenuBar();\n    createMenus(mb);\n    frame.setMenuBar(mb);\n    Label suiteLabel = new Label(\"Test class name:\");\n    fSuiteField = new TextField(suiteName != null ? suiteName : \"\");\n    fSuiteField.selectAll();\n    fSuiteField.requestFocus();\n    fSuiteField.setFont(PLAIN_FONT);\n    fSuiteField.setColumns(40);\n    fSuiteField.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    fSuiteField.addTextListener(new TextListener() {\n        public void textValueChanged(TextEvent e) {\n            fRun.setEnabled(fSuiteField.getText().length() > 0);\n            fStatusLine.setText(\"\");\n        }\n    });\n    fRun = new Button(\"Run\");\n    fRun.setEnabled(false);\n    fRun.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    boolean useLoader = useReloadingTestSuiteLoader();\n    fUseLoadingRunner = new Checkbox(\"Reload classes every run\", useLoader);\n    fProgressIndicator = new ProgressBar();\n    fNumberOfErrors = new Label(\"0000\", Label.RIGHT);\n    fNumberOfErrors.setText(\"0\");\n    fNumberOfErrors.setFont(PLAIN_FONT);\n    fNumberOfFailures = new Label(\"0000\", Label.RIGHT);\n    fNumberOfFailures.setText(\"0\");\n    fNumberOfFailures.setFont(PLAIN_FONT);\n    fNumberOfRuns = new Label(\"0000\", Label.RIGHT);\n    fNumberOfRuns.setText(\"0\");\n    fNumberOfRuns.setFont(PLAIN_FONT);\n    Panel numbersPanel = new Panel(new FlowLayout());\n    numbersPanel.add(new Label(\"Runs:\"));\n    numbersPanel.add(fNumberOfRuns);\n    numbersPanel.add(new Label(\"   Errors:\"));\n    numbersPanel.add(fNumberOfErrors);\n    numbersPanel.add(new Label(\"   Failures:\"));\n    numbersPanel.add(fNumberOfFailures);\n    Label failureLabel = new Label(\"Errors and Failures:\");\n    fFailureList = new List(5);\n    fFailureList.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n            failureSelected();\n        }\n    });\n    fRerunButton = new Button(\"Run\");\n    fRerunButton.setEnabled(false);\n    fRerunButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            rerun();\n        }\n    });\n    Panel failedPanel = new Panel(new GridLayout(0, 1, 0, 2));\n    failedPanel.add(fRerunButton);\n    fTraceArea = new TextArea();\n    fTraceArea.setRows(5);\n    fTraceArea.setColumns(60);\n    fStatusLine = new TextField();\n    fStatusLine.setFont(PLAIN_FONT);\n    fStatusLine.setEditable(false);\n    fStatusLine.setForeground(Color.red);\n    fQuitButton = new Button(\"Exit\");\n    fQuitButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    fLogo = new Logo();\n    Panel panel = new Panel(new GridBagLayout());\n    addGrid(panel, suiteLabel, 0, 0, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fSuiteField, 0, 1, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fRun, 2, 1, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fLogo, 2, 3, 1, GridBagConstraints.NONE, 0.0, GridBagConstraints.NORTH);\n    addGrid(panel, numbersPanel, 0, 4, 2, GridBagConstraints.NONE, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, failureLabel, 0, 5, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fFailureList, 0, 6, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, failedPanel, 2, 6, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fTraceArea, 0, 7, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fStatusLine, 0, 8, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.CENTER);\n    addGrid(panel, fQuitButton, 2, 8, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    frame.add(panel, BorderLayout.CENTER);\n    frame.pack();\n    return frame;\n}", "methodAfter": "protected Frame createUI(String suiteName) {\n    Frame frame = new Frame(\"JUnit\");\n    Image icon = loadFrameIcon();\n    if (icon != null) {\n        frame.setIconImage(icon);\n    }\n    frame.setLayout(new BorderLayout(0, 0));\n    frame.setBackground(SystemColor.control);\n    final Frame finalFrame = frame;\n    frame.addWindowListener(new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n            finalFrame.dispose();\n            System.exit(0);\n        }\n    });\n    MenuBar mb = new MenuBar();\n    createMenus(mb);\n    frame.setMenuBar(mb);\n    Label suiteLabel = new Label(\"Test class name:\");\n    fSuiteField = new TextField(suiteName != null ? suiteName : \"\");\n    fSuiteField.selectAll();\n    fSuiteField.requestFocus();\n    fSuiteField.setFont(PLAIN_FONT);\n    fSuiteField.setColumns(40);\n    fSuiteField.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    fSuiteField.addTextListener(new TextListener() {\n        public void textValueChanged(TextEvent e) {\n            fRun.setEnabled(fSuiteField.getText().length() > 0);\n            fStatusLine.setText(\"\");\n        }\n    });\n    fRun = new Button(\"Run\");\n    fRun.setEnabled(false);\n    fRun.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            runSuite();\n        }\n    });\n    boolean useLoader = useReloadingTestSuiteLoader();\n    fUseLoadingRunner = new Checkbox(\"Reload classes every run\", useLoader);\n    if (inVAJava()) {\n        fUseLoadingRunner.setVisible(false);\n    }\n    fProgressIndicator = new ProgressBar();\n    fNumberOfErrors = new Label(\"0000\", Label.RIGHT);\n    fNumberOfErrors.setText(\"0\");\n    fNumberOfErrors.setFont(PLAIN_FONT);\n    fNumberOfFailures = new Label(\"0000\", Label.RIGHT);\n    fNumberOfFailures.setText(\"0\");\n    fNumberOfFailures.setFont(PLAIN_FONT);\n    fNumberOfRuns = new Label(\"0000\", Label.RIGHT);\n    fNumberOfRuns.setText(\"0\");\n    fNumberOfRuns.setFont(PLAIN_FONT);\n    Panel numbersPanel = new Panel(new FlowLayout());\n    numbersPanel.add(new Label(\"Runs:\"));\n    numbersPanel.add(fNumberOfRuns);\n    numbersPanel.add(new Label(\"   Errors:\"));\n    numbersPanel.add(fNumberOfErrors);\n    numbersPanel.add(new Label(\"   Failures:\"));\n    numbersPanel.add(fNumberOfFailures);\n    Label failureLabel = new Label(\"Errors and Failures:\");\n    fFailureList = new List(5);\n    fFailureList.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n            failureSelected();\n        }\n    });\n    fRerunButton = new Button(\"Run\");\n    fRerunButton.setEnabled(false);\n    fRerunButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            rerun();\n        }\n    });\n    Panel failedPanel = new Panel(new GridLayout(0, 1, 0, 2));\n    failedPanel.add(fRerunButton);\n    fTraceArea = new TextArea();\n    fTraceArea.setRows(5);\n    fTraceArea.setColumns(60);\n    fStatusLine = new TextField();\n    fStatusLine.setFont(PLAIN_FONT);\n    fStatusLine.setEditable(false);\n    fStatusLine.setForeground(Color.red);\n    fQuitButton = new Button(\"Exit\");\n    fQuitButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    fLogo = new Logo();\n    Panel panel = new Panel(new GridBagLayout());\n    addGrid(panel, suiteLabel, 0, 0, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fSuiteField, 0, 1, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fRun, 2, 1, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fLogo, 2, 3, 1, GridBagConstraints.NONE, 0.0, GridBagConstraints.NORTH);\n    addGrid(panel, numbersPanel, 0, 4, 2, GridBagConstraints.NONE, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, failureLabel, 0, 5, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fFailureList, 0, 6, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, failedPanel, 2, 6, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    addGrid(panel, fTraceArea, 0, 7, 2, GridBagConstraints.BOTH, 1.0, GridBagConstraints.WEST);\n    addGrid(panel, fStatusLine, 0, 8, 2, GridBagConstraints.HORIZONTAL, 1.0, GridBagConstraints.CENTER);\n    addGrid(panel, fQuitButton, 2, 8, 1, GridBagConstraints.HORIZONTAL, 0.0, GridBagConstraints.CENTER);\n    frame.add(panel, BorderLayout.CENTER);\n    frame.pack();\n    return frame;\n}"}], [{"methodBefore": "public static void assertNotSame(Object expected, Object actual) {\n    assertNotSame(null, expected, actual);\n}", "methodAfter": "public static void assertNotSame(Object unexpected, Object actual) {\n    assertNotSame(null, unexpected, actual);\n}"}, {"methodBefore": "public static void assertNotSame(String message, Object expected, Object actual) {\n    if (expected == actual) {\n        failSame(message);\n    }\n}", "methodAfter": "public static void assertNotSame(String message, Object unexpected, Object actual) {\n    if (unexpected == actual) {\n        failSame(message);\n    }\n}"}], [{"methodBefore": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), testClass.getAnnotations());\n}", "methodAfter": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), testClass, testClass.getAnnotations());\n}"}, {"methodBefore": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), testClass.getAnnotations());\n}", "methodAfter": "public static Description createSuiteDescription(Class<?> testClass) {\n    return new Description(testClass.getName(), null, testClass.getAnnotations());\n}"}], [{"methodBefore": "public void setTest(Test test) {\n    fTest = test;\n}", "methodAfter": "private void setTest(Test test) {\n    fTest = test;\n}"}, {"methodBefore": "public PrintableResult(Result result) {\n    this.result = result;\n}", "methodAfter": "private PrintableResult(Result result) {\n    this.result = result;\n}"}], [{"methodBefore": "public void removeListener(RunListener listener) {\n    fNotifier.removeListener(listener);\n}", "methodAfter": "public void removeListener(RunListener listener) {\n    notifier.removeListener(listener);\n}"}, {"methodBefore": "public void addListener(RunListener listener) {\n    fNotifier.addListener(listener);\n}", "methodAfter": "public void addListener(RunListener listener) {\n    notifier.addListener(listener);\n}"}], [{"methodBefore": "public AllMembersSupplier(TestClass type) {\n    fClass = type;\n}", "methodAfter": "public AllMembersSupplier(TestClass type) {\n    clazz = type;\n}"}, {"methodBefore": "public IgnoredClassRunner(Class<?> testClass) {\n    fTestClass = testClass;\n}", "methodAfter": "public IgnoredClassRunner(Class<?> testClass) {\n    clazz = testClass;\n}"}], [{"methodBefore": "public static Request aClass(Class<?> clazz) {\n    return new ClassRequest(clazz);\n}", "methodAfter": "public static Request aClass(Class<?> clazz) {\n    return new ClassRequest(clazz, newSuiteBuilder());\n}"}, {"methodBefore": "public static Request aClass(Class<?> clazz) {\n    return new ClassRequest(clazz, newSuiteBuilder());\n}", "methodAfter": "public static Request aClass(Class<?> clazz) {\n    return new ClassRequest(clazz);\n}"}], [{"methodBefore": "@Test\npublic void memberClassDeepInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class)))));\n}", "methodAfter": "@Test\npublic void memberClassDeepInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class))));\n}"}, {"methodBefore": "@Test\npublic void memberClassDeepInsideAnnotatedMemberClass_isRunWithParentMemberClassRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class)))));\n}", "methodAfter": "@Test\npublic void memberClassDeepInsideAnnotatedMemberClass_isRunWithParentMemberClassRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class))));\n}"}], [{"methodBefore": "protected Statement withAfters(FrameworkMethod method, Object target, Statement link) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return new RunAfters(link, afters, target);\n}", "methodAfter": "protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);\n    return new RunAfters(statement, afters, target);\n}"}, {"methodBefore": "protected Statement withBefores(FrameworkMethod method, Object target, Statement link) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return new RunBefores(link, befores, target);\n}", "methodAfter": "protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);\n    return new RunBefores(statement, befores, target);\n}"}], [{"methodBefore": "@Override\npublic int hashCode() {\n    int prime = 14747;\n    int result = prime + fName.hashCode();\n    result = (prime * result) + fTestClass.hashCode();\n    return (prime * result) + fParameters.hashCode();\n}", "methodAfter": "@Override\npublic int hashCode() {\n    int prime = 14747;\n    int result = prime + name.hashCode();\n    result = (prime * result) + testClass.hashCode();\n    return (prime * result) + parameters.hashCode();\n}"}, {"methodBefore": "@Override\npublic String toString() {\n    return (((fTestClass.getName() + \" '\") + fName) + \"' with parameters \") + fParameters;\n}", "methodAfter": "@Override\npublic String toString() {\n    return (((testClass.getName() + \" '\") + name) + \"' with parameters \") + parameters;\n}"}], [{"methodBefore": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    return getAnnotatedMembers(fMethodsForAnnotations, annotationClass);\n}", "methodAfter": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    return Collections.unmodifiableList(getAnnotatedMembers(fMethodsForAnnotations, annotationClass, false));\n}"}, {"methodBefore": "public List<FrameworkField> getAnnotatedFields(Class<? extends Annotation> annotationClass) {\n    return getAnnotatedMembers(fFieldsForAnnotations, annotationClass);\n}", "methodAfter": "public List<FrameworkField> getAnnotatedFields(Class<? extends Annotation> annotationClass) {\n    return Collections.unmodifiableList(getAnnotatedMembers(fFieldsForAnnotations, annotationClass, false));\n}"}], [{"methodBefore": "public synchronized Enumeration errors() {\n    return fErrors.elements();\n}", "methodAfter": "public synchronized Enumeration<TestFailure> errors() {\n    return Collections.enumeration(fErrors);\n}"}, {"methodBefore": "public synchronized Enumeration failures() {\n    return fFailures.elements();\n}", "methodAfter": "public synchronized Enumeration<TestFailure> failures() {\n    return Collections.enumeration(fFailures);\n}"}], [{"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}], [{"methodBefore": "@Override\nprotected void describeMismatchSafely(T item, Description description) {\n    fThrowableMatcher.describeMismatch(item, description);\n    description.appendText(\"\\nStacktrace was: \");\n    description.appendText(readStacktrace(item));\n}", "methodAfter": "@Override\nprotected void describeMismatchSafely(T item, Description description) {\n    throwableMatcher.describeMismatch(item, description);\n    description.appendText(\"\\nStacktrace was: \");\n    description.appendText(readStacktrace(item));\n}"}, {"methodBefore": "public void describeTo(Description description) {\n    fThrowableMatcher.describeTo(description);\n}", "methodAfter": "public void describeTo(Description description) {\n    throwableMatcher.describeTo(description);\n}"}], [{"methodBefore": "List<Method> getBefores() {\n    return getAnnotatedMethods(BeforeClass.class);\n}", "methodAfter": "@Override\nprotected List<Method> getBefores() {\n    return getAnnotatedMethods(BeforeClass.class);\n}"}, {"methodBefore": "List<Method> getAfters() {\n    return getAnnotatedMethods(AfterClass.class);\n}", "methodAfter": "@Override\nprotected List<Method> getAfters() {\n    return getAnnotatedMethods(AfterClass.class);\n}"}], [{"methodBefore": "@Test\npublic void dataPointsArrayFieldMayContainNullValue() throws SecurityException, NoSuchMethodException {\n    List<PotentialAssignment> valueSources = new AllMembersSupplier(new TestClass(AllMembersSupplierTest.HasDataPointsFieldWithNullValue.class)).getValueSources(ParameterSignature.signatures(AllMembersSupplierTest.HasDataPointsFieldWithNullValue.class.getConstructor(Object.class)).get(0));\n    assertThat(valueSources.size(), is(2));\n}", "methodAfter": "@Test\npublic void dataPointsArrayFieldMayContainNullValue() throws Throwable {\n    List<PotentialAssignment> valueSources = allMemberValuesFor(AllMembersSupplierTest.HasDataPointsFieldWithNullValue.class, Object.class);\n    assertThat(valueSources.size(), is(2));\n}"}, {"methodBefore": "@Test\npublic void dataPointsAnnotationMeansTreatAsArrayOnly() throws SecurityException, NoSuchMethodException {\n    List<PotentialAssignment> valueSources = new AllMembersSupplier(new TestClass(AllMembersSupplierTest.HasDataPoints.class)).getValueSources(ParameterSignature.signatures(AllMembersSupplierTest.HasDataPoints.class.getConstructor(Object.class)).get(0));\n    assertThat(valueSources.size(), is(2));\n}", "methodAfter": "@Test\npublic void dataPointsAnnotationMeansTreatAsArrayOnly() throws Throwable {\n    List<PotentialAssignment> valueSources = allMemberValuesFor(AllMembersSupplierTest.HasDataPoints.class, Object.class);\n    assertThat(valueSources.size(), is(2));\n}"}], [{"methodBefore": "private JTextField createOutputField(int width) {\n    JTextField field = new JTextField(\"0\", width);\n    field.setMinimumSize(field.getPreferredSize());\n    field.setMaximumSize(field.getPreferredSize());\n    field.setHorizontalAlignment(JTextField.LEFT);\n    field.setFont(BOLD_FONT);\n    field.setEditable(false);\n    field.setBorder(BorderFactory.createEmptyBorder());\n    return field;\n}", "methodAfter": "private JTextField createOutputField(int width) {\n    JTextField field = new JTextField(\"0\", width);\n    field.setMinimumSize(field.getPreferredSize());\n    field.setMaximumSize(field.getPreferredSize());\n    field.setHorizontalAlignment(SwingConstants.LEFT);\n    field.setFont(BOLD_FONT);\n    field.setEditable(false);\n    field.setBorder(BorderFactory.createEmptyBorder());\n    return field;\n}"}, {"methodBefore": "protected JTabbedPane createTestRunViews() {\n    JTabbedPane pane = new JTabbedPane(JTabbedPane.BOTTOM);\n    FailureRunView lv = new FailureRunView(this);\n    fTestRunViews.addElement(lv);\n    lv.addTab(pane);\n    TestHierarchyRunView tv = new TestHierarchyRunView(this);\n    fTestRunViews.addElement(tv);\n    tv.addTab(pane);\n    pane.addChangeListener(new ChangeListener() {\n        public void stateChanged(ChangeEvent e) {\n            testViewChanged();\n        }\n    });\n    return pane;\n}", "methodAfter": "protected JTabbedPane createTestRunViews() {\n    JTabbedPane pane = new JTabbedPane(SwingConstants.BOTTOM);\n    FailureRunView lv = new FailureRunView(this);\n    fTestRunViews.addElement(lv);\n    lv.addTab(pane);\n    TestHierarchyRunView tv = new TestHierarchyRunView(this);\n    fTestRunViews.addElement(tv);\n    tv.addTab(pane);\n    pane.addChangeListener(new ChangeListener() {\n        public void stateChanged(ChangeEvent e) {\n            testViewChanged();\n        }\n    });\n    return pane;\n}"}], [{"methodBefore": "private Statement possiblyExpectingExceptions(TestAnnotation annotation, Statement next) {\n    return annotation.expectsException() ? new ExpectException(next, annotation.getExpectedException()) : next;\n}", "methodAfter": "protected Statement possiblyExpectingExceptions(TestAnnotation annotation, Statement next) {\n    return annotation.expectsException() ? new ExpectException(next, annotation.getExpectedException()) : next;\n}"}, {"methodBefore": "private List<T> getFilteredChildren() {\n    ArrayList<T> filtered = new ArrayList<T>();\n    for (T each : getChildren()) {\n        if (shouldRun(each)) {\n            try {\n                filterChild(each);\n                sortChild(each);\n                filtered.add(each);\n            } catch (NoTestsRemainException e) {\n            }\n        }\n    }\n    Collections.sort(filtered, comparator());\n    return filtered;\n}", "methodAfter": "protected List<T> getFilteredChildren() {\n    ArrayList<T> filtered = new ArrayList<T>();\n    for (T each : getChildren()) {\n        if (shouldRun(each)) {\n            try {\n                filterChild(each);\n                sortChild(each);\n                filtered.add(each);\n            } catch (NoTestsRemainException e) {\n            }\n        }\n    }\n    Collections.sort(filtered, comparator());\n    return filtered;\n}"}, {"methodBefore": "public Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}, {"methodBefore": "public MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}", "methodAfter": "private MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}"}, {"methodBefore": "protected void validate() throws InitializationError {\n    List<Throwable> errors = new ArrayList<Throwable>();\n    collectInitializationErrors(errors);\n    if (!errors.isEmpty()) {\n        throw new InitializationError(errors);\n    }\n}", "methodAfter": "private void validate() throws InitializationError {\n    List<Throwable> errors = new ArrayList<Throwable>();\n    collectInitializationErrors(errors);\n    if (!errors.isEmpty()) {\n        throw new InitializationError(errors);\n    }\n}"}, {"methodBefore": "private void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}", "methodAfter": "protected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "protected PrintStream getWriter() {\n    return fWriter;\n}", "methodAfter": "public PrintStream getWriter() {\n    return fWriter;\n}"}, {"methodBefore": "private EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}", "methodAfter": "protected EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}"}, {"methodBefore": "private static boolean isArray(Object expected) {\n    return (expected != null) && expected.getClass().isArray();\n}", "methodAfter": "public static boolean isArray(Object expected) {\n    return (expected != null) && expected.getClass().isArray();\n}"}, {"methodBefore": "private void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}", "methodAfter": "protected void validateConstructor(List<Throwable> errors) {\n    validateOnlyOneConstructor(errors);\n    validateZeroArgConstructor(errors);\n}"}, {"methodBefore": "public void failed(Throwable e, Description description) {\n}", "methodAfter": "protected void failed(Throwable e, Description description) {\n}"}, {"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "public PrintableResult(Result result) {\n    this.result = result;\n}", "methodAfter": "private PrintableResult(Result result) {\n    this.result = result;\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "protected EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}", "methodAfter": "private EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}"}, {"methodBefore": "protected final TestClass getTestClass() {\n    return fTestClass;\n}", "methodAfter": "public final TestClass getTestClass() {\n    return fTestClass;\n}"}, {"methodBefore": "public void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "public static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}", "methodAfter": "private static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}"}, {"methodBefore": "private EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}", "methodAfter": "protected EachTestNotifier makeNotifier(FrameworkMethod method, RunNotifier notifier) {\n    Description description = describeChild(method);\n    return new EachTestNotifier(notifier, description);\n}"}, {"methodBefore": "protected Test getTest() {\n    return fTest;\n}", "methodAfter": "public Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "private List<TestRule> getTestRules(Object target) {\n    return getTestClass().getAnnotatedFieldValues(target, Rule.class, TestRule.class);\n}", "methodAfter": "protected List<TestRule> getTestRules(Object target) {\n    return getTestClass().getAnnotatedFieldValues(target, Rule.class, TestRule.class);\n}"}, {"methodBefore": "protected void addFailure(Throwable targetException) {\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}", "methodAfter": "public void addFailure(Throwable targetException) {\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"}, {"methodBefore": "public MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}", "methodAfter": "private MaxHistory(File storedResults) {\n    fFolder = storedResults;\n}"}, {"methodBefore": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "protected Statement childrenInvoker(final RunNotifier notifier) {\n    return new Statement() {\n        @Override\n        public void evaluate() {\n            runChildren(notifier);\n        }\n    };\n}", "methodAfter": "public Statement childrenInvoker(final RunNotifier notifier) {\n    return new Statement() {\n        @Override\n        public void evaluate() {\n            runChildren(notifier);\n        }\n    };\n}"}, {"methodBefore": "protected void validateFields(List<Throwable> errors) {\n    for (FrameworkField each : ruleFields()) {\n        validateRuleField(each.getField(), errors);\n    }\n}", "methodAfter": "private void validateFields(List<Throwable> errors) {\n    for (FrameworkField each : ruleFields()) {\n        validateRuleField(each.getField(), errors);\n    }\n}"}, {"methodBefore": "private Annotation[] classAnnotations() {\n    return fTestClass.getJavaClass().getAnnotations();\n}", "methodAfter": "protected Annotation[] classAnnotations() {\n    return fTestClass.getJavaClass().getAnnotations();\n}"}, {"methodBefore": "private RunnerBuilder suiteMethodBuilder() {\n    if (fCanUseSuiteMethod) {\n        return new SuiteMethodBuilder();\n    }\n    return new NullBuilder();\n}", "methodAfter": "protected RunnerBuilder suiteMethodBuilder() {\n    if (fCanUseSuiteMethod) {\n        return new SuiteMethodBuilder();\n    }\n    return new NullBuilder();\n}"}, {"methodBefore": "public void starting(Description description) {\n}", "methodAfter": "protected void starting(Description description) {\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "public Test getTest() {\n    return fTest;\n}", "methodAfter": "private Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "protected Object createTest() throws Exception {\n    return fTestClass.getConstructor().newInstance();\n}", "methodAfter": "public Object createTest() throws Exception {\n    return fTestClass.getConstructor().newInstance();\n}"}, {"methodBefore": "private void validateOnlyOneConstructor(List<Throwable> errors) {\n    if (!hasOneConstructor()) {\n        String gripe = \"Test class should have exactly one public constructor\";\n        errors.add(new Exception(gripe));\n    }\n}", "methodAfter": "protected void validateOnlyOneConstructor(List<Throwable> errors) {\n    if (!hasOneConstructor()) {\n        String gripe = \"Test class should have exactly one public constructor\";\n        errors.add(new Exception(gripe));\n    }\n}"}, {"methodBefore": "private static void failNotEquals(String message, Object expected, Object actual) {\n    fail(format(message, expected, actual));\n}", "methodAfter": "public static void failNotEquals(String message, Object expected, Object actual) {\n    fail(format(message, expected, actual));\n}"}, {"methodBefore": "@Override\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}", "methodAfter": "@Override\npublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}"}, {"methodBefore": "public void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}", "methodAfter": "private void save() throws IOException {\n    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fFolder));\n    stream.writeObject(this);\n    stream.close();\n}"}, {"methodBefore": "public String compact(String message) {\n    if (((fExpected == null) || (fActual == null)) || areStringsEqual()) {\n        return Assert.format(message, fExpected, fActual);\n    }\n    findCommonPrefix();\n    findCommonSuffix();\n    String expected = compactString(fExpected);\n    String actual = compactString(fActual);\n    return Assert.format(message, expected, actual);\n}", "methodAfter": "private String compact(String message) {\n    if (((fExpected == null) || (fActual == null)) || areStringsEqual()) {\n        return Assert.format(message, fExpected, fActual);\n    }\n    findCommonPrefix();\n    findCommonSuffix();\n    String expected = compactString(fExpected);\n    String actual = compactString(fActual);\n    return Assert.format(message, expected, actual);\n}"}, {"methodBefore": "public Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}", "methodAfter": "private Runner buildRunner(Description each) {\n    if (each.toString().equals(\"TestSuite with 0 tests\")) {\n        try {\n            return new Suite(null, new Class<?>[0]);\n        } catch (InitializationError e) {\n            e.printStackTrace();\n        }\n    }\n    Class<?> type = each.getTestClass();\n    if (type == null) {\n        throw new RuntimeException((\"Can't build a runner from description [\" + each) + \"]\");\n    }\n    String methodName = each.getMethodName();\n    if (methodName == null) {\n        return Request.aClass(type).getRunner();\n    }\n    return Request.method(type, methodName).getRunner();\n}"}, {"methodBefore": "public Test getTest() {\n    return fTest;\n}", "methodAfter": "private Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "@Override\npublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        runIgnored(eachNotifier);\n    } else {\n        runNotIgnored(method, eachNotifier);\n    }\n}", "methodAfter": "@Override\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        runIgnored(eachNotifier);\n    } else {\n        runNotIgnored(method, eachNotifier);\n    }\n}"}, {"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "@Override\nprotected List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}", "methodAfter": "@Override\npublic List<Method> getBefores() {\n    return fTestClass.getAnnotatedMethods(Before.class);\n}"}, {"methodBefore": "public void setTest(Test test) {\n    fTest = test;\n}", "methodAfter": "private void setTest(Test test) {\n    fTest = test;\n}"}, {"methodBefore": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "private static Test warning(final String message) {\n    return new TestCase(\"warning\") {\n        protected void runTest() {\n            fail(message);\n        }\n    };\n}", "methodAfter": "public static Test warning(final String message) {\n    return new TestCase(\"warning\") {\n        protected void runTest() {\n            fail(message);\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected List<Method> getAfters() {\n    return fTestClass.getAnnotatedMethods(After.class);\n}", "methodAfter": "@Override\npublic List<Method> getAfters() {\n    return fTestClass.getAnnotatedMethods(After.class);\n}"}, {"methodBefore": "public Object createTest() throws Exception {\n    return getTestClass().getConstructor().newInstance();\n}", "methodAfter": "protected Object createTest() throws Exception {\n    return getTestClass().getConstructor().newInstance();\n}"}, {"methodBefore": "private CategoryFilter(boolean matchAnyIncludes, Set<Class<?>> includes, boolean matchAnyExcludes, Set<Class<?>> excludes) {\n    fIncludedAny = matchAnyIncludes;\n    fExcludedAny = matchAnyExcludes;\n    fIncluded = copyAndRefine(includes);\n    fExcluded = copyAndRefine(excludes);\n}", "methodAfter": "protected CategoryFilter(boolean matchAnyIncludes, Set<Class<?>> includes, boolean matchAnyExcludes, Set<Class<?>> excludes) {\n    fIncludedAny = matchAnyIncludes;\n    fExcludedAny = matchAnyExcludes;\n    fIncluded = copyAndRefine(includes);\n    fExcluded = copyAndRefine(excludes);\n}"}, {"methodBefore": "private Color getStatusColor() {\n    if (fError) {\n        return Color.red;\n    }\n    return Color.green;\n}", "methodAfter": "protected Color getStatusColor() {\n    if (fError) {\n        return Color.red;\n    }\n    return Color.green;\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "public List<Runner> runners(Class<?>[] children) {\n    ArrayList<Runner> runners = new ArrayList<Runner>();\n    for (Class<?> each : children) {\n        Runner childRunner = safeRunnerForClass(each);\n        if (childRunner != null) {\n            runners.add(childRunner);\n        }\n    }\n    return runners;\n}", "methodAfter": "private List<Runner> runners(Class<?>[] children) {\n    ArrayList<Runner> runners = new ArrayList<Runner>();\n    for (Class<?> each : children) {\n        Runner childRunner = safeRunnerForClass(each);\n        if (childRunner != null) {\n            runners.add(childRunner);\n        }\n    }\n    return runners;\n}"}, {"methodBefore": "public Plan(Description description) {\n    fDescription = description;\n}", "methodAfter": "private Plan(Description description) {\n    fDescription = description;\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "private StacktracePrintingMatcher(Matcher<T> throwableMatcher) {\n    fThrowableMatcher = throwableMatcher;\n}", "methodAfter": "public StacktracePrintingMatcher(Matcher<T> throwableMatcher) {\n    fThrowableMatcher = throwableMatcher;\n}"}, {"methodBefore": "public Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    statement = withRules(method, test, statement);\n    return statement;\n}", "methodAfter": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    statement = withRules(method, test, statement);\n    return statement;\n}"}, {"methodBefore": "private void validateOnlyOneConstructor(List<Throwable> errors) {\n    if (!hasOneConstructor()) {\n        String gripe = \"Test class should have exactly one public constructor\";\n        errors.add(new Exception(gripe));\n    }\n}", "methodAfter": "protected void validateOnlyOneConstructor(List<Throwable> errors) {\n    if (!hasOneConstructor()) {\n        String gripe = \"Test class should have exactly one public constructor\";\n        errors.add(new Exception(gripe));\n    }\n}"}, {"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "public boolean testStarted(final Class<?> testClass) {\n    return startedTests.contains(testClass.getName());\n}", "methodAfter": "private boolean testStarted(final Class<?> testClass) {\n    return startedTests.contains(testClass.getName());\n}"}, {"methodBefore": "private Test getTest() {\n    return fTest;\n}", "methodAfter": "public Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "private static void failNotSame(String message, Object expected, Object actual) {\n    String formatted = \"\";\n    if (message != null) {\n        formatted = message + \" \";\n    }\n    fail(((((formatted + \"expected same:<\") + expected) + \"> was not:<\") + actual) + \">\");\n}", "methodAfter": "public static void failNotSame(String message, Object expected, Object actual) {\n    String formatted = \"\";\n    if (message != null) {\n        formatted = message + \" \";\n    }\n    fail(((((formatted + \"expected same:<\") + expected) + \"> was not:<\") + actual) + \">\");\n}"}, {"methodBefore": "public String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}", "methodAfter": "private String parseMethod() {\n    Matcher matcher = Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n    if (matcher.matches()) {\n        return matcher.group(1);\n    }\n    return null;\n}"}, {"methodBefore": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "private static void failSame(String message) {\n    String formatted = \"\";\n    if (message != null) {\n        formatted = message + \" \";\n    }\n    fail(formatted + \"expected not same\");\n}", "methodAfter": "public static void failSame(String message) {\n    String formatted = \"\";\n    if (message != null) {\n        formatted = message + \" \";\n    }\n    fail(formatted + \"expected not same\");\n}"}, {"methodBefore": "public void finished(Description description) {\n}", "methodAfter": "protected void finished(Description description) {\n}"}, {"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "protected boolean isExcluded(String name) {\n    for (int i = 0; i < fExcluded.size(); i++) {\n        if (name.startsWith(((String) (fExcluded.elementAt(i))))) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "public boolean isExcluded(String name) {\n    for (int i = 0; i < fExcluded.size(); i++) {\n        if (name.startsWith(((String) (fExcluded.elementAt(i))))) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private static int getPreference(String key, int dflt) {\n    String value = getPreference(key);\n    int intValue = dflt;\n    if (value == null) {\n        return intValue;\n    }\n    try {\n        intValue = Integer.parseInt(value);\n    } catch (NumberFormatException ne) {\n    }\n    return intValue;\n}", "methodAfter": "public static int getPreference(String key, int dflt) {\n    String value = getPreference(key);\n    int intValue = dflt;\n    if (value == null) {\n        return intValue;\n    }\n    try {\n        intValue = Integer.parseInt(value);\n    } catch (NumberFormatException ne) {\n    }\n    return intValue;\n}"}, {"methodBefore": "@Override\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}", "methodAfter": "@Override\npublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n    methods.add(method);\n}"}, {"methodBefore": "public boolean isShadowedBy(FrameworkMethod each) {\n    if (!each.getName().equals(getName())) {\n        return false;\n    }\n    if (each.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < each.getParameterTypes().length; i++) {\n        if (!each.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "methodAfter": "private boolean isShadowedBy(FrameworkMethod each) {\n    if (!each.getName().equals(getName())) {\n        return false;\n    }\n    if (each.getParameterTypes().length != getParameterTypes().length) {\n        return false;\n    }\n    for (int i = 0; i < each.getParameterTypes().length; i++) {\n        if (!each.getParameterTypes()[i].equals(getParameterTypes()[i])) {\n            return false;\n        }\n    }\n    return true;\n}"}, {"methodBefore": "private boolean hasSuiteMethod() {\n    try {\n        fTestClass.getMethod(\"suite\");\n    } catch (SecurityException e) {\n        e.printStackTrace();\n    } catch (NoSuchMethodException e) {\n        return false;\n    }\n    return true;\n}", "methodAfter": "public boolean hasSuiteMethod() {\n    try {\n        fTestClass.getMethod(\"suite\");\n    } catch (SecurityException e) {\n        e.printStackTrace();\n    } catch (NoSuchMethodException e) {\n        return false;\n    }\n    return true;\n}"}, {"methodBefore": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    statement = withRules(method, test, statement);\n    return statement;\n}", "methodAfter": "public Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    statement = withRules(method, test, statement);\n    return statement;\n}"}, {"methodBefore": "protected void setLoading(boolean enable) {\n    fLoading = enable;\n}", "methodAfter": "public void setLoading(boolean enable) {\n    fLoading = enable;\n}"}, {"methodBefore": "private static String getPreference(String key) {\n    return fPreferences.getProperty(key);\n}", "methodAfter": "public static String getPreference(String key) {\n    return fPreferences.getProperty(key);\n}"}, {"methodBefore": "private Test getTest() {\n    return fTest;\n}", "methodAfter": "public Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "@Override\npublic void starting(Description d) {\n    fName = d.getMethodName();\n}", "methodAfter": "@Override\nprotected void starting(Description d) {\n    fName = d.getMethodName();\n}"}, {"methodBefore": "public Statement childBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    TestAnnotation annotation = new TestAnnotation(method);\n    Statement link = invoke(method, test);\n    link = possiblyExpectingExceptions(annotation, link);\n    link = withPotentialTimeout(annotation, link);\n    link = withBefores(method, test, link);\n    link = withAfters(method, test, link);\n    return link;\n}", "methodAfter": "protected Statement childBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    TestAnnotation annotation = new TestAnnotation(method);\n    Statement link = invoke(method, test);\n    link = possiblyExpectingExceptions(annotation, link);\n    link = withPotentialTimeout(annotation, link);\n    link = withBefores(method, test, link);\n    link = withAfters(method, test, link);\n    return link;\n}"}, {"methodBefore": "public Test getTest() {\n    return fTest;\n}", "methodAfter": "private Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "public Assignments(List<PotentialAssignment> assigned, List<ParameterSignature> unassigned, TestClass testClass) {\n    fUnassigned = unassigned;\n    fAssigned = assigned;\n    fClass = testClass;\n}", "methodAfter": "private Assignments(List<PotentialAssignment> assigned, List<ParameterSignature> unassigned, TestClass testClass) {\n    fUnassigned = unassigned;\n    fAssigned = assigned;\n    fClass = testClass;\n}"}, {"methodBefore": "protected List<T> getFilteredChildren() {\n    ArrayList<T> filtered = new ArrayList<T>();\n    for (T each : getChildren()) {\n        if (shouldRun(each)) {\n            try {\n                filterChild(each);\n                sortChild(each);\n                filtered.add(each);\n            } catch (NoTestsRemainException e) {\n            }\n        }\n    }\n    Collections.sort(filtered, comparator());\n    return filtered;\n}", "methodAfter": "private List<T> getFilteredChildren() {\n    ArrayList<T> filtered = new ArrayList<T>();\n    for (T each : getChildren()) {\n        if (shouldRun(each)) {\n            try {\n                filterChild(each);\n                sortChild(each);\n                filtered.add(each);\n            } catch (NoTestsRemainException e) {\n            }\n        }\n    }\n    Collections.sort(filtered, comparator());\n    return filtered;\n}"}, {"methodBefore": "protected final TestClass getTestClass() {\n    return fTestClass;\n}", "methodAfter": "public final TestClass getTestClass() {\n    return fTestClass;\n}"}, {"methodBefore": "public Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}", "methodAfter": "private Request constructLeafRequest(List<Description> leaves) {\n    final List<Runner> runners = new ArrayList<Runner>();\n    for (Description each : leaves) {\n        runners.add(buildRunner(each));\n    }\n    return new Request() {\n        @Override\n        public Runner getRunner() {\n            try {\n                return new Suite(((Class<?>) (null)), runners) {};\n            } catch (InitializationError e) {\n                return new ErrorReportingRunner(null, e);\n            }\n        }\n    };\n}"}, {"methodBefore": "public static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}", "methodAfter": "private static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}"}, {"methodBefore": "public void succeeded(Description description) {\n}", "methodAfter": "protected void succeeded(Description description) {\n}"}, {"methodBefore": "private void validateFields(List<Throwable> errors) {\n    RULE_VALIDATOR.validate(getTestClass(), errors);\n}", "methodAfter": "protected void validateFields(List<Throwable> errors) {\n    RULE_VALIDATOR.validate(getTestClass(), errors);\n}"}, {"methodBefore": "public boolean testFinished(final Class<?> testClass) {\n    return finishedTests.contains(testClass.getName());\n}", "methodAfter": "private boolean testFinished(final Class<?> testClass) {\n    return finishedTests.contains(testClass.getName());\n}"}, {"methodBefore": "public String elapsedTimeAsString(long runTime) {\n    return NumberFormat.getInstance().format(((double) (runTime)) / 1000);\n}", "methodAfter": "protected String elapsedTimeAsString(long runTime) {\n    return NumberFormat.getInstance().format(((double) (runTime)) / 1000);\n}"}, {"methodBefore": "public void assertFieldIsPublic(FrameworkField frameworkField) {\n    Field field = frameworkField.getField();\n    int modifiers = field.getModifiers();\n    if (!isPublic(modifiers)) {\n        throw new IllegalArgumentException((((\"The \" + field.getType().getSimpleName()) + \" '\") + field.getName()) + \"' is not public.\");\n    }\n}", "methodAfter": "private void assertFieldIsPublic(FrameworkField frameworkField) {\n    Field field = frameworkField.getField();\n    int modifiers = field.getModifiers();\n    if (!isPublic(modifiers)) {\n        throw new IllegalArgumentException((((\"The \" + field.getType().getSimpleName()) + \" '\") + field.getName()) + \"' is not public.\");\n    }\n}"}, {"methodBefore": "@Override\nprotected Object createTest() throws Exception {\n    return fConstructor.newInstance(fParameters);\n}", "methodAfter": "@Override\npublic Object createTest() throws Exception {\n    return fConstructor.newInstance(fParameters);\n}"}, {"methodBefore": "private Description(final String displayName) {\n    fDisplayName = displayName;\n}", "methodAfter": "protected Description(final String displayName) {\n    fDisplayName = displayName;\n}"}], [{"methodBefore": "public List<Throwable> validateAnnotatedMethod(Method method) {\n    return Collections.emptyList();\n}", "methodAfter": "public List<Exception> validateAnnotatedMethod(Method method) {\n    return NO_VALIDATION_ERRORS;\n}"}, {"methodBefore": "public List<Throwable> validateAnnotatedField(Field field) {\n    return Collections.emptyList();\n}", "methodAfter": "public List<Exception> validateAnnotatedField(Field field) {\n    return NO_VALIDATION_ERRORS;\n}"}], [{"methodBefore": "public Description childlessCopy() {\n    return new Description(fDisplayName, fAnnotations);\n}", "methodAfter": "public Description childlessCopy() {\n    return new Description(fDisplayName, fClazz, fAnnotations);\n}"}, {"methodBefore": "public Description childlessCopy() {\n    return new Description(fDisplayName, fAnnotations);\n}", "methodAfter": "public Description childlessCopy() {\n    return new Description(fDisplayName);\n}"}], [{"methodBefore": "public static List<PotentialAssignment> potentialAssignments(Method method) throws Exception {\n    return Assignments.allUnassigned(method, new TestClass(method.getDeclaringClass())).potentialsForNextUnassigned();\n}", "methodAfter": "public static List<PotentialAssignment> potentialAssignments(Method method) throws Throwable {\n    return Assignments.allUnassigned(method, new TestClass(method.getDeclaringClass())).potentialsForNextUnassigned();\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedSingleMethodDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single method value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedSingleMethodDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single method value\"));\n}"}, {"methodBefore": "@Test\npublic void shouldReturnNothingIfTheNamedDataPointsAreMissing() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingWrongNamedString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(0, assignedStrings.size());\n}", "methodAfter": "@Test\npublic void shouldReturnNothingIfTheNamedDataPointsAreMissing() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingWrongNamedString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(0, assignedStrings.size());\n}"}, {"methodBefore": "@Test\npublic void shouldPickUpDataPointsFromParameterSupplier() throws Exception {\n    List<PotentialAssignment> assignments = potentialAssignments(WithParameterSupplier.TestClassUsingParameterSupplier.class.getMethod(\"theoryMethod\", String.class));\n    assertEquals(2, assignments.size());\n    assertEquals(DATAPOINTS.get(0), assignments.get(0).getValue());\n    assertEquals(DATAPOINTS.get(1), assignments.get(1).getValue());\n}", "methodAfter": "@Test\npublic void shouldPickUpDataPointsFromParameterSupplier() throws Throwable {\n    List<PotentialAssignment> assignments = potentialAssignments(WithParameterSupplier.TestClassUsingParameterSupplier.class.getMethod(\"theoryMethod\", String.class));\n    assertEquals(2, assignments.size());\n    assertEquals(DATAPOINTS.get(0), assignments.get(0).getValue());\n    assertEquals(DATAPOINTS.get(1), assignments.get(1).getValue());\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedFieldDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named field\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedFieldDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named field\"));\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingAllNamedStrings\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(4, assignedStrings.size());\n    assertThat(assignedStrings, hasItems(\"named field\", \"named method\", \"named single value\", \"named single method value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingAllNamedStrings\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(4, assignedStrings.size());\n    assertThat(assignedStrings, hasItems(\"named field\", \"named method\", \"named single value\", \"named single method value\"));\n}"}, {"methodBefore": "public List<PotentialAssignment> potentialsForNextUnassigned() throws Exception {\n    ParameterSignature unassigned = nextUnassigned();\n    return getSupplier(unassigned).getValueSources(unassigned);\n}", "methodAfter": "public List<PotentialAssignment> potentialsForNextUnassigned() throws Throwable {\n    ParameterSignature unassigned = nextUnassigned();\n    return getSupplier(unassigned).getValueSources(unassigned);\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedSingleFieldDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single value\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedSingleFieldDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedSingleFieldString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named single value\"));\n}"}, {"methodBefore": "public void runAfters(Object target) throws MultipleFailureException {\n    MultipleFailureException errors = new MultipleFailureException();\n    List<TestMethod> afters = getAfters();\n    for (TestMethod after : afters) {\n        try {\n            after.invokeExplosively(target);\n        } catch (Throwable e) {\n            errors.add(e);\n        }\n    }\n    errors.assertEmpty();\n}", "methodAfter": "public void runAfters(Object target) throws Throwable {\n    MultipleFailureException errors = new MultipleFailureException();\n    List<TestMethod> afters = getAfters();\n    for (TestMethod after : afters) {\n        try {\n            after.invokeExplosively(target);\n        } catch (Throwable e) {\n            errors.add(e);\n        }\n    }\n    errors.assertEmpty();\n}"}, {"methodBefore": "@Test\npublic void shouldReturnOnlyTheNamedMethodDataPoints() throws Exception {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named method\"));\n}", "methodAfter": "@Test\npublic void shouldReturnOnlyTheNamedMethodDataPoints() throws Throwable {\n    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(SpecificDataPointsSupplierTest.TestClassWithNamedDataPoints.class));\n    List<PotentialAssignment> assignments = supplier.getValueSources(signature(\"methodWantingNamedMethodString\"));\n    List<String> assignedStrings = getStringValuesFromAssignments(assignments);\n    assertEquals(1, assignedStrings.size());\n    assertThat(assignedStrings, hasItem(\"named method\"));\n}"}, {"methodBefore": "@Test\npublic void ignoreDataPointMethodsWithWrongTypes() throws Exception {\n    assertThat(potentialAssignments(WithDataPointMethod.HasDateMethod.class.getMethod(\"onlyStringsOk\", String.class)).toString(), not(containsString(\"100\")));\n}", "methodAfter": "@Test\npublic void ignoreDataPointMethodsWithWrongTypes() throws Throwable {\n    assertThat(potentialAssignments(WithDataPointMethod.HasDateMethod.class.getMethod(\"onlyStringsOk\", String.class)).toString(), not(containsString(\"100\")));\n}"}, {"methodBefore": "@Test\npublic void onlyUseSpecificDataPointsIfSpecified() throws Exception {\n    List<PotentialAssignment> assignments = potentialAssignments(WithNamedDataPoints.HasSpecificDatapointsParameters.class.getMethod(\"theory\", String.class));\n    assertEquals(5, assignments.size());\n    for (PotentialAssignment assignment : assignments) {\n        assertThat(((String) (assignment.getValue())), containsString(\"expected\"));\n    }\n}", "methodAfter": "@Test\npublic void onlyUseSpecificDataPointsIfSpecified() throws Throwable {\n    List<PotentialAssignment> assignments = potentialAssignments(WithNamedDataPoints.HasSpecificDatapointsParameters.class.getMethod(\"theory\", String.class));\n    assertEquals(5, assignments.size());\n    for (PotentialAssignment assignment : assignments) {\n        assertThat(((String) (assignment.getValue())), containsString(\"expected\"));\n    }\n}"}, {"methodBefore": "private GuesserQueue createGuesserQueue(Assignments incomplete) throws Exception {\n    ParameterSignature nextUnassigned = incomplete.nextUnassigned();\n    if (nextUnassigned.hasAnnotation(Stub.class)) {\n        GuesserQueue queue = new GuesserQueue();\n        queue.add(new Guesser<Object>(nextUnassigned.getType()));\n        return queue;\n    }\n    return GuesserQueue.forSingleValues(incomplete.potentialsForNextUnassigned());\n}", "methodAfter": "private GuesserQueue createGuesserQueue(Assignments incomplete) throws Throwable {\n    ParameterSignature nextUnassigned = incomplete.nextUnassigned();\n    if (nextUnassigned.hasAnnotation(Stub.class)) {\n        GuesserQueue queue = new GuesserQueue();\n        queue.add(new Guesser<Object>(nextUnassigned.getType()));\n        return queue;\n    }\n    return GuesserQueue.forSingleValues(incomplete.potentialsForNextUnassigned());\n}"}], [{"methodBefore": "private Statement withTestRules(FrameworkMethod method, Object target, Statement result) {\n    return TestRule.applyAll(getTestRules(target), result, describeChild(method));\n}", "methodAfter": "private Statement withTestRules(FrameworkMethod method, Object target, Statement result) {\n    for (TestRule each : getTestRules(target)) {\n        result = each.apply(result, describeChild(method));\n    }\n    return result;\n}"}, {"methodBefore": "private Statement withTestRules(FrameworkMethod method, Object target, Statement result) {\n    for (TestRule each : getTestRules(target)) {\n        result = each.apply(result, describeChild(method));\n    }\n    return result;\n}", "methodAfter": "private Statement withTestRules(FrameworkMethod method, Object target, Statement result) {\n    return TestRule.applyAll(getTestRules(target), result, describeChild(method));\n}"}], [{"methodBefore": "public void testComparisonErrorOverlapingMatches() {\n    String failure = new ComparisonCompactor(0, \"abc\", \"abbc\").compact(null);\n    assertEquals(\"expected:<...[]...> but was:<...[b]...>\", failure);\n}", "methodAfter": "public void testComparisonErrorOverlappingMatches() {\n    String failure = new ComparisonCompactor(0, \"abc\", \"abbc\").compact(null);\n    assertEquals(\"expected:<...[]...> but was:<...[b]...>\", failure);\n}"}, {"methodBefore": "public void testComparisonErrorOverlapingMatches2() {\n    String failure = new ComparisonCompactor(0, \"abcdde\", \"abcde\").compact(null);\n    assertEquals(\"expected:<...[d]...> but was:<...[]...>\", failure);\n}", "methodAfter": "public void testComparisonErrorOverlappingMatches2() {\n    String failure = new ComparisonCompactor(0, \"abcdde\", \"abcde\").compact(null);\n    assertEquals(\"expected:<...[d]...> but was:<...[]...>\", failure);\n}"}, {"methodBefore": "public void testComparisonErrorOverlapingMatches2Context() {\n    String failure = new ComparisonCompactor(2, \"abcdde\", \"abcde\").compact(null);\n    assertEquals(\"expected:<...cd[d]e> but was:<...cd[]e>\", failure);\n}", "methodAfter": "public void testComparisonErrorOverlappingMatches2Context() {\n    String failure = new ComparisonCompactor(2, \"abcdde\", \"abcde\").compact(null);\n    assertEquals(\"expected:<...cd[d]e> but was:<...cd[]e>\", failure);\n}"}, {"methodBefore": "public void testComparisonErrorOverlapingMatchesContext() {\n    String failure = new ComparisonCompactor(2, \"abc\", \"abbc\").compact(null);\n    assertEquals(\"expected:<ab[]c> but was:<ab[b]c>\", failure);\n}", "methodAfter": "public void testComparisonErrorOverlappingMatchesContext() {\n    String failure = new ComparisonCompactor(2, \"abc\", \"abbc\").compact(null);\n    assertEquals(\"expected:<ab[]c> but was:<ab[b]c>\", failure);\n}"}], [{"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}], [{"methodBefore": "public void fireTestFinished() {\n    fNotifier.fireTestFinished(fDescription);\n}", "methodAfter": "public void fireTestFinished() {\n    notifier.fireTestFinished(description);\n}"}, {"methodBefore": "public void fireTestStarted() {\n    fNotifier.fireTestStarted(fDescription);\n}", "methodAfter": "public void fireTestStarted() {\n    notifier.fireTestStarted(description);\n}"}], [{"methodBefore": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    return Collections.unmodifiableList(getAnnotatedMembers(fMethodsForAnnotations, annotationClass, false));\n}", "methodAfter": "public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotationClass) {\n    return Collections.unmodifiableList(getAnnotatedMembers(methodsForAnnotations, annotationClass, false));\n}"}, {"methodBefore": "public List<FrameworkMethod> getAnnotatedMethods() {\n    List<FrameworkMethod> methods = collectValues(fMethodsForAnnotations);\n    Collections.sort(methods, METHOD_COMPARATOR);\n    return methods;\n}", "methodAfter": "public List<FrameworkMethod> getAnnotatedMethods() {\n    List<FrameworkMethod> methods = collectValues(methodsForAnnotations);\n    Collections.sort(methods, METHOD_COMPARATOR);\n    return methods;\n}"}], [{"methodBefore": "private void starting() {\n    fStartNanos = currentNanoTime();\n}", "methodAfter": "private void starting() {\n    startNanos = currentNanoTime();\n}"}, {"methodBefore": "public long runtime(TimeUnit unit) {\n    return unit.convert(currentNanoTime() - fStartNanos, TimeUnit.NANOSECONDS);\n}", "methodAfter": "public long runtime(TimeUnit unit) {\n    return unit.convert(currentNanoTime() - startNanos, TimeUnit.NANOSECONDS);\n}"}], [{"methodBefore": "public Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    statement = withRules(method, test, statement);\n    return statement;\n}", "methodAfter": "protected Statement methodBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    Statement statement = methodInvoker(method, test);\n    statement = possiblyExpectingExceptions(method, test, statement);\n    statement = withPotentialTimeout(method, test, statement);\n    statement = withBefores(method, test, statement);\n    statement = withAfters(method, test, statement);\n    statement = withRules(method, test, statement);\n    return statement;\n}"}, {"methodBefore": "public Statement childBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    TestAnnotation annotation = new TestAnnotation(method);\n    Statement link = invoke(method, test);\n    link = possiblyExpectingExceptions(annotation, link);\n    link = withPotentialTimeout(annotation, link);\n    link = withBefores(method, test, link);\n    link = withAfters(method, test, link);\n    return link;\n}", "methodAfter": "protected Statement childBlock(FrameworkMethod method) {\n    Object test;\n    try {\n        test = new ReflectiveCallable() {\n            @Override\n            protected Object runReflectiveCall() throws Throwable {\n                return createTest();\n            }\n        }.run();\n    } catch (Throwable e) {\n        return new Fail(e);\n    }\n    TestAnnotation annotation = new TestAnnotation(method);\n    Statement link = invoke(method, test);\n    link = possiblyExpectingExceptions(annotation, link);\n    link = withPotentialTimeout(annotation, link);\n    link = withBefores(method, test, link);\n    link = withAfters(method, test, link);\n    return link;\n}"}], [{"methodBefore": "public void testComparisonErrorWithNullArgument2() {\n    ComparisonFailure failure = new ComparisonFailure(null, null, \"a\");\n    assertEquals(\"expected:<null> but was:<a>\", failure.getMessage());\n}", "methodAfter": "public void testComparisonErrorWithExpectedNull() {\n    ComparisonFailure failure = new ComparisonFailure(null, null, \"a\");\n    assertEquals(\"expected:<null> but was:<a>\", failure.getMessage());\n}"}, {"methodBefore": "public void testComparisonErrorWithNullArgument() {\n    ComparisonFailure failure = new ComparisonFailure(null, \"a\", null);\n    assertEquals(\"expected:<a> but was:<null>\", failure.getMessage());\n}", "methodAfter": "public void testComparisonErrorWithActualNull() {\n    ComparisonFailure failure = new ComparisonFailure(null, \"a\", null);\n    assertEquals(\"expected:<a> but was:<null>\", failure.getMessage());\n}"}], [{"methodBefore": "public void describeTo(Description description) {\n    fCompositeMatcher.describeTo(description);\n}", "methodAfter": "public void describeTo(Description description) {\n    getCompositeMatcher().describeTo(description);\n}"}, {"methodBefore": "@Override\nprotected void describeMismatchSafely(Throwable item, Description mismatchDescription) {\n    fCompositeMatcher.describeMismatch(item, mismatchDescription);\n}", "methodAfter": "@Override\nprotected void describeMismatchSafely(Throwable item, Description mismatchDescription) {\n    getCompositeMatcher().describeMismatch(item, mismatchDescription);\n}"}, {"methodBefore": "@Override\nprotected boolean matchesSafely(Throwable item) {\n    return fCompositeMatcher.matches(item);\n}", "methodAfter": "@Override\nprotected boolean matchesSafely(Throwable item) {\n    return getCompositeMatcher().matches(item);\n}"}], [{"methodBefore": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method, getTestClass());\n}"}, {"methodBefore": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method, getTestClass());\n}"}], [{"methodBefore": "public Test getTest() {\n    return fTest;\n}", "methodAfter": "private Test getTest() {\n    return fTest;\n}"}, {"methodBefore": "public static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}", "methodAfter": "private static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}"}], [{"methodBefore": "public void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}", "methodAfter": "private void findLeaves(Description description, List<Description> results) {\n    if (description.getChildren().isEmpty()) {\n        results.add(description);\n    } else {\n        for (Description each : description.getChildren()) {\n            findLeaves(each, results);\n        }\n    }\n}"}, {"methodBefore": "public static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}", "methodAfter": "private static Description makeDescription(Test test) {\n    if (test instanceof TestCase) {\n        TestCase tc = ((TestCase) (test));\n        return Description.createTestDescription(tc.getClass(), tc.getName());\n    } else if (test instanceof TestSuite) {\n        TestSuite ts = ((TestSuite) (test));\n        String name = (ts.getName() == null) ? createSuiteDescription(ts) : ts.getName();\n        Description description = Description.createSuiteDescription(name);\n        int n = ts.testCount();\n        for (int i = 0; i < n; i++) {\n            Description made = makeDescription(ts.testAt(i));\n            if (!made.toString().startsWith(\"warning(\")) {\n                description.addChild(made);\n            }\n        }\n        return description;\n    } else if (test instanceof Describable) {\n        Describable adapter = ((Describable) (test));\n        return adapter.getDescription();\n    } else if (test instanceof TestDecorator) {\n        TestDecorator decorator = ((TestDecorator) (test));\n        return makeDescription(decorator.getTest());\n    } else {\n        return Description.createSuiteDescription(test.getClass());\n    }\n}"}], [{"methodBefore": "@Test\npublic void getMethodsNullSorter() throws Exception {\n    String[] expected = new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN };\n    assertEquals(Arrays.asList(expected).toString(), declaredMethods(MethodSorterTest.Dummy.class));\n    assertEquals(\"[void superMario()]\", declaredMethods(MethodSorterTest.Super.class));\n    assertEquals(\"[void subBowser()]\", declaredMethods(MethodSorterTest.Sub.class));\n}", "methodAfter": "@Test\npublic void getMethodsNullSorter() throws Exception {\n    String[] expected = new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN };\n    assertEquals(Arrays.asList(expected).toString(), declaredMethods(MethodSorterTest.ClassWithoutSorterAnnotation.class));\n    assertEquals(\"[void superMario()]\", declaredMethods(MethodSorterTest.Super.class));\n    assertEquals(\"[void subBowser()]\", declaredMethods(MethodSorterTest.Sub.class));\n}"}, {"methodBefore": "@Test\npublic void testMethodsNullSorterSelf() {\n    List<String> expected = Arrays.asList(new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.Dummy.class, expected);\n    assertEquals(expected, actual);\n}", "methodAfter": "@Test\npublic void testMethodsNullSorterSelf() {\n    List<String> expected = Arrays.asList(new String[]{ EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN });\n    List<String> actual = getDeclaredFilteredMethods(MethodSorterTest.ClassWithoutSorterAnnotation.class, expected);\n    assertEquals(expected, actual);\n}"}], [{"methodBefore": "public Filter createFilterFromFilterSpec(String filterSpec) throws FilterFactoryNotFoundException, FilterNotCreatedException {\n    String filterFactoryFqcn;\n    FilterFactoryParams args;\n    if (filterSpec.contains(\"=\")) {\n        String[] tuple = filterSpec.split(\"=\", 2);\n        filterFactoryFqcn = tuple[0];\n        args = new FilterFactoryParams.OneArg(tuple[1]);\n    } else {\n        filterFactoryFqcn = filterSpec;\n        args = new FilterFactoryParams.ZeroArg();\n    }\n    return createFilter(filterFactoryFqcn, args);\n}", "methodAfter": "public Filter createFilterFromFilterSpec(String filterSpec) throws FilterFactoryNotCreatedException, FilterNotCreatedException {\n    String filterFactoryFqcn;\n    FilterFactoryParams args;\n    if (filterSpec.contains(\"=\")) {\n        String[] tuple = filterSpec.split(\"=\", 2);\n        filterFactoryFqcn = tuple[0];\n        args = new FilterFactoryParams.OneArg(tuple[1]);\n    } else {\n        filterFactoryFqcn = filterSpec;\n        args = new FilterFactoryParams.ZeroArg();\n    }\n    return createFilter(filterFactoryFqcn, args);\n}"}, {"methodBefore": "public Filter createFilter(Class<? extends FilterFactory> filterFactoryClass, FilterFactoryParams args) throws FilterNotCreatedException, FilterFactoryNotFoundException {\n    return createFilter(filterFactoryClass.getName(), args);\n}", "methodAfter": "public Filter createFilter(Class<? extends FilterFactory> filterFactoryClass, FilterFactoryParams args) throws FilterNotCreatedException, FilterFactoryNotCreatedException {\n    return createFilter(filterFactoryClass.getName(), args);\n}"}, {"methodBefore": "public Filter createFilter(String filterFactoryFqcn, FilterFactoryParams args) throws FilterNotCreatedException, FilterFactoryNotFoundException {\n    return args.apply(filterFactoryFqcn);\n}", "methodAfter": "public Filter createFilter(String filterFactoryFqcn, FilterFactoryParams args) throws FilterNotCreatedException, FilterFactoryNotCreatedException {\n    return args.apply(filterFactoryFqcn);\n}"}], [{"methodBefore": "@Override\npublic void testStarted(Description description) {\n    fWriter.append('.');\n}", "methodAfter": "@Override\npublic void testStarted(Description description) {\n    writer.append('.');\n}"}, {"methodBefore": "@Override\npublic void testFailure(Failure failure) {\n    fWriter.append('E');\n}", "methodAfter": "@Override\npublic void testFailure(Failure failure) {\n    writer.append('E');\n}"}, {"methodBefore": "@Override\npublic void testIgnored(Description description) {\n    fWriter.append('I');\n}", "methodAfter": "@Override\npublic void testIgnored(Description description) {\n    writer.append('I');\n}"}], [{"methodBefore": "@Test\npublic void memberClassDeepInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class)))));\n}", "methodAfter": "@Test\npublic void memberClassDeepInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class))));\n}"}, {"methodBefore": "@Test\npublic void memberClassDeepInsideAnnotatedMemberClass_isRunWithParentMemberClassRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class)))));\n}", "methodAfter": "@Test\npublic void memberClassDeepInsideAnnotatedMemberClass_isRunWithParentMemberClassRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class))));\n}"}, {"methodBefore": "@Test\npublic void topLevelTestClassWithAnnotation_isRunWithAnnotatedRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.class)))));\n}", "methodAfter": "@Test\npublic void topLevelTestClassWithAnnotation_isRunWithAnnotatedRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.class))));\n}"}, {"methodBefore": "@Test\npublic void annotatedMemberClassInsideAnnotatedTopLevelClass_isRunWithOwnRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class)))));\n}", "methodAfter": "@Test\npublic void annotatedMemberClassInsideAnnotatedTopLevelClass_isRunWithOwnRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class);\n    assertThat(runner, is(instanceOf(AnnotatedBuilderTest.InnerRunner.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.InnerClassWithOwnRunWith.class))));\n}"}, {"methodBefore": "@Test\npublic void memberClassInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(equalTo(((Class) (AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.class)))));\n}", "methodAfter": "@Test\npublic void memberClassInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner() throws Exception {\n    Runner runner = builder.runnerForClass(AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.class);\n    assertThat(runner, is(instanceOf(RunnerSpy.class)));\n    RunnerSpy runnerSpy = ((RunnerSpy) (runner));\n    assertThat(runnerSpy.getInvokedTestClass(), is(((Object) (AnnotatedBuilderTest.OuterClass.InnerClassWithoutOwnRunWith.class))));\n}"}], [{"methodBefore": "@Override\nprotected Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            base.evaluate();\n            verify();\n        }\n    };\n}"}, {"methodBefore": "@Override\nprotected Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}", "methodAfter": "public Statement apply(Statement base, Description description) {\n    applications++;\n    return base;\n}"}, {"methodBefore": "@Override\nprotected Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}", "methodAfter": "public Statement apply(final Statement base, final Description description) {\n    return new Statement() {\n        @Override\n        public void evaluate() throws Throwable {\n            name = description.getMethodName();\n            base.evaluate();\n        }\n    };\n}"}], [{"methodBefore": "public void assertFieldIsPublic(FrameworkField frameworkField) {\n    Field field = frameworkField.getField();\n    int modifiers = field.getModifiers();\n    if (!isPublic(modifiers)) {\n        throw new IllegalArgumentException((((\"The \" + field.getType().getSimpleName()) + \" '\") + field.getName()) + \"' is not public.\");\n    }\n}", "methodAfter": "private void assertFieldIsPublic(FrameworkField frameworkField) {\n    Field field = frameworkField.getField();\n    int modifiers = field.getModifiers();\n    if (!isPublic(modifiers)) {\n        throw new IllegalArgumentException((((\"The \" + field.getType().getSimpleName()) + \" '\") + field.getName()) + \"' is not public.\");\n    }\n}"}, {"methodBefore": "public boolean testFinished(final Class<?> testClass) {\n    return finishedTests.contains(testClass.getName());\n}", "methodAfter": "private boolean testFinished(final Class<?> testClass) {\n    return finishedTests.contains(testClass.getName());\n}"}, {"methodBefore": "public List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}", "methodAfter": "private List<Description> findLeaves(Request request) {\n    List<Description> results = new ArrayList<Description>();\n    findLeaves(request.getRunner().getDescription(), results);\n    return results;\n}"}, {"methodBefore": "public boolean testStarted(final Class<?> testClass) {\n    return startedTests.contains(testClass.getName());\n}", "methodAfter": "private boolean testStarted(final Class<?> testClass) {\n    return startedTests.contains(testClass.getName());\n}"}], [{"methodBefore": "private T filterChild(T child) throws NoTestsRemainException {\n    if (fFilter != null) {\n        fFilter.apply(child);\n    }\n    return child;\n}", "methodAfter": "private void filterChild(T child) throws NoTestsRemainException {\n    if (fFilter != null) {\n        fFilter.apply(child);\n    }\n}"}, {"methodBefore": "public Runner apply(Runner runner) throws NoTestsRemainException {\n    if (runner instanceof Filterable) {\n        Filterable filterable = ((Filterable) (runner));\n        filterable.filter(this);\n    }\n    return runner;\n}", "methodAfter": "public void apply(Runner runner) throws NoTestsRemainException {\n    if (runner instanceof Filterable) {\n        Filterable filterable = ((Filterable) (runner));\n        filterable.filter(this);\n    }\n}"}], [{"methodBefore": "@Override\npublic Statement childBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(FrameworkMethod method) {\n    return new StubbedTheoryAnchor(method);\n}"}, {"methodBefore": "@Override\npublic Statement childBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method);\n}", "methodAfter": "@Override\npublic Statement methodBlock(final FrameworkMethod method) {\n    return new TheoryAnchor(method);\n}"}], [{"methodBefore": "@Test\npublic void dataPointsAnnotationMeansTreatAsArrayOnly() throws SecurityException, NoSuchMethodException {\n    List<PotentialAssignment> valueSources = new AllMembersSupplier(new TestClass(AllMembersSupplierTest.HasDataPoints.class)).getValueSources(ParameterSignature.signatures(AllMembersSupplierTest.HasDataPoints.class.getConstructor(Object.class)).get(0));\n    assertThat(valueSources.size(), is(2));\n}", "methodAfter": "@Test\npublic void dataPointsAnnotationMeansTreatAsArrayOnly() throws Throwable {\n    List<PotentialAssignment> valueSources = allMemberValuesFor(AllMembersSupplierTest.HasDataPoints.class, Object.class);\n    assertThat(valueSources.size(), is(2));\n}"}, {"methodBefore": "@Test\npublic void dataPointsArrayFieldMayContainNullValue() throws SecurityException, NoSuchMethodException {\n    List<PotentialAssignment> valueSources = new AllMembersSupplier(new TestClass(AllMembersSupplierTest.HasDataPointsFieldWithNullValue.class)).getValueSources(ParameterSignature.signatures(AllMembersSupplierTest.HasDataPointsFieldWithNullValue.class.getConstructor(Object.class)).get(0));\n    assertThat(valueSources.size(), is(2));\n}", "methodAfter": "@Test\npublic void dataPointsArrayFieldMayContainNullValue() throws Throwable {\n    List<PotentialAssignment> valueSources = allMemberValuesFor(AllMembersSupplierTest.HasDataPointsFieldWithNullValue.class, Object.class);\n    assertThat(valueSources.size(), is(2));\n}"}], [{"methodBefore": "public String getName() {\n    return fClass.getName();\n}", "methodAfter": "public String getName() {\n    if (fClass == null) {\n        return \"null\";\n    }\n    return fClass.getName();\n}"}, {"methodBefore": "public long getTimeout() {\n    Test annotation = fMethod.getAnnotation(Test.class);\n    long timeout = annotation.timeout();\n    return timeout;\n}", "methodAfter": "public long getTimeout() {\n    Test annotation = fMethod.getAnnotation(Test.class);\n    if (annotation == null) {\n        return 0;\n    }\n    long timeout = annotation.timeout();\n    return timeout;\n}"}], [{"methodBefore": "public AllMembersSupplier(TestClass type) {\n    fClass = type;\n}", "methodAfter": "public AllMembersSupplier(TestClass type) {\n    clazz = type;\n}"}, {"methodBefore": "public IgnoredClassRunner(Class<?> testClass) {\n    fTestClass = testClass;\n}", "methodAfter": "public IgnoredClassRunner(Class<?> testClass) {\n    clazz = testClass;\n}"}], [{"methodBefore": "public void handleAssertionErrors() {\n    handleAssertionErrors = true;\n}", "methodAfter": "public ExpectedException handleAssertionErrors() {\n    handleAssertionErrors = true;\n    return this;\n}"}, {"methodBefore": "public void handleAssumptionViolatedExceptions() {\n    handleAssumptionViolatedExceptions = true;\n}", "methodAfter": "public ExpectedException handleAssumptionViolatedExceptions() {\n    handleAssumptionViolatedExceptions = true;\n    return this;\n}"}], [{"methodBefore": "private void invokeValidatorsOnFields(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        for (FrameworkField frameworkField : annotationMap.get(annotationType)) {\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedField(frameworkField.getField()));\n        }\n    }\n}", "methodAfter": "private void invokeValidatorsOnFields(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        if (validateWithAnnotation != null) {\n            for (FrameworkField frameworkField : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedField(frameworkField.getField()));\n            }\n        }\n    }\n}"}, {"methodBefore": "private void invokeValidatorsOnMethods(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n        }\n    }\n}", "methodAfter": "private void invokeValidatorsOnMethods(List<Throwable> errors) {\n    Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n    for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n        ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n        if (validateWithAnnotation != null) {\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n            }\n        }\n    }\n}"}], [{"methodBefore": "public Annotation[] getAnnotations() {\n    return fMethod.getAnnotations();\n}", "methodAfter": "public Annotation[] getAnnotations() {\n    return method.getAnnotations();\n}"}, {"methodBefore": "private MethodParameterValue(FrameworkMethod dataPointMethod) {\n    fMethod = dataPointMethod;\n}", "methodAfter": "private MethodParameterValue(FrameworkMethod dataPointMethod) {\n    method = dataPointMethod;\n}"}, {"methodBefore": "NoGenericTypeParametersValidator(Method method) {\n    this.fMethod = method;\n}", "methodAfter": "NoGenericTypeParametersValidator(Method method) {\n    this.method = method;\n}"}, {"methodBefore": "@Override\nprotected int getModifiers() {\n    return fMethod.getModifiers();\n}", "methodAfter": "@Override\nprotected int getModifiers() {\n    return method.getModifiers();\n}"}, {"methodBefore": "void validate(List<Throwable> errors) {\n    for (Type each : fMethod.getGenericParameterTypes()) {\n        validateNoTypeParameterOnType(each, errors);\n    }\n}", "methodAfter": "void validate(List<Throwable> errors) {\n    for (Type each : method.getGenericParameterTypes()) {\n        validateNoTypeParameterOnType(each, errors);\n    }\n}"}, {"methodBefore": "@Override\npublic String toString() {\n    return fMethod.toString();\n}", "methodAfter": "@Override\npublic String toString() {\n    return method.toString();\n}"}, {"methodBefore": "@Override\npublic String getDescription() throws CouldNotGenerateValueException {\n    return fMethod.getName();\n}", "methodAfter": "@Override\npublic String getDescription() throws CouldNotGenerateValueException {\n    return method.getName();\n}"}, {"methodBefore": "private void validateNoTypeParameterOnType(Type type, List<Throwable> errors) {\n    if (type instanceof TypeVariable<?>) {\n        errors.add(new Exception(((\"Method \" + fMethod.getName()) + \"() contains unresolved type variable \") + type));\n    } else if (type instanceof ParameterizedType) {\n        validateNoTypeParameterOnParameterizedType(((ParameterizedType) (type)), errors);\n    } else if (type instanceof WildcardType) {\n        validateNoTypeParameterOnWildcardType(((WildcardType) (type)), errors);\n    } else if (type instanceof GenericArrayType) {\n        validateNoTypeParameterOnGenericArrayType(((GenericArrayType) (type)), errors);\n    }\n}", "methodAfter": "private void validateNoTypeParameterOnType(Type type, List<Throwable> errors) {\n    if (type instanceof TypeVariable<?>) {\n        errors.add(new Exception(((\"Method \" + method.getName()) + \"() contains unresolved type variable \") + type));\n    } else if (type instanceof ParameterizedType) {\n        validateNoTypeParameterOnParameterizedType(((ParameterizedType) (type)), errors);\n    } else if (type instanceof WildcardType) {\n        validateNoTypeParameterOnWildcardType(((WildcardType) (type)), errors);\n    } else if (type instanceof GenericArrayType) {\n        validateNoTypeParameterOnGenericArrayType(((GenericArrayType) (type)), errors);\n    }\n}"}, {"methodBefore": "public void validateNoTypeParametersOnArgs(List<Throwable> errors) {\n    new NoGenericTypeParametersValidator(fMethod).validate(errors);\n}", "methodAfter": "public void validateNoTypeParametersOnArgs(List<Throwable> errors) {\n    new NoGenericTypeParametersValidator(method).validate(errors);\n}"}, {"methodBefore": "@Override\npublic String getName() {\n    return fMethod.getName();\n}", "methodAfter": "@Override\npublic String getName() {\n    return method.getName();\n}"}, {"methodBefore": "public Method getMethod() {\n    return fMethod;\n}", "methodAfter": "public Method getMethod() {\n    return method;\n}"}, {"methodBefore": "@Override\npublic int hashCode() {\n    return fMethod.hashCode();\n}", "methodAfter": "@Override\npublic int hashCode() {\n    return method.hashCode();\n}"}, {"methodBefore": "@Deprecated\npublic boolean producesType(Type type) {\n    return ((getParameterTypes().length == 0) && (type instanceof Class<?>)) && ((Class<?>) (type)).isAssignableFrom(fMethod.getReturnType());\n}", "methodAfter": "@Deprecated\npublic boolean producesType(Type type) {\n    return ((getParameterTypes().length == 0) && (type instanceof Class<?>)) && ((Class<?>) (type)).isAssignableFrom(method.getReturnType());\n}"}], [{"methodBefore": "@Test\npublic void timeUnitTimeout() throws InterruptedException {\n    HasGlobalTimeUnitTimeout.logger.setLength(0);\n    Result result = JUnitCore.runClasses(TimeoutRuleTest.HasGlobalTimeUnitTimeout.class);\n    assertEquals(3, result.getFailureCount());\n    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run1\"));\n    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run2\"));\n    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run3\"));\n}", "methodAfter": "@Test\npublic void timeUnitTimeout() throws InterruptedException {\n    HasGlobalTimeUnitTimeout.logger.setLength(0);\n    Result result = JUnitCore.runClasses(TimeoutRuleTest.HasGlobalTimeUnitTimeout.class);\n    assertEquals(4, result.getFailureCount());\n    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run1\"));\n    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run2\"));\n    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run3\"));\n    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString(\"run4\"));\n}"}, {"methodBefore": "@Test\npublic void longTimeout() throws InterruptedException {\n    HasGlobalLongTimeout.logger.setLength(0);\n    Result result = JUnitCore.runClasses(TimeoutRuleTest.HasGlobalLongTimeout.class);\n    assertEquals(3, result.getFailureCount());\n    assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run1\"));\n    assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run2\"));\n    assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run3\"));\n}", "methodAfter": "@Test\npublic void longTimeout() throws InterruptedException {\n    HasGlobalLongTimeout.logger.setLength(0);\n    Result result = JUnitCore.runClasses(TimeoutRuleTest.HasGlobalLongTimeout.class);\n    assertEquals(4, result.getFailureCount());\n    assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run1\"));\n    assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run2\"));\n    assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run3\"));\n    assertThat(HasGlobalLongTimeout.logger.toString(), containsString(\"run4\"));\n}"}], [{"methodBefore": "public static void assertNotEquals(String message, double unexpected, double actual, double delta) {\n    if (!doubleIsDifferent(unexpected, actual, delta)) {\n        failEquals(message, actual);\n    }\n}", "methodAfter": "public static void assertNotEquals(String message, double unexpected, double actual, double delta) {\n    if (!doubleIsDifferent(unexpected, actual, delta)) {\n        failEquals(message, Double.valueOf(actual));\n    }\n}"}, {"methodBefore": "public static void assertNotEquals(String message, long unexpected, long actual) {\n    if (unexpected == actual) {\n        failEquals(message, actual);\n    }\n}", "methodAfter": "public static void assertNotEquals(String message, long unexpected, long actual) {\n    if (unexpected == actual) {\n        failEquals(message, Long.valueOf(actual));\n    }\n}"}, {"methodBefore": "public static void assertNotEquals(String message, float unexpected, float actual, float delta) {\n    if (!floatIsDifferent(unexpected, actual, delta)) {\n        failEquals(message, actual);\n    }\n}", "methodAfter": "public static void assertNotEquals(String message, float unexpected, float actual, float delta) {\n    if (!floatIsDifferent(unexpected, actual, delta)) {\n        failEquals(message, Float.valueOf(actual));\n    }\n}"}], [{"methodBefore": "public void succeeded(Description description) {\n}", "methodAfter": "protected void succeeded(Description description) {\n}"}, {"methodBefore": "public void finished(Description description) {\n}", "methodAfter": "protected void finished(Description description) {\n}"}, {"methodBefore": "public void starting(Description description) {\n}", "methodAfter": "protected void starting(Description description) {\n}"}], [{"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    suite.addTestSuite(TextFeedbackTest.class);\n    suite.addTestSuite(TextRunnerSingleMethodTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}, {"methodBefore": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}", "methodAfter": "public static Test suite() {\n    TestSuite suite = new TestSuite(\"Framework Tests\");\n    suite.addTestSuite(StackFilterTest.class);\n    suite.addTestSuite(SorterTest.class);\n    suite.addTestSuite(SimpleTestCollectorTest.class);\n    suite.addTestSuite(BaseTestRunnerTest.class);\n    if (!BaseTestRunner.inVAJava()) {\n        suite.addTestSuite(TextRunnerTest.class);\n        if (!isJDK11()) {\n            suite.addTest(new TestSuite(TestCaseClassLoaderTest.class));\n        }\n    }\n    return suite;\n}"}]]