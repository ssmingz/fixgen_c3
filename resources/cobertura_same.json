[[{"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        LOGGER.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classPackageName + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowsForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(generateHtmlizedJavaSource(sourceFileData));\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        LOGGER.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classPackageName + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowsForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(generateHtmlizedJavaSource(sourceFileData));\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generatePackageList() throws IOException {\n    File file = new File(destinationDir, \"frame-packages.html\");\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xml:lang=\\\"en\\\" lang=\\\"en\\\">\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onclick=\\'parent.sourceFileList.location.href=\\\"frame-sourcefiles.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        Iterator iter = projectData.getPackages().iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generatePackageList() throws IOException {\n    File file = new File(destinationDir, \"frame-packages.html\");\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xml:lang=\\\"en\\\" lang=\\\"en\\\">\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onclick=\\'parent.sourceFileList.location.href=\\\"frame-sourcefiles.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        Iterator iter = projectData.getPackages().iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_373() {\n    if (jj_scan_token(TESTAAAA)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_373() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_373() {\n    if (jj_scan_token(TESTAAAA)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_373() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private String generateTableRowForTotal() {\n    StringBuffer ret = new StringBuffer();\n    double ccn = complexity.getCCNForProject(projectData);\n    ret.append(\"  <tr>\");\n    ret.append(\"<td><b>All Packages</b></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + projectData.getNumberOfSourceFiles()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(projectData, ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}", "methodAfter": "private String generateTableRowForTotal() {\n    StringBuffer ret = new StringBuffer();\n    double ccn = complexity.getCCNForProject(projectData);\n    ret.append(\"  <tr>\");\n    ret.append(\"<td><b>All Packages</b></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + projectData.getNumberOfClasses()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(projectData, ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}"}, {"methodBefore": "private String generateTableRowForTotal() {\n    StringBuffer ret = new StringBuffer();\n    double ccn = complexity.getCCNForProject(projectData);\n    ret.append(\"  <tr>\");\n    ret.append(\"<td><b>All Packages</b></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + projectData.getNumberOfSourceFiles()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(projectData, ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}", "methodAfter": "private String generateTableRowForTotal() {\n    StringBuffer ret = new StringBuffer();\n    double ccn = complexity.getCCNForProject(projectData);\n    ret.append(\"  <tr>\");\n    ret.append(\"<td><b>All Packages</b></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + projectData.getNumberOfClasses()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(projectData, ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}"}], [{"methodBefore": "private boolean jj_3R_254() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_252() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_254() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_252() {\n    if (jj_3R_274()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "@Test\npublic void performanceTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(mainSourceFile, (((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tlong start = System.nanoTime();\") + \"\\n \\t\\tint j = 0;\") + \"\\n \\t\\tfor (int i = 0; i < 100000; i++) {\") + \"\\n \\t\\t   if (i % 2 == 0) { j+=2; };\") + \"\\n \\t\\t   switch (i % 4) {\") + \"\\n \\t\\t      case 0 : \") + \"\\n \\t\\t      case 1 : j++;\") + \"\\n \\t\\t      case 2 : j+=2;\") + \"\\n \\t\\t      default: j+=3;\") + \"\\n \\t\\t   } \") + \"\\n \\t\\t}\") + \"\\n \\t\\tlong stop = System.nanoTime();\") + \"\\n \\t\\tSystem.out.println(\\\"Test took:\\\" + (stop - start)/100000.0 + \\\" milis\\\");\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    System.out.println(\"Run without instrumentation:\\n\");\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetSrcDir);\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setOutput(new File(tempDir, \"PT_uninstrumented.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_uninstrumented.log\")));\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    System.out.println(\"Run with instrumentation (not threadsafe-rigorous):\\n\");\n    classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\")).toString());\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"threadsafeRigorous\", true);\n        }\n    });\n    System.out.println(\"Run with instrumentation (threadsafe-rigorous):\\n\");\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedThreadSafe.log\")));\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n}", "methodAfter": "@Test\npublic void performanceTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(mainSourceFile, (((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tlong start = System.nanoTime();\") + \"\\n \\t\\tint j = 0;\") + \"\\n \\t\\tfor (int i = 0; i < 100000; i++) {\") + \"\\n \\t\\t   if (i % 2 == 0) { j+=2; };\") + \"\\n \\t\\t   switch (i % 4) {\") + \"\\n \\t\\t      case 0 : \") + \"\\n \\t\\t      case 1 : j++;\") + \"\\n \\t\\t      case 2 : j+=2;\") + \"\\n \\t\\t      default: j+=3;\") + \"\\n \\t\\t   } \") + \"\\n \\t\\t}\") + \"\\n \\t\\tlong stop = System.nanoTime();\") + \"\\n \\t\\tSystem.out.println(\\\"Test took:\\\" + (stop - start)/100000.0 + \\\" milis\\\");\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    System.out.println(\"Run without instrumentation:\\n\");\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetSrcDir);\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setOutput(new File(tempDir, \"PT_uninstrumented.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_uninstrumented.log\")));\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    System.out.println(\"Run with instrumentation (not threadsafe-rigorous):\\n\");\n    classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\")).toString());\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"threadsafeRigorous\", true);\n        }\n    });\n    System.out.println(\"Run with instrumentation (threadsafe-rigorous):\\n\");\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedThreadSafe.log\")));\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n}"}, {"methodBefore": "@Test\npublic void ignoreTrivialTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File reportDir = new File(tempDir, \"report\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    instrumentDir.mkdirs();\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File interfaceSourceFile = new File(srcDir, \"mypackage/MyInterface.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(interfaceSourceFile, (((\"\\n package mypackage;\" + \"\\n \") + \"\\n public interface MyInterface {\") + \"\\n \\tpublic void myInterfaceMethod();\") + \"\\n }\");\n    FileUtils.write(mainSourceFile, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic static class MyObject implements MyInterface\") + \"\\n \\t{\") + \"\\n \\t\\tpublic void myInterfaceMethod()\") + \"\\n \\t\\t{\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tMain main = new Main();\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * Call all methods so they will be considered \\\"covered\\\" unless\") + \"\\n \\t\\t * they are ignored as trivial.\") + \"\\n \\t\\t *\") + \"\\n \\t\\t * These are in no particular order.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tmain.getterTrivial();\") + \"\\n \\t\\tmain.empty();\") + \"\\n \\t\\tmain.getVoid();\") + \"\\n \\t\\tmain.getIntWithIntParm(0);\") + \"\\n \\t\\tmain.isBool();\") + \"\\n \\t\\tmain.hasBool();\") + \"\\n \\t\\tmain.set();\") + \"\\n \\t\\tmain.setInt(1);\") + \"\\n \\t\\tmain.setIntWithTwoParms(1, 2);\") + \"\\n \\t\\tmain.getMultiDimArray();\") + \"\\n \\t\\tmain.setIncrement(1);\") + \"\\n \\t\\tmain.setConst(\\\"\\\");\") + \"\\n \\t\\tmain.getArray();\") + \"\\n \\t\\tmain.getObject();\") + \"\\n \\t\\tmain.getStatic();\") + \"\\n \\t\\tmain.setStatic(1);\") + \"\\n \\t\\tmain.setISTORE(1);\") + \"\\n \\t\\tmain.setLSTORE(1);\") + \"\\n \\t\\tmain.setFSTORE((float)1.0);\") + \"\\n \\t\\tmain.setDSTORE(1.0);\") + \"\\n \\t\\tmain.setASTORE(null);\") + \"\\n \\t\\tmain.getINVOKEVIRTUAL();\") + \"\\n \\t\\tmain.getINVOKESPECIAL();\") + \"\\n \\t\\tmain.getINVOKESTATIC();\") + \"\\n \\t\\tmain.setINVOKEINTERFACE(new MyObject());\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t// call constructors in no particular order\") + \"\\n \\t\\tnew Main(1);\") + \"\\n \\t\\tnew Main(true);\") + \"\\n \\t\\tnew Main(\\\"str\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", \\\"\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", 0);\") + \"\\n \\t\\tnew Main(\\\"\\\", true);\") + \"\\n \\t\\tnew Main((Thread) null, \\\"string\\\");\") + \"\\n \\t\\tnew Main((Thread) null, 0);\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// Be careful when initializing members.  If you instantiate an\") + \"\\n \\t// object, then trivial constructors will become non-trivial.\") + \"\\n \\t// Ex. Integer myInteger = new Integer(1); will cause Main() to be non-trivial.\") + \"\\n \\tint myint;\") + \"\\n \\tboolean mybool;\") + \"\\n \\tprivate static int mystatic;\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial constructor\") + \"\\n \\tpublic Main() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// constructors that just call super() are trivial\") + \"\\n \\tpublic Main(Thread t, String str)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(str);\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// constructors that just call super() are usually trivial, but\") + \"\\n \\t// this constructor uses a constant, so it is considered non-trivial.\") + \"\\n \\tpublic Main(Thread t, int i)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(\\\"string\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(boolean bool) {\") + \"\\n \\t\\t// non-trivial conditional\") + \"\\n \\t\\tmyint = bool ? 0 : 1;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(int num) {\") + \"\\n \\t\\t// non-trivial switch\") + \"\\n \\t\\tswitch(num) {\") + \"\\n \\t\\t\\tdefault:\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str) {\") + \"\\n \\t\\t// setting of statics is non-trivial\") + \"\\n \\t\\tmystatic = 2;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, String str2)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial method call\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic Main(String str1, int i)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial object construction\") + \"\\n \\t\\tnew StringBuffer();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, boolean bool)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial this() call\") + \"\\n \\t\\tthis(str1, 0);\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic int getterTrivial() {\") + \"\\n \\t\\treturn myint;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean isBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean hasBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial setter\") + \"\\n \\tpublic void setInt(int i) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be trivial, but it is a getter that with no return value\") + \"\\n \\tpublic void getVoid() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// \\\"empty\\\" does not start with \\\"get\\\", \\\"is\\\", \\\"has\\\", or \\\"set\\\", so\") + \"\\n \\t// it is considered non-trivial.\") + \"\\n \\tprivate int empty() {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this is a getter that takes a parameter, so it is non-trivial.\") + \"\\n \\tpublic int getIntWithIntParm(int i) {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// this would be a trivial setter, but it does not have a parameter.\") + \"\\n \\tpublic void set() {\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be a trivial setter, but it has more than one parameter.\") + \"\\n \\tpublic void setIntWithTwoParms(int i, int j) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic int[][] getMultiDimArray() {\") + \"\\n \\t\\t// non-trivial construction of a multi-dimensional array\") + \"\\n \\t\\treturn new int[1][1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setIncrement(int i) {\") + \"\\n \\t\\t// non-trivial increment of local variable\") + \"\\n \\t\\ti++;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setConst(String str) {\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * cause visitLdcInsn to be called because \\\"str\\\" is in the\") + \"\\n \\t\\t * runtime constant pool.  An LDC operation is performed\") + \"\\n \\t\\t * which is considered non-trivial.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tSystem.out.println(\\\"str\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int[] getArray() {\") + \"\\n \\t\\t// causes visitIntInsn to be called.  Creating an array is a \\\"single int operand\\\".\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new int[1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Object getObject() {\") + \"\\n \\t\\t// causes visitTypeInsn to be called.  Creating an object is a type instruction.\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new Object();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int getStatic() {\") + \"\\n \\t\\t// getting a static is non-trivial.\") + \"\\n \\t\\treturn mystatic;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setStatic(int i) {\") + \"\\n \\t\\t// setting a static is non-trivial.\") + \"\\n \\t\\tmystatic = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ISTORE)) (int store to local var)\") + \"\\n \\tpublic void setISTORE(int i) {\") + \"\\n \\t\\ti = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(LSTORE)) (long store to local var)\") + \"\\n \\tpublic void setLSTORE(long l) {\") + \"\\n \\t\\tl = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(FSTORE)) (floating store to local var)\") + \"\\n \\tpublic void setFSTORE(float f) {\") + \"\\n \\t\\tf = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(DSTORE)) (double store to local var)\") + \"\\n \\tpublic void setDSTORE(double d) {\") + \"\\n \\t\\td = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ASTORE)) (object store to local var)\") + \"\\n \\tpublic void setASTORE(Object obj) {\") + \"\\n \\t\\tobj = null;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic void publicMethod() {\") + \"\\n \\t}\") + \"\\n \\tprivate void privateMethod() {\") + \"\\n \\t}\") + \"\\n \\tpublic static void staticMethod() {\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \\t// non-trivial public method call (causes visitMethodInsn(INVOKEVIRTUAL))\") + \"\\n \\tpublic int getINVOKEVIRTUAL() {\") + \"\\n \\t\\tpublicMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial private method call (causes visitMethodInsn(INVOKESPECIAL)) \") + \"\\n \\tpublic int getINVOKESPECIAL() {\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial static method call (causes visitMethodInsn(INVOKESTATIC)) \") + \"\\n \\tpublic int getINVOKESTATIC() {\") + \"\\n \\t\\tstaticMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial interface method call (causes visitMethodInsn(INVOKEINTERFACE))\") + \"\\n \\tpublic void setINVOKEINTERFACE(MyInterface obj) {\") + \"\\n \\t\\tobj.myInterfaceMethod();\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"ignoretrivial\", true);\n        }\n    });\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    ignoreUtil = new IgnoreUtil(\"mypackage.Main\", dom);\n    assertIgnored(\"<init>\", \"()V\");\n    assertIgnored(\"<init>\", \"(Ljava/lang/Thread;Ljava/lang/String;)V\");\n    assertIgnored(\"getterTrivial\");\n    assertIgnored(\"isBool\");\n    assertIgnored(\"hasBool\");\n    assertIgnored(\"setInt\");\n    assertNotIgnored(\"<init>\", \"(I)V\");\n    assertNotIgnored(\"<init>\", \"(Z)V\");\n    assertNotIgnored(\"empty\");\n    assertNotIgnored(\"getVoid\");\n    assertNotIgnored(\"getIntWithIntParm\");\n    assertNotIgnored(\"set\");\n    assertNotIgnored(\"setIntWithTwoParms\");\n    assertNotIgnored(\"getMultiDimArray\");\n    assertNotIgnored(\"setIncrement\");\n    assertNotIgnored(\"setConst\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/Thread;I)V\");\n    assertNotIgnored(\"getArray\");\n    assertNotIgnored(\"getObject\");\n    assertNotIgnored(\"getStatic\");\n    assertNotIgnored(\"setStatic\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;)V\");\n    assertNotIgnored(\"setISTORE\");\n    assertNotIgnored(\"setLSTORE\");\n    assertNotIgnored(\"setFSTORE\");\n    assertNotIgnored(\"setDSTORE\");\n    assertNotIgnored(\"setASTORE\");\n    assertNotIgnored(\"getINVOKEVIRTUAL\");\n    assertNotIgnored(\"getINVOKESPECIAL\");\n    assertNotIgnored(\"getINVOKESTATIC\");\n    assertNotIgnored(\"setINVOKEINTERFACE\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Ljava/lang/String;)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;I)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Z)V\");\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"html\");\n    reportTask.setDestDir(reportDir);\n    reportTask.setSrcDir(srcDir.getAbsolutePath());\n    reportTask.execute();\n    assertTrue(new File(reportDir, \"index.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.Main.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.MyInterface.html\").exists());\n    File frameSummaryFile = new File(reportDir, \"frame-summary.html\");\n    assertTrue(frameSummaryFile.exists());\n    TestUtils.checkFrameSummaryHtmlFile(frameSummaryFile);\n}", "methodAfter": "@Test\npublic void ignoreTrivialTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File reportDir = new File(tempDir, \"report\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    instrumentDir.mkdirs();\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File interfaceSourceFile = new File(srcDir, \"mypackage/MyInterface.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(interfaceSourceFile, (((\"\\n package mypackage;\" + \"\\n \") + \"\\n public interface MyInterface {\") + \"\\n \\tpublic void myInterfaceMethod();\") + \"\\n }\");\n    FileUtils.write(mainSourceFile, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic static class MyObject implements MyInterface\") + \"\\n \\t{\") + \"\\n \\t\\tpublic void myInterfaceMethod()\") + \"\\n \\t\\t{\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tMain main = new Main();\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * Call all methods so they will be considered \\\"covered\\\" unless\") + \"\\n \\t\\t * they are ignored as trivial.\") + \"\\n \\t\\t *\") + \"\\n \\t\\t * These are in no particular order.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tmain.getterTrivial();\") + \"\\n \\t\\tmain.empty();\") + \"\\n \\t\\tmain.getVoid();\") + \"\\n \\t\\tmain.getIntWithIntParm(0);\") + \"\\n \\t\\tmain.isBool();\") + \"\\n \\t\\tmain.hasBool();\") + \"\\n \\t\\tmain.set();\") + \"\\n \\t\\tmain.setInt(1);\") + \"\\n \\t\\tmain.setIntWithTwoParms(1, 2);\") + \"\\n \\t\\tmain.getMultiDimArray();\") + \"\\n \\t\\tmain.setIncrement(1);\") + \"\\n \\t\\tmain.setConst(\\\"\\\");\") + \"\\n \\t\\tmain.getArray();\") + \"\\n \\t\\tmain.getObject();\") + \"\\n \\t\\tmain.getStatic();\") + \"\\n \\t\\tmain.setStatic(1);\") + \"\\n \\t\\tmain.setISTORE(1);\") + \"\\n \\t\\tmain.setLSTORE(1);\") + \"\\n \\t\\tmain.setFSTORE((float)1.0);\") + \"\\n \\t\\tmain.setDSTORE(1.0);\") + \"\\n \\t\\tmain.setASTORE(null);\") + \"\\n \\t\\tmain.getINVOKEVIRTUAL();\") + \"\\n \\t\\tmain.getINVOKESPECIAL();\") + \"\\n \\t\\tmain.getINVOKESTATIC();\") + \"\\n \\t\\tmain.setINVOKEINTERFACE(new MyObject());\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t// call constructors in no particular order\") + \"\\n \\t\\tnew Main(1);\") + \"\\n \\t\\tnew Main(true);\") + \"\\n \\t\\tnew Main(\\\"str\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", \\\"\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", 0);\") + \"\\n \\t\\tnew Main(\\\"\\\", true);\") + \"\\n \\t\\tnew Main((Thread) null, \\\"string\\\");\") + \"\\n \\t\\tnew Main((Thread) null, 0);\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// Be careful when initializing members.  If you instantiate an\") + \"\\n \\t// object, then trivial constructors will become non-trivial.\") + \"\\n \\t// Ex. Integer myInteger = new Integer(1); will cause Main() to be non-trivial.\") + \"\\n \\tint myint;\") + \"\\n \\tboolean mybool;\") + \"\\n \\tprivate static int mystatic;\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial constructor\") + \"\\n \\tpublic Main() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// constructors that just call super() are trivial\") + \"\\n \\tpublic Main(Thread t, String str)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(str);\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// constructors that just call super() are usually trivial, but\") + \"\\n \\t// this constructor uses a constant, so it is considered non-trivial.\") + \"\\n \\tpublic Main(Thread t, int i)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(\\\"string\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(boolean bool) {\") + \"\\n \\t\\t// non-trivial conditional\") + \"\\n \\t\\tmyint = bool ? 0 : 1;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(int num) {\") + \"\\n \\t\\t// non-trivial switch\") + \"\\n \\t\\tswitch(num) {\") + \"\\n \\t\\t\\tdefault:\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str) {\") + \"\\n \\t\\t// setting of statics is non-trivial\") + \"\\n \\t\\tmystatic = 2;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, String str2)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial method call\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic Main(String str1, int i)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial object construction\") + \"\\n \\t\\tnew StringBuffer();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, boolean bool)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial this() call\") + \"\\n \\t\\tthis(str1, 0);\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic int getterTrivial() {\") + \"\\n \\t\\treturn myint;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean isBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean hasBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial setter\") + \"\\n \\tpublic void setInt(int i) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be trivial, but it is a getter that with no return value\") + \"\\n \\tpublic void getVoid() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// \\\"empty\\\" does not start with \\\"get\\\", \\\"is\\\", \\\"has\\\", or \\\"set\\\", so\") + \"\\n \\t// it is considered non-trivial.\") + \"\\n \\tprivate int empty() {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this is a getter that takes a parameter, so it is non-trivial.\") + \"\\n \\tpublic int getIntWithIntParm(int i) {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// this would be a trivial setter, but it does not have a parameter.\") + \"\\n \\tpublic void set() {\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be a trivial setter, but it has more than one parameter.\") + \"\\n \\tpublic void setIntWithTwoParms(int i, int j) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic int[][] getMultiDimArray() {\") + \"\\n \\t\\t// non-trivial construction of a multi-dimensional array\") + \"\\n \\t\\treturn new int[1][1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setIncrement(int i) {\") + \"\\n \\t\\t// non-trivial increment of local variable\") + \"\\n \\t\\ti++;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setConst(String str) {\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * cause visitLdcInsn to be called because \\\"str\\\" is in the\") + \"\\n \\t\\t * runtime constant pool.  An LDC operation is performed\") + \"\\n \\t\\t * which is considered non-trivial.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tSystem.out.println(\\\"str\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int[] getArray() {\") + \"\\n \\t\\t// causes visitIntInsn to be called.  Creating an array is a \\\"single int operand\\\".\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new int[1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Object getObject() {\") + \"\\n \\t\\t// causes visitTypeInsn to be called.  Creating an object is a type instruction.\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new Object();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int getStatic() {\") + \"\\n \\t\\t// getting a static is non-trivial.\") + \"\\n \\t\\treturn mystatic;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setStatic(int i) {\") + \"\\n \\t\\t// setting a static is non-trivial.\") + \"\\n \\t\\tmystatic = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ISTORE)) (int store to local var)\") + \"\\n \\tpublic void setISTORE(int i) {\") + \"\\n \\t\\ti = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(LSTORE)) (long store to local var)\") + \"\\n \\tpublic void setLSTORE(long l) {\") + \"\\n \\t\\tl = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(FSTORE)) (floating store to local var)\") + \"\\n \\tpublic void setFSTORE(float f) {\") + \"\\n \\t\\tf = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(DSTORE)) (double store to local var)\") + \"\\n \\tpublic void setDSTORE(double d) {\") + \"\\n \\t\\td = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ASTORE)) (object store to local var)\") + \"\\n \\tpublic void setASTORE(Object obj) {\") + \"\\n \\t\\tobj = null;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic void publicMethod() {\") + \"\\n \\t}\") + \"\\n \\tprivate void privateMethod() {\") + \"\\n \\t}\") + \"\\n \\tpublic static void staticMethod() {\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \\t// non-trivial public method call (causes visitMethodInsn(INVOKEVIRTUAL))\") + \"\\n \\tpublic int getINVOKEVIRTUAL() {\") + \"\\n \\t\\tpublicMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial private method call (causes visitMethodInsn(INVOKESPECIAL)) \") + \"\\n \\tpublic int getINVOKESPECIAL() {\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial static method call (causes visitMethodInsn(INVOKESTATIC)) \") + \"\\n \\tpublic int getINVOKESTATIC() {\") + \"\\n \\t\\tstaticMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial interface method call (causes visitMethodInsn(INVOKEINTERFACE))\") + \"\\n \\tpublic void setINVOKEINTERFACE(MyInterface obj) {\") + \"\\n \\t\\tobj.myInterfaceMethod();\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"ignoretrivial\", true);\n        }\n    });\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    ignoreUtil = new IgnoreUtil(\"mypackage.Main\", dom);\n    assertIgnored(\"<init>\", \"()V\");\n    assertIgnored(\"<init>\", \"(Ljava/lang/Thread;Ljava/lang/String;)V\");\n    assertIgnored(\"getterTrivial\");\n    assertIgnored(\"isBool\");\n    assertIgnored(\"hasBool\");\n    assertIgnored(\"setInt\");\n    assertNotIgnored(\"<init>\", \"(I)V\");\n    assertNotIgnored(\"<init>\", \"(Z)V\");\n    assertNotIgnored(\"empty\");\n    assertNotIgnored(\"getVoid\");\n    assertNotIgnored(\"getIntWithIntParm\");\n    assertNotIgnored(\"set\");\n    assertNotIgnored(\"setIntWithTwoParms\");\n    assertNotIgnored(\"getMultiDimArray\");\n    assertNotIgnored(\"setIncrement\");\n    assertNotIgnored(\"setConst\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/Thread;I)V\");\n    assertNotIgnored(\"getArray\");\n    assertNotIgnored(\"getObject\");\n    assertNotIgnored(\"getStatic\");\n    assertNotIgnored(\"setStatic\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;)V\");\n    assertNotIgnored(\"setISTORE\");\n    assertNotIgnored(\"setLSTORE\");\n    assertNotIgnored(\"setFSTORE\");\n    assertNotIgnored(\"setDSTORE\");\n    assertNotIgnored(\"setASTORE\");\n    assertNotIgnored(\"getINVOKEVIRTUAL\");\n    assertNotIgnored(\"getINVOKESPECIAL\");\n    assertNotIgnored(\"getINVOKESTATIC\");\n    assertNotIgnored(\"setINVOKEINTERFACE\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Ljava/lang/String;)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;I)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Z)V\");\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"html\");\n    reportTask.setDestDir(reportDir);\n    reportTask.setSrcDir(srcDir.getAbsolutePath());\n    reportTask.execute();\n    assertTrue(new File(reportDir, \"index.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.Main.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.MyInterface.html\").exists());\n    File frameSummaryFile = new File(reportDir, \"frame-summary.html\");\n    assertTrue(frameSummaryFile.exists());\n    TestUtils.checkFrameSummaryHtmlFile(frameSummaryFile);\n}"}], [{"methodBefore": "private boolean jj_3R_119() {\n    if (jj_scan_token(ASSERT)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_122() {\n    if (jj_scan_token(ASSERT)) {\n        return true;\n    }\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_119() {\n    if (jj_scan_token(ASSERT)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_122() {\n    if (jj_scan_token(ASSERT)) {\n        return true;\n    }\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public SortedSet getPackages() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getPackages() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getClasses() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getClasses() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getLines() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getLines() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public int getNumberOfChildren() {\n    return this.children.size();\n}", "methodAfter": "public int getNumberOfChildren() {\n    lock.lock();\n    try {\n        return this.children.size();\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getClasses() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getClasses() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public boolean contains(String name) {\n    return this.children.containsKey(name);\n}", "methodAfter": "public boolean contains(String name) {\n    lock.lock();\n    try {\n        return this.children.containsKey(name);\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public int hashCode() {\n    return this.children.size();\n}", "methodAfter": "public int hashCode() {\n    lock.lock();\n    try {\n        return this.children.size();\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public boolean contains(String name) {\n    return this.children.containsKey(name);\n}", "methodAfter": "public boolean contains(String name) {\n    lock.lock();\n    try {\n        return this.children.containsKey(name);\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "public final void ReturnStatement() throws ParseException {\n    jj_consume_token(RETURN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            Expression();\n            break;\n        default :\n            jj_la1[157] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _cyc++;\n    _bReturn = true;\n}", "methodAfter": "public final void ReturnStatement() throws ParseException {\n    jj_consume_token(RETURN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            Expression();\n            break;\n        default :\n            jj_la1[158] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _cyc++;\n    _bReturn = true;\n}"}, {"methodBefore": "public final void ReturnStatement() throws ParseException {\n    jj_consume_token(RETURN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            Expression();\n            break;\n        default :\n            jj_la1[157] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _cyc++;\n    _bReturn = true;\n}", "methodAfter": "public final void ReturnStatement() throws ParseException {\n    jj_consume_token(RETURN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            Expression();\n            break;\n        default :\n            jj_la1[158] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _cyc++;\n    _bReturn = true;\n}"}], [{"methodBefore": "private boolean jj_3R_205() {\n    if (jj_3R_218()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_236()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_193() {\n    if (jj_3R_207()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_221()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_205() {\n    if (jj_3R_218()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_236()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_193() {\n    if (jj_3R_207()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_221()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_337() {\n    if (jj_scan_token(THROWS)) {\n        return true;\n    }\n    if (jj_3R_363()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_331() {\n    if (jj_scan_token(THROWS)) {\n        return true;\n    }\n    if (jj_3R_366()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_337() {\n    if (jj_scan_token(THROWS)) {\n        return true;\n    }\n    if (jj_3R_363()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_331() {\n    if (jj_scan_token(THROWS)) {\n        return true;\n    }\n    if (jj_3R_366()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void MethodDeclarator15() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    FormalParameters();\n    label_79 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                break;\n            default :\n                jj_la1[198] = jj_gen;\n                break label_79;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n}", "methodAfter": "public final void MethodDeclarator15() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    FormalParameters();\n    label_83 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                break;\n            default :\n                jj_la1[204] = jj_gen;\n                break label_83;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n}"}, {"methodBefore": "public final void MethodDeclarator15() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    FormalParameters();\n    label_79 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                break;\n            default :\n                jj_la1[198] = jj_gen;\n                break label_79;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n}", "methodAfter": "public final void MethodDeclarator15() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    FormalParameters();\n    label_83 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                break;\n            default :\n                jj_la1[204] = jj_gen;\n                break label_83;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_403() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_403() {\n    if (jj_3R_308()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_403() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_403() {\n    if (jj_3R_308()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_328() {\n    if (jj_scan_token(THROWS)) {\n        return true;\n    }\n    if (jj_3R_363()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_340() {\n    if (jj_scan_token(THROWS)) {\n        return true;\n    }\n    if (jj_3R_366()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_328() {\n    if (jj_scan_token(THROWS)) {\n        return true;\n    }\n    if (jj_3R_363()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_340() {\n    if (jj_scan_token(THROWS)) {\n        return true;\n    }\n    if (jj_3R_366()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_227() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(61)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(30)) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_229() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(62)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(31)) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_227() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(61)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(30)) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_229() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(62)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(31)) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_4() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_4() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_4() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_4() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void ShiftExpression() throws ParseException {\n    AdditiveExpression();\n    label_47 : while (true) {\n        if (jj_2_26(3)) {\n        } else {\n            break label_47;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LSHIFT :\n                jj_consume_token(LSHIFT);\n                break;\n            case GT :\n                jj_consume_token(GT);\n                jj_consume_token(GT);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case GT :\n                        jj_consume_token(GT);\n                        break;\n                    default :\n                        jj_la1[103] = jj_gen;\n                }\n                break;\n            default :\n                jj_la1[104] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        AdditiveExpression();\n    } \n}", "methodAfter": "public final void ShiftExpression() throws ParseException {\n    AdditiveExpression();\n    label_48 : while (true) {\n        if (jj_2_25(3)) {\n        } else {\n            break label_48;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LSHIFT :\n                jj_consume_token(LSHIFT);\n                break;\n            case GT :\n                jj_consume_token(GT);\n                jj_consume_token(GT);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case GT :\n                        jj_consume_token(GT);\n                        break;\n                    default :\n                        jj_la1[103] = jj_gen;\n                }\n                break;\n            default :\n                jj_la1[104] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        AdditiveExpression();\n    } \n}"}, {"methodBefore": "public final void ShiftExpression() throws ParseException {\n    AdditiveExpression();\n    label_47 : while (true) {\n        if (jj_2_26(3)) {\n        } else {\n            break label_47;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LSHIFT :\n                jj_consume_token(LSHIFT);\n                break;\n            case GT :\n                jj_consume_token(GT);\n                jj_consume_token(GT);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case GT :\n                        jj_consume_token(GT);\n                        break;\n                    default :\n                        jj_la1[103] = jj_gen;\n                }\n                break;\n            default :\n                jj_la1[104] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        AdditiveExpression();\n    } \n}", "methodAfter": "public final void ShiftExpression() throws ParseException {\n    AdditiveExpression();\n    label_48 : while (true) {\n        if (jj_2_25(3)) {\n        } else {\n            break label_48;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LSHIFT :\n                jj_consume_token(LSHIFT);\n                break;\n            case GT :\n                jj_consume_token(GT);\n                jj_consume_token(GT);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case GT :\n                        jj_consume_token(GT);\n                        break;\n                    default :\n                        jj_la1[103] = jj_gen;\n                }\n                break;\n            default :\n                jj_la1[104] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        AdditiveExpression();\n    } \n}"}], [{"methodBefore": "public static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}", "methodAfter": "@Test\npublic static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}"}, {"methodBefore": "public static void testInstrumentUsingClassPath() throws Exception {\n    runTestAntScript(\"classpath\", \"test-classpath\");\n    verify(\"classpath\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingClassPath() throws Exception {\n    runTestAntScript(\"classpath\", \"test-classpath\");\n    verify(\"classpath\");\n}"}], [{"methodBefore": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}, {"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}], [{"methodBefore": "public final void ConditionalOrExpression() throws ParseException {\n    ConditionalAndExpression();\n    label_40 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case SC_OR :\n                break;\n            default :\n                jj_la1[93] = jj_gen;\n                break label_40;\n        }\n        jj_consume_token(SC_OR);\n        _cyc++;\n        ConditionalAndExpression();\n    } \n}", "methodAfter": "public final void ConditionalOrExpression() throws ParseException {\n    ConditionalAndExpression();\n    label_40 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case SC_OR :\n                break;\n            default :\n                jj_la1[92] = jj_gen;\n                break label_40;\n        }\n        jj_consume_token(SC_OR);\n        _cyc++;\n        ConditionalAndExpression();\n    } \n}"}, {"methodBefore": "public final void ConditionalOrExpression() throws ParseException {\n    ConditionalAndExpression();\n    label_40 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case SC_OR :\n                break;\n            default :\n                jj_la1[93] = jj_gen;\n                break label_40;\n        }\n        jj_consume_token(SC_OR);\n        _cyc++;\n        ConditionalAndExpression();\n    } \n}", "methodAfter": "public final void ConditionalOrExpression() throws ParseException {\n    ConditionalAndExpression();\n    label_40 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case SC_OR :\n                break;\n            default :\n                jj_la1[92] = jj_gen;\n                break label_40;\n        }\n        jj_consume_token(SC_OR);\n        _cyc++;\n        ConditionalAndExpression();\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_158() {\n    if (jj_3R_110()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_184() {\n    if (jj_3R_118()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_158() {\n    if (jj_3R_110()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_184() {\n    if (jj_3R_118()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public double getBranchCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = conditionals.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndDescriptor)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}", "methodAfter": "public double getBranchCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = conditionals.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (methodNameAndDescriptor.equals(next.getMethodName() + next.getMethodDescriptor())) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}"}, {"methodBefore": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = lines.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndDescriptor)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}", "methodAfter": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = lines.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (methodNameAndDescriptor.equals(next.getMethodName() + next.getMethodDescriptor())) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}"}], [{"methodBefore": "public void testEquals() {\n    assertFalse(a.equals(null));\n    assertFalse(a.equals(Integer.valueOf(4)));\n    assertTrue(a.equals(a));\n    assertFalse(a.equals(b));\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 });\n    assertTrue(a.equals(aPrime));\n}", "methodAfter": "public void testEquals() {\n    assertFalse(a.equals(null));\n    assertFalse(a.equals(Integer.valueOf(4)));\n    assertTrue(a.equals(a));\n    assertFalse(a.equals(b));\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 }, Integer.MAX_VALUE);\n    assertTrue(a.equals(aPrime));\n}"}, {"methodBefore": "public void testHashCode() {\n    assertEquals(a.hashCode(), a.hashCode());\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 });\n    assertEquals(a.hashCode(), aPrime.hashCode());\n}", "methodAfter": "public void testHashCode() {\n    assertEquals(a.hashCode(), a.hashCode());\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 }, Integer.MAX_VALUE);\n    assertEquals(a.hashCode(), aPrime.hashCode());\n}"}], [{"methodBefore": "public final void NormalAnnotation() throws ParseException {\n    jj_consume_token(AT);\n    Name();\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IDENTIFIER :\n            MemberValuePairs();\n            break;\n        default :\n            jj_la1[162] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}", "methodAfter": "public final void NormalAnnotation() throws ParseException {\n    jj_consume_token(AT);\n    Name();\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IDENTIFIER :\n            MemberValuePairs();\n            break;\n        default :\n            jj_la1[167] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}"}, {"methodBefore": "public final void NormalAnnotation() throws ParseException {\n    jj_consume_token(AT);\n    Name();\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IDENTIFIER :\n            MemberValuePairs();\n            break;\n        default :\n            jj_la1[162] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}", "methodAfter": "public final void NormalAnnotation() throws ParseException {\n    jj_consume_token(AT);\n    Name();\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IDENTIFIER :\n            MemberValuePairs();\n            break;\n        default :\n            jj_la1[167] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}"}], [{"methodBefore": "public Vector getImports() {\n    return _vImports;\n}", "methodAfter": "public List getImports() {\n    return _vImports;\n}"}, {"methodBefore": "public Vector getImports() {\n    return _vImports;\n}", "methodAfter": "public List getImports() {\n    return _vImports;\n}"}], [{"methodBefore": "public void clear() {\n    name = \".\";\n    classes = 0;\n    functions = 0;\n    ncss = 0;\n    javadocs = 0;\n    javadocsLn = 0;\n    singleLn = 0;\n    multiLn = 0;\n}", "methodAfter": "public void clear() {\n    super.clear();\n    classes = 0;\n    functions = 0;\n}"}, {"methodBefore": "public void clear() {\n    name = \".\";\n    classes = 0;\n    functions = 0;\n    ncss = 0;\n    javadocs = 0;\n    javadocsLn = 0;\n    singleLn = 0;\n    multiLn = 0;\n}", "methodAfter": "public void clear() {\n    super.clear();\n    classes = 0;\n    functions = 0;\n}"}], [{"methodBefore": "public final void ContinueStatement() throws ParseException {\n    jj_consume_token(CONTINUE);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case IDENTIFIER :\n            Identifier();\n            break;\n        default :\n            jj_la1[156] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void ContinueStatement() throws ParseException {\n    jj_consume_token(CONTINUE);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case IDENTIFIER :\n            Identifier();\n            break;\n        default :\n            jj_la1[157] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}, {"methodBefore": "public final void ContinueStatement() throws ParseException {\n    jj_consume_token(CONTINUE);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case IDENTIFIER :\n            Identifier();\n            break;\n        default :\n            jj_la1[156] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void ContinueStatement() throws ParseException {\n    jj_consume_token(CONTINUE);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case IDENTIFIER :\n            Identifier();\n            break;\n        default :\n            jj_la1[157] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}], [{"methodBefore": "public final void PrimaryExpression() throws ParseException {\n    PrimaryPrefix();\n    label_51 : while (true) {\n        if (jj_2_32(2)) {\n        } else {\n            break label_51;\n        }\n        PrimarySuffix();\n    } \n}", "methodAfter": "public final void PrimaryExpression() throws ParseException {\n    PrimaryPrefix();\n    label_52 : while (true) {\n        if (jj_2_31(2)) {\n        } else {\n            break label_52;\n        }\n        PrimarySuffix();\n    } \n}"}, {"methodBefore": "public final void PrimaryExpression() throws ParseException {\n    PrimaryPrefix();\n    label_51 : while (true) {\n        if (jj_2_32(2)) {\n        } else {\n            break label_51;\n        }\n        PrimarySuffix();\n    } \n}", "methodAfter": "public final void PrimaryExpression() throws ParseException {\n    PrimaryPrefix();\n    label_52 : while (true) {\n        if (jj_2_31(2)) {\n        } else {\n            break label_52;\n        }\n        PrimarySuffix();\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_452() {\n    if (jj_3R_222()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_452() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_107()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_459()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_380()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_452() {\n    if (jj_3R_222()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_452() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_107()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_459()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_380()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_347() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_379() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_347() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_379() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_330() {\n    if (jj_3R_364()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_333() {\n    if (jj_3R_367()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_330() {\n    if (jj_3R_364()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_333() {\n    if (jj_3R_367()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_399() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_399() {\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_399() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_399() {\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_130() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_130() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_130() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_130() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_442() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_448()) {\n        jj_scanpos = xsp;\n        if (jj_3R_449()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_446() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_454()) {\n        jj_scanpos = xsp;\n        if (jj_3R_455()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_442() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_448()) {\n        jj_scanpos = xsp;\n        if (jj_3R_449()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_446() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_454()) {\n        jj_scanpos = xsp;\n        if (jj_3R_455()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_30() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_29() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_30() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_29() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_249() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_247() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_249() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_247() {\n    if (jj_3R_269()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_31() {\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    if (jj_3R_110()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_30() {\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    if (jj_3R_113()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_31() {\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    if (jj_3R_110()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_30() {\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    if (jj_3R_113()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void Annotation() throws ParseException {\n    if (jj_2_48(2147483647)) {\n        NormalAnnotation();\n    } else if (jj_2_49(2147483647)) {\n        SingleMemberAnnotation();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                MarkerAnnotation();\n                break;\n            default :\n                jj_la1[161] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void Annotation() throws ParseException {\n    if (jj_2_47(2147483647)) {\n        NormalAnnotation();\n    } else if (jj_2_48(2147483647)) {\n        SingleMemberAnnotation();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                MarkerAnnotation();\n                break;\n            default :\n                jj_la1[166] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}, {"methodBefore": "public final void Annotation() throws ParseException {\n    if (jj_2_48(2147483647)) {\n        NormalAnnotation();\n    } else if (jj_2_49(2147483647)) {\n        SingleMemberAnnotation();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                MarkerAnnotation();\n                break;\n            default :\n                jj_la1[161] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void Annotation() throws ParseException {\n    if (jj_2_47(2147483647)) {\n        NormalAnnotation();\n    } else if (jj_2_48(2147483647)) {\n        SingleMemberAnnotation();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                MarkerAnnotation();\n                break;\n            default :\n                jj_la1[166] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}], [{"methodBefore": "protected void generateRegisterClass(MethodVisitor mv, String className) {\n    mv.visitLdcInsn(Type.getObjectType(className));\n    mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(TouchCollector.class), \"registerClass\", \"(Ljava/lang/Class;)V\");\n}", "methodAfter": "protected void generateRegisterClass(MethodVisitor mv, String className) {\n    mv.visitLdcInsn(className);\n    mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(TouchCollector.class), \"registerClass\", \"(Ljava/lang/String;)V\");\n}"}, {"methodBefore": "protected void generateRegisterClass(MethodVisitor mv, String className) {\n    mv.visitLdcInsn(Type.getObjectType(className));\n    mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(TouchCollector.class), \"registerClass\", \"(Ljava/lang/Class;)V\");\n}", "methodAfter": "protected void generateRegisterClass(MethodVisitor mv, String className) {\n    mv.visitLdcInsn(className);\n    mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(TouchCollector.class), \"registerClass\", \"(Ljava/lang/String;)V\");\n}"}], [{"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (destDir != null) {\n            builder.addArg(\"--destination\", destDir.getAbsolutePath());\n        }\n        if (format != null) {\n            builder.addArg(\"--format\", format);\n        }\n        if (encoding != null) {\n            builder.addArg(\"--encoding\", encoding);\n        }\n        if (srcDir != null) {\n            builder.addArg(srcDir);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    createCommandsFileAndExecute(builder);\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (destDir != null) {\n            builder.addArg(\"--destination\", destDir.getAbsolutePath());\n        }\n        if (format != null) {\n            builder.addArg(\"--format\", format);\n        }\n        if (encoding != null) {\n            builder.addArg(\"--encoding\", encoding);\n        }\n        if (srcDir != null) {\n            builder.addArg(srcDir);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error running reports. See messages above.\");\n    }\n    builder.dispose();\n}"}, {"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    createCommandsFileAndExecute(builder);\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error running reports. See messages above.\");\n    }\n    builder.dispose();\n}"}], [{"methodBefore": "private boolean jj_3R_362() {\n    if (jj_3R_386()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_387()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_365() {\n    if (jj_3R_389()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_390()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_362() {\n    if (jj_3R_386()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_387()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_365() {\n    if (jj_3R_389()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_390()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_384() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_184()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_387() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_187()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_384() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_184()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_387() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_187()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_340() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_341() {\n    if (jj_3R_145()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_340() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_341() {\n    if (jj_3R_145()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_44() {\n    if (jj_3R_119()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_37() {\n    if (jj_3R_119()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_44() {\n    if (jj_3R_119()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_37() {\n    if (jj_3R_119()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_171() {\n    if (jj_3R_193()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_457() {\n    if (jj_3R_463()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_171() {\n    if (jj_3R_193()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_457() {\n    if (jj_3R_463()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_431() {\n    if (jj_3R_442()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_443()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_434() {\n    if (jj_3R_446()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_447()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_431() {\n    if (jj_3R_442()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_443()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_434() {\n    if (jj_3R_446()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_447()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "public final void AndExpression() throws ParseException {\n    EqualityExpression();\n    label_44 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_AND :\n                break;\n            default :\n                jj_la1[97] = jj_gen;\n                break label_44;\n        }\n        jj_consume_token(BIT_AND);\n        EqualityExpression();\n    } \n}", "methodAfter": "public final void AndExpression() throws ParseException {\n    EqualityExpression();\n    label_44 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_AND :\n                break;\n            default :\n                jj_la1[96] = jj_gen;\n                break label_44;\n        }\n        jj_consume_token(BIT_AND);\n        EqualityExpression();\n    } \n}"}, {"methodBefore": "public final void AndExpression() throws ParseException {\n    EqualityExpression();\n    label_44 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_AND :\n                break;\n            default :\n                jj_la1[97] = jj_gen;\n                break label_44;\n        }\n        jj_consume_token(BIT_AND);\n        EqualityExpression();\n    } \n}", "methodAfter": "public final void AndExpression() throws ParseException {\n    EqualityExpression();\n    label_44 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_AND :\n                break;\n            default :\n                jj_la1[96] = jj_gen;\n                break label_44;\n        }\n        jj_consume_token(BIT_AND);\n        EqualityExpression();\n    } \n}"}], [{"methodBefore": "private void generateOverviews() throws IOException {\n    generateOverview(null);\n    Iterator iter = projectData.getChildren().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateOverview(packageData);\n    } \n}", "methodAfter": "private void generateOverviews() throws IOException {\n    generateOverview(null);\n    Iterator iter = projectData.getPackages().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateOverview(packageData);\n    } \n}"}, {"methodBefore": "private void generateSourceFileLists() throws IOException {\n    generateSourceFileList(null);\n    Iterator iter = projectData.getChildren().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateSourceFileList(packageData);\n    } \n}", "methodAfter": "private void generateSourceFileLists() throws IOException {\n    generateSourceFileList(null);\n    Iterator iter = projectData.getPackages().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateSourceFileList(packageData);\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_111() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_22()) {\n        jj_scanpos = xsp;\n        if (jj_3R_158()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_114() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_22()) {\n        jj_scanpos = xsp;\n        if (jj_3R_161()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_111() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_22()) {\n        jj_scanpos = xsp;\n        if (jj_3R_158()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_114() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_22()) {\n        jj_scanpos = xsp;\n        if (jj_3R_161()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "public final void PrimaryExpression() throws ParseException {\n    PrimaryPrefix();\n    label_51 : while (true) {\n        if (jj_2_32(2)) {\n        } else {\n            break label_51;\n        }\n        PrimarySuffix();\n    } \n}", "methodAfter": "public final void PrimaryExpression() throws ParseException {\n    PrimaryPrefix();\n    label_52 : while (true) {\n        if (jj_2_31(2)) {\n        } else {\n            break label_52;\n        }\n        PrimarySuffix();\n    } \n}"}, {"methodBefore": "public final void PrimaryExpression() throws ParseException {\n    PrimaryPrefix();\n    label_51 : while (true) {\n        if (jj_2_32(2)) {\n        } else {\n            break label_51;\n        }\n        PrimarySuffix();\n    } \n}", "methodAfter": "public final void PrimaryExpression() throws ParseException {\n    PrimaryPrefix();\n    label_52 : while (true) {\n        if (jj_2_31(2)) {\n        } else {\n            break label_52;\n        }\n        PrimarySuffix();\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_129() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_129() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_129() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_129() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_115() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_39()) {\n        jj_scanpos = xsp;\n        if (jj_3R_163()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_118() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_38()) {\n        jj_scanpos = xsp;\n        if (jj_3R_166()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_115() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_39()) {\n        jj_scanpos = xsp;\n        if (jj_3R_163()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_118() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_38()) {\n        jj_scanpos = xsp;\n        if (jj_3R_166()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[193] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[194] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[199] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[200] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[193] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[194] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[199] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[200] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_250() {\n    if (jj_3R_270()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_248() {\n    if (jj_3R_270()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_250() {\n    if (jj_3R_270()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_248() {\n    if (jj_3R_270()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}", "methodAfter": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(ASM4, mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}"}, {"methodBefore": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(mv);\n    this.eventsToTrace = eventsToTrace;\n}", "methodAfter": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(ASM4, mv);\n    this.eventsToTrace = eventsToTrace;\n}"}, {"methodBefore": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(mv);\n    this.eventsToTrace = eventsToTrace;\n}", "methodAfter": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(ASM4, mv);\n    this.eventsToTrace = eventsToTrace;\n}"}, {"methodBefore": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}", "methodAfter": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(ASM4, mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}"}], [{"methodBefore": "private boolean jj_3R_84() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_52()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_360() {\n    if (jj_3R_139()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_52()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_84() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_52()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_360() {\n    if (jj_3R_139()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_52()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_138() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_138() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_138() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_138() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void WildcardBounds() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            ReferenceType();\n            break;\n        case SUPER :\n            jj_consume_token(SUPER);\n            ReferenceType();\n            break;\n        default :\n            jj_la1[196] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void WildcardBounds() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            ReferenceType();\n            break;\n        case SUPER :\n            jj_consume_token(SUPER);\n            ReferenceType();\n            break;\n        default :\n            jj_la1[202] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void WildcardBounds() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            ReferenceType();\n            break;\n        case SUPER :\n            jj_consume_token(SUPER);\n            ReferenceType();\n            break;\n        default :\n            jj_la1[196] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void WildcardBounds() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            ReferenceType();\n            break;\n        case SUPER :\n            jj_consume_token(SUPER);\n            ReferenceType();\n            break;\n        default :\n            jj_la1[202] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_451() {\n    if (jj_3R_454()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_450() {\n    if (jj_3R_457()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_451() {\n    if (jj_3R_454()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_450() {\n    if (jj_3R_457()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void generateCINITmethod(MethodVisitor mv, String className, int counters_cnt) {\n    super.generateCINITmethod(mv, className, counters_cnt);\n    mv.visitTypeInsn(NEW, Type.getInternalName(AtomicIntegerArray.class));\n    mv.visitInsn(DUP);\n    mv.visitLdcInsn(counters_cnt);\n    mv.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(AtomicIntegerArray.class), \"<init>\", \"(I)V\");\n    mv.visitFieldInsn(PUTSTATIC, className, COBERTURA_COUNTERS_FIELD_NAME, COBERTURA_COUNTERS_FIELD_TYPE);\n}", "methodAfter": "public void generateCINITmethod(MethodVisitor mv, String className, int counters_cnt) {\n    mv.visitFieldInsn(GETSTATIC, className, COBERTURA_COUNTERS_FIELD_NAME, COBERTURA_COUNTERS_FIELD_TYPE);\n    Label l1 = new Label();\n    mv.visitJumpInsn(IFNONNULL, l1);\n    mv.visitTypeInsn(NEW, Type.getInternalName(AtomicIntegerArray.class));\n    mv.visitInsn(DUP);\n    mv.visitLdcInsn(counters_cnt);\n    mv.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(AtomicIntegerArray.class), \"<init>\", \"(I)V\");\n    mv.visitFieldInsn(PUTSTATIC, className, COBERTURA_COUNTERS_FIELD_NAME, COBERTURA_COUNTERS_FIELD_TYPE);\n    generateRegisterClass(mv, className);\n    mv.visitLabel(l1);\n}"}, {"methodBefore": "public void generateCINITmethod(MethodVisitor mv, String className, int counters_cnt) {\n    super.generateCINITmethod(mv, className, counters_cnt);\n    mv.visitLdcInsn(counters_cnt);\n    mv.visitIntInsn(NEWARRAY, T_INT);\n    mv.visitFieldInsn(PUTSTATIC, className, COBERTURA_COUNTERS_FIELD_NAME, COBERTURA_COUNTERS_FIELD_TYPE);\n}", "methodAfter": "public void generateCINITmethod(MethodVisitor mv, String className, int counters_cnt) {\n    mv.visitFieldInsn(GETSTATIC, className, COBERTURA_COUNTERS_FIELD_NAME, COBERTURA_COUNTERS_FIELD_TYPE);\n    Label l1 = new Label();\n    mv.visitJumpInsn(IFNONNULL, l1);\n    mv.visitLdcInsn(counters_cnt);\n    mv.visitIntInsn(NEWARRAY, T_INT);\n    mv.visitFieldInsn(PUTSTATIC, className, COBERTURA_COUNTERS_FIELD_NAME, COBERTURA_COUNTERS_FIELD_TYPE);\n    generateRegisterClass(mv, className);\n    mv.visitLabel(l1);\n}"}], [{"methodBefore": "public final void ConditionalAndExpression() throws ParseException {\n    InclusiveOrExpression();\n    label_41 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case SC_AND :\n                break;\n            default :\n                jj_la1[94] = jj_gen;\n                break label_41;\n        }\n        jj_consume_token(SC_AND);\n        _cyc++;\n        InclusiveOrExpression();\n    } \n}", "methodAfter": "public final void ConditionalAndExpression() throws ParseException {\n    InclusiveOrExpression();\n    label_41 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case SC_AND :\n                break;\n            default :\n                jj_la1[93] = jj_gen;\n                break label_41;\n        }\n        jj_consume_token(SC_AND);\n        _cyc++;\n        InclusiveOrExpression();\n    } \n}"}, {"methodBefore": "public final void ConditionalAndExpression() throws ParseException {\n    InclusiveOrExpression();\n    label_41 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case SC_AND :\n                break;\n            default :\n                jj_la1[94] = jj_gen;\n                break label_41;\n        }\n        jj_consume_token(SC_AND);\n        _cyc++;\n        InclusiveOrExpression();\n    } \n}", "methodAfter": "public final void ConditionalAndExpression() throws ParseException {\n    InclusiveOrExpression();\n    label_41 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case SC_AND :\n                break;\n            default :\n                jj_la1[93] = jj_gen;\n                break label_41;\n        }\n        jj_consume_token(SC_AND);\n        _cyc++;\n        InclusiveOrExpression();\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_243() {\n    if (jj_3R_263()) {\n        return true;\n    }\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_244() {\n    if (jj_3R_266()) {\n        return true;\n    }\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_243() {\n    if (jj_3R_263()) {\n        return true;\n    }\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_244() {\n    if (jj_3R_266()) {\n        return true;\n    }\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_450() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_452()) {\n        jj_scanpos = xsp;\n        if (jj_3R_453()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_88() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_51()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_450() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_452()) {\n        jj_scanpos = xsp;\n        if (jj_3R_453()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_88() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_51()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_50() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_123()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_49() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_126()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_50() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_123()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_49() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_126()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}, {"methodBefore": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    lock.lock();\n    try {\n        Iterator iter = children.values().iterator();\n        while (iter.hasNext()) {\n            LineData next = ((LineData) (iter.next()));\n            if (methodNameAndDescriptor.equals(next.getMethodName() + next.getMethodDescriptor())) {\n                total++;\n                if (next.getHits() > 0) {\n                    hits++;\n                }\n            }\n        } \n        if (total == 0) {\n            return 1.0;\n        }\n        return ((double) (hits)) / total;\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = children.values().iterator();\n        while (iter.hasNext()) {\n            LineData next = ((LineData) (iter.next()));\n            if (methodNameAndDescriptor.equals(next.getMethodName() + next.getMethodDescriptor())) {\n                total++;\n                if (next.getHits() > 0) {\n                    hits++;\n                }\n            }\n        } \n        if (total == 0) {\n            return 1.0;\n        }\n        return ((double) (hits)) / total;\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}], [{"methodBefore": "private boolean jj_3R_207() {\n    if (jj_3R_221()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_205() {\n    if (jj_3R_218()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_207() {\n    if (jj_3R_221()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_205() {\n    if (jj_3R_218()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "@Before\npublic void setUp() throws IOException {\n    tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    srcDir = new File(tempDir, \"src\");\n    reportDir = new File(tempDir, \"report\");\n    instrumentDir = new File(tempDir, \"instrument\");\n    mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    datafile = new File(srcDir, \"cobertura.ser\");\n}", "methodAfter": "@Before\npublic void setUp() throws IOException {\n    tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    srcDir = new File(tempDir, \"src\");\n    reportDir = new File(tempDir, \"report\");\n    instrumentDir = new File(tempDir, \"instrument\");\n    mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    datafile = new File(srcDir, \"cobertura.ser\");\n    srcDir.mkdirs();\n    reportDir.mkdirs();\n    instrumentDir.mkdirs();\n}"}, {"methodBefore": "@Before\npublic void setUp() throws IOException {\n    tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    srcDir = new File(tempDir, \"src\");\n    reportDir = new File(tempDir, \"report\");\n    instrumentDir = new File(tempDir, \"instrument\");\n    mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    datafile = new File(srcDir, \"cobertura.ser\");\n}", "methodAfter": "@Before\npublic void setUp() throws IOException {\n    tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    srcDir = new File(tempDir, \"src\");\n    reportDir = new File(tempDir, \"report\");\n    instrumentDir = new File(tempDir, \"instrument\");\n    mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    datafile = new File(srcDir, \"cobertura.ser\");\n    srcDir.mkdirs();\n    reportDir.mkdirs();\n    instrumentDir.mkdirs();\n}"}], [{"methodBefore": "private boolean jj_3R_96() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_97() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_96() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_97() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void WildcardBounds() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            ReferenceType();\n            break;\n        case SUPER :\n            jj_consume_token(SUPER);\n            ReferenceType();\n            break;\n        default :\n            jj_la1[196] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void WildcardBounds() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            ReferenceType();\n            break;\n        case SUPER :\n            jj_consume_token(SUPER);\n            ReferenceType();\n            break;\n        default :\n            jj_la1[202] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void WildcardBounds() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            ReferenceType();\n            break;\n        case SUPER :\n            jj_consume_token(SUPER);\n            ReferenceType();\n            break;\n        default :\n            jj_la1[196] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void WildcardBounds() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            ReferenceType();\n            break;\n        case SUPER :\n            jj_consume_token(SUPER);\n            ReferenceType();\n            break;\n        default :\n            jj_la1[202] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public JavaParser(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 192; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}", "methodAfter": "public JavaParser(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 202; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}"}, {"methodBefore": "public void ReInit(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 192; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}", "methodAfter": "public void ReInit(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 202; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}"}], [{"methodBefore": "public final void AnnotationTypeMemberDeclaration() throws ParseException {\n    int modifiers;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case CLASS :\n        case DOUBLE :\n        case ENUM :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case INTERFACE :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            modifiers = Modifiers();\n            if (jj_2_51(2147483647)) {\n                Type();\n                jj_consume_token(IDENTIFIER);\n                jj_consume_token(LPAREN);\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case _DEFAULT :\n                        DefaultValue();\n                        break;\n                    default :\n                        jj_la1[169] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    case AT :\n                        AnnotationTypeDeclaration(modifiers);\n                        break;\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case SHORT :\n                    case IDENTIFIER :\n                        FieldDeclaration15(modifiers);\n                        break;\n                    default :\n                        jj_la1[170] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[171] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void AnnotationTypeMemberDeclaration() throws ParseException {\n    int modifiers;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case CLASS :\n        case DOUBLE :\n        case ENUM :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case INTERFACE :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            modifiers = Modifiers();\n            if (jj_2_50(2147483647)) {\n                Type();\n                jj_consume_token(IDENTIFIER);\n                jj_consume_token(LPAREN);\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case _DEFAULT :\n                        DefaultValue();\n                        break;\n                    default :\n                        jj_la1[174] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    case AT :\n                        AnnotationTypeDeclaration(modifiers);\n                        break;\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case SHORT :\n                    case IDENTIFIER :\n                        FieldDeclaration15(modifiers);\n                        break;\n                    default :\n                        jj_la1[175] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[176] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void AnnotationTypeMemberDeclaration() throws ParseException {\n    int modifiers;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case CLASS :\n        case DOUBLE :\n        case ENUM :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case INTERFACE :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            modifiers = Modifiers();\n            if (jj_2_51(2147483647)) {\n                Type();\n                jj_consume_token(IDENTIFIER);\n                jj_consume_token(LPAREN);\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case _DEFAULT :\n                        DefaultValue();\n                        break;\n                    default :\n                        jj_la1[169] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    case AT :\n                        AnnotationTypeDeclaration(modifiers);\n                        break;\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case SHORT :\n                    case IDENTIFIER :\n                        FieldDeclaration15(modifiers);\n                        break;\n                    default :\n                        jj_la1[170] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[171] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void AnnotationTypeMemberDeclaration() throws ParseException {\n    int modifiers;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case CLASS :\n        case DOUBLE :\n        case ENUM :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case INTERFACE :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            modifiers = Modifiers();\n            if (jj_2_50(2147483647)) {\n                Type();\n                jj_consume_token(IDENTIFIER);\n                jj_consume_token(LPAREN);\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case _DEFAULT :\n                        DefaultValue();\n                        break;\n                    default :\n                        jj_la1[174] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    case AT :\n                        AnnotationTypeDeclaration(modifiers);\n                        break;\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case SHORT :\n                    case IDENTIFIER :\n                        FieldDeclaration15(modifiers);\n                        break;\n                    default :\n                        jj_la1[175] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[176] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "public JavaParser(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 202; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}", "methodAfter": "public JavaParser(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 208; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}"}, {"methodBefore": "public JavaParser(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 202; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}", "methodAfter": "public JavaParser(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 208; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_134() {\n    if (jj_scan_token(TESTAAAA)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_134() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_134() {\n    if (jj_scan_token(TESTAAAA)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_134() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void ForStatement() throws ParseException {\n    jj_consume_token(FOR);\n    jj_consume_token(LPAREN);\n    if (jj_2_46(2147483647)) {\n        Modifiers();\n        Type();\n        jj_consume_token(IDENTIFIER);\n        jj_consume_token(COLON);\n        Expression();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SYNCHRONIZED :\n            case THIS :\n            case TRANSIENT :\n            case TRUE :\n            case VOID :\n            case VOLATILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NATIVE :\n                    case NEW :\n                    case NULL :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SUPER :\n                    case SYNCHRONIZED :\n                    case THIS :\n                    case TRANSIENT :\n                    case TRUE :\n                    case VOID :\n                    case VOLATILE :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case AT :\n                    case INCR :\n                    case DECR :\n                        ForInit();\n                        break;\n                    default :\n                        jj_la1[149] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case BANG :\n                    case TILDE :\n                    case INCR :\n                    case DECR :\n                    case PLUS :\n                    case MINUS :\n                        Expression();\n                        break;\n                    default :\n                        jj_la1[150] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case INCR :\n                    case DECR :\n                        ForUpdate();\n                        break;\n                    default :\n                        jj_la1[151] = jj_gen;\n                }\n                break;\n            default :\n                jj_la1[152] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n    jj_consume_token(RPAREN);\n    Statement();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void ForStatement() throws ParseException {\n    jj_consume_token(FOR);\n    jj_consume_token(LPAREN);\n    if (jj_2_45(2147483647)) {\n        Modifiers();\n        Type();\n        jj_consume_token(IDENTIFIER);\n        jj_consume_token(COLON);\n        Expression();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SYNCHRONIZED :\n            case THIS :\n            case TRANSIENT :\n            case TRUE :\n            case VOID :\n            case VOLATILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NATIVE :\n                    case NEW :\n                    case NULL :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SUPER :\n                    case SYNCHRONIZED :\n                    case THIS :\n                    case TRANSIENT :\n                    case TRUE :\n                    case VOID :\n                    case VOLATILE :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case AT :\n                    case INCR :\n                    case DECR :\n                        ForInit();\n                        break;\n                    default :\n                        jj_la1[150] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case BANG :\n                    case TILDE :\n                    case INCR :\n                    case DECR :\n                    case PLUS :\n                    case MINUS :\n                        Expression();\n                        break;\n                    default :\n                        jj_la1[151] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case INCR :\n                    case DECR :\n                        ForUpdate();\n                        break;\n                    default :\n                        jj_la1[152] = jj_gen;\n                }\n                break;\n            default :\n                jj_la1[153] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n    jj_consume_token(RPAREN);\n    Statement();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}, {"methodBefore": "public final void ForStatement() throws ParseException {\n    jj_consume_token(FOR);\n    jj_consume_token(LPAREN);\n    if (jj_2_46(2147483647)) {\n        Modifiers();\n        Type();\n        jj_consume_token(IDENTIFIER);\n        jj_consume_token(COLON);\n        Expression();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SYNCHRONIZED :\n            case THIS :\n            case TRANSIENT :\n            case TRUE :\n            case VOID :\n            case VOLATILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NATIVE :\n                    case NEW :\n                    case NULL :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SUPER :\n                    case SYNCHRONIZED :\n                    case THIS :\n                    case TRANSIENT :\n                    case TRUE :\n                    case VOID :\n                    case VOLATILE :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case AT :\n                    case INCR :\n                    case DECR :\n                        ForInit();\n                        break;\n                    default :\n                        jj_la1[149] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case BANG :\n                    case TILDE :\n                    case INCR :\n                    case DECR :\n                    case PLUS :\n                    case MINUS :\n                        Expression();\n                        break;\n                    default :\n                        jj_la1[150] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case INCR :\n                    case DECR :\n                        ForUpdate();\n                        break;\n                    default :\n                        jj_la1[151] = jj_gen;\n                }\n                break;\n            default :\n                jj_la1[152] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n    jj_consume_token(RPAREN);\n    Statement();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void ForStatement() throws ParseException {\n    jj_consume_token(FOR);\n    jj_consume_token(LPAREN);\n    if (jj_2_45(2147483647)) {\n        Modifiers();\n        Type();\n        jj_consume_token(IDENTIFIER);\n        jj_consume_token(COLON);\n        Expression();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SYNCHRONIZED :\n            case THIS :\n            case TRANSIENT :\n            case TRUE :\n            case VOID :\n            case VOLATILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NATIVE :\n                    case NEW :\n                    case NULL :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SUPER :\n                    case SYNCHRONIZED :\n                    case THIS :\n                    case TRANSIENT :\n                    case TRUE :\n                    case VOID :\n                    case VOLATILE :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case AT :\n                    case INCR :\n                    case DECR :\n                        ForInit();\n                        break;\n                    default :\n                        jj_la1[150] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case BANG :\n                    case TILDE :\n                    case INCR :\n                    case DECR :\n                    case PLUS :\n                    case MINUS :\n                        Expression();\n                        break;\n                    default :\n                        jj_la1[151] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                    case INCR :\n                    case DECR :\n                        ForUpdate();\n                        break;\n                    default :\n                        jj_la1[152] = jj_gen;\n                }\n                break;\n            default :\n                jj_la1[153] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n    jj_consume_token(RPAREN);\n    Statement();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}], [{"methodBefore": "private boolean jj_3R_439() {\n    if (jj_scan_token(FINALLY)) {\n        return true;\n    }\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_443() {\n    if (jj_scan_token(FINALLY)) {\n        return true;\n    }\n    if (jj_3R_145()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_439() {\n    if (jj_scan_token(FINALLY)) {\n        return true;\n    }\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_443() {\n    if (jj_scan_token(FINALLY)) {\n        return true;\n    }\n    if (jj_3R_145()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_380() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_383() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_380() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_383() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_10() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_10() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_10() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_10() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_424() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_430() {\n    if (jj_3R_432()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_424() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_430() {\n    if (jj_3R_432()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void testLineCoverage() {\n    assertEquals(0, a.getNumberOfCoveredLines());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(2, b.getNumberOfCoveredLines());\n    assertEquals(5, b.getNumberOfValidLines());\n    assertEquals(0, c.getNumberOfCoveredLines());\n    assertEquals(5, c.getNumberOfValidLines());\n    assertEquals(1.0, a.getLineCoverageRate(), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, b.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, c.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n}", "methodAfter": "@Test\npublic void testLineCoverage() {\n    assertEquals(0, a.getNumberOfCoveredLines());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(2, b.getNumberOfCoveredLines());\n    assertEquals(5, b.getNumberOfValidLines());\n    assertEquals(0, c.getNumberOfCoveredLines());\n    assertEquals(5, c.getNumberOfValidLines());\n    assertEquals(1.0, a.getLineCoverageRate(), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, b.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, c.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n}"}, {"methodBefore": "public void testBranchCoverage() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(1.0, a.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, a.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.addLineJump(1, 0);\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 3, Integer.MAX_VALUE);\n    c.addLineSwitch(4, 0, 1, 3, Integer.MAX_VALUE);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(0, c.getNumberOfCoveredBranches());\n    assertEquals(0.0, c.getBranchCoverageRate(), 0.0);\n    assertEquals(0.0, c.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.touchJump(1, 0, true, 1);\n    c.touchJump(1, 0, false, 1);\n    c.touchJump(2, 0, true, 1);\n    c.touchJump(2, 0, false, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(4, c.getNumberOfCoveredBranches());\n    assertEquals(0.33, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.33, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n    c.touchSwitch(3, 0, 0, 1);\n    c.touchSwitch(3, 0, 1, 1);\n    c.touchSwitch(4, 0, 2, 1);\n    c.touchSwitch(4, 0, -1, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(8, c.getNumberOfCoveredBranches());\n    assertEquals(0.66, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.66, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n}", "methodAfter": "@Test\npublic void testBranchCoverage() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(1.0, a.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, a.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.addLineJump(1, 0);\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 3, Integer.MAX_VALUE);\n    c.addLineSwitch(4, 0, 1, 3, Integer.MAX_VALUE);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(0, c.getNumberOfCoveredBranches());\n    assertEquals(0.0, c.getBranchCoverageRate(), 0.0);\n    assertEquals(0.0, c.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.touchJump(1, 0, true, 1);\n    c.touchJump(1, 0, false, 1);\n    c.touchJump(2, 0, true, 1);\n    c.touchJump(2, 0, false, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(4, c.getNumberOfCoveredBranches());\n    assertEquals(0.33, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.33, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n    c.touchSwitch(3, 0, 0, 1);\n    c.touchSwitch(3, 0, 1, 1);\n    c.touchSwitch(4, 0, 2, 1);\n    c.touchSwitch(4, 0, -1, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(8, c.getNumberOfCoveredBranches());\n    assertEquals(0.66, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.66, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n}"}], [{"methodBefore": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(cv2, EXPAND_FRAMES);\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}", "methodAfter": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(new CheckClassAdapter(cv2), SKIP_FRAMES);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        CheckClassAdapter.verify(new ClassReader(cw2.toByteArray()), false, pw);\n        logger.debug(sw.toString());\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}"}, {"methodBefore": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(cv2, EXPAND_FRAMES);\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}", "methodAfter": "public InstrumentationResult instrumentClass(InputStream inputStream) throws IOException {\n    ClassReader cr0 = new ClassReader(inputStream);\n    ClassWriter cw0 = new ClassWriter(0);\n    DetectIgnoredCodeClassVisitor detectIgnoredCv = new DetectIgnoredCodeClassVisitor(cw0, ignoreTrivial, ignoreMethodAnnotations);\n    DetectDuplicatedCodeClassVisitor cv0 = new DetectDuplicatedCodeClassVisitor(detectIgnoredCv);\n    cr0.accept(cv0, 0);\n    ClassReader cr = new ClassReader(cw0.toByteArray());\n    ClassWriter cw = new ClassWriter(0);\n    BuildClassMapClassVisitor cv = new BuildClassMapClassVisitor(cw, ignoreRegexes, cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n    cr.accept(cv, EXPAND_FRAMES);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"=============== Detected duplicated code =============\");\n        Map<Integer, Map<Integer, Integer>> l = cv0.getDuplicatesLinesCollector();\n        for (Map.Entry<Integer, Map<Integer, Integer>> m : l.entrySet()) {\n            if (m.getValue() != null) {\n                for (Map.Entry<Integer, Integer> pair : m.getValue().entrySet()) {\n                    logger.debug((((((cv.getClassMap().getClassName() + \":\") + m.getKey()) + \" \") + pair.getKey()) + \"->\") + pair.getValue());\n                }\n            }\n        }\n        logger.debug(\"=============== End of detected duplicated code ======\");\n    }\n    logger.debug(\"Migrating classmap in projectData to store in *.ser file: \" + cv.getClassMap().getClassName());\n    cv.getClassMap().applyOnProjectData(projectData, cv.shouldBeInstrumented());\n    if (cv.shouldBeInstrumented()) {\n        ClassReader cr2 = new ClassReader(cw0.toByteArray());\n        ClassWriter cw2 = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n        cv.getClassMap().assignCounterIds();\n        logger.debug(((\"Assigned \" + cv.getClassMap().getMaxCounterId()) + \" counters for class:\") + cv.getClassMap().getClassName());\n        InjectCodeClassInstrumenter cv2 = new InjectCodeClassInstrumenter(cw2, ignoreRegexes, threadsafeRigorous, cv.getClassMap(), cv0.getDuplicatesLinesCollector(), detectIgnoredCv.getIgnoredMethodNamesAndSignatures());\n        cr2.accept(new CheckClassAdapter(cv2), SKIP_FRAMES);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        CheckClassAdapter.verify(new ClassReader(cw2.toByteArray()), false, pw);\n        logger.debug(sw.toString());\n        return new InstrumentationResult(cv.getClassMap().getClassName(), cw2.toByteArray());\n    } else {\n        logger.debug(\"Class shouldn't be instrumented: \" + cv.getClassMap().getClassName());\n        return null;\n    }\n}"}], [{"methodBefore": "public void generateCoberturaClassMapMethod(ClassVisitor cv, ClassMap classMap) {\n    LinkedList<TouchPointDescriptor> touchPointDescriptors = new LinkedList<TouchPointDescriptor>(classMap.getTouchPointsInLineOrder());\n    int parts = 0;\n    for (int j = 0; touchPointDescriptors.size() > 0; j++) {\n        List<TouchPointDescriptor> bufor = new LinkedList<TouchPointDescriptor>();\n        for (int i = 0; (i < 1000) && (touchPointDescriptors.size() > 0); i++) {\n            bufor.add(touchPointDescriptors.removeFirst());\n        }\n        classMapContent(cv, j, bufor);\n        parts++;\n    }\n    MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, COBERTURA_CLASSMAP_METHOD_NAME, (\"(\" + Type.getType(LightClassmapListener.class).toString()) + \")V\", null, null);\n    mv.visitCode();\n    mv.visitVarInsn(ALOAD, 0);\n    mv.visitInsn(DUP);\n    mv.visitLdcInsn(Type.getObjectType(classMap.getClassName()));\n    mv.visitMethodInsn(INVOKEINTERFACE, CLASSMAP_LISTENER_INTERNALNAME, \"setClazz\", \"(Ljava/lang/Class;)V\");\n    if (classMap.getSource() != null) {\n        mv.visitInsn(DUP);\n        mv.visitLdcInsn(classMap.getSource());\n        mv.visitMethodInsn(INVOKEINTERFACE, CLASSMAP_LISTENER_INTERNALNAME, \"setSource\", \"(Ljava/lang/String;)V\");\n    }\n    for (int i = 0; i < parts; i++) {\n        mv.visitInsn(DUP);\n        mv.visitMethodInsn(INVOKESTATIC, classMap.getClassName(), (COBERTURA_CLASSMAP_METHOD_NAME + \"_\") + i, (\"(\" + Type.getType(LightClassmapListener.class).toString()) + \")V\");\n    }\n    mv.visitInsn(POP);\n    mv.visitInsn(RETURN);\n    mv.visitMaxs(0, 0);\n    mv.visitEnd();\n}", "methodAfter": "public void generateCoberturaClassMapMethod(ClassVisitor cv, ClassMap classMap) {\n    LinkedList<TouchPointDescriptor> touchPointDescriptors = new LinkedList<TouchPointDescriptor>(classMap.getTouchPointsInLineOrder());\n    int parts = 0;\n    for (int j = 0; touchPointDescriptors.size() > 0; j++) {\n        List<TouchPointDescriptor> bufor = new LinkedList<TouchPointDescriptor>();\n        for (int i = 0; (i < 1000) && (touchPointDescriptors.size() > 0); i++) {\n            bufor.add(touchPointDescriptors.removeFirst());\n        }\n        classMapContent(cv, j, bufor);\n        parts++;\n    }\n    MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, COBERTURA_CLASSMAP_METHOD_NAME, (\"(\" + Type.getType(LightClassmapListener.class).toString()) + \")V\", null, null);\n    mv.visitCode();\n    mv.visitVarInsn(ALOAD, 0);\n    mv.visitInsn(DUP);\n    mv.visitLdcInsn(classMap.getClassName());\n    mv.visitMethodInsn(INVOKEINTERFACE, CLASSMAP_LISTENER_INTERNALNAME, \"setClazz\", \"(Ljava/lang/String;)V\");\n    if (classMap.getSource() != null) {\n        mv.visitInsn(DUP);\n        mv.visitLdcInsn(classMap.getSource());\n        mv.visitMethodInsn(INVOKEINTERFACE, CLASSMAP_LISTENER_INTERNALNAME, \"setSource\", \"(Ljava/lang/String;)V\");\n    }\n    for (int i = 0; i < parts; i++) {\n        mv.visitInsn(DUP);\n        mv.visitMethodInsn(INVOKESTATIC, classMap.getClassName(), (COBERTURA_CLASSMAP_METHOD_NAME + \"_\") + i, (\"(\" + Type.getType(LightClassmapListener.class).toString()) + \")V\");\n    }\n    mv.visitInsn(POP);\n    mv.visitInsn(RETURN);\n    mv.visitMaxs(0, 0);\n    mv.visitEnd();\n}"}, {"methodBefore": "public void generateCoberturaClassMapMethod(ClassVisitor cv, ClassMap classMap) {\n    LinkedList<TouchPointDescriptor> touchPointDescriptors = new LinkedList<TouchPointDescriptor>(classMap.getTouchPointsInLineOrder());\n    int parts = 0;\n    for (int j = 0; touchPointDescriptors.size() > 0; j++) {\n        List<TouchPointDescriptor> bufor = new LinkedList<TouchPointDescriptor>();\n        for (int i = 0; (i < 1000) && (touchPointDescriptors.size() > 0); i++) {\n            bufor.add(touchPointDescriptors.removeFirst());\n        }\n        classMapContent(cv, j, bufor);\n        parts++;\n    }\n    MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, COBERTURA_CLASSMAP_METHOD_NAME, (\"(\" + Type.getType(LightClassmapListener.class).toString()) + \")V\", null, null);\n    mv.visitCode();\n    mv.visitVarInsn(ALOAD, 0);\n    mv.visitInsn(DUP);\n    mv.visitLdcInsn(Type.getObjectType(classMap.getClassName()));\n    mv.visitMethodInsn(INVOKEINTERFACE, CLASSMAP_LISTENER_INTERNALNAME, \"setClazz\", \"(Ljava/lang/Class;)V\");\n    if (classMap.getSource() != null) {\n        mv.visitInsn(DUP);\n        mv.visitLdcInsn(classMap.getSource());\n        mv.visitMethodInsn(INVOKEINTERFACE, CLASSMAP_LISTENER_INTERNALNAME, \"setSource\", \"(Ljava/lang/String;)V\");\n    }\n    for (int i = 0; i < parts; i++) {\n        mv.visitInsn(DUP);\n        mv.visitMethodInsn(INVOKESTATIC, classMap.getClassName(), (COBERTURA_CLASSMAP_METHOD_NAME + \"_\") + i, (\"(\" + Type.getType(LightClassmapListener.class).toString()) + \")V\");\n    }\n    mv.visitInsn(POP);\n    mv.visitInsn(RETURN);\n    mv.visitMaxs(0, 0);\n    mv.visitEnd();\n}", "methodAfter": "public void generateCoberturaClassMapMethod(ClassVisitor cv, ClassMap classMap) {\n    LinkedList<TouchPointDescriptor> touchPointDescriptors = new LinkedList<TouchPointDescriptor>(classMap.getTouchPointsInLineOrder());\n    int parts = 0;\n    for (int j = 0; touchPointDescriptors.size() > 0; j++) {\n        List<TouchPointDescriptor> bufor = new LinkedList<TouchPointDescriptor>();\n        for (int i = 0; (i < 1000) && (touchPointDescriptors.size() > 0); i++) {\n            bufor.add(touchPointDescriptors.removeFirst());\n        }\n        classMapContent(cv, j, bufor);\n        parts++;\n    }\n    MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, COBERTURA_CLASSMAP_METHOD_NAME, (\"(\" + Type.getType(LightClassmapListener.class).toString()) + \")V\", null, null);\n    mv.visitCode();\n    mv.visitVarInsn(ALOAD, 0);\n    mv.visitInsn(DUP);\n    mv.visitLdcInsn(classMap.getClassName());\n    mv.visitMethodInsn(INVOKEINTERFACE, CLASSMAP_LISTENER_INTERNALNAME, \"setClazz\", \"(Ljava/lang/String;)V\");\n    if (classMap.getSource() != null) {\n        mv.visitInsn(DUP);\n        mv.visitLdcInsn(classMap.getSource());\n        mv.visitMethodInsn(INVOKEINTERFACE, CLASSMAP_LISTENER_INTERNALNAME, \"setSource\", \"(Ljava/lang/String;)V\");\n    }\n    for (int i = 0; i < parts; i++) {\n        mv.visitInsn(DUP);\n        mv.visitMethodInsn(INVOKESTATIC, classMap.getClassName(), (COBERTURA_CLASSMAP_METHOD_NAME + \"_\") + i, (\"(\" + Type.getType(LightClassmapListener.class).toString()) + \")V\");\n    }\n    mv.visitInsn(POP);\n    mv.visitInsn(RETURN);\n    mv.visitMaxs(0, 0);\n    mv.visitEnd();\n}"}], [{"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (destDir != null) {\n            builder.addArg(\"--destination\", destDir.getAbsolutePath());\n        }\n        if (format != null) {\n            builder.addArg(\"--format\", format);\n        }\n        if (srcDir != null) {\n            builder.addArg(srcDir);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error running reports. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (destDir != null) {\n            builder.addArg(\"--destination\", destDir.getAbsolutePath());\n        }\n        if (format != null) {\n            builder.addArg(\"--format\", format);\n        }\n        if (srcDir != null) {\n            builder.addArg(srcDir);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error running reports. See messages above.\");\n    }\n    builder.dispose();\n}"}, {"methodBefore": "public void execute() throws BuildException {\n    if (dataFile != null) {\n        getJava().createArg().setValue(\"--datafile\");\n        getJava().createArg().setValue(dataFile);\n    }\n    if (branchRate != null) {\n        getJava().createArg().setValue(\"--branch\");\n        getJava().createArg().setValue(branchRate);\n    }\n    if (lineRate != null) {\n        getJava().createArg().setValue(\"--line\");\n        getJava().createArg().setValue(lineRate);\n    }\n    if (packageBranchRate != null) {\n        getJava().createArg().setValue(\"--packagebranch\");\n        getJava().createArg().setValue(packageBranchRate);\n    }\n    if (packageLineRate != null) {\n        getJava().createArg().setValue(\"--packageline\");\n        getJava().createArg().setValue(packageLineRate);\n    }\n    if (totalBranchRate != null) {\n        getJava().createArg().setValue(\"--totalbranch\");\n        getJava().createArg().setValue(totalBranchRate);\n    }\n    if (totalLineRate != null) {\n        getJava().createArg().setValue(\"--totalline\");\n        getJava().createArg().setValue(totalLineRate);\n    }\n    Iterator iter = regexes.iterator();\n    while (iter.hasNext()) {\n        getJava().createArg().setValue(\"--regex\");\n        getJava().createArg().setValue(iter.next().toString());\n    } \n    int returnCode = getJava().executeJava();\n    if (returnCode == 0) {\n        System.out.println(\"All checks passed.\");\n    } else if (haltOnFailure) {\n        throw new BuildException(\"Coverage check failed. See messages above.\");\n    } else if (failureProperty != null) {\n        getProject().setProperty(failureProperty, \"true\");\n    } else {\n        System.err.println(\"Coverage check failed. See messages above.\");\n    }\n}", "methodAfter": "public void execute() throws BuildException {\n    if (dataFile != null) {\n        getJava().createArg().setValue(\"--datafile\");\n        getJava().createArg().setValue(dataFile);\n    }\n    if (branchRate != null) {\n        getJava().createArg().setValue(\"--branch\");\n        getJava().createArg().setValue(branchRate);\n    }\n    if (lineRate != null) {\n        getJava().createArg().setValue(\"--line\");\n        getJava().createArg().setValue(lineRate);\n    }\n    if (packageBranchRate != null) {\n        getJava().createArg().setValue(\"--packagebranch\");\n        getJava().createArg().setValue(packageBranchRate);\n    }\n    if (packageLineRate != null) {\n        getJava().createArg().setValue(\"--packageline\");\n        getJava().createArg().setValue(packageLineRate);\n    }\n    if (totalBranchRate != null) {\n        getJava().createArg().setValue(\"--totalbranch\");\n        getJava().createArg().setValue(totalBranchRate);\n    }\n    if (totalLineRate != null) {\n        getJava().createArg().setValue(\"--totalline\");\n        getJava().createArg().setValue(totalLineRate);\n    }\n    Iterator iter = regexes.iterator();\n    while (iter.hasNext()) {\n        getJava().createArg().setValue(\"--regex\");\n        getJava().createArg().setValue(iter.next().toString());\n    } \n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    int returnCode = getJava().executeJava();\n    if (returnCode == 0) {\n        System.out.println(\"All checks passed.\");\n    } else if (haltOnFailure) {\n        throw new BuildException(\"Coverage check failed. See messages above.\");\n    } else if (failureProperty != null) {\n        getProject().setProperty(failureProperty, \"true\");\n    } else {\n        System.err.println(\"Coverage check failed. See messages above.\");\n    }\n}"}, {"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error running reports. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error running reports. See messages above.\");\n    }\n    builder.dispose();\n}"}], [{"methodBefore": "public final void FormalParameter15() throws ParseException {\n    Modifiers();\n    Type();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ELLIPSIS :\n            jj_consume_token(ELLIPSIS);\n            break;\n        default :\n            jj_la1[201] = jj_gen;\n    }\n    VariableDeclaratorId();\n}", "methodAfter": "public final void FormalParameter15() throws ParseException {\n    Modifiers();\n    Type();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ELLIPSIS :\n            jj_consume_token(ELLIPSIS);\n            break;\n        default :\n            jj_la1[207] = jj_gen;\n    }\n    VariableDeclaratorId();\n}"}, {"methodBefore": "public final void FormalParameter15() throws ParseException {\n    Modifiers();\n    Type();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ELLIPSIS :\n            jj_consume_token(ELLIPSIS);\n            break;\n        default :\n            jj_la1[201] = jj_gen;\n    }\n    VariableDeclaratorId();\n}", "methodAfter": "public final void FormalParameter15() throws ParseException {\n    Modifiers();\n    Type();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ELLIPSIS :\n            jj_consume_token(ELLIPSIS);\n            break;\n        default :\n            jj_la1[207] = jj_gen;\n    }\n    VariableDeclaratorId();\n}"}], [{"methodBefore": "private boolean jj_3R_292() {\n    if (jj_scan_token(BIT_AND)) {\n        return true;\n    }\n    if (jj_3R_288()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_292() {\n    if (jj_scan_token(BIT_AND)) {\n        return true;\n    }\n    if (jj_3R_284()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_292() {\n    if (jj_scan_token(BIT_AND)) {\n        return true;\n    }\n    if (jj_3R_288()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_292() {\n    if (jj_scan_token(BIT_AND)) {\n        return true;\n    }\n    if (jj_3R_284()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_354() {\n    if (jj_scan_token(EXTENDS)) {\n        return true;\n    }\n    if (jj_3R_363()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_357() {\n    if (jj_scan_token(EXTENDS)) {\n        return true;\n    }\n    if (jj_3R_366()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_354() {\n    if (jj_scan_token(EXTENDS)) {\n        return true;\n    }\n    if (jj_3R_363()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_357() {\n    if (jj_scan_token(EXTENDS)) {\n        return true;\n    }\n    if (jj_3R_366()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_241() {\n    if (jj_3R_262()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_212() {\n    if (jj_3R_226()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_241() {\n    if (jj_3R_262()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_212() {\n    if (jj_3R_226()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_103() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_152()) {\n        jj_scanpos = xsp;\n        if (jj_3R_153()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_104() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_152()) {\n        jj_scanpos = xsp;\n        if (jj_3R_153()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_103() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_152()) {\n        jj_scanpos = xsp;\n        if (jj_3R_153()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_104() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_152()) {\n        jj_scanpos = xsp;\n        if (jj_3R_153()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_102() {\n    if (jj_3R_151()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_32()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_106() {\n    if (jj_3R_154()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_31()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_102() {\n    if (jj_3R_151()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_32()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_106() {\n    if (jj_3R_154()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_31()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "public static void main(String[] args) {\n    Copyright.print(System.out);\n    System.out.println(\"Cobertura instrumentation merge tool\");\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufreader = null;\n        try {\n            bufreader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufreader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufreader != null) {\n                try {\n                    bufreader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    new Main(args);\n}", "methodAfter": "public static void main(String[] args) {\n    Header.print(System.out);\n    System.out.println(\"Cobertura instrumentation merge tool\");\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufreader = null;\n        try {\n            bufreader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufreader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufreader != null) {\n                try {\n                    bufreader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    new Main(args);\n}"}, {"methodBefore": "public Main(String[] args) throws IOException {\n    Copyright.print(System.out);\n    System.out.println(\"Cobertura coverage check\");\n    LongOpt[] longOpts = new LongOpt[4];\n    longOpts[0] = new LongOpt(\"branch\", LongOpt.REQUIRED_ARGUMENT, null, 'b');\n    longOpts[1] = new LongOpt(\"line\", LongOpt.REQUIRED_ARGUMENT, null, 'l');\n    longOpts[2] = new LongOpt(\"directory\", LongOpt.REQUIRED_ARGUMENT, null, 'd');\n    longOpts[3] = new LongOpt(\"regex\", LongOpt.REQUIRED_ARGUMENT, null, 'r');\n    Getopt g = new Getopt(getClass().getName(), args, \":b:l:d:r:\", longOpts);\n    int c;\n    double branchCoverageRate = 0.8;\n    double lineCoverageRate = 0.7;\n    while ((c = g.getopt()) != (-1)) {\n        switch (c) {\n            case 'b' :\n                branchCoverageRate = inRangeAndDivideByOneHundred(g.getOptarg());\n                break;\n            case 'l' :\n                lineCoverageRate = inRangeAndDivideByOneHundred(g.getOptarg());\n                break;\n            case 'd' :\n                setInstrumentationDirectory(new File(g.getOptarg()));\n                break;\n            case 'r' :\n                setMinimumCoverageRate(g.getOptarg());\n                break;\n        }\n    } \n    minimumCoverageRate = new CoverageRate(lineCoverageRate, branchCoverageRate);\n    if (logger.isInfoEnabled()) {\n        logger.info(\"instrumentation directory: \" + instrumentationDirectory);\n    }\n    merge(loadInstrumentation(new FileInputStream(new File(instrumentationDirectory, InstrumentationPersistence.FILE_NAME))));\n    if (logger.isInfoEnabled()) {\n        logger.info((\"instrumentation has \" + keySet().size()) + \" entries\");\n    }\n    Iterator i = keySet().iterator();\n    while (i.hasNext()) {\n        String key = ((String) (i.next()));\n        CoverageRate coverageRate = findMinimumCoverageRate(key);\n        CoverageData instrumentation = getInstrumentation(key);\n        if (logger.isInfoEnabled()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\", line: \");\n            sb.append(percentage(instrumentation.getLineCoverageRate()));\n            sb.append(\"% (\");\n            sb.append(percentage(coverageRate.getLineCoverageRate()));\n            sb.append(\"%), branch: \");\n            sb.append(percentage(instrumentation.getBranchCoverageRate()));\n            sb.append(\"% (\");\n            sb.append(percentage(coverageRate.getBranchCoverageRate()));\n            sb.append(\"%)\");\n            logger.info(sb.toString());\n        }\n        if (instrumentation.getLineCoverageRate() < coverageRate.getLineCoverageRate()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\" line coverage rate of: \");\n            sb.append(percentage(instrumentation.getLineCoverageRate()));\n            sb.append(\"% (required: \");\n            sb.append(percentage(coverageRate.getLineCoverageRate()));\n            sb.append(\"%)\");\n            System.out.println(sb.toString());\n        }\n        if (instrumentation.getBranchCoverageRate() < coverageRate.getBranchCoverageRate()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\" branch coverage rate of: \");\n            sb.append(percentage(instrumentation.getBranchCoverageRate()));\n            sb.append(\"% (required: \");\n            sb.append(percentage(coverageRate.getBranchCoverageRate()));\n            sb.append(\"%)\");\n            System.out.println(sb.toString());\n        }\n    } \n}", "methodAfter": "public Main(String[] args) throws IOException {\n    Header.print(System.out);\n    System.out.println(\"Cobertura coverage check\");\n    LongOpt[] longOpts = new LongOpt[4];\n    longOpts[0] = new LongOpt(\"branch\", LongOpt.REQUIRED_ARGUMENT, null, 'b');\n    longOpts[1] = new LongOpt(\"line\", LongOpt.REQUIRED_ARGUMENT, null, 'l');\n    longOpts[2] = new LongOpt(\"directory\", LongOpt.REQUIRED_ARGUMENT, null, 'd');\n    longOpts[3] = new LongOpt(\"regex\", LongOpt.REQUIRED_ARGUMENT, null, 'r');\n    Getopt g = new Getopt(getClass().getName(), args, \":b:l:d:r:\", longOpts);\n    int c;\n    double branchCoverageRate = 0.8;\n    double lineCoverageRate = 0.7;\n    while ((c = g.getopt()) != (-1)) {\n        switch (c) {\n            case 'b' :\n                branchCoverageRate = inRangeAndDivideByOneHundred(g.getOptarg());\n                break;\n            case 'l' :\n                lineCoverageRate = inRangeAndDivideByOneHundred(g.getOptarg());\n                break;\n            case 'd' :\n                setInstrumentationDirectory(new File(g.getOptarg()));\n                break;\n            case 'r' :\n                setMinimumCoverageRate(g.getOptarg());\n                break;\n        }\n    } \n    minimumCoverageRate = new CoverageRate(lineCoverageRate, branchCoverageRate);\n    if (logger.isInfoEnabled()) {\n        logger.info(\"instrumentation directory: \" + instrumentationDirectory);\n    }\n    merge(loadInstrumentation(new FileInputStream(new File(instrumentationDirectory, InstrumentationPersistence.FILE_NAME))));\n    if (logger.isInfoEnabled()) {\n        logger.info((\"instrumentation has \" + keySet().size()) + \" entries\");\n    }\n    Iterator i = keySet().iterator();\n    while (i.hasNext()) {\n        String key = ((String) (i.next()));\n        CoverageRate coverageRate = findMinimumCoverageRate(key);\n        CoverageData instrumentation = getInstrumentation(key);\n        if (logger.isInfoEnabled()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\", line: \");\n            sb.append(percentage(instrumentation.getLineCoverageRate()));\n            sb.append(\"% (\");\n            sb.append(percentage(coverageRate.getLineCoverageRate()));\n            sb.append(\"%), branch: \");\n            sb.append(percentage(instrumentation.getBranchCoverageRate()));\n            sb.append(\"% (\");\n            sb.append(percentage(coverageRate.getBranchCoverageRate()));\n            sb.append(\"%)\");\n            logger.info(sb.toString());\n        }\n        if (instrumentation.getLineCoverageRate() < coverageRate.getLineCoverageRate()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\" line coverage rate of: \");\n            sb.append(percentage(instrumentation.getLineCoverageRate()));\n            sb.append(\"% (required: \");\n            sb.append(percentage(coverageRate.getLineCoverageRate()));\n            sb.append(\"%)\");\n            System.out.println(sb.toString());\n        }\n        if (instrumentation.getBranchCoverageRate() < coverageRate.getBranchCoverageRate()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\" branch coverage rate of: \");\n            sb.append(percentage(instrumentation.getBranchCoverageRate()));\n            sb.append(\"% (required: \");\n            sb.append(percentage(coverageRate.getBranchCoverageRate()));\n            sb.append(\"%)\");\n            System.out.println(sb.toString());\n        }\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_409() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_412() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_409() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_412() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_375() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_375() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_375() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_375() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_120() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_123() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_120() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_123() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_366() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_374() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_366() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_374() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_228() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_42()) {\n        jj_scanpos = xsp;\n        if (jj_3R_255()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_230() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_41()) {\n        jj_scanpos = xsp;\n        if (jj_3R_256()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_228() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_42()) {\n        jj_scanpos = xsp;\n        if (jj_3R_255()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_230() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_41()) {\n        jj_scanpos = xsp;\n        if (jj_3R_256()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_230() {\n    if (jj_3R_228()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_215() {\n    if (jj_3R_229()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_230() {\n    if (jj_3R_228()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_215() {\n    if (jj_3R_229()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "JumpData(int conditionNumber) {\n    super();\n    this.conditionNumber = conditionNumber;\n    this.trueHits = 0L;\n    this.falseHits = 0L;\n}", "methodAfter": "JumpData(int conditionNumber) {\n    super();\n    this.conditionNumber = conditionNumber;\n    this.trueHits = 0L;\n    this.falseHits = 0L;\n    initLock();\n}"}, {"methodBefore": "public SwitchData(int switchNumber, int[] keys) {\n    super();\n    this.switchNumber = switchNumber;\n    defaultHits = 0;\n    hits = new long[keys.length];\n    Arrays.fill(hits, 0);\n    this.keys = new int[keys.length];\n    System.arraycopy(keys, 0, this.keys, 0, keys.length);\n}", "methodAfter": "public SwitchData(int switchNumber, int[] keys) {\n    super();\n    this.switchNumber = switchNumber;\n    defaultHits = 0;\n    hits = new long[keys.length];\n    Arrays.fill(hits, 0);\n    this.keys = new int[keys.length];\n    System.arraycopy(keys, 0, this.keys, 0, keys.length);\n    initLock();\n}"}, {"methodBefore": "LineData(int lineNumber, String methodName, String methodDescriptor) {\n    this.hits = 0;\n    this.jumps = null;\n    this.lineNumber = lineNumber;\n    this.methodName = methodName;\n    this.methodDescriptor = methodDescriptor;\n}", "methodAfter": "LineData(int lineNumber, String methodName, String methodDescriptor) {\n    this.hits = 0;\n    this.jumps = null;\n    this.lineNumber = lineNumber;\n    this.methodName = methodName;\n    this.methodDescriptor = methodDescriptor;\n    initLock();\n}"}], [{"methodBefore": "public final void MethodDeclarator15() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    FormalParameters();\n    label_79 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                break;\n            default :\n                jj_la1[198] = jj_gen;\n                break label_79;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n}", "methodAfter": "public final void MethodDeclarator15() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    FormalParameters();\n    label_83 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                break;\n            default :\n                jj_la1[204] = jj_gen;\n                break label_83;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n}"}, {"methodBefore": "public final void MethodDeclarator15() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    FormalParameters();\n    label_79 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                break;\n            default :\n                jj_la1[198] = jj_gen;\n                break label_79;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n}", "methodAfter": "public final void MethodDeclarator15() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    FormalParameters();\n    label_83 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                break;\n            default :\n                jj_la1[204] = jj_gen;\n                break label_83;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_233() {\n    if (jj_3R_257()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_236() {\n    if (jj_3R_259()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_233() {\n    if (jj_3R_257()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_236() {\n    if (jj_3R_259()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void BreakStatement() throws ParseException {\n    jj_consume_token(BREAK);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case IDENTIFIER :\n            Identifier();\n            break;\n        default :\n            jj_la1[155] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void BreakStatement() throws ParseException {\n    jj_consume_token(BREAK);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case IDENTIFIER :\n            Identifier();\n            break;\n        default :\n            jj_la1[156] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}, {"methodBefore": "public final void BreakStatement() throws ParseException {\n    jj_consume_token(BREAK);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case IDENTIFIER :\n            Identifier();\n            break;\n        default :\n            jj_la1[155] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void BreakStatement() throws ParseException {\n    jj_consume_token(BREAK);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case IDENTIFIER :\n            Identifier();\n            break;\n        default :\n            jj_la1[156] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}], [{"methodBefore": "private boolean jj_3_41() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_40() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_41() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_40() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void PostfixLookahead() throws ParseException {\n    jj_consume_token(LPAREN);\n    Name();\n    label_50 : while (true) {\n        if (jj_2_30(2)) {\n        } else {\n            break label_50;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n    jj_consume_token(DOT);\n}", "methodAfter": "public final void PostfixLookahead() throws ParseException {\n    jj_consume_token(LPAREN);\n    Name();\n    label_51 : while (true) {\n        if (jj_2_29(2)) {\n        } else {\n            break label_51;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n    jj_consume_token(DOT);\n}"}, {"methodBefore": "public final void PostfixLookahead() throws ParseException {\n    jj_consume_token(LPAREN);\n    Name();\n    label_50 : while (true) {\n        if (jj_2_30(2)) {\n        } else {\n            break label_50;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n    jj_consume_token(DOT);\n}", "methodAfter": "public final void PostfixLookahead() throws ParseException {\n    jj_consume_token(LPAREN);\n    Name();\n    label_51 : while (true) {\n        if (jj_2_29(2)) {\n        } else {\n            break label_51;\n        }\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } \n    jj_consume_token(DOT);\n}"}], [{"methodBefore": "public final void AllocationExpression() throws ParseException {\n    String sOldClass = _sClass;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    String sName;\n    int oldJavadocs = _javadocs;\n    int oldNcss = _ncss;\n    if (jj_2_39(2)) {\n        jj_consume_token(NEW);\n        PrimitiveType();\n        ArrayDimsAndInits();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case NEW :\n                jj_consume_token(NEW);\n                Name();\n                sName = _sName;\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LT :\n                        TypeArguments();\n                        break;\n                    default :\n                        jj_la1[131] = jj_gen;\n                }\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET :\n                        ArrayDimsAndInits();\n                        break;\n                    case LPAREN :\n                        Arguments();\n                        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                            case LBRACE :\n                                if (!_sClass.equals(\"\")) {\n                                    _sClass += \".\";\n                                }\n                                _sClass += sName;\n                                _classLevel++;\n                                ClassBody();\n                                ObjectMetric metric = new ObjectMetric();\n                                metric.name = _sPackage + _sClass;\n                                metric.ncss = _ncss - oldNcss;\n                                metric.functions = _functions - oldFunctions;\n                                metric.classes = _classes - oldClasses;\n                                Token lastToken = getToken(0);\n                                _vClasses.add(metric);\n                                _pPackageMetric.functions += _functions - oldFunctions;\n                                _pPackageMetric.classes++;\n                                metric.javadocs = _javadocs - oldJavadocs;\n                                _classLevel--;\n                                _functions = oldFunctions;\n                                _classes = oldClasses + 1;\n                                _sClass = sOldClass;\n                                break;\n                            default :\n                                jj_la1[132] = jj_gen;\n                        }\n                        break;\n                    default :\n                        jj_la1[133] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                break;\n            default :\n                jj_la1[134] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void AllocationExpression() throws ParseException {\n    String sOldClass = _sClass;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    String sName;\n    if (jj_2_38(2)) {\n        jj_consume_token(NEW);\n        PrimitiveType();\n        ArrayDimsAndInits();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case NEW :\n                jj_consume_token(NEW);\n                Name();\n                sName = _sName;\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LT :\n                        TypeArguments();\n                        break;\n                    default :\n                        jj_la1[132] = jj_gen;\n                }\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET :\n                        ArrayDimsAndInits();\n                        break;\n                    case LPAREN :\n                        Arguments();\n                        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                            case LBRACE :\n                                if (!_sClass.equals(\"\")) {\n                                    _sClass += \".\";\n                                }\n                                _sClass += (sName + \"$\") + _anonClassCount;\n                                _classLevel++;\n                                ClassBody();\n                                _classLevel--;\n                                _functions = oldFunctions;\n                                _classes = oldClasses + 1;\n                                _sClass = sOldClass;\n                                break;\n                            default :\n                                jj_la1[133] = jj_gen;\n                        }\n                        break;\n                    default :\n                        jj_la1[134] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                break;\n            default :\n                jj_la1[135] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}, {"methodBefore": "public final void AllocationExpression() throws ParseException {\n    String sOldClass = _sClass;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    String sName;\n    int oldJavadocs = _javadocs;\n    int oldNcss = _ncss;\n    if (jj_2_39(2)) {\n        jj_consume_token(NEW);\n        PrimitiveType();\n        ArrayDimsAndInits();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case NEW :\n                jj_consume_token(NEW);\n                Name();\n                sName = _sName;\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LT :\n                        TypeArguments();\n                        break;\n                    default :\n                        jj_la1[131] = jj_gen;\n                }\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET :\n                        ArrayDimsAndInits();\n                        break;\n                    case LPAREN :\n                        Arguments();\n                        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                            case LBRACE :\n                                if (!_sClass.equals(\"\")) {\n                                    _sClass += \".\";\n                                }\n                                _sClass += sName;\n                                _classLevel++;\n                                ClassBody();\n                                ObjectMetric metric = new ObjectMetric();\n                                metric.name = _sPackage + _sClass;\n                                metric.ncss = _ncss - oldNcss;\n                                metric.functions = _functions - oldFunctions;\n                                metric.classes = _classes - oldClasses;\n                                Token lastToken = getToken(0);\n                                _vClasses.add(metric);\n                                _pPackageMetric.functions += _functions - oldFunctions;\n                                _pPackageMetric.classes++;\n                                metric.javadocs = _javadocs - oldJavadocs;\n                                _classLevel--;\n                                _functions = oldFunctions;\n                                _classes = oldClasses + 1;\n                                _sClass = sOldClass;\n                                break;\n                            default :\n                                jj_la1[132] = jj_gen;\n                        }\n                        break;\n                    default :\n                        jj_la1[133] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                break;\n            default :\n                jj_la1[134] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void AllocationExpression() throws ParseException {\n    String sOldClass = _sClass;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    String sName;\n    if (jj_2_38(2)) {\n        jj_consume_token(NEW);\n        PrimitiveType();\n        ArrayDimsAndInits();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case NEW :\n                jj_consume_token(NEW);\n                Name();\n                sName = _sName;\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LT :\n                        TypeArguments();\n                        break;\n                    default :\n                        jj_la1[132] = jj_gen;\n                }\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET :\n                        ArrayDimsAndInits();\n                        break;\n                    case LPAREN :\n                        Arguments();\n                        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                            case LBRACE :\n                                if (!_sClass.equals(\"\")) {\n                                    _sClass += \".\";\n                                }\n                                _sClass += (sName + \"$\") + _anonClassCount;\n                                _classLevel++;\n                                ClassBody();\n                                _classLevel--;\n                                _functions = oldFunctions;\n                                _classes = oldClasses + 1;\n                                _sClass = sOldClass;\n                                break;\n                            default :\n                                jj_la1[133] = jj_gen;\n                        }\n                        break;\n                    default :\n                        jj_la1[134] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                break;\n            default :\n                jj_la1[135] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_135() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_351() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_135() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_351() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_286() {\n    if (jj_3R_100()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_17()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_289() {\n    if (jj_3R_104()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_17()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_286() {\n    if (jj_3R_100()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_17()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_289() {\n    if (jj_3R_104()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_17()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "public final void MemberValueArrayInitializer() throws ParseException {\n    jj_consume_token(LBRACE);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case LBRACE :\n        case AT :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            MemberValue();\n            break;\n        default :\n            jj_la1[165] = jj_gen;\n    }\n    label_63 : while (true) {\n        if (jj_2_50(2)) {\n        } else {\n            break label_63;\n        }\n        jj_consume_token(COMMA);\n        MemberValue();\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[166] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void MemberValueArrayInitializer() throws ParseException {\n    jj_consume_token(LBRACE);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case LBRACE :\n        case AT :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            MemberValue();\n            break;\n        default :\n            jj_la1[170] = jj_gen;\n    }\n    label_66 : while (true) {\n        if (jj_2_49(2)) {\n        } else {\n            break label_66;\n        }\n        jj_consume_token(COMMA);\n        MemberValue();\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[171] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}"}, {"methodBefore": "public final void MemberValueArrayInitializer() throws ParseException {\n    jj_consume_token(LBRACE);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case LBRACE :\n        case AT :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            MemberValue();\n            break;\n        default :\n            jj_la1[165] = jj_gen;\n    }\n    label_63 : while (true) {\n        if (jj_2_50(2)) {\n        } else {\n            break label_63;\n        }\n        jj_consume_token(COMMA);\n        MemberValue();\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[166] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void MemberValueArrayInitializer() throws ParseException {\n    jj_consume_token(LBRACE);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case LBRACE :\n        case AT :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            MemberValue();\n            break;\n        default :\n            jj_la1[170] = jj_gen;\n    }\n    label_66 : while (true) {\n        if (jj_2_49(2)) {\n        } else {\n            break label_66;\n        }\n        jj_consume_token(COMMA);\n        MemberValue();\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[171] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}"}], [{"methodBefore": "private Cobertura() {\n}", "methodAfter": "private Cobertura() {\n    report = new CompositeReport();\n}"}, {"methodBefore": "public Cobertura(Arguments arguments) {\n    args = arguments;\n    instrumentationTask = new CodeInstrumentationTask();\n    checkCoverageTask = new CheckCoverageTask();\n    mergeProjectDataFilesTask = new MergeProjectDataFilesTask();\n    didApplyInstrumentationResults = new AtomicBoolean(false);\n}", "methodAfter": "public Cobertura(Arguments arguments) {\n    report = new CompositeReport();\n    args = arguments;\n    instrumentationTask = new CodeInstrumentationTask();\n    checkCoverageTask = new CheckCoverageTask();\n    mergeProjectDataFilesTask = new MergeProjectDataFilesTask();\n    didApplyInstrumentationResults = new AtomicBoolean(false);\n}"}], [{"methodBefore": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_68 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[173] = jj_gen;\n                break label_68;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}"}, {"methodBefore": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_68 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[173] = jj_gen;\n                break label_68;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}"}], [{"methodBefore": "private boolean jj_3R_324() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_323() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_324() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_323() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_426() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_426() {\n    if (jj_3R_414()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_426() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_426() {\n    if (jj_3R_414()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_148() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_148() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_148() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_148() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void TypeArguments() throws ParseException {\n    jj_consume_token(LT);\n    TypeArgument();\n    label_75 : while (true) {\n        if (jj_2_60(2)) {\n        } else {\n            break label_75;\n        }\n        jj_consume_token(COMMA);\n        TypeArgument();\n    } \n    jj_consume_token(GT);\n}", "methodAfter": "public final void TypeArguments() throws ParseException {\n    jj_consume_token(LT);\n    label_78 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case SHORT :\n            case IDENTIFIER :\n            case HOOK :\n                break;\n            default :\n                jj_la1[198] = jj_gen;\n                break label_78;\n        }\n        TypeArgument();\n        label_79 : while (true) {\n            if (jj_2_59(2)) {\n            } else {\n                break label_79;\n            }\n            jj_consume_token(COMMA);\n            TypeArgument();\n        } \n    } \n    jj_consume_token(GT);\n}"}, {"methodBefore": "public final void TypeArguments() throws ParseException {\n    jj_consume_token(LT);\n    TypeArgument();\n    label_75 : while (true) {\n        if (jj_2_60(2)) {\n        } else {\n            break label_75;\n        }\n        jj_consume_token(COMMA);\n        TypeArgument();\n    } \n    jj_consume_token(GT);\n}", "methodAfter": "public final void TypeArguments() throws ParseException {\n    jj_consume_token(LT);\n    label_78 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case SHORT :\n            case IDENTIFIER :\n            case HOOK :\n                break;\n            default :\n                jj_la1[198] = jj_gen;\n                break label_78;\n        }\n        TypeArgument();\n        label_79 : while (true) {\n            if (jj_2_59(2)) {\n            } else {\n                break label_79;\n            }\n            jj_consume_token(COMMA);\n            TypeArgument();\n        } \n    } \n    jj_consume_token(GT);\n}"}], [{"methodBefore": "private boolean jj_3R_140() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_169()) {\n        jj_scanpos = xsp;\n        if (jj_3R_170()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_126() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_168()) {\n        jj_scanpos = xsp;\n        if (jj_3R_169()) {\n            jj_scanpos = xsp;\n            if (jj_3R_170()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_140() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_169()) {\n        jj_scanpos = xsp;\n        if (jj_3R_170()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_126() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_168()) {\n        jj_scanpos = xsp;\n        if (jj_3R_169()) {\n            jj_scanpos = xsp;\n            if (jj_3R_170()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_331() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_334() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_331() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_334() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_244() {\n    if (jj_3R_264()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_243() {\n    if (jj_3R_145()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_244() {\n    if (jj_3R_264()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_243() {\n    if (jj_3R_145()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_28() {\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    if (jj_3R_110()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_27() {\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    if (jj_3R_113()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_28() {\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    if (jj_3R_110()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_27() {\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    if (jj_3R_113()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_247() {\n    if (jj_3R_267()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_245() {\n    if (jj_3R_267()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_247() {\n    if (jj_3R_267()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_245() {\n    if (jj_3R_267()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}"}, {"methodBefore": "public static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}"}], [{"methodBefore": "private boolean jj_3_7() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_88()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(AT)) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_7() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_92()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(AT)) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_7() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_88()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(AT)) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_7() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_92()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(AT)) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_318() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(52)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(13)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(31)) {\n                jj_scanpos = xsp;\n                if (jj_3R_346()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_347()) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(47)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(53)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_318() {\n    if (jj_3R_348()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_318() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(52)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(13)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(31)) {\n                jj_scanpos = xsp;\n                if (jj_3R_346()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_347()) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(47)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(53)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_318() {\n    if (jj_3R_348()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void testGetSwitchNumber() {\n    assertEquals(0, a.getSwitchNumber());\n    assertEquals(1, b.getSwitchNumber());\n}", "methodAfter": "@Test\npublic void testGetSwitchNumber() {\n    assertEquals(0, a.getSwitchNumber());\n    assertEquals(1, b.getSwitchNumber());\n}"}, {"methodBefore": "public void testHashCode() {\n    assertEquals(a.hashCode(), a.hashCode());\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 }, Integer.MAX_VALUE);\n    assertEquals(a.hashCode(), aPrime.hashCode());\n}", "methodAfter": "@Test\npublic void testHashCode() {\n    assertEquals(a.hashCode(), a.hashCode());\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 }, Integer.MAX_VALUE);\n    assertEquals(a.hashCode(), aPrime.hashCode());\n}"}], [{"methodBefore": "public final int Modifiers() throws ParseException {\n    int modifiers = 0;\n    _tmpToken = null;\n    label_66 : while (true) {\n        if (jj_2_52(2)) {\n        } else {\n            break label_66;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                modifiers |= ModifierSet.PUBLIC;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case STATIC :\n                jj_consume_token(STATIC);\n                modifiers |= ModifierSet.STATIC;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case PROTECTED :\n                jj_consume_token(PROTECTED);\n                modifiers |= ModifierSet.PROTECTED;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case PRIVATE :\n                jj_consume_token(PRIVATE);\n                modifiers |= ModifierSet.PRIVATE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case FINAL :\n                jj_consume_token(FINAL);\n                modifiers |= ModifierSet.FINAL;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                modifiers |= ModifierSet.ABSTRACT;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case SYNCHRONIZED :\n                jj_consume_token(SYNCHRONIZED);\n                modifiers |= ModifierSet.SYNCHRONIZED;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case NATIVE :\n                jj_consume_token(NATIVE);\n                modifiers |= ModifierSet.NATIVE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case TRANSIENT :\n                jj_consume_token(TRANSIENT);\n                modifiers |= ModifierSet.TRANSIENT;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case VOLATILE :\n                jj_consume_token(VOLATILE);\n                modifiers |= ModifierSet.VOLATILE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                modifiers |= ModifierSet.STRICTFP;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case AT :\n                Annotation();\n                break;\n            default :\n                jj_la1[172] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    {\n        if (true) {\n            return modifiers;\n        }\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "methodAfter": "public final int Modifiers() throws ParseException {\n    int modifiers = 0;\n    _tmpToken = null;\n    label_69 : while (true) {\n        if (jj_2_51(2)) {\n        } else {\n            break label_69;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                modifiers |= ModifierSet.PUBLIC;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case STATIC :\n                jj_consume_token(STATIC);\n                modifiers |= ModifierSet.STATIC;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case PROTECTED :\n                jj_consume_token(PROTECTED);\n                modifiers |= ModifierSet.PROTECTED;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case PRIVATE :\n                jj_consume_token(PRIVATE);\n                modifiers |= ModifierSet.PRIVATE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case FINAL :\n                jj_consume_token(FINAL);\n                modifiers |= ModifierSet.FINAL;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                modifiers |= ModifierSet.ABSTRACT;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case SYNCHRONIZED :\n                jj_consume_token(SYNCHRONIZED);\n                modifiers |= ModifierSet.SYNCHRONIZED;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case NATIVE :\n                jj_consume_token(NATIVE);\n                modifiers |= ModifierSet.NATIVE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case TRANSIENT :\n                jj_consume_token(TRANSIENT);\n                modifiers |= ModifierSet.TRANSIENT;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case VOLATILE :\n                jj_consume_token(VOLATILE);\n                modifiers |= ModifierSet.VOLATILE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                modifiers |= ModifierSet.STRICTFP;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case AT :\n                Annotation();\n                break;\n            default :\n                jj_la1[177] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    {\n        if (true) {\n            return modifiers;\n        }\n    }\n    throw new Error(\"Missing return statement in function\");\n}"}, {"methodBefore": "public final int Modifiers() throws ParseException {\n    int modifiers = 0;\n    _tmpToken = null;\n    label_66 : while (true) {\n        if (jj_2_52(2)) {\n        } else {\n            break label_66;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                modifiers |= ModifierSet.PUBLIC;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case STATIC :\n                jj_consume_token(STATIC);\n                modifiers |= ModifierSet.STATIC;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case PROTECTED :\n                jj_consume_token(PROTECTED);\n                modifiers |= ModifierSet.PROTECTED;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case PRIVATE :\n                jj_consume_token(PRIVATE);\n                modifiers |= ModifierSet.PRIVATE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case FINAL :\n                jj_consume_token(FINAL);\n                modifiers |= ModifierSet.FINAL;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                modifiers |= ModifierSet.ABSTRACT;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case SYNCHRONIZED :\n                jj_consume_token(SYNCHRONIZED);\n                modifiers |= ModifierSet.SYNCHRONIZED;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case NATIVE :\n                jj_consume_token(NATIVE);\n                modifiers |= ModifierSet.NATIVE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case TRANSIENT :\n                jj_consume_token(TRANSIENT);\n                modifiers |= ModifierSet.TRANSIENT;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case VOLATILE :\n                jj_consume_token(VOLATILE);\n                modifiers |= ModifierSet.VOLATILE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                modifiers |= ModifierSet.STRICTFP;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case AT :\n                Annotation();\n                break;\n            default :\n                jj_la1[172] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    {\n        if (true) {\n            return modifiers;\n        }\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "methodAfter": "public final int Modifiers() throws ParseException {\n    int modifiers = 0;\n    _tmpToken = null;\n    label_69 : while (true) {\n        if (jj_2_51(2)) {\n        } else {\n            break label_69;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                modifiers |= ModifierSet.PUBLIC;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case STATIC :\n                jj_consume_token(STATIC);\n                modifiers |= ModifierSet.STATIC;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case PROTECTED :\n                jj_consume_token(PROTECTED);\n                modifiers |= ModifierSet.PROTECTED;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case PRIVATE :\n                jj_consume_token(PRIVATE);\n                modifiers |= ModifierSet.PRIVATE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case FINAL :\n                jj_consume_token(FINAL);\n                modifiers |= ModifierSet.FINAL;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                modifiers |= ModifierSet.ABSTRACT;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case SYNCHRONIZED :\n                jj_consume_token(SYNCHRONIZED);\n                modifiers |= ModifierSet.SYNCHRONIZED;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case NATIVE :\n                jj_consume_token(NATIVE);\n                modifiers |= ModifierSet.NATIVE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case TRANSIENT :\n                jj_consume_token(TRANSIENT);\n                modifiers |= ModifierSet.TRANSIENT;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case VOLATILE :\n                jj_consume_token(VOLATILE);\n                modifiers |= ModifierSet.VOLATILE;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                modifiers |= ModifierSet.STRICTFP;\n                if (_tmpToken == null) {\n                    _tmpToken = getToken(0);\n                }\n                break;\n            case AT :\n                Annotation();\n                break;\n            default :\n                jj_la1[177] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    {\n        if (true) {\n            return modifiers;\n        }\n    }\n    throw new Error(\"Missing return statement in function\");\n}"}], [{"methodBefore": "private boolean jj_3R_420() {\n    if (jj_3R_356()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_325() {\n    if (jj_3R_359()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_420() {\n    if (jj_3R_356()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_325() {\n    if (jj_3R_359()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_346() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_349() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_346() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_349() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void SwitchStatement() throws ParseException {\n    _localCases = 0;\n    jj_consume_token(SWITCH);\n    jj_consume_token(LPAREN);\n    Expression();\n    jj_consume_token(RPAREN);\n    jj_consume_token(LBRACE);\n    label_58 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case CASE :\n            case _DEFAULT :\n                break;\n            default :\n                jj_la1[145] = jj_gen;\n                break label_58;\n        }\n        SwitchLabel();\n        label_59 : while (true) {\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ABSTRACT :\n                case ASSERT :\n                case BOOLEAN :\n                case BREAK :\n                case BYTE :\n                case CHAR :\n                case CLASS :\n                case CONTINUE :\n                case DO :\n                case DOUBLE :\n                case ENUM :\n                case FALSE :\n                case FINAL :\n                case FLOAT :\n                case FOR :\n                case IF :\n                case INT :\n                case INTERFACE :\n                case LONG :\n                case NATIVE :\n                case NEW :\n                case NULL :\n                case PRIVATE :\n                case PROTECTED :\n                case PUBLIC :\n                case RETURN :\n                case SHORT :\n                case STATIC :\n                case TESTAAAA :\n                case SUPER :\n                case SWITCH :\n                case SYNCHRONIZED :\n                case THIS :\n                case THROW :\n                case TRANSIENT :\n                case TRUE :\n                case TRY :\n                case VOID :\n                case VOLATILE :\n                case WHILE :\n                case INTEGER_LITERAL :\n                case FLOATING_POINT_LITERAL :\n                case CHARACTER_LITERAL :\n                case STRING_LITERAL :\n                case IDENTIFIER :\n                case LPAREN :\n                case LBRACE :\n                case SEMICOLON :\n                case AT :\n                case INCR :\n                case DECR :\n                    break;\n                default :\n                    jj_la1[146] = jj_gen;\n                    break label_59;\n            }\n            BlockStatement();\n        } \n    } \n    jj_consume_token(RBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void SwitchStatement() throws ParseException {\n    _localCases = 0;\n    jj_consume_token(SWITCH);\n    jj_consume_token(LPAREN);\n    Expression();\n    jj_consume_token(RPAREN);\n    jj_consume_token(LBRACE);\n    label_59 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case CASE :\n            case _DEFAULT :\n                break;\n            default :\n                jj_la1[146] = jj_gen;\n                break label_59;\n        }\n        SwitchLabel();\n        label_60 : while (true) {\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ABSTRACT :\n                case ASSERT :\n                case BOOLEAN :\n                case BREAK :\n                case BYTE :\n                case CHAR :\n                case CLASS :\n                case CONTINUE :\n                case DO :\n                case DOUBLE :\n                case ENUM :\n                case FALSE :\n                case FINAL :\n                case FLOAT :\n                case FOR :\n                case IF :\n                case INT :\n                case INTERFACE :\n                case LONG :\n                case NATIVE :\n                case NEW :\n                case NULL :\n                case PRIVATE :\n                case PROTECTED :\n                case PUBLIC :\n                case RETURN :\n                case SHORT :\n                case STATIC :\n                case TESTAAAA :\n                case SUPER :\n                case SWITCH :\n                case SYNCHRONIZED :\n                case THIS :\n                case THROW :\n                case TRANSIENT :\n                case TRUE :\n                case TRY :\n                case VOID :\n                case VOLATILE :\n                case WHILE :\n                case INTEGER_LITERAL :\n                case FLOATING_POINT_LITERAL :\n                case CHARACTER_LITERAL :\n                case STRING_LITERAL :\n                case IDENTIFIER :\n                case LPAREN :\n                case LBRACE :\n                case SEMICOLON :\n                case AT :\n                case INCR :\n                case DECR :\n                    break;\n                default :\n                    jj_la1[147] = jj_gen;\n                    break label_60;\n            }\n            BlockStatement();\n        } \n    } \n    jj_consume_token(RBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}, {"methodBefore": "public final void SwitchStatement() throws ParseException {\n    _localCases = 0;\n    jj_consume_token(SWITCH);\n    jj_consume_token(LPAREN);\n    Expression();\n    jj_consume_token(RPAREN);\n    jj_consume_token(LBRACE);\n    label_58 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case CASE :\n            case _DEFAULT :\n                break;\n            default :\n                jj_la1[145] = jj_gen;\n                break label_58;\n        }\n        SwitchLabel();\n        label_59 : while (true) {\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ABSTRACT :\n                case ASSERT :\n                case BOOLEAN :\n                case BREAK :\n                case BYTE :\n                case CHAR :\n                case CLASS :\n                case CONTINUE :\n                case DO :\n                case DOUBLE :\n                case ENUM :\n                case FALSE :\n                case FINAL :\n                case FLOAT :\n                case FOR :\n                case IF :\n                case INT :\n                case INTERFACE :\n                case LONG :\n                case NATIVE :\n                case NEW :\n                case NULL :\n                case PRIVATE :\n                case PROTECTED :\n                case PUBLIC :\n                case RETURN :\n                case SHORT :\n                case STATIC :\n                case TESTAAAA :\n                case SUPER :\n                case SWITCH :\n                case SYNCHRONIZED :\n                case THIS :\n                case THROW :\n                case TRANSIENT :\n                case TRUE :\n                case TRY :\n                case VOID :\n                case VOLATILE :\n                case WHILE :\n                case INTEGER_LITERAL :\n                case FLOATING_POINT_LITERAL :\n                case CHARACTER_LITERAL :\n                case STRING_LITERAL :\n                case IDENTIFIER :\n                case LPAREN :\n                case LBRACE :\n                case SEMICOLON :\n                case AT :\n                case INCR :\n                case DECR :\n                    break;\n                default :\n                    jj_la1[146] = jj_gen;\n                    break label_59;\n            }\n            BlockStatement();\n        } \n    } \n    jj_consume_token(RBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void SwitchStatement() throws ParseException {\n    _localCases = 0;\n    jj_consume_token(SWITCH);\n    jj_consume_token(LPAREN);\n    Expression();\n    jj_consume_token(RPAREN);\n    jj_consume_token(LBRACE);\n    label_59 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case CASE :\n            case _DEFAULT :\n                break;\n            default :\n                jj_la1[146] = jj_gen;\n                break label_59;\n        }\n        SwitchLabel();\n        label_60 : while (true) {\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ABSTRACT :\n                case ASSERT :\n                case BOOLEAN :\n                case BREAK :\n                case BYTE :\n                case CHAR :\n                case CLASS :\n                case CONTINUE :\n                case DO :\n                case DOUBLE :\n                case ENUM :\n                case FALSE :\n                case FINAL :\n                case FLOAT :\n                case FOR :\n                case IF :\n                case INT :\n                case INTERFACE :\n                case LONG :\n                case NATIVE :\n                case NEW :\n                case NULL :\n                case PRIVATE :\n                case PROTECTED :\n                case PUBLIC :\n                case RETURN :\n                case SHORT :\n                case STATIC :\n                case TESTAAAA :\n                case SUPER :\n                case SWITCH :\n                case SYNCHRONIZED :\n                case THIS :\n                case THROW :\n                case TRANSIENT :\n                case TRUE :\n                case TRY :\n                case VOID :\n                case VOLATILE :\n                case WHILE :\n                case INTEGER_LITERAL :\n                case FLOATING_POINT_LITERAL :\n                case CHARACTER_LITERAL :\n                case STRING_LITERAL :\n                case IDENTIFIER :\n                case LPAREN :\n                case LBRACE :\n                case SEMICOLON :\n                case AT :\n                case INCR :\n                case DECR :\n                    break;\n                default :\n                    jj_la1[147] = jj_gen;\n                    break label_60;\n            }\n            BlockStatement();\n        } \n    } \n    jj_consume_token(RBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}], [{"methodBefore": "private boolean jj_3R_154() {\n    if (jj_3R_185()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_186()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_111() {\n    if (jj_3R_157()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_158()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_154() {\n    if (jj_3R_185()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_186()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_111() {\n    if (jj_3R_157()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_158()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_360() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_363() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_360() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_363() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void AssertStatement() throws ParseException {\n    jj_consume_token(ASSERT);\n    Expression();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COLON :\n            jj_consume_token(COLON);\n            Expression();\n            break;\n        default :\n            jj_la1[138] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void AssertStatement() throws ParseException {\n    jj_consume_token(ASSERT);\n    Expression();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COLON :\n            jj_consume_token(COLON);\n            Expression();\n            break;\n        default :\n            jj_la1[139] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}, {"methodBefore": "public final void AssertStatement() throws ParseException {\n    jj_consume_token(ASSERT);\n    Expression();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COLON :\n            jj_consume_token(COLON);\n            Expression();\n            break;\n        default :\n            jj_la1[138] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void AssertStatement() throws ParseException {\n    jj_consume_token(ASSERT);\n    Expression();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COLON :\n            jj_consume_token(COLON);\n            Expression();\n            break;\n        default :\n            jj_la1[139] = jj_gen;\n    }\n    jj_consume_token(SEMICOLON);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}], [{"methodBefore": "public final void TypeBound() throws ParseException {\n    jj_consume_token(EXTENDS);\n    ClassOrInterfaceType();\n    label_74 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_AND :\n                break;\n            default :\n                jj_la1[192] = jj_gen;\n                break label_74;\n        }\n        jj_consume_token(BIT_AND);\n        ClassOrInterfaceType();\n    } \n}", "methodAfter": "public final void TypeBound() throws ParseException {\n    jj_consume_token(EXTENDS);\n    ClassOrInterfaceType();\n    label_77 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_AND :\n                break;\n            default :\n                jj_la1[197] = jj_gen;\n                break label_77;\n        }\n        jj_consume_token(BIT_AND);\n        ClassOrInterfaceType();\n    } \n}"}, {"methodBefore": "public final void TypeBound() throws ParseException {\n    jj_consume_token(EXTENDS);\n    ClassOrInterfaceType();\n    label_74 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_AND :\n                break;\n            default :\n                jj_la1[192] = jj_gen;\n                break label_74;\n        }\n        jj_consume_token(BIT_AND);\n        ClassOrInterfaceType();\n    } \n}", "methodAfter": "public final void TypeBound() throws ParseException {\n    jj_consume_token(EXTENDS);\n    ClassOrInterfaceType();\n    label_77 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_AND :\n                break;\n            default :\n                jj_la1[197] = jj_gen;\n                break label_77;\n        }\n        jj_consume_token(BIT_AND);\n        ClassOrInterfaceType();\n    } \n}"}], [{"methodBefore": "private boolean jj_3_19() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_101()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_19() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_105()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_19() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_101()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_19() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_105()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, new CheckClassAdapter(cv, false));\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}, {"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, new CheckClassAdapter(cv, false));\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}, {"methodBefore": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, cv);\n}", "methodAfter": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, new CheckClassAdapter(cv, false));\n}"}], [{"methodBefore": "private boolean jj_3R_291() {\n    if (jj_3R_301()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_313()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_207() {\n    if (jj_3R_220()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_238()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_291() {\n    if (jj_3R_301()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_313()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_207() {\n    if (jj_3R_220()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_238()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_150() {\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_150() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_150() {\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_150() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void BlockStatement() throws ParseException {\n    if (jj_2_45(2147483647)) {\n        LocalVariableDeclaration();\n        jj_consume_token(SEMICOLON);\n        _ncss++;\n        Util.debug(\"_ncss++\");\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case RETURN :\n            case SHORT :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case INCR :\n            case DECR :\n                Statement();\n                break;\n            case ABSTRACT :\n            case CLASS :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case TRANSIENT :\n            case VOLATILE :\n            case AT :\n                UnmodifiedClassDeclaration();\n                break;\n            case INTERFACE :\n                UnmodifiedInterfaceDeclaration();\n                break;\n            default :\n                jj_la1[140] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void BlockStatement() throws ParseException {\n    if (jj_2_44(2147483647)) {\n        LocalVariableDeclaration();\n        jj_consume_token(SEMICOLON);\n        _ncss++;\n        Util.debug(\"_ncss++\");\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case RETURN :\n            case SHORT :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case INCR :\n            case DECR :\n                Statement();\n                break;\n            case ABSTRACT :\n            case CLASS :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case TRANSIENT :\n            case VOLATILE :\n            case AT :\n                UnmodifiedClassDeclaration();\n                break;\n            case INTERFACE :\n                UnmodifiedInterfaceDeclaration();\n                break;\n            default :\n                jj_la1[141] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}, {"methodBefore": "public final void BlockStatement() throws ParseException {\n    if (jj_2_45(2147483647)) {\n        LocalVariableDeclaration();\n        jj_consume_token(SEMICOLON);\n        _ncss++;\n        Util.debug(\"_ncss++\");\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case RETURN :\n            case SHORT :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case INCR :\n            case DECR :\n                Statement();\n                break;\n            case ABSTRACT :\n            case CLASS :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case TRANSIENT :\n            case VOLATILE :\n            case AT :\n                UnmodifiedClassDeclaration();\n                break;\n            case INTERFACE :\n                UnmodifiedInterfaceDeclaration();\n                break;\n            default :\n                jj_la1[140] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void BlockStatement() throws ParseException {\n    if (jj_2_44(2147483647)) {\n        LocalVariableDeclaration();\n        jj_consume_token(SEMICOLON);\n        _ncss++;\n        Util.debug(\"_ncss++\");\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case RETURN :\n            case SHORT :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case INCR :\n            case DECR :\n                Statement();\n                break;\n            case ABSTRACT :\n            case CLASS :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case TRANSIENT :\n            case VOLATILE :\n            case AT :\n                UnmodifiedClassDeclaration();\n                break;\n            case INTERFACE :\n                UnmodifiedInterfaceDeclaration();\n                break;\n            default :\n                jj_la1[141] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_283() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_287() {\n    if (jj_3R_217()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_283() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_287() {\n    if (jj_3R_217()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintWriter out = null;\n    try {\n        out = IOUtil.getPrintWriter(file);\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        LOGGER.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classPackageName + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowsForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(generateHtmlizedJavaSource(sourceFileData));\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        LOGGER.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintWriter out = null;\n    try {\n        out = IOUtil.getPrintWriter(file);\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classPackageName + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowsForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(generateHtmlizedJavaSource(sourceFileData));\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_419() {\n    if (jj_3R_428()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_411() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_419() {\n    if (jj_3R_428()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_411() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_410() {\n    if (jj_3R_416()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_409() {\n    if (jj_3R_416()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_410() {\n    if (jj_3R_416()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_409() {\n    if (jj_3R_416()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_11() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_91()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    xsp = jj_scanpos;\n    if (jj_3R_92()) {\n        jj_scanpos = xsp;\n    }\n    xsp = jj_scanpos;\n    if (jj_3R_93()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_3R_94()) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_11() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_95()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    xsp = jj_scanpos;\n    if (jj_3R_96()) {\n        jj_scanpos = xsp;\n    }\n    xsp = jj_scanpos;\n    if (jj_3R_97()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_3R_98()) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_11() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_91()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    xsp = jj_scanpos;\n    if (jj_3R_92()) {\n        jj_scanpos = xsp;\n    }\n    xsp = jj_scanpos;\n    if (jj_3R_93()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_3R_94()) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_11() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_95()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    xsp = jj_scanpos;\n    if (jj_3R_96()) {\n        jj_scanpos = xsp;\n    }\n    xsp = jj_scanpos;\n    if (jj_3R_97()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_3R_98()) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}, {"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}, {"methodBefore": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(cv);\n}", "methodAfter": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, cv);\n}"}], [{"methodBefore": "private boolean jj_3R_131() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_131() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_131() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_131() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_24() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_24() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_24() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_24() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_54() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_42() {\n    if (jj_3R_121()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_54() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_42() {\n    if (jj_3R_121()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "@Test\npublic void flushCoberturaDataOnly() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"deployCoberturaFlush\", true);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountBefore);\n    System.out.println((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\");\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountAfter);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int finalCount = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    webappServer.killServer();\n    assertEquals(0, finalCount);\n}", "methodAfter": "@Test\npublic void flushCoberturaDataOnly() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    new File(webappServerDir, \"logs\").mkdirs();\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"deployCoberturaFlush\", true);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountBefore);\n    System.out.println((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\");\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountAfter);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int finalCount = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    webappServer.killServer();\n    assertEquals(0, finalCount);\n}"}, {"methodBefore": "@Test\npublic void flushCoberturaDataOnly() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"deployCoberturaFlush\", true);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountBefore);\n    System.out.println((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\");\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountAfter);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int finalCount = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    webappServer.killServer();\n    assertEquals(0, finalCount);\n}", "methodAfter": "@Test\npublic void flushCoberturaDataOnly() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    new File(webappServerDir, \"logs\").mkdirs();\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"deployCoberturaFlush\", true);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountBefore);\n    System.out.println((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\");\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountAfter);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int finalCount = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    webappServer.killServer();\n    assertEquals(0, finalCount);\n}"}], [{"methodBefore": "private boolean jj_3R_321() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(52)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(13)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(31)) {\n                jj_scanpos = xsp;\n                if (jj_3R_351()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_352()) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(47)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(53)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_321() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(53)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(14)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(32)) {\n                jj_scanpos = xsp;\n                if (jj_3R_349()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_350()) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(48)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(54)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_321() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(52)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(13)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(31)) {\n                jj_scanpos = xsp;\n                if (jj_3R_351()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_352()) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(47)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(53)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_321() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(53)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(14)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(32)) {\n                jj_scanpos = xsp;\n                if (jj_3R_349()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_350()) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(48)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(54)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_287() {\n    if (jj_3R_290()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_255() {\n    if (jj_3R_277()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_287() {\n    if (jj_3R_290()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_255() {\n    if (jj_3R_277()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_16() {\n    if (jj_3R_95()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_16() {\n    if (jj_3R_99()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_12() {\n    if (jj_3R_95()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_12() {\n    if (jj_3R_99()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_12() {\n    if (jj_3R_95()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_12() {\n    if (jj_3R_99()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_16() {\n    if (jj_3R_95()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_16() {\n    if (jj_3R_99()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_310() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_231() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_310() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_231() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_369() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_369() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_369() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_369() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_129() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_129() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_129() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_129() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_295() {\n    if (jj_3R_305()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_232() {\n    if (jj_3R_230()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_295() {\n    if (jj_3R_305()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_232() {\n    if (jj_3R_230()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void StatementExpression() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INCR :\n            PreIncrementExpression();\n            break;\n        case DECR :\n            PreDecrementExpression();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n            PrimaryExpression();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN :\n                case INCR :\n                case DECR :\n                case PLUSASSIGN :\n                case MINUSASSIGN :\n                case STARASSIGN :\n                case SLASHASSIGN :\n                case ANDASSIGN :\n                case ORASSIGN :\n                case XORASSIGN :\n                case REMASSIGN :\n                case LSHIFTASSIGN :\n                case RSIGNEDSHIFTASSIGN :\n                case RUNSIGNEDSHIFTASSIGN :\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case INCR :\n                            jj_consume_token(INCR);\n                            break;\n                        case DECR :\n                            jj_consume_token(DECR);\n                            break;\n                        case ASSIGN :\n                        case PLUSASSIGN :\n                        case MINUSASSIGN :\n                        case STARASSIGN :\n                        case SLASHASSIGN :\n                        case ANDASSIGN :\n                        case ORASSIGN :\n                        case XORASSIGN :\n                        case REMASSIGN :\n                        case LSHIFTASSIGN :\n                        case RSIGNEDSHIFTASSIGN :\n                        case RUNSIGNEDSHIFTASSIGN :\n                            AssignmentOperator();\n                            Expression();\n                            break;\n                        default :\n                            jj_la1[142] = jj_gen;\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default :\n                    jj_la1[143] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[144] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void StatementExpression() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INCR :\n            PreIncrementExpression();\n            break;\n        case DECR :\n            PreDecrementExpression();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n            PrimaryExpression();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN :\n                case INCR :\n                case DECR :\n                case PLUSASSIGN :\n                case MINUSASSIGN :\n                case STARASSIGN :\n                case SLASHASSIGN :\n                case ANDASSIGN :\n                case ORASSIGN :\n                case XORASSIGN :\n                case REMASSIGN :\n                case LSHIFTASSIGN :\n                case RSIGNEDSHIFTASSIGN :\n                case RUNSIGNEDSHIFTASSIGN :\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case INCR :\n                            jj_consume_token(INCR);\n                            break;\n                        case DECR :\n                            jj_consume_token(DECR);\n                            break;\n                        case ASSIGN :\n                        case PLUSASSIGN :\n                        case MINUSASSIGN :\n                        case STARASSIGN :\n                        case SLASHASSIGN :\n                        case ANDASSIGN :\n                        case ORASSIGN :\n                        case XORASSIGN :\n                        case REMASSIGN :\n                        case LSHIFTASSIGN :\n                        case RSIGNEDSHIFTASSIGN :\n                        case RUNSIGNEDSHIFTASSIGN :\n                            AssignmentOperator();\n                            Expression();\n                            break;\n                        default :\n                            jj_la1[143] = jj_gen;\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default :\n                    jj_la1[144] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[145] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void StatementExpression() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INCR :\n            PreIncrementExpression();\n            break;\n        case DECR :\n            PreDecrementExpression();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n            PrimaryExpression();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN :\n                case INCR :\n                case DECR :\n                case PLUSASSIGN :\n                case MINUSASSIGN :\n                case STARASSIGN :\n                case SLASHASSIGN :\n                case ANDASSIGN :\n                case ORASSIGN :\n                case XORASSIGN :\n                case REMASSIGN :\n                case LSHIFTASSIGN :\n                case RSIGNEDSHIFTASSIGN :\n                case RUNSIGNEDSHIFTASSIGN :\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case INCR :\n                            jj_consume_token(INCR);\n                            break;\n                        case DECR :\n                            jj_consume_token(DECR);\n                            break;\n                        case ASSIGN :\n                        case PLUSASSIGN :\n                        case MINUSASSIGN :\n                        case STARASSIGN :\n                        case SLASHASSIGN :\n                        case ANDASSIGN :\n                        case ORASSIGN :\n                        case XORASSIGN :\n                        case REMASSIGN :\n                        case LSHIFTASSIGN :\n                        case RSIGNEDSHIFTASSIGN :\n                        case RUNSIGNEDSHIFTASSIGN :\n                            AssignmentOperator();\n                            Expression();\n                            break;\n                        default :\n                            jj_la1[142] = jj_gen;\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default :\n                    jj_la1[143] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[144] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void StatementExpression() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INCR :\n            PreIncrementExpression();\n            break;\n        case DECR :\n            PreDecrementExpression();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n            PrimaryExpression();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN :\n                case INCR :\n                case DECR :\n                case PLUSASSIGN :\n                case MINUSASSIGN :\n                case STARASSIGN :\n                case SLASHASSIGN :\n                case ANDASSIGN :\n                case ORASSIGN :\n                case XORASSIGN :\n                case REMASSIGN :\n                case LSHIFTASSIGN :\n                case RSIGNEDSHIFTASSIGN :\n                case RUNSIGNEDSHIFTASSIGN :\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case INCR :\n                            jj_consume_token(INCR);\n                            break;\n                        case DECR :\n                            jj_consume_token(DECR);\n                            break;\n                        case ASSIGN :\n                        case PLUSASSIGN :\n                        case MINUSASSIGN :\n                        case STARASSIGN :\n                        case SLASHASSIGN :\n                        case ANDASSIGN :\n                        case ORASSIGN :\n                        case XORASSIGN :\n                        case REMASSIGN :\n                        case LSHIFTASSIGN :\n                        case RSIGNEDSHIFTASSIGN :\n                        case RUNSIGNEDSHIFTASSIGN :\n                            AssignmentOperator();\n                            Expression();\n                            break;\n                        default :\n                            jj_la1[143] = jj_gen;\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default :\n                    jj_la1[144] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[145] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_208() {\n    if (jj_3R_222()) {\n        return true;\n    }\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_210() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_208() {\n    if (jj_3R_222()) {\n        return true;\n    }\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_210() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_454() {\n    if (jj_3R_263()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_455()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_463() {\n    if (jj_3R_266()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_464()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_454() {\n    if (jj_3R_263()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_455()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_463() {\n    if (jj_3R_266()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_464()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "@Test\npublic void performanceTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(mainSourceFile, (((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tlong start = System.nanoTime();\") + \"\\n \\t\\tint j = 0;\") + \"\\n \\t\\tfor (int i = 0; i < 100000; i++) {\") + \"\\n \\t\\t   if (i % 2 == 0) { j+=2; };\") + \"\\n \\t\\t   switch (i % 4) {\") + \"\\n \\t\\t      case 0 : \") + \"\\n \\t\\t      case 1 : j++;\") + \"\\n \\t\\t      case 2 : j+=2;\") + \"\\n \\t\\t      default: j+=3;\") + \"\\n \\t\\t   } \") + \"\\n \\t\\t}\") + \"\\n \\t\\tlong stop = System.nanoTime();\") + \"\\n \\t\\tSystem.out.println(\\\"Test took:\\\" + (stop - start)/100000.0 + \\\" milis\\\");\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    System.out.println(\"Run without instrumentation:\\n\");\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetSrcDir);\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setOutput(new File(tempDir, \"PT_uninstrumented.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_uninstrumented.log\")));\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    System.out.println(\"Run with instrumentation (not threadsafe-rigorous):\\n\");\n    classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\")).toString());\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"threadsafeRigorous\", true);\n        }\n    });\n    System.out.println(\"Run with instrumentation (threadsafe-rigorous):\\n\");\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedThreadSafe.log\")));\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n}", "methodAfter": "@Test\npublic void performanceTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(mainSourceFile, (((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tlong start = System.nanoTime();\") + \"\\n \\t\\tint j = 0;\") + \"\\n \\t\\tfor (int i = 0; i < 100000; i++) {\") + \"\\n \\t\\t   if (i % 2 == 0) { j+=2; };\") + \"\\n \\t\\t   switch (i % 4) {\") + \"\\n \\t\\t      case 0 : \") + \"\\n \\t\\t      case 1 : j++;\") + \"\\n \\t\\t      case 2 : j+=2;\") + \"\\n \\t\\t      default: j+=3;\") + \"\\n \\t\\t   } \") + \"\\n \\t\\t}\") + \"\\n \\t\\tlong stop = System.nanoTime();\") + \"\\n \\t\\tSystem.out.println(\\\"Test took:\\\" + (stop - start)/100000.0 + \\\" milis\\\");\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    System.out.println(\"Run without instrumentation:\\n\");\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetSrcDir);\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setOutput(new File(tempDir, \"PT_uninstrumented.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_uninstrumented.log\")));\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    System.out.println(\"Run with instrumentation (not threadsafe-rigorous):\\n\");\n    classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\")).toString());\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"threadsafeRigorous\", true);\n        }\n    });\n    System.out.println(\"Run with instrumentation (threadsafe-rigorous):\\n\");\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedThreadSafe.log\")));\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n}"}, {"methodBefore": "private void runTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    BufferedWriter bw = null;\n    try {\n        bw = new BufferedWriter(new FileWriter(mainSourceFile));\n        bw.write(getMainCode(instrumentDir));\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    File calledSourceFile = new File(srcDir, \"mypackage/Called.java\");\n    try {\n        bw = new BufferedWriter(new FileWriter(calledSourceFile));\n        bw.write(CALLED_CODE);\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    DirSet dirSet = new DirSet();\n    dirSet.setDir(srcDir);\n    dirSet.setProject(project);\n    Path classpath = new Path(TestUtils.project);\n    classpath.addDirset(dirSet);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    List<Node> lines = TestUtils.getLineCounts(dom, \"mypackage.Called\", \"callThis\", null);\n    assertEquals(1, lines.size());\n    for (int i = 0; i < lines.size(); i++) {\n        assertEquals(\"hit count incorrect\", \"2\", lines.get(i).attribute(\"hits\"));\n    }\n}", "methodAfter": "private void runTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    BufferedWriter bw = null;\n    try {\n        bw = new BufferedWriter(new FileWriter(mainSourceFile));\n        bw.write(getMainCode(instrumentDir));\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    File calledSourceFile = new File(srcDir, \"mypackage/Called.java\");\n    try {\n        bw = new BufferedWriter(new FileWriter(calledSourceFile));\n        bw.write(CALLED_CODE);\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    DirSet dirSet = new DirSet();\n    dirSet.setDir(srcDir);\n    dirSet.setProject(project);\n    Path classpath = new Path(TestUtils.project);\n    classpath.addDirset(dirSet);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    List<Node> lines = TestUtils.getLineCounts(dom, \"mypackage.Called\", \"callThis\", null);\n    assertEquals(1, lines.size());\n    for (int i = 0; i < lines.size(); i++) {\n        assertEquals(\"hit count incorrect\", \"2\", lines.get(i).attribute(\"hits\"));\n    }\n}"}, {"methodBefore": "@Test\npublic void ignoreTrivialTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File reportDir = new File(tempDir, \"report\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    instrumentDir.mkdirs();\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File interfaceSourceFile = new File(srcDir, \"mypackage/MyInterface.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(interfaceSourceFile, (((\"\\n package mypackage;\" + \"\\n \") + \"\\n public interface MyInterface {\") + \"\\n \\tpublic void myInterfaceMethod();\") + \"\\n }\");\n    FileUtils.write(mainSourceFile, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic static class MyObject implements MyInterface\") + \"\\n \\t{\") + \"\\n \\t\\tpublic void myInterfaceMethod()\") + \"\\n \\t\\t{\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tMain main = new Main();\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * Call all methods so they will be considered \\\"covered\\\" unless\") + \"\\n \\t\\t * they are ignored as trivial.\") + \"\\n \\t\\t *\") + \"\\n \\t\\t * These are in no particular order.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tmain.getterTrivial();\") + \"\\n \\t\\tmain.empty();\") + \"\\n \\t\\tmain.getVoid();\") + \"\\n \\t\\tmain.getIntWithIntParm(0);\") + \"\\n \\t\\tmain.isBool();\") + \"\\n \\t\\tmain.hasBool();\") + \"\\n \\t\\tmain.set();\") + \"\\n \\t\\tmain.setInt(1);\") + \"\\n \\t\\tmain.setIntWithTwoParms(1, 2);\") + \"\\n \\t\\tmain.getMultiDimArray();\") + \"\\n \\t\\tmain.setIncrement(1);\") + \"\\n \\t\\tmain.setConst(\\\"\\\");\") + \"\\n \\t\\tmain.getArray();\") + \"\\n \\t\\tmain.getObject();\") + \"\\n \\t\\tmain.getStatic();\") + \"\\n \\t\\tmain.setStatic(1);\") + \"\\n \\t\\tmain.setISTORE(1);\") + \"\\n \\t\\tmain.setLSTORE(1);\") + \"\\n \\t\\tmain.setFSTORE((float)1.0);\") + \"\\n \\t\\tmain.setDSTORE(1.0);\") + \"\\n \\t\\tmain.setASTORE(null);\") + \"\\n \\t\\tmain.getINVOKEVIRTUAL();\") + \"\\n \\t\\tmain.getINVOKESPECIAL();\") + \"\\n \\t\\tmain.getINVOKESTATIC();\") + \"\\n \\t\\tmain.setINVOKEINTERFACE(new MyObject());\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t// call constructors in no particular order\") + \"\\n \\t\\tnew Main(1);\") + \"\\n \\t\\tnew Main(true);\") + \"\\n \\t\\tnew Main(\\\"str\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", \\\"\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", 0);\") + \"\\n \\t\\tnew Main(\\\"\\\", true);\") + \"\\n \\t\\tnew Main((Thread) null, \\\"string\\\");\") + \"\\n \\t\\tnew Main((Thread) null, 0);\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// Be careful when initializing members.  If you instantiate an\") + \"\\n \\t// object, then trivial constructors will become non-trivial.\") + \"\\n \\t// Ex. Integer myInteger = new Integer(1); will cause Main() to be non-trivial.\") + \"\\n \\tint myint;\") + \"\\n \\tboolean mybool;\") + \"\\n \\tprivate static int mystatic;\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial constructor\") + \"\\n \\tpublic Main() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// constructors that just call super() are trivial\") + \"\\n \\tpublic Main(Thread t, String str)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(str);\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// constructors that just call super() are usually trivial, but\") + \"\\n \\t// this constructor uses a constant, so it is considered non-trivial.\") + \"\\n \\tpublic Main(Thread t, int i)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(\\\"string\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(boolean bool) {\") + \"\\n \\t\\t// non-trivial conditional\") + \"\\n \\t\\tmyint = bool ? 0 : 1;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(int num) {\") + \"\\n \\t\\t// non-trivial switch\") + \"\\n \\t\\tswitch(num) {\") + \"\\n \\t\\t\\tdefault:\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str) {\") + \"\\n \\t\\t// setting of statics is non-trivial\") + \"\\n \\t\\tmystatic = 2;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, String str2)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial method call\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic Main(String str1, int i)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial object construction\") + \"\\n \\t\\tnew StringBuffer();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, boolean bool)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial this() call\") + \"\\n \\t\\tthis(str1, 0);\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic int getterTrivial() {\") + \"\\n \\t\\treturn myint;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean isBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean hasBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial setter\") + \"\\n \\tpublic void setInt(int i) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be trivial, but it is a getter that with no return value\") + \"\\n \\tpublic void getVoid() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// \\\"empty\\\" does not start with \\\"get\\\", \\\"is\\\", \\\"has\\\", or \\\"set\\\", so\") + \"\\n \\t// it is considered non-trivial.\") + \"\\n \\tprivate int empty() {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this is a getter that takes a parameter, so it is non-trivial.\") + \"\\n \\tpublic int getIntWithIntParm(int i) {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// this would be a trivial setter, but it does not have a parameter.\") + \"\\n \\tpublic void set() {\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be a trivial setter, but it has more than one parameter.\") + \"\\n \\tpublic void setIntWithTwoParms(int i, int j) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic int[][] getMultiDimArray() {\") + \"\\n \\t\\t// non-trivial construction of a multi-dimensional array\") + \"\\n \\t\\treturn new int[1][1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setIncrement(int i) {\") + \"\\n \\t\\t// non-trivial increment of local variable\") + \"\\n \\t\\ti++;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setConst(String str) {\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * cause visitLdcInsn to be called because \\\"str\\\" is in the\") + \"\\n \\t\\t * runtime constant pool.  An LDC operation is performed\") + \"\\n \\t\\t * which is considered non-trivial.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tSystem.out.println(\\\"str\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int[] getArray() {\") + \"\\n \\t\\t// causes visitIntInsn to be called.  Creating an array is a \\\"single int operand\\\".\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new int[1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Object getObject() {\") + \"\\n \\t\\t// causes visitTypeInsn to be called.  Creating an object is a type instruction.\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new Object();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int getStatic() {\") + \"\\n \\t\\t// getting a static is non-trivial.\") + \"\\n \\t\\treturn mystatic;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setStatic(int i) {\") + \"\\n \\t\\t// setting a static is non-trivial.\") + \"\\n \\t\\tmystatic = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ISTORE)) (int store to local var)\") + \"\\n \\tpublic void setISTORE(int i) {\") + \"\\n \\t\\ti = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(LSTORE)) (long store to local var)\") + \"\\n \\tpublic void setLSTORE(long l) {\") + \"\\n \\t\\tl = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(FSTORE)) (floating store to local var)\") + \"\\n \\tpublic void setFSTORE(float f) {\") + \"\\n \\t\\tf = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(DSTORE)) (double store to local var)\") + \"\\n \\tpublic void setDSTORE(double d) {\") + \"\\n \\t\\td = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ASTORE)) (object store to local var)\") + \"\\n \\tpublic void setASTORE(Object obj) {\") + \"\\n \\t\\tobj = null;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic void publicMethod() {\") + \"\\n \\t}\") + \"\\n \\tprivate void privateMethod() {\") + \"\\n \\t}\") + \"\\n \\tpublic static void staticMethod() {\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \\t// non-trivial public method call (causes visitMethodInsn(INVOKEVIRTUAL))\") + \"\\n \\tpublic int getINVOKEVIRTUAL() {\") + \"\\n \\t\\tpublicMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial private method call (causes visitMethodInsn(INVOKESPECIAL)) \") + \"\\n \\tpublic int getINVOKESPECIAL() {\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial static method call (causes visitMethodInsn(INVOKESTATIC)) \") + \"\\n \\tpublic int getINVOKESTATIC() {\") + \"\\n \\t\\tstaticMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial interface method call (causes visitMethodInsn(INVOKEINTERFACE))\") + \"\\n \\tpublic void setINVOKEINTERFACE(MyInterface obj) {\") + \"\\n \\t\\tobj.myInterfaceMethod();\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"ignoretrivial\", true);\n        }\n    });\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    ignoreUtil = new IgnoreUtil(\"mypackage.Main\", dom);\n    assertIgnored(\"<init>\", \"()V\");\n    assertIgnored(\"<init>\", \"(Ljava/lang/Thread;Ljava/lang/String;)V\");\n    assertIgnored(\"getterTrivial\");\n    assertIgnored(\"isBool\");\n    assertIgnored(\"hasBool\");\n    assertIgnored(\"setInt\");\n    assertNotIgnored(\"<init>\", \"(I)V\");\n    assertNotIgnored(\"<init>\", \"(Z)V\");\n    assertNotIgnored(\"empty\");\n    assertNotIgnored(\"getVoid\");\n    assertNotIgnored(\"getIntWithIntParm\");\n    assertNotIgnored(\"set\");\n    assertNotIgnored(\"setIntWithTwoParms\");\n    assertNotIgnored(\"getMultiDimArray\");\n    assertNotIgnored(\"setIncrement\");\n    assertNotIgnored(\"setConst\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/Thread;I)V\");\n    assertNotIgnored(\"getArray\");\n    assertNotIgnored(\"getObject\");\n    assertNotIgnored(\"getStatic\");\n    assertNotIgnored(\"setStatic\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;)V\");\n    assertNotIgnored(\"setISTORE\");\n    assertNotIgnored(\"setLSTORE\");\n    assertNotIgnored(\"setFSTORE\");\n    assertNotIgnored(\"setDSTORE\");\n    assertNotIgnored(\"setASTORE\");\n    assertNotIgnored(\"getINVOKEVIRTUAL\");\n    assertNotIgnored(\"getINVOKESPECIAL\");\n    assertNotIgnored(\"getINVOKESTATIC\");\n    assertNotIgnored(\"setINVOKEINTERFACE\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Ljava/lang/String;)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;I)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Z)V\");\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"html\");\n    reportTask.setDestDir(reportDir);\n    reportTask.setSrcDir(srcDir.getAbsolutePath());\n    reportTask.execute();\n    assertTrue(new File(reportDir, \"index.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.Main.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.MyInterface.html\").exists());\n    File frameSummaryFile = new File(reportDir, \"frame-summary.html\");\n    assertTrue(frameSummaryFile.exists());\n    TestUtils.checkFrameSummaryHtmlFile(frameSummaryFile);\n}", "methodAfter": "@Test\npublic void ignoreTrivialTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File reportDir = new File(tempDir, \"report\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    instrumentDir.mkdirs();\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File interfaceSourceFile = new File(srcDir, \"mypackage/MyInterface.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(interfaceSourceFile, (((\"\\n package mypackage;\" + \"\\n \") + \"\\n public interface MyInterface {\") + \"\\n \\tpublic void myInterfaceMethod();\") + \"\\n }\");\n    FileUtils.write(mainSourceFile, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic static class MyObject implements MyInterface\") + \"\\n \\t{\") + \"\\n \\t\\tpublic void myInterfaceMethod()\") + \"\\n \\t\\t{\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tMain main = new Main();\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * Call all methods so they will be considered \\\"covered\\\" unless\") + \"\\n \\t\\t * they are ignored as trivial.\") + \"\\n \\t\\t *\") + \"\\n \\t\\t * These are in no particular order.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tmain.getterTrivial();\") + \"\\n \\t\\tmain.empty();\") + \"\\n \\t\\tmain.getVoid();\") + \"\\n \\t\\tmain.getIntWithIntParm(0);\") + \"\\n \\t\\tmain.isBool();\") + \"\\n \\t\\tmain.hasBool();\") + \"\\n \\t\\tmain.set();\") + \"\\n \\t\\tmain.setInt(1);\") + \"\\n \\t\\tmain.setIntWithTwoParms(1, 2);\") + \"\\n \\t\\tmain.getMultiDimArray();\") + \"\\n \\t\\tmain.setIncrement(1);\") + \"\\n \\t\\tmain.setConst(\\\"\\\");\") + \"\\n \\t\\tmain.getArray();\") + \"\\n \\t\\tmain.getObject();\") + \"\\n \\t\\tmain.getStatic();\") + \"\\n \\t\\tmain.setStatic(1);\") + \"\\n \\t\\tmain.setISTORE(1);\") + \"\\n \\t\\tmain.setLSTORE(1);\") + \"\\n \\t\\tmain.setFSTORE((float)1.0);\") + \"\\n \\t\\tmain.setDSTORE(1.0);\") + \"\\n \\t\\tmain.setASTORE(null);\") + \"\\n \\t\\tmain.getINVOKEVIRTUAL();\") + \"\\n \\t\\tmain.getINVOKESPECIAL();\") + \"\\n \\t\\tmain.getINVOKESTATIC();\") + \"\\n \\t\\tmain.setINVOKEINTERFACE(new MyObject());\") + \"\\n \\t\\t\\t\") + \"\\n \\t\\t// call constructors in no particular order\") + \"\\n \\t\\tnew Main(1);\") + \"\\n \\t\\tnew Main(true);\") + \"\\n \\t\\tnew Main(\\\"str\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", \\\"\\\");\") + \"\\n \\t\\tnew Main(\\\"\\\", 0);\") + \"\\n \\t\\tnew Main(\\\"\\\", true);\") + \"\\n \\t\\tnew Main((Thread) null, \\\"string\\\");\") + \"\\n \\t\\tnew Main((Thread) null, 0);\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// Be careful when initializing members.  If you instantiate an\") + \"\\n \\t// object, then trivial constructors will become non-trivial.\") + \"\\n \\t// Ex. Integer myInteger = new Integer(1); will cause Main() to be non-trivial.\") + \"\\n \\tint myint;\") + \"\\n \\tboolean mybool;\") + \"\\n \\tprivate static int mystatic;\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial constructor\") + \"\\n \\tpublic Main() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// constructors that just call super() are trivial\") + \"\\n \\tpublic Main(Thread t, String str)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(str);\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// constructors that just call super() are usually trivial, but\") + \"\\n \\t// this constructor uses a constant, so it is considered non-trivial.\") + \"\\n \\tpublic Main(Thread t, int i)\") + \"\\n \\t{\") + \"\\n \\t\\tsuper(\\\"string\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(boolean bool) {\") + \"\\n \\t\\t// non-trivial conditional\") + \"\\n \\t\\tmyint = bool ? 0 : 1;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(int num) {\") + \"\\n \\t\\t// non-trivial switch\") + \"\\n \\t\\tswitch(num) {\") + \"\\n \\t\\t\\tdefault:\") + \"\\n \\t\\t}\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str) {\") + \"\\n \\t\\t// setting of statics is non-trivial\") + \"\\n \\t\\tmystatic = 2;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, String str2)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial method call\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic Main(String str1, int i)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial object construction\") + \"\\n \\t\\tnew StringBuffer();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Main(String str1, boolean bool)\") + \"\\n \\t{\") + \"\\n \\t\\t// non-trivial this() call\") + \"\\n \\t\\tthis(str1, 0);\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic int getterTrivial() {\") + \"\\n \\t\\treturn myint;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean isBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// trivial getter\") + \"\\n \\tpublic boolean hasBool() {\") + \"\\n \\t\\treturn mybool;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// trivial setter\") + \"\\n \\tpublic void setInt(int i) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be trivial, but it is a getter that with no return value\") + \"\\n \\tpublic void getVoid() {\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// \\\"empty\\\" does not start with \\\"get\\\", \\\"is\\\", \\\"has\\\", or \\\"set\\\", so\") + \"\\n \\t// it is considered non-trivial.\") + \"\\n \\tprivate int empty() {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this is a getter that takes a parameter, so it is non-trivial.\") + \"\\n \\tpublic int getIntWithIntParm(int i) {\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// this would be a trivial setter, but it does not have a parameter.\") + \"\\n \\tpublic void set() {\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\t// this would be a trivial setter, but it has more than one parameter.\") + \"\\n \\tpublic void setIntWithTwoParms(int i, int j) {\") + \"\\n \\t\\tmyint = i;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\tpublic int[][] getMultiDimArray() {\") + \"\\n \\t\\t// non-trivial construction of a multi-dimensional array\") + \"\\n \\t\\treturn new int[1][1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setIncrement(int i) {\") + \"\\n \\t\\t// non-trivial increment of local variable\") + \"\\n \\t\\ti++;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setConst(String str) {\") + \"\\n \\t\\t/*\") + \"\\n \\t\\t * cause visitLdcInsn to be called because \\\"str\\\" is in the\") + \"\\n \\t\\t * runtime constant pool.  An LDC operation is performed\") + \"\\n \\t\\t * which is considered non-trivial.\") + \"\\n \\t\\t */\") + \"\\n \\t\\tSystem.out.println(\\\"str\\\");\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int[] getArray() {\") + \"\\n \\t\\t// causes visitIntInsn to be called.  Creating an array is a \\\"single int operand\\\".\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new int[1];\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic Object getObject() {\") + \"\\n \\t\\t// causes visitTypeInsn to be called.  Creating an object is a type instruction.\") + \"\\n \\t\\t// non-trivial.\") + \"\\n \\t\\treturn new Object();\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic int getStatic() {\") + \"\\n \\t\\t// getting a static is non-trivial.\") + \"\\n \\t\\treturn mystatic;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\tpublic void setStatic(int i) {\") + \"\\n \\t\\t// setting a static is non-trivial.\") + \"\\n \\t\\tmystatic = i;\") + \"\\n \\t}\") + \"\\n \\t\\t\") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ISTORE)) (int store to local var)\") + \"\\n \\tpublic void setISTORE(int i) {\") + \"\\n \\t\\ti = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(LSTORE)) (long store to local var)\") + \"\\n \\tpublic void setLSTORE(long l) {\") + \"\\n \\t\\tl = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(FSTORE)) (floating store to local var)\") + \"\\n \\tpublic void setFSTORE(float f) {\") + \"\\n \\t\\tf = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(DSTORE)) (double store to local var)\") + \"\\n \\tpublic void setDSTORE(double d) {\") + \"\\n \\t\\td = 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial local variable instruction (causes visitVarInsn(ASTORE)) (object store to local var)\") + \"\\n \\tpublic void setASTORE(Object obj) {\") + \"\\n \\t\\tobj = null;\") + \"\\n \\t}\") + \"\\n \\t\\t\\t\") + \"\\n \\tpublic void publicMethod() {\") + \"\\n \\t}\") + \"\\n \\tprivate void privateMethod() {\") + \"\\n \\t}\") + \"\\n \\tpublic static void staticMethod() {\") + \"\\n \\t}\") + \"\\n \\t\") + \"\\n \\t// non-trivial public method call (causes visitMethodInsn(INVOKEVIRTUAL))\") + \"\\n \\tpublic int getINVOKEVIRTUAL() {\") + \"\\n \\t\\tpublicMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial private method call (causes visitMethodInsn(INVOKESPECIAL)) \") + \"\\n \\tpublic int getINVOKESPECIAL() {\") + \"\\n \\t\\tprivateMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial static method call (causes visitMethodInsn(INVOKESTATIC)) \") + \"\\n \\tpublic int getINVOKESTATIC() {\") + \"\\n \\t\\tstaticMethod();\") + \"\\n \\t\\treturn 0;\") + \"\\n \\t}\") + \"\\n \") + \"\\n \\t// non-trivial interface method call (causes visitMethodInsn(INVOKEINTERFACE))\") + \"\\n \\tpublic void setINVOKEINTERFACE(MyInterface obj) {\") + \"\\n \\t\\tobj.myInterfaceMethod();\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"ignoretrivial\", true);\n        }\n    });\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    ignoreUtil = new IgnoreUtil(\"mypackage.Main\", dom);\n    assertIgnored(\"<init>\", \"()V\");\n    assertIgnored(\"<init>\", \"(Ljava/lang/Thread;Ljava/lang/String;)V\");\n    assertIgnored(\"getterTrivial\");\n    assertIgnored(\"isBool\");\n    assertIgnored(\"hasBool\");\n    assertIgnored(\"setInt\");\n    assertNotIgnored(\"<init>\", \"(I)V\");\n    assertNotIgnored(\"<init>\", \"(Z)V\");\n    assertNotIgnored(\"empty\");\n    assertNotIgnored(\"getVoid\");\n    assertNotIgnored(\"getIntWithIntParm\");\n    assertNotIgnored(\"set\");\n    assertNotIgnored(\"setIntWithTwoParms\");\n    assertNotIgnored(\"getMultiDimArray\");\n    assertNotIgnored(\"setIncrement\");\n    assertNotIgnored(\"setConst\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/Thread;I)V\");\n    assertNotIgnored(\"getArray\");\n    assertNotIgnored(\"getObject\");\n    assertNotIgnored(\"getStatic\");\n    assertNotIgnored(\"setStatic\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;)V\");\n    assertNotIgnored(\"setISTORE\");\n    assertNotIgnored(\"setLSTORE\");\n    assertNotIgnored(\"setFSTORE\");\n    assertNotIgnored(\"setDSTORE\");\n    assertNotIgnored(\"setASTORE\");\n    assertNotIgnored(\"getINVOKEVIRTUAL\");\n    assertNotIgnored(\"getINVOKESPECIAL\");\n    assertNotIgnored(\"getINVOKESTATIC\");\n    assertNotIgnored(\"setINVOKEINTERFACE\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Ljava/lang/String;)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;I)V\");\n    assertNotIgnored(\"<init>\", \"(Ljava/lang/String;Z)V\");\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"html\");\n    reportTask.setDestDir(reportDir);\n    reportTask.setSrcDir(srcDir.getAbsolutePath());\n    reportTask.execute();\n    assertTrue(new File(reportDir, \"index.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.Main.html\").exists());\n    assertTrue(new File(reportDir, \"mypackage.MyInterface.html\").exists());\n    File frameSummaryFile = new File(reportDir, \"frame-summary.html\");\n    assertTrue(frameSummaryFile.exists());\n    TestUtils.checkFrameSummaryHtmlFile(frameSummaryFile);\n}"}], [{"methodBefore": "private boolean jj_3R_406() {\n    if (jj_3R_413()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_406() {\n    if (jj_3R_312()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_406() {\n    if (jj_3R_413()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_406() {\n    if (jj_3R_312()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_174() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_175() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_174() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_175() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_277() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_239() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_262()) {\n        jj_scanpos = xsp;\n        if (jj_3R_263()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_277() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_239() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_262()) {\n        jj_scanpos = xsp;\n        if (jj_3R_263()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "public void setUp() {\n    coverageData = new ProjectData();\n}", "methodAfter": "@Before\npublic void setUp() {\n    coverageData = new ProjectData();\n}"}, {"methodBefore": "public void setUp() {\n    a.setSourceFileName(\"com/example/HelloWorld.java\");\n    b.setSourceFileName(\"com/example/HelloWorld.java\");\n    c.setSourceFileName(\"com/example/HelloWorld.java\");\n    defPckg.setSourceFileName(\"DefaultPackageClass.java\");\n    for (int i = 1; i <= 5; i++) {\n        b.addLine(i, \"test\", \"(I)B\");\n    }\n    for (int i = 1; i <= 5; i++) {\n        c.addLine(i, \"test\", \"(I)B\");\n    }\n    for (int i = 1; i <= 5; i++) {\n        defPckg.addLine(i, \"test\", \"(I)B\");\n    }\n    b.touch(1, 1);\n    b.touch(2, 1);\n}", "methodAfter": "@Before\npublic void setUp() {\n    a.setSourceFileName(\"com/example/HelloWorld.java\");\n    b.setSourceFileName(\"com/example/HelloWorld.java\");\n    c.setSourceFileName(\"com/example/HelloWorld.java\");\n    defPckg.setSourceFileName(\"DefaultPackageClass.java\");\n    for (int i = 1; i <= 5; i++) {\n        b.addLine(i, \"test\", \"(I)B\");\n    }\n    for (int i = 1; i <= 5; i++) {\n        c.addLine(i, \"test\", \"(I)B\");\n    }\n    for (int i = 1; i <= 5; i++) {\n        defPckg.addLine(i, \"test\", \"(I)B\");\n    }\n    b.touch(1, 1);\n    b.touch(2, 1);\n}"}], [{"methodBefore": "public final void CastLookahead() throws ParseException {\n    if (jj_2_28(2)) {\n        jj_consume_token(LPAREN);\n        PrimitiveType();\n    } else if (jj_2_29(2147483647)) {\n        jj_consume_token(LPAREN);\n        Type();\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LPAREN :\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case TILDE :\n                        jj_consume_token(TILDE);\n                        break;\n                    case BANG :\n                        jj_consume_token(BANG);\n                        break;\n                    case LPAREN :\n                        jj_consume_token(LPAREN);\n                        break;\n                    case ASSERT :\n                    case IDENTIFIER :\n                        Identifier();\n                        break;\n                    case THIS :\n                        jj_consume_token(THIS);\n                        break;\n                    case SUPER :\n                        jj_consume_token(SUPER);\n                        break;\n                    case NEW :\n                        jj_consume_token(NEW);\n                        break;\n                    case FALSE :\n                    case NULL :\n                    case TRUE :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                        Literal();\n                        break;\n                    default :\n                        jj_la1[114] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                break;\n            default :\n                jj_la1[115] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void CastLookahead() throws ParseException {\n    if (jj_2_27(2)) {\n        jj_consume_token(LPAREN);\n        PrimitiveType();\n    } else if (jj_2_28(2147483647)) {\n        jj_consume_token(LPAREN);\n        Type();\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LPAREN :\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case TILDE :\n                        jj_consume_token(TILDE);\n                        break;\n                    case BANG :\n                        jj_consume_token(BANG);\n                        break;\n                    case LPAREN :\n                        jj_consume_token(LPAREN);\n                        break;\n                    case ASSERT :\n                    case IDENTIFIER :\n                        Identifier();\n                        break;\n                    case THIS :\n                        jj_consume_token(THIS);\n                        break;\n                    case SUPER :\n                        jj_consume_token(SUPER);\n                        break;\n                    case NEW :\n                        jj_consume_token(NEW);\n                        break;\n                    case FALSE :\n                    case NULL :\n                    case TRUE :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                        Literal();\n                        break;\n                    default :\n                        jj_la1[114] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                break;\n            default :\n                jj_la1[115] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}, {"methodBefore": "public final void CastLookahead() throws ParseException {\n    if (jj_2_28(2)) {\n        jj_consume_token(LPAREN);\n        PrimitiveType();\n    } else if (jj_2_29(2147483647)) {\n        jj_consume_token(LPAREN);\n        Type();\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LPAREN :\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case TILDE :\n                        jj_consume_token(TILDE);\n                        break;\n                    case BANG :\n                        jj_consume_token(BANG);\n                        break;\n                    case LPAREN :\n                        jj_consume_token(LPAREN);\n                        break;\n                    case ASSERT :\n                    case IDENTIFIER :\n                        Identifier();\n                        break;\n                    case THIS :\n                        jj_consume_token(THIS);\n                        break;\n                    case SUPER :\n                        jj_consume_token(SUPER);\n                        break;\n                    case NEW :\n                        jj_consume_token(NEW);\n                        break;\n                    case FALSE :\n                    case NULL :\n                    case TRUE :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                        Literal();\n                        break;\n                    default :\n                        jj_la1[114] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                break;\n            default :\n                jj_la1[115] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void CastLookahead() throws ParseException {\n    if (jj_2_27(2)) {\n        jj_consume_token(LPAREN);\n        PrimitiveType();\n    } else if (jj_2_28(2147483647)) {\n        jj_consume_token(LPAREN);\n        Type();\n        jj_consume_token(LBRACKET);\n        jj_consume_token(RBRACKET);\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LPAREN :\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case TILDE :\n                        jj_consume_token(TILDE);\n                        break;\n                    case BANG :\n                        jj_consume_token(BANG);\n                        break;\n                    case LPAREN :\n                        jj_consume_token(LPAREN);\n                        break;\n                    case ASSERT :\n                    case IDENTIFIER :\n                        Identifier();\n                        break;\n                    case THIS :\n                        jj_consume_token(THIS);\n                        break;\n                    case SUPER :\n                        jj_consume_token(SUPER);\n                        break;\n                    case NEW :\n                        jj_consume_token(NEW);\n                        break;\n                    case FALSE :\n                    case NULL :\n                    case TRUE :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                        Literal();\n                        break;\n                    default :\n                        jj_la1[114] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                break;\n            default :\n                jj_la1[115] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_126() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_355() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_126() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_355() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_124() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_137() {\n    if (jj_scan_token(TESTAAAA)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_124() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_137() {\n    if (jj_scan_token(TESTAAAA)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[193] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[194] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[199] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[200] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[193] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[194] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[199] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[200] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "public final void EnumDeclaration(int modifiers) throws ParseException {\n    String sOldClass = _sClass;\n    int oldClasses = _classes;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldSingle;\n    int oldMulti;\n    Util.debug(\"EnumDeclaration().START\");\n    jj_consume_token(ENUM);\n    jj_consume_token(IDENTIFIER);\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(0).image;\n    _classLevel++;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(false);\n            break;\n        default :\n            jj_la1[177] = jj_gen;\n    }\n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    EnumBody();\n    _classLevel--;\n    if (_classLevel == 0) {\n        ObjectMetric metric = new ObjectMetric();\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        metric.javadocs = _javadocs;\n        metric.javadocsLn = _jvdcLines;\n        metric.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n        metric.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}", "methodAfter": "public final void EnumDeclaration(int modifiers) throws ParseException {\n    String sOldClass = _sClass;\n    int oldClasses = _classes;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldSingle;\n    int oldMulti;\n    Util.debug(\"EnumDeclaration().START\");\n    jj_consume_token(ENUM);\n    jj_consume_token(IDENTIFIER);\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(0).image;\n    _classLevel++;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(false);\n            break;\n        default :\n            jj_la1[182] = jj_gen;\n    }\n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    EnumBody();\n    _classLevel--;\n    if (_classLevel == 0) {\n        ObjectMetric metric = new ObjectMetric();\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        metric.javadocs = _javadocs;\n        metric.javadocsLn = _jvdcLines;\n        metric.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n        metric.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}"}, {"methodBefore": "public final void EnumDeclaration(int modifiers) throws ParseException {\n    String sOldClass = _sClass;\n    int oldClasses = _classes;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldSingle;\n    int oldMulti;\n    Util.debug(\"EnumDeclaration().START\");\n    jj_consume_token(ENUM);\n    jj_consume_token(IDENTIFIER);\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(0).image;\n    _classLevel++;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(false);\n            break;\n        default :\n            jj_la1[177] = jj_gen;\n    }\n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    EnumBody();\n    _classLevel--;\n    if (_classLevel == 0) {\n        ObjectMetric metric = new ObjectMetric();\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        metric.javadocs = _javadocs;\n        metric.javadocsLn = _jvdcLines;\n        metric.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n        metric.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}", "methodAfter": "public final void EnumDeclaration(int modifiers) throws ParseException {\n    String sOldClass = _sClass;\n    int oldClasses = _classes;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldSingle;\n    int oldMulti;\n    Util.debug(\"EnumDeclaration().START\");\n    jj_consume_token(ENUM);\n    jj_consume_token(IDENTIFIER);\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(0).image;\n    _classLevel++;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(false);\n            break;\n        default :\n            jj_la1[182] = jj_gen;\n    }\n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    EnumBody();\n    _classLevel--;\n    if (_classLevel == 0) {\n        ObjectMetric metric = new ObjectMetric();\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        metric.javadocs = _javadocs;\n        metric.javadocsLn = _jvdcLines;\n        metric.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n        metric.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}"}], [{"methodBefore": "private void generateOverviews() throws IOException {\n    generateOverview(null);\n    Iterator iter = projectData.getChildren().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateOverview(packageData);\n    } \n}", "methodAfter": "private void generateOverviews() throws IOException {\n    generateOverview(null);\n    Iterator iter = projectData.getPackages().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateOverview(packageData);\n    } \n}"}, {"methodBefore": "private void generateSourceFileLists() throws IOException {\n    generateSourceFileList(null);\n    Iterator iter = projectData.getChildren().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateSourceFileList(packageData);\n    } \n}", "methodAfter": "private void generateSourceFileLists() throws IOException {\n    generateSourceFileList(null);\n    Iterator iter = projectData.getPackages().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateSourceFileList(packageData);\n    } \n}"}, {"methodBefore": "private void dumpPackages(ProjectData projectData) {\n    println(\"<packages>\");\n    increaseIndentation();\n    Iterator it = projectData.getChildren().iterator();\n    while (it.hasNext()) {\n        dumpPackage(((PackageData) (it.next())));\n    } \n    decreaseIndentation();\n    println(\"</packages>\");\n}", "methodAfter": "private void dumpPackages(ProjectData projectData) {\n    println(\"<packages>\");\n    increaseIndentation();\n    Iterator it = projectData.getPackages().iterator();\n    while (it.hasNext()) {\n        dumpPackage(((PackageData) (it.next())));\n    } \n    decreaseIndentation();\n    println(\"</packages>\");\n}"}], [{"methodBefore": "private boolean jj_3R_128() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_128() {\n    if (jj_scan_token(STATIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_128() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_128() {\n    if (jj_scan_token(STATIC)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        LOGGER.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classPackageName + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowsForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(generateHtmlizedJavaSource(sourceFileData));\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        LOGGER.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classPackageName + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowsForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(generateHtmlizedJavaSource(sourceFileData));\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generatePackageList() throws IOException {\n    File file = new File(destinationDir, \"frame-packages.html\");\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xml:lang=\\\"en\\\" lang=\\\"en\\\">\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onclick=\\'parent.sourceFileList.location.href=\\\"frame-sourcefiles.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        Iterator iter = projectData.getPackages().iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generatePackageList() throws IOException {\n    File file = new File(destinationDir, \"frame-packages.html\");\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xml:lang=\\\"en\\\" lang=\\\"en\\\">\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onclick=\\'parent.sourceFileList.location.href=\\\"frame-sourcefiles.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        Iterator iter = projectData.getPackages().iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_398() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_398() {\n    if (jj_3R_414()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_398() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_398() {\n    if (jj_3R_414()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void StatementExpressionList() throws ParseException {\n    StatementExpression();\n    label_60 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[154] = jj_gen;\n                break label_60;\n        }\n        jj_consume_token(COMMA);\n        StatementExpression();\n    } \n}", "methodAfter": "public final void StatementExpressionList() throws ParseException {\n    StatementExpression();\n    label_61 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[155] = jj_gen;\n                break label_61;\n        }\n        jj_consume_token(COMMA);\n        StatementExpression();\n    } \n}"}, {"methodBefore": "public final void StatementExpressionList() throws ParseException {\n    StatementExpression();\n    label_60 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[154] = jj_gen;\n                break label_60;\n        }\n        jj_consume_token(COMMA);\n        StatementExpression();\n    } \n}", "methodAfter": "public final void StatementExpressionList() throws ParseException {\n    StatementExpression();\n    label_61 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[155] = jj_gen;\n                break label_61;\n        }\n        jj_consume_token(COMMA);\n        StatementExpression();\n    } \n}"}], [{"methodBefore": "public static void main(String[] args) {\n    Header.print(System.out);\n    args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    new Main(args);\n}", "methodAfter": "public static void main(String[] args) {\n    Header.print(System.out);\n    try {\n        args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    } catch (Exception ex) {\n        System.err.println(\"Error: Cannot process arguments: \" + ex.getMessage());\n        System.exit(1);\n    }\n    new Main(args);\n}"}, {"methodBefore": "public static void main(String[] args) {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Instrument time: \" + (stopTime - startTime)) + \"ms\");\n}", "methodAfter": "public static void main(String[] args) {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    try {\n        args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    } catch (Exception ex) {\n        System.err.println(\"Error: Cannot process arguments: \" + ex.getMessage());\n        System.exit(1);\n    }\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Instrument time: \" + (stopTime - startTime)) + \"ms\");\n}"}, {"methodBefore": "public static void main(String[] args) throws Exception {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Report time: \" + (stopTime - startTime)) + \"ms\");\n}", "methodAfter": "public static void main(String[] args) throws Exception {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    try {\n        args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    } catch (Exception ex) {\n        System.err.println(\"Error: Cannot process arguments: \" + ex.getMessage());\n        System.exit(1);\n    }\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Report time: \" + (stopTime - startTime)) + \"ms\");\n}"}], [{"methodBefore": "public final void ExtendsList(boolean isInterface) throws ParseException {\n    boolean extendsMoreThanOne = false;\n    jj_consume_token(EXTENDS);\n    ClassOrInterfaceType();\n    label_68 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[179] = jj_gen;\n                break label_68;\n        }\n        jj_consume_token(COMMA);\n        ClassOrInterfaceType();\n        extendsMoreThanOne = true;\n    } \n    if (extendsMoreThanOne && (!isInterface)) {\n        if (true) {\n            throw new ParseException(\"A class cannot extend more than one other class\");\n        }\n    }\n}", "methodAfter": "public final void ExtendsList(boolean isInterface) throws ParseException {\n    boolean extendsMoreThanOne = false;\n    jj_consume_token(EXTENDS);\n    ClassOrInterfaceType();\n    label_71 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[184] = jj_gen;\n                break label_71;\n        }\n        jj_consume_token(COMMA);\n        ClassOrInterfaceType();\n        extendsMoreThanOne = true;\n    } \n    if (extendsMoreThanOne && (!isInterface)) {\n        if (true) {\n            throw new ParseException(\"A class cannot extend more than one other class\");\n        }\n    }\n}"}, {"methodBefore": "public final void ExtendsList(boolean isInterface) throws ParseException {\n    boolean extendsMoreThanOne = false;\n    jj_consume_token(EXTENDS);\n    ClassOrInterfaceType();\n    label_68 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[179] = jj_gen;\n                break label_68;\n        }\n        jj_consume_token(COMMA);\n        ClassOrInterfaceType();\n        extendsMoreThanOne = true;\n    } \n    if (extendsMoreThanOne && (!isInterface)) {\n        if (true) {\n            throw new ParseException(\"A class cannot extend more than one other class\");\n        }\n    }\n}", "methodAfter": "public final void ExtendsList(boolean isInterface) throws ParseException {\n    boolean extendsMoreThanOne = false;\n    jj_consume_token(EXTENDS);\n    ClassOrInterfaceType();\n    label_71 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[184] = jj_gen;\n                break label_71;\n        }\n        jj_consume_token(COMMA);\n        ClassOrInterfaceType();\n        extendsMoreThanOne = true;\n    } \n    if (extendsMoreThanOne && (!isInterface)) {\n        if (true) {\n            throw new ParseException(\"A class cannot extend more than one other class\");\n        }\n    }\n}"}], [{"methodBefore": "public final void InterfaceDeclaration() throws ParseException {\n    Token tmpToken = null;\n    _javadocs = 0;\n    Vector vMetric = null;\n    int oldSingle;\n    int oldMulti;\n    _jvdcLines = 0;\n    boolean bTemp = _bPublic;\n    _bPublic = false;\n    label_20 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case PUBLIC :\n            case TESTAAAA :\n                break;\n            default :\n                jj_la1[36] = jj_gen;\n                break label_20;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                break;\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                _bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            default :\n                jj_la1[37] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    if (tmpToken == null) {\n        tmpToken = getToken(1);\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            Util.debug(\"InterfaceDeclaration()._javadocs++\");\n            if (_bPublic || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                _jvdcLines += JavaParserTokenManager._iMultiCommentsLast;\n                JavaParserTokenManager._iFormalComments += JavaParserTokenManager._iMultiCommentsLast;\n            }\n            JavaParserTokenManager._iMultiComments -= JavaParserTokenManager._iMultiCommentsLast;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    UnmodifiedInterfaceDeclaration();\n    vMetric = ((Vector) (_vClasses.lastElement()));\n    vMetric.addElement(new Integer(_javadocs));\n    vMetric.addElement(new Integer(_jvdcLines));\n    vMetric.addElement(new Integer(JavaParserTokenManager._iSingleComments - oldSingle));\n    vMetric.addElement(new Integer(JavaParserTokenManager._iMultiComments - oldMulti));\n    _bPublic = bTemp;\n}", "methodAfter": "public final void InterfaceDeclaration() throws ParseException {\n    Token tmpToken = null;\n    _javadocs = 0;\n    ObjectMetric metric = null;\n    int oldSingle;\n    int oldMulti;\n    _jvdcLines = 0;\n    boolean bTemp = _bPublic;\n    _bPublic = false;\n    label_20 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case PUBLIC :\n            case TESTAAAA :\n                break;\n            default :\n                jj_la1[36] = jj_gen;\n                break label_20;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                break;\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                _bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            default :\n                jj_la1[37] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    if (tmpToken == null) {\n        tmpToken = getToken(1);\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            Util.debug(\"InterfaceDeclaration()._javadocs++\");\n            if (_bPublic || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                _jvdcLines += JavaParserTokenManager._iMultiCommentsLast;\n                JavaParserTokenManager._iFormalComments += JavaParserTokenManager._iMultiCommentsLast;\n            }\n            JavaParserTokenManager._iMultiComments -= JavaParserTokenManager._iMultiCommentsLast;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    UnmodifiedInterfaceDeclaration();\n    metric = ((ObjectMetric) (_vClasses.get(_vClasses.size() - 1)));\n    metric.javadocs = _javadocs;\n    metric.javadocsLn = _jvdcLines;\n    metric.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n    metric.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n    _bPublic = bTemp;\n}"}, {"methodBefore": "public final void ClassDeclaration() throws ParseException {\n    Token tmpToken = null;\n    _javadocs = 0;\n    Vector vMetric = null;\n    int oldSingle = 0;\n    int oldMulti = 0;\n    _jvdcLines = 0;\n    boolean bTemp = _bPublic;\n    _bPublic = false;\n    label_11 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case FINAL :\n            case PUBLIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n                break;\n            default :\n                jj_la1[17] = jj_gen;\n                break label_11;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case FINAL :\n                jj_consume_token(FINAL);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                _bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case SYNCHRONIZED :\n                jj_consume_token(SYNCHRONIZED);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            default :\n                jj_la1[18] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    if (tmpToken == null) {\n        tmpToken = getToken(1);\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            Util.debug(\"ClassDeclaration()._javadocs++\");\n            if (_bPublic || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                _jvdcLines += JavaParserTokenManager._iMultiCommentsLast;\n                JavaParserTokenManager._iFormalComments += JavaParserTokenManager._iMultiCommentsLast;\n            }\n            JavaParserTokenManager._iMultiComments -= JavaParserTokenManager._iMultiCommentsLast;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    UnmodifiedClassDeclaration();\n    vMetric = ((Vector) (_vClasses.lastElement()));\n    vMetric.addElement(new Integer(_javadocs));\n    vMetric.addElement(new Integer(_jvdcLines));\n    vMetric.addElement(new Integer(JavaParserTokenManager._iSingleComments - oldSingle));\n    vMetric.addElement(new Integer(JavaParserTokenManager._iMultiComments - oldMulti));\n    _bPublic = bTemp;\n}", "methodAfter": "public final void ClassDeclaration() throws ParseException {\n    Token tmpToken = null;\n    _javadocs = 0;\n    ObjectMetric metric = null;\n    int oldSingle = 0;\n    int oldMulti = 0;\n    _jvdcLines = 0;\n    boolean bTemp = _bPublic;\n    _bPublic = false;\n    label_11 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case FINAL :\n            case PUBLIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n                break;\n            default :\n                jj_la1[17] = jj_gen;\n                break label_11;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case FINAL :\n                jj_consume_token(FINAL);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                _bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case SYNCHRONIZED :\n                jj_consume_token(SYNCHRONIZED);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            default :\n                jj_la1[18] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    if (tmpToken == null) {\n        tmpToken = getToken(1);\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            Util.debug(\"ClassDeclaration()._javadocs++\");\n            if (_bPublic || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                _jvdcLines += JavaParserTokenManager._iMultiCommentsLast;\n                JavaParserTokenManager._iFormalComments += JavaParserTokenManager._iMultiCommentsLast;\n            }\n            JavaParserTokenManager._iMultiComments -= JavaParserTokenManager._iMultiCommentsLast;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    UnmodifiedClassDeclaration();\n    metric = ((ObjectMetric) (_vClasses.get(_vClasses.size() - 1)));\n    metric.javadocs = _javadocs;\n    metric.javadocsLn = _jvdcLines;\n    metric.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n    metric.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n    _bPublic = bTemp;\n}"}], [{"methodBefore": "private boolean jj_3R_443() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_432() {\n    if (jj_3R_312()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_443() {\n    if (jj_3R_196()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_432() {\n    if (jj_3R_312()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_313() {\n    if (jj_scan_token(INSTANCEOF)) {\n        return true;\n    }\n    if (jj_3R_111()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_316() {\n    if (jj_scan_token(INSTANCEOF)) {\n        return true;\n    }\n    if (jj_3R_114()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_313() {\n    if (jj_scan_token(INSTANCEOF)) {\n        return true;\n    }\n    if (jj_3R_111()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_316() {\n    if (jj_scan_token(INSTANCEOF)) {\n        return true;\n    }\n    if (jj_3R_114()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_385() {\n    if (jj_3R_407()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_440() {\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_385() {\n    if (jj_3R_407()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_440() {\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_91() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_90() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_91() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_90() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_14() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_98()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_99()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_14() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_102()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_103()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_14() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_98()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_99()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_14() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_102()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_103()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generatePackageList() throws IOException {\n    File file = new File(destinationDir, \"frame-packages.html\");\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xml:lang=\\\"en\\\" lang=\\\"en\\\">\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onclick=\\'parent.sourceFileList.location.href=\\\"frame-sourcefiles.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        Iterator iter = projectData.getPackages().iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generatePackageList() throws IOException {\n    File file = new File(destinationDir, \"frame-packages.html\");\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xml:lang=\\\"en\\\" lang=\\\"en\\\">\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onclick=\\'parent.sourceFileList.location.href=\\\"frame-sourcefiles.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        Iterator iter = projectData.getPackages().iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_127() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_127() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_127() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_127() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_335() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_335() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_335() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_335() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_432() {\n    if (jj_scan_token(ELSE)) {\n        return true;\n    }\n    if (jj_3R_223()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_435() {\n    if (jj_scan_token(ELSE)) {\n        return true;\n    }\n    if (jj_3R_225()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_432() {\n    if (jj_scan_token(ELSE)) {\n        return true;\n    }\n    if (jj_3R_223()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_435() {\n    if (jj_scan_token(ELSE)) {\n        return true;\n    }\n    if (jj_3R_225()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void jj_rescan_token() {\n    jj_rescan = true;\n    for (int i = 0; i < 62; i++) {\n        try {\n            JJCalls p = jj_2_rtns[i];\n            do {\n                if (p.gen > jj_gen) {\n                    jj_la = p.arg;\n                    jj_lastpos = jj_scanpos = p.first;\n                    switch (i) {\n                        case 0 :\n                            jj_3_1();\n                            break;\n                        case 1 :\n                            jj_3_2();\n                            break;\n                        case 2 :\n                            jj_3_3();\n                            break;\n                        case 3 :\n                            jj_3_4();\n                            break;\n                        case 4 :\n                            jj_3_5();\n                            break;\n                        case 5 :\n                            jj_3_6();\n                            break;\n                        case 6 :\n                            jj_3_7();\n                            break;\n                        case 7 :\n                            jj_3_8();\n                            break;\n                        case 8 :\n                            jj_3_9();\n                            break;\n                        case 9 :\n                            jj_3_10();\n                            break;\n                        case 10 :\n                            jj_3_11();\n                            break;\n                        case 11 :\n                            jj_3_12();\n                            break;\n                        case 12 :\n                            jj_3_13();\n                            break;\n                        case 13 :\n                            jj_3_14();\n                            break;\n                        case 14 :\n                            jj_3_15();\n                            break;\n                        case 15 :\n                            jj_3_16();\n                            break;\n                        case 16 :\n                            jj_3_17();\n                            break;\n                        case 17 :\n                            jj_3_18();\n                            break;\n                        case 18 :\n                            jj_3_19();\n                            break;\n                        case 19 :\n                            jj_3_20();\n                            break;\n                        case 20 :\n                            jj_3_21();\n                            break;\n                        case 21 :\n                            jj_3_22();\n                            break;\n                        case 22 :\n                            jj_3_23();\n                            break;\n                        case 23 :\n                            jj_3_24();\n                            break;\n                        case 24 :\n                            jj_3_25();\n                            break;\n                        case 25 :\n                            jj_3_26();\n                            break;\n                        case 26 :\n                            jj_3_27();\n                            break;\n                        case 27 :\n                            jj_3_28();\n                            break;\n                        case 28 :\n                            jj_3_29();\n                            break;\n                        case 29 :\n                            jj_3_30();\n                            break;\n                        case 30 :\n                            jj_3_31();\n                            break;\n                        case 31 :\n                            jj_3_32();\n                            break;\n                        case 32 :\n                            jj_3_33();\n                            break;\n                        case 33 :\n                            jj_3_34();\n                            break;\n                        case 34 :\n                            jj_3_35();\n                            break;\n                        case 35 :\n                            jj_3_36();\n                            break;\n                        case 36 :\n                            jj_3_37();\n                            break;\n                        case 37 :\n                            jj_3_38();\n                            break;\n                        case 38 :\n                            jj_3_39();\n                            break;\n                        case 39 :\n                            jj_3_40();\n                            break;\n                        case 40 :\n                            jj_3_41();\n                            break;\n                        case 41 :\n                            jj_3_42();\n                            break;\n                        case 42 :\n                            jj_3_43();\n                            break;\n                        case 43 :\n                            jj_3_44();\n                            break;\n                        case 44 :\n                            jj_3_45();\n                            break;\n                        case 45 :\n                            jj_3_46();\n                            break;\n                        case 46 :\n                            jj_3_47();\n                            break;\n                        case 47 :\n                            jj_3_48();\n                            break;\n                        case 48 :\n                            jj_3_49();\n                            break;\n                        case 49 :\n                            jj_3_50();\n                            break;\n                        case 50 :\n                            jj_3_51();\n                            break;\n                        case 51 :\n                            jj_3_52();\n                            break;\n                        case 52 :\n                            jj_3_53();\n                            break;\n                        case 53 :\n                            jj_3_54();\n                            break;\n                        case 54 :\n                            jj_3_55();\n                            break;\n                        case 55 :\n                            jj_3_56();\n                            break;\n                        case 56 :\n                            jj_3_57();\n                            break;\n                        case 57 :\n                            jj_3_58();\n                            break;\n                        case 58 :\n                            jj_3_59();\n                            break;\n                        case 59 :\n                            jj_3_60();\n                            break;\n                        case 60 :\n                            jj_3_61();\n                            break;\n                        case 61 :\n                            jj_3_62();\n                            break;\n                    }\n                }\n                p = p.next;\n            } while (p != null );\n        } catch (LookaheadSuccess ls) {\n        }\n    }\n    jj_rescan = false;\n}", "methodAfter": "private void jj_rescan_token() {\n    jj_rescan = true;\n    for (int i = 0; i < 61; i++) {\n        try {\n            JJCalls p = jj_2_rtns[i];\n            do {\n                if (p.gen > jj_gen) {\n                    jj_la = p.arg;\n                    jj_lastpos = jj_scanpos = p.first;\n                    switch (i) {\n                        case 0 :\n                            jj_3_1();\n                            break;\n                        case 1 :\n                            jj_3_2();\n                            break;\n                        case 2 :\n                            jj_3_3();\n                            break;\n                        case 3 :\n                            jj_3_4();\n                            break;\n                        case 4 :\n                            jj_3_5();\n                            break;\n                        case 5 :\n                            jj_3_6();\n                            break;\n                        case 6 :\n                            jj_3_7();\n                            break;\n                        case 7 :\n                            jj_3_8();\n                            break;\n                        case 8 :\n                            jj_3_9();\n                            break;\n                        case 9 :\n                            jj_3_10();\n                            break;\n                        case 10 :\n                            jj_3_11();\n                            break;\n                        case 11 :\n                            jj_3_12();\n                            break;\n                        case 12 :\n                            jj_3_13();\n                            break;\n                        case 13 :\n                            jj_3_14();\n                            break;\n                        case 14 :\n                            jj_3_15();\n                            break;\n                        case 15 :\n                            jj_3_16();\n                            break;\n                        case 16 :\n                            jj_3_17();\n                            break;\n                        case 17 :\n                            jj_3_18();\n                            break;\n                        case 18 :\n                            jj_3_19();\n                            break;\n                        case 19 :\n                            jj_3_20();\n                            break;\n                        case 20 :\n                            jj_3_21();\n                            break;\n                        case 21 :\n                            jj_3_22();\n                            break;\n                        case 22 :\n                            jj_3_23();\n                            break;\n                        case 23 :\n                            jj_3_24();\n                            break;\n                        case 24 :\n                            jj_3_25();\n                            break;\n                        case 25 :\n                            jj_3_26();\n                            break;\n                        case 26 :\n                            jj_3_27();\n                            break;\n                        case 27 :\n                            jj_3_28();\n                            break;\n                        case 28 :\n                            jj_3_29();\n                            break;\n                        case 29 :\n                            jj_3_30();\n                            break;\n                        case 30 :\n                            jj_3_31();\n                            break;\n                        case 31 :\n                            jj_3_32();\n                            break;\n                        case 32 :\n                            jj_3_33();\n                            break;\n                        case 33 :\n                            jj_3_34();\n                            break;\n                        case 34 :\n                            jj_3_35();\n                            break;\n                        case 35 :\n                            jj_3_36();\n                            break;\n                        case 36 :\n                            jj_3_37();\n                            break;\n                        case 37 :\n                            jj_3_38();\n                            break;\n                        case 38 :\n                            jj_3_39();\n                            break;\n                        case 39 :\n                            jj_3_40();\n                            break;\n                        case 40 :\n                            jj_3_41();\n                            break;\n                        case 41 :\n                            jj_3_42();\n                            break;\n                        case 42 :\n                            jj_3_43();\n                            break;\n                        case 43 :\n                            jj_3_44();\n                            break;\n                        case 44 :\n                            jj_3_45();\n                            break;\n                        case 45 :\n                            jj_3_46();\n                            break;\n                        case 46 :\n                            jj_3_47();\n                            break;\n                        case 47 :\n                            jj_3_48();\n                            break;\n                        case 48 :\n                            jj_3_49();\n                            break;\n                        case 49 :\n                            jj_3_50();\n                            break;\n                        case 50 :\n                            jj_3_51();\n                            break;\n                        case 51 :\n                            jj_3_52();\n                            break;\n                        case 52 :\n                            jj_3_53();\n                            break;\n                        case 53 :\n                            jj_3_54();\n                            break;\n                        case 54 :\n                            jj_3_55();\n                            break;\n                        case 55 :\n                            jj_3_56();\n                            break;\n                        case 56 :\n                            jj_3_57();\n                            break;\n                        case 57 :\n                            jj_3_58();\n                            break;\n                        case 58 :\n                            jj_3_59();\n                            break;\n                        case 59 :\n                            jj_3_60();\n                            break;\n                        case 60 :\n                            jj_3_61();\n                            break;\n                    }\n                }\n                p = p.next;\n            } while (p != null );\n        } catch (LookaheadSuccess ls) {\n        }\n    }\n    jj_rescan = false;\n}"}, {"methodBefore": "private void jj_rescan_token() {\n    jj_rescan = true;\n    for (int i = 0; i < 62; i++) {\n        try {\n            JJCalls p = jj_2_rtns[i];\n            do {\n                if (p.gen > jj_gen) {\n                    jj_la = p.arg;\n                    jj_lastpos = jj_scanpos = p.first;\n                    switch (i) {\n                        case 0 :\n                            jj_3_1();\n                            break;\n                        case 1 :\n                            jj_3_2();\n                            break;\n                        case 2 :\n                            jj_3_3();\n                            break;\n                        case 3 :\n                            jj_3_4();\n                            break;\n                        case 4 :\n                            jj_3_5();\n                            break;\n                        case 5 :\n                            jj_3_6();\n                            break;\n                        case 6 :\n                            jj_3_7();\n                            break;\n                        case 7 :\n                            jj_3_8();\n                            break;\n                        case 8 :\n                            jj_3_9();\n                            break;\n                        case 9 :\n                            jj_3_10();\n                            break;\n                        case 10 :\n                            jj_3_11();\n                            break;\n                        case 11 :\n                            jj_3_12();\n                            break;\n                        case 12 :\n                            jj_3_13();\n                            break;\n                        case 13 :\n                            jj_3_14();\n                            break;\n                        case 14 :\n                            jj_3_15();\n                            break;\n                        case 15 :\n                            jj_3_16();\n                            break;\n                        case 16 :\n                            jj_3_17();\n                            break;\n                        case 17 :\n                            jj_3_18();\n                            break;\n                        case 18 :\n                            jj_3_19();\n                            break;\n                        case 19 :\n                            jj_3_20();\n                            break;\n                        case 20 :\n                            jj_3_21();\n                            break;\n                        case 21 :\n                            jj_3_22();\n                            break;\n                        case 22 :\n                            jj_3_23();\n                            break;\n                        case 23 :\n                            jj_3_24();\n                            break;\n                        case 24 :\n                            jj_3_25();\n                            break;\n                        case 25 :\n                            jj_3_26();\n                            break;\n                        case 26 :\n                            jj_3_27();\n                            break;\n                        case 27 :\n                            jj_3_28();\n                            break;\n                        case 28 :\n                            jj_3_29();\n                            break;\n                        case 29 :\n                            jj_3_30();\n                            break;\n                        case 30 :\n                            jj_3_31();\n                            break;\n                        case 31 :\n                            jj_3_32();\n                            break;\n                        case 32 :\n                            jj_3_33();\n                            break;\n                        case 33 :\n                            jj_3_34();\n                            break;\n                        case 34 :\n                            jj_3_35();\n                            break;\n                        case 35 :\n                            jj_3_36();\n                            break;\n                        case 36 :\n                            jj_3_37();\n                            break;\n                        case 37 :\n                            jj_3_38();\n                            break;\n                        case 38 :\n                            jj_3_39();\n                            break;\n                        case 39 :\n                            jj_3_40();\n                            break;\n                        case 40 :\n                            jj_3_41();\n                            break;\n                        case 41 :\n                            jj_3_42();\n                            break;\n                        case 42 :\n                            jj_3_43();\n                            break;\n                        case 43 :\n                            jj_3_44();\n                            break;\n                        case 44 :\n                            jj_3_45();\n                            break;\n                        case 45 :\n                            jj_3_46();\n                            break;\n                        case 46 :\n                            jj_3_47();\n                            break;\n                        case 47 :\n                            jj_3_48();\n                            break;\n                        case 48 :\n                            jj_3_49();\n                            break;\n                        case 49 :\n                            jj_3_50();\n                            break;\n                        case 50 :\n                            jj_3_51();\n                            break;\n                        case 51 :\n                            jj_3_52();\n                            break;\n                        case 52 :\n                            jj_3_53();\n                            break;\n                        case 53 :\n                            jj_3_54();\n                            break;\n                        case 54 :\n                            jj_3_55();\n                            break;\n                        case 55 :\n                            jj_3_56();\n                            break;\n                        case 56 :\n                            jj_3_57();\n                            break;\n                        case 57 :\n                            jj_3_58();\n                            break;\n                        case 58 :\n                            jj_3_59();\n                            break;\n                        case 59 :\n                            jj_3_60();\n                            break;\n                        case 60 :\n                            jj_3_61();\n                            break;\n                        case 61 :\n                            jj_3_62();\n                            break;\n                    }\n                }\n                p = p.next;\n            } while (p != null );\n        } catch (LookaheadSuccess ls) {\n        }\n    }\n    jj_rescan = false;\n}", "methodAfter": "private void jj_rescan_token() {\n    jj_rescan = true;\n    for (int i = 0; i < 61; i++) {\n        try {\n            JJCalls p = jj_2_rtns[i];\n            do {\n                if (p.gen > jj_gen) {\n                    jj_la = p.arg;\n                    jj_lastpos = jj_scanpos = p.first;\n                    switch (i) {\n                        case 0 :\n                            jj_3_1();\n                            break;\n                        case 1 :\n                            jj_3_2();\n                            break;\n                        case 2 :\n                            jj_3_3();\n                            break;\n                        case 3 :\n                            jj_3_4();\n                            break;\n                        case 4 :\n                            jj_3_5();\n                            break;\n                        case 5 :\n                            jj_3_6();\n                            break;\n                        case 6 :\n                            jj_3_7();\n                            break;\n                        case 7 :\n                            jj_3_8();\n                            break;\n                        case 8 :\n                            jj_3_9();\n                            break;\n                        case 9 :\n                            jj_3_10();\n                            break;\n                        case 10 :\n                            jj_3_11();\n                            break;\n                        case 11 :\n                            jj_3_12();\n                            break;\n                        case 12 :\n                            jj_3_13();\n                            break;\n                        case 13 :\n                            jj_3_14();\n                            break;\n                        case 14 :\n                            jj_3_15();\n                            break;\n                        case 15 :\n                            jj_3_16();\n                            break;\n                        case 16 :\n                            jj_3_17();\n                            break;\n                        case 17 :\n                            jj_3_18();\n                            break;\n                        case 18 :\n                            jj_3_19();\n                            break;\n                        case 19 :\n                            jj_3_20();\n                            break;\n                        case 20 :\n                            jj_3_21();\n                            break;\n                        case 21 :\n                            jj_3_22();\n                            break;\n                        case 22 :\n                            jj_3_23();\n                            break;\n                        case 23 :\n                            jj_3_24();\n                            break;\n                        case 24 :\n                            jj_3_25();\n                            break;\n                        case 25 :\n                            jj_3_26();\n                            break;\n                        case 26 :\n                            jj_3_27();\n                            break;\n                        case 27 :\n                            jj_3_28();\n                            break;\n                        case 28 :\n                            jj_3_29();\n                            break;\n                        case 29 :\n                            jj_3_30();\n                            break;\n                        case 30 :\n                            jj_3_31();\n                            break;\n                        case 31 :\n                            jj_3_32();\n                            break;\n                        case 32 :\n                            jj_3_33();\n                            break;\n                        case 33 :\n                            jj_3_34();\n                            break;\n                        case 34 :\n                            jj_3_35();\n                            break;\n                        case 35 :\n                            jj_3_36();\n                            break;\n                        case 36 :\n                            jj_3_37();\n                            break;\n                        case 37 :\n                            jj_3_38();\n                            break;\n                        case 38 :\n                            jj_3_39();\n                            break;\n                        case 39 :\n                            jj_3_40();\n                            break;\n                        case 40 :\n                            jj_3_41();\n                            break;\n                        case 41 :\n                            jj_3_42();\n                            break;\n                        case 42 :\n                            jj_3_43();\n                            break;\n                        case 43 :\n                            jj_3_44();\n                            break;\n                        case 44 :\n                            jj_3_45();\n                            break;\n                        case 45 :\n                            jj_3_46();\n                            break;\n                        case 46 :\n                            jj_3_47();\n                            break;\n                        case 47 :\n                            jj_3_48();\n                            break;\n                        case 48 :\n                            jj_3_49();\n                            break;\n                        case 49 :\n                            jj_3_50();\n                            break;\n                        case 50 :\n                            jj_3_51();\n                            break;\n                        case 51 :\n                            jj_3_52();\n                            break;\n                        case 52 :\n                            jj_3_53();\n                            break;\n                        case 53 :\n                            jj_3_54();\n                            break;\n                        case 54 :\n                            jj_3_55();\n                            break;\n                        case 55 :\n                            jj_3_56();\n                            break;\n                        case 56 :\n                            jj_3_57();\n                            break;\n                        case 57 :\n                            jj_3_58();\n                            break;\n                        case 58 :\n                            jj_3_59();\n                            break;\n                        case 59 :\n                            jj_3_60();\n                            break;\n                        case 60 :\n                            jj_3_61();\n                            break;\n                    }\n                }\n                p = p.next;\n            } while (p != null );\n        } catch (LookaheadSuccess ls) {\n        }\n    }\n    jj_rescan = false;\n}"}], [{"methodBefore": "public int getNumberOfCoveredLines() {\n    int hits = 0;\n    Iterator iter = lines.values().iterator();\n    while (iter.hasNext()) {\n        if (((LineInformation) (iter.next())).getHits() > 0) {\n            hits++;\n        }\n    } \n    return hits;\n}", "methodAfter": "public int getNumberOfCoveredLines() {\n    int num = 0;\n    Iterator iter = lines.values().iterator();\n    while (iter.hasNext()) {\n        if (((LineInformation) (iter.next())).getHits() > 0) {\n            num++;\n        }\n    } \n    return num;\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int hits = 0;\n    Iterator iter = conditionals.values().iterator();\n    while (iter.hasNext()) {\n        if (((LineInformation) (iter.next())).getHits() > 0) {\n            hits++;\n        }\n    } \n    return hits;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    int num = 0;\n    Iterator iter = conditionals.values().iterator();\n    while (iter.hasNext()) {\n        if (((LineInformation) (iter.next())).getHits() > 0) {\n            num++;\n        }\n    } \n    return num;\n}"}], [{"methodBefore": "public void testBaseDir() throws IOException {\n    greenProject.addClassData(firstClass);\n    redProject.addClassData(seventhClass);\n    blueProject.addClassData(secondClass);\n    File greenFile = createTempSerFile();\n    File redFile = createTempSerFile();\n    File blueFile = createTempSerFile();\n    File dataFile = createTempSerFile();\n    dataFile.delete();\n    CoverageDataFileHandler.saveCoverageData(greenProject, greenFile);\n    CoverageDataFileHandler.saveCoverageData(redProject, redFile);\n    CoverageDataFileHandler.saveCoverageData(blueProject, blueFile);\n    String[] args = new String[]{ \"--datafile\", dataFile.getAbsolutePath(), greenFile.getAbsolutePath(), \"--basedir\", redFile.getParent(), redFile.getName(), blueFile.getName() };\n    Main.main(args);\n    ProjectData merged = CoverageDataFileHandler.loadCoverageData(dataFile);\n    assertEquals(3, merged.getNumberOfClasses());\n    assertNotNull(merged.getClassData(\"test.First\"));\n    assertNotNull(merged.getClassData(\"test.Second\"));\n    assertNotNull(merged.getClassData(\"Seventh\"));\n}", "methodAfter": "public void testBaseDir() throws IOException {\n    greenProject.addClassData(firstClass);\n    redProject.addClassData(seventhClass);\n    blueProject.addClassData(secondClass);\n    File greenFile = createTempSerFile();\n    File redFile = createTempSerFile();\n    File blueFile = createTempSerFile();\n    File dataFile = createTempSerFile();\n    dataFile.delete();\n    CoverageDataFileHandler.saveCoverageData(greenProject, greenFile);\n    CoverageDataFileHandler.saveCoverageData(redProject, redFile);\n    CoverageDataFileHandler.saveCoverageData(blueProject, blueFile);\n    String[] args = new String[]{ \"--datafile\", dataFile.getAbsolutePath(), greenFile.getAbsolutePath(), \"--basedir\", redFile.getParent(), redFile.getName(), blueFile.getName() };\n    MergeMain.main(args);\n    ProjectData merged = CoverageDataFileHandler.loadCoverageData(dataFile);\n    assertEquals(3, merged.getNumberOfClasses());\n    assertNotNull(merged.getClassData(\"test.First\"));\n    assertNotNull(merged.getClassData(\"test.Second\"));\n    assertNotNull(merged.getClassData(\"Seventh\"));\n}"}, {"methodBefore": "public void testExistingDestinationFile() throws IOException {\n    greenProject.addClassData(firstClass);\n    redProject.addClassData(secondClass);\n    File greenFile = createTempSerFile();\n    File dataFile = createTempSerFile();\n    CoverageDataFileHandler.saveCoverageData(greenProject, greenFile);\n    CoverageDataFileHandler.saveCoverageData(redProject, dataFile);\n    String[] args = new String[]{ \"--datafile\", dataFile.getAbsolutePath(), greenFile.getAbsolutePath() };\n    Main.main(args);\n    ProjectData merged = CoverageDataFileHandler.loadCoverageData(dataFile);\n    assertEquals(2, merged.getNumberOfClasses());\n    assertNotNull(merged.getClassData(\"test.First\"));\n    assertNotNull(merged.getClassData(\"test.Second\"));\n}", "methodAfter": "public void testExistingDestinationFile() throws IOException {\n    greenProject.addClassData(firstClass);\n    redProject.addClassData(secondClass);\n    File greenFile = createTempSerFile();\n    File dataFile = createTempSerFile();\n    CoverageDataFileHandler.saveCoverageData(greenProject, greenFile);\n    CoverageDataFileHandler.saveCoverageData(redProject, dataFile);\n    String[] args = new String[]{ \"--datafile\", dataFile.getAbsolutePath(), greenFile.getAbsolutePath() };\n    MergeMain.main(args);\n    ProjectData merged = CoverageDataFileHandler.loadCoverageData(dataFile);\n    assertEquals(2, merged.getNumberOfClasses());\n    assertNotNull(merged.getClassData(\"test.First\"));\n    assertNotNull(merged.getClassData(\"test.Second\"));\n}"}], [{"methodBefore": "public static void main(String[] args) {\n    Header.print(System.out);\n    args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    new Main(args);\n}", "methodAfter": "public static void main(String[] args) {\n    Header.print(System.out);\n    try {\n        args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    } catch (Exception ex) {\n        System.err.println(\"Error: Cannot process arguments: \" + ex.getMessage());\n        System.exit(1);\n    }\n    new Main(args);\n}"}, {"methodBefore": "public static void main(String[] args) throws Exception {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Report time: \" + (stopTime - startTime)) + \"ms\");\n}", "methodAfter": "public static void main(String[] args) throws Exception {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    try {\n        args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    } catch (Exception ex) {\n        System.err.println(\"Error: Cannot process arguments: \" + ex.getMessage());\n        System.exit(1);\n    }\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Report time: \" + (stopTime - startTime)) + \"ms\");\n}"}, {"methodBefore": "public static void main(String[] args) {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Instrument time: \" + (stopTime - startTime)) + \"ms\");\n}", "methodAfter": "public static void main(String[] args) {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    try {\n        args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    } catch (Exception ex) {\n        System.err.println(\"Error: Cannot process arguments: \" + ex.getMessage());\n        System.exit(1);\n    }\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Instrument time: \" + (stopTime - startTime)) + \"ms\");\n}"}], [{"methodBefore": "public final void CreationAnnotation() throws ParseException {\n    jj_consume_token(AT);\n    jj_consume_token(INTERFACE);\n    jj_consume_token(IDENTIFIER);\n    jj_consume_token(LBRACE);\n    label_64 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[167] = jj_gen;\n                break label_64;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void CreationAnnotation() throws ParseException {\n    jj_consume_token(AT);\n    jj_consume_token(INTERFACE);\n    jj_consume_token(IDENTIFIER);\n    jj_consume_token(LBRACE);\n    label_67 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[172] = jj_gen;\n                break label_67;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}"}, {"methodBefore": "public final void CreationAnnotation() throws ParseException {\n    jj_consume_token(AT);\n    jj_consume_token(INTERFACE);\n    jj_consume_token(IDENTIFIER);\n    jj_consume_token(LBRACE);\n    label_64 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[167] = jj_gen;\n                break label_64;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void CreationAnnotation() throws ParseException {\n    jj_consume_token(AT);\n    jj_consume_token(INTERFACE);\n    jj_consume_token(IDENTIFIER);\n    jj_consume_token(LBRACE);\n    label_67 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[172] = jj_gen;\n                break label_67;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}"}], [{"methodBefore": "private boolean jj_3R_378() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_100()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_381() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_104()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_378() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_100()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_381() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_104()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void ClassOrInterfaceDeclaration(int modifiers) throws ParseException {\n    boolean isInterface = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CLASS :\n            jj_consume_token(CLASS);\n            break;\n        case INTERFACE :\n            jj_consume_token(INTERFACE);\n            isInterface = true;\n            break;\n        default :\n            jj_la1[173] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[174] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            ExtendsList(isInterface);\n            break;\n        default :\n            jj_la1[175] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(isInterface);\n            break;\n        default :\n            jj_la1[176] = jj_gen;\n    }\n    ClassOrInterfaceBody(isInterface);\n}", "methodAfter": "public final void ClassOrInterfaceDeclaration(int modifiers) throws ParseException {\n    boolean isInterface = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CLASS :\n            jj_consume_token(CLASS);\n            break;\n        case INTERFACE :\n            jj_consume_token(INTERFACE);\n            isInterface = true;\n            break;\n        default :\n            jj_la1[178] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[179] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            ExtendsList(isInterface);\n            break;\n        default :\n            jj_la1[180] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(isInterface);\n            break;\n        default :\n            jj_la1[181] = jj_gen;\n    }\n    ClassOrInterfaceBody(isInterface);\n}"}, {"methodBefore": "public final void ClassOrInterfaceDeclaration(int modifiers) throws ParseException {\n    boolean isInterface = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CLASS :\n            jj_consume_token(CLASS);\n            break;\n        case INTERFACE :\n            jj_consume_token(INTERFACE);\n            isInterface = true;\n            break;\n        default :\n            jj_la1[173] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[174] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            ExtendsList(isInterface);\n            break;\n        default :\n            jj_la1[175] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(isInterface);\n            break;\n        default :\n            jj_la1[176] = jj_gen;\n    }\n    ClassOrInterfaceBody(isInterface);\n}", "methodAfter": "public final void ClassOrInterfaceDeclaration(int modifiers) throws ParseException {\n    boolean isInterface = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CLASS :\n            jj_consume_token(CLASS);\n            break;\n        case INTERFACE :\n            jj_consume_token(INTERFACE);\n            isInterface = true;\n            break;\n        default :\n            jj_la1[178] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[179] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            ExtendsList(isInterface);\n            break;\n        default :\n            jj_la1[180] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(isInterface);\n            break;\n        default :\n            jj_la1[181] = jj_gen;\n    }\n    ClassOrInterfaceBody(isInterface);\n}"}], [{"methodBefore": "private boolean jj_3R_125() {\n    if (jj_scan_token(STATIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_133() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_125() {\n    if (jj_scan_token(STATIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_133() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_15() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_15() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_3() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_3() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_10() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_10() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_4() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_4() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_9() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_9() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_15() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_15() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_296() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_296() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_9() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_9() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_3() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_3() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_4() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_4() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_296() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_296() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_10() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_10() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void ClassOrInterfaceBodyDeclaration(boolean isInterface) throws ParseException {\n    int modifiers;\n    if (jj_2_59(2)) {\n        Initializer();\n        if (isInterface) {\n            if (true) {\n                throw new ParseException(\"An interface cannot have initializers\");\n            }\n        }\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case AT :\n            case LT :\n                modifiers = Modifiers();\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    default :\n                        jj_la1[187] = jj_gen;\n                        if (jj_2_57(2147483647)) {\n                            ConstructorDeclaration();\n                        } else if (jj_2_58(2147483647)) {\n                            FieldDeclaration15(modifiers);\n                        } else {\n                            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                                case ABSTRACT :\n                                case BOOLEAN :\n                                case BYTE :\n                                case CHAR :\n                                case DOUBLE :\n                                case FINAL :\n                                case FLOAT :\n                                case INT :\n                                case LONG :\n                                case NATIVE :\n                                case PRIVATE :\n                                case PROTECTED :\n                                case PUBLIC :\n                                case SHORT :\n                                case STATIC :\n                                case TESTAAAA :\n                                case SYNCHRONIZED :\n                                case VOID :\n                                case IDENTIFIER :\n                                case AT :\n                                case LT :\n                                    MethodDeclaration15(modifiers);\n                                    break;\n                                default :\n                                    jj_la1[188] = jj_gen;\n                                    jj_consume_token(-1);\n                                    throw new ParseException();\n                            }\n                        }\n                }\n                break;\n            case SEMICOLON :\n                jj_consume_token(SEMICOLON);\n                break;\n            default :\n                jj_la1[189] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void ClassOrInterfaceBodyDeclaration(boolean isInterface) throws ParseException {\n    int modifiers;\n    if (jj_2_58(2)) {\n        Initializer();\n        if (isInterface) {\n            if (true) {\n                throw new ParseException(\"An interface cannot have initializers\");\n            }\n        }\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case AT :\n            case LT :\n                modifiers = Modifiers();\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    default :\n                        jj_la1[192] = jj_gen;\n                        if (jj_2_56(2147483647)) {\n                            ConstructorDeclaration();\n                        } else if (jj_2_57(2147483647)) {\n                            FieldDeclaration15(modifiers);\n                        } else {\n                            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                                case ABSTRACT :\n                                case BOOLEAN :\n                                case BYTE :\n                                case CHAR :\n                                case DOUBLE :\n                                case FINAL :\n                                case FLOAT :\n                                case INT :\n                                case LONG :\n                                case NATIVE :\n                                case PRIVATE :\n                                case PROTECTED :\n                                case PUBLIC :\n                                case SHORT :\n                                case STATIC :\n                                case TESTAAAA :\n                                case SYNCHRONIZED :\n                                case VOID :\n                                case IDENTIFIER :\n                                case AT :\n                                case LT :\n                                    MethodDeclaration15(modifiers);\n                                    break;\n                                default :\n                                    jj_la1[193] = jj_gen;\n                                    jj_consume_token(-1);\n                                    throw new ParseException();\n                            }\n                        }\n                }\n                break;\n            case SEMICOLON :\n                jj_consume_token(SEMICOLON);\n                break;\n            default :\n                jj_la1[194] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}, {"methodBefore": "public final void ClassOrInterfaceBodyDeclaration(boolean isInterface) throws ParseException {\n    int modifiers;\n    if (jj_2_59(2)) {\n        Initializer();\n        if (isInterface) {\n            if (true) {\n                throw new ParseException(\"An interface cannot have initializers\");\n            }\n        }\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case AT :\n            case LT :\n                modifiers = Modifiers();\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    default :\n                        jj_la1[187] = jj_gen;\n                        if (jj_2_57(2147483647)) {\n                            ConstructorDeclaration();\n                        } else if (jj_2_58(2147483647)) {\n                            FieldDeclaration15(modifiers);\n                        } else {\n                            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                                case ABSTRACT :\n                                case BOOLEAN :\n                                case BYTE :\n                                case CHAR :\n                                case DOUBLE :\n                                case FINAL :\n                                case FLOAT :\n                                case INT :\n                                case LONG :\n                                case NATIVE :\n                                case PRIVATE :\n                                case PROTECTED :\n                                case PUBLIC :\n                                case SHORT :\n                                case STATIC :\n                                case TESTAAAA :\n                                case SYNCHRONIZED :\n                                case VOID :\n                                case IDENTIFIER :\n                                case AT :\n                                case LT :\n                                    MethodDeclaration15(modifiers);\n                                    break;\n                                default :\n                                    jj_la1[188] = jj_gen;\n                                    jj_consume_token(-1);\n                                    throw new ParseException();\n                            }\n                        }\n                }\n                break;\n            case SEMICOLON :\n                jj_consume_token(SEMICOLON);\n                break;\n            default :\n                jj_la1[189] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void ClassOrInterfaceBodyDeclaration(boolean isInterface) throws ParseException {\n    int modifiers;\n    if (jj_2_58(2)) {\n        Initializer();\n        if (isInterface) {\n            if (true) {\n                throw new ParseException(\"An interface cannot have initializers\");\n            }\n        }\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case AT :\n            case LT :\n                modifiers = Modifiers();\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    default :\n                        jj_la1[192] = jj_gen;\n                        if (jj_2_56(2147483647)) {\n                            ConstructorDeclaration();\n                        } else if (jj_2_57(2147483647)) {\n                            FieldDeclaration15(modifiers);\n                        } else {\n                            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                                case ABSTRACT :\n                                case BOOLEAN :\n                                case BYTE :\n                                case CHAR :\n                                case DOUBLE :\n                                case FINAL :\n                                case FLOAT :\n                                case INT :\n                                case LONG :\n                                case NATIVE :\n                                case PRIVATE :\n                                case PROTECTED :\n                                case PUBLIC :\n                                case SHORT :\n                                case STATIC :\n                                case TESTAAAA :\n                                case SYNCHRONIZED :\n                                case VOID :\n                                case IDENTIFIER :\n                                case AT :\n                                case LT :\n                                    MethodDeclaration15(modifiers);\n                                    break;\n                                default :\n                                    jj_la1[193] = jj_gen;\n                                    jj_consume_token(-1);\n                                    throw new ParseException();\n                            }\n                        }\n                }\n                break;\n            case SEMICOLON :\n                jj_consume_token(SEMICOLON);\n                break;\n            default :\n                jj_la1[194] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}], [{"methodBefore": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, cv);\n}", "methodAfter": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, new CheckClassAdapter(cv, false));\n}"}, {"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, new CheckClassAdapter(cv, false));\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}, {"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, new CheckClassAdapter(cv, false));\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}, {"methodBefore": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, cv);\n}", "methodAfter": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, new CheckClassAdapter(cv, false));\n}"}], [{"methodBefore": "public final void ArgumentList() throws ParseException {\n    Expression();\n    label_52 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[130] = jj_gen;\n                break label_52;\n        }\n        jj_consume_token(COMMA);\n        Expression();\n    } \n}", "methodAfter": "public final void ArgumentList() throws ParseException {\n    Expression();\n    label_53 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[131] = jj_gen;\n                break label_53;\n        }\n        jj_consume_token(COMMA);\n        Expression();\n    } \n}"}, {"methodBefore": "public final void ArgumentList() throws ParseException {\n    Expression();\n    label_52 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[130] = jj_gen;\n                break label_52;\n        }\n        jj_consume_token(COMMA);\n        Expression();\n    } \n}", "methodAfter": "public final void ArgumentList() throws ParseException {\n    Expression();\n    label_53 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[131] = jj_gen;\n                break label_53;\n        }\n        jj_consume_token(COMMA);\n        Expression();\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_294() {\n    if (jj_3R_304()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_294() {\n    if (jj_3R_304()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_316()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_294() {\n    if (jj_3R_304()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_294() {\n    if (jj_3R_304()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_316()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_365() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_362() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_365() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_362() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "@Override\npublic void visitLookupSwitchInsn(Label def, int[] values, Label[] labels) {\n    touchPointListener.beforeSwitch(getEventId(), def, labels, currentLine, mv);\n    super.visitLookupSwitchInsn(def, values, labels);\n}", "methodAfter": "@Override\npublic void visitLookupSwitchInsn(Label def, int[] values, Label[] labels) {\n    touchPointListener.beforeSwitch(getEventId(), def, labels, currentLine, mv, tryToFindSignatureOfConditionEnum());\n    super.visitLookupSwitchInsn(def, values, labels);\n}"}, {"methodBefore": "@Override\npublic void visitTableSwitchInsn(int min, int max, Label def, Label[] labels) {\n    touchPointListener.beforeSwitch(getEventId(), def, labels, currentLine, mv);\n    super.visitTableSwitchInsn(min, max, def, labels);\n}", "methodAfter": "@Override\npublic void visitTableSwitchInsn(int min, int max, Label def, Label[] labels) {\n    touchPointListener.beforeSwitch(getEventId(), def, labels, currentLine, mv, tryToFindSignatureOfConditionEnum());\n    super.visitTableSwitchInsn(min, max, def, labels);\n}"}], [{"methodBefore": "private void instrumentWar(File war, String instrumentRegEx) {\n    InstrumentTask instrumentTask = new InstrumentTask();\n    instrumentTask.setProject(project);\n    instrumentTask.setDataFile(dir.getAbsolutePath() + \"/cobertura.ser\");\n    instrumentTask.createIncludeClasses().setRegex(instrumentRegEx);\n    instrumentTask.createExcludeClasses().setRegex(\".*Test.*\");\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(war.getParentFile());\n    fileSet.setIncludes(\"**/*.war\");\n    instrumentTask.addFileset(fileSet);\n    instrumentTask.execute();\n}", "methodAfter": "private void instrumentWar(File war, String instrumentRegEx) {\n    InstrumentTask instrumentTask = new InstrumentTask();\n    instrumentTask.setProject(project);\n    instrumentTask.setDataFile(dir.getAbsolutePath() + \"/cobertura.ser\");\n    instrumentTask.createIncludeClasses().setRegex(instrumentRegEx);\n    instrumentTask.createExcludeClasses().setRegex(\".*Test.*\");\n    System.out.println(war.getAbsolutePath());\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(war.getParentFile());\n    fileSet.setIncludes(\"**/*.war\");\n    instrumentTask.addFileset(fileSet);\n    instrumentTask.execute();\n}"}, {"methodBefore": "private void instrumentWar(File war, String instrumentRegEx) {\n    InstrumentTask instrumentTask = new InstrumentTask();\n    instrumentTask.setProject(project);\n    instrumentTask.setDataFile(dir.getAbsolutePath() + \"/cobertura.ser\");\n    instrumentTask.createIncludeClasses().setRegex(instrumentRegEx);\n    instrumentTask.createExcludeClasses().setRegex(\".*Test.*\");\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(war.getParentFile());\n    fileSet.setIncludes(\"**/*.war\");\n    instrumentTask.addFileset(fileSet);\n    instrumentTask.execute();\n}", "methodAfter": "private void instrumentWar(File war, String instrumentRegEx) {\n    InstrumentTask instrumentTask = new InstrumentTask();\n    instrumentTask.setProject(project);\n    instrumentTask.setDataFile(dir.getAbsolutePath() + \"/cobertura.ser\");\n    instrumentTask.createIncludeClasses().setRegex(instrumentRegEx);\n    instrumentTask.createExcludeClasses().setRegex(\".*Test.*\");\n    System.out.println(war.getAbsolutePath());\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(war.getParentFile());\n    fileSet.setIncludes(\"**/*.war\");\n    instrumentTask.addFileset(fileSet);\n    instrumentTask.execute();\n}"}], [{"methodBefore": "private boolean jj_3R_319() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_319() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_319() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_319() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_114() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(63)) {\n        jj_scanpos = xsp;\n        if (jj_3R_162()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_458() {\n    if (jj_3R_120()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(84)) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_114() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(63)) {\n        jj_scanpos = xsp;\n        if (jj_3R_162()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_458() {\n    if (jj_3R_120()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(84)) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void ClassOrInterfaceDeclaration(int modifiers) throws ParseException {\n    boolean isInterface = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CLASS :\n            jj_consume_token(CLASS);\n            break;\n        case INTERFACE :\n            jj_consume_token(INTERFACE);\n            isInterface = true;\n            break;\n        default :\n            jj_la1[173] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[174] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            ExtendsList(isInterface);\n            break;\n        default :\n            jj_la1[175] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(isInterface);\n            break;\n        default :\n            jj_la1[176] = jj_gen;\n    }\n    ClassOrInterfaceBody(isInterface);\n}", "methodAfter": "public final void ClassOrInterfaceDeclaration(int modifiers) throws ParseException {\n    boolean isInterface = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CLASS :\n            jj_consume_token(CLASS);\n            break;\n        case INTERFACE :\n            jj_consume_token(INTERFACE);\n            isInterface = true;\n            break;\n        default :\n            jj_la1[178] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[179] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            ExtendsList(isInterface);\n            break;\n        default :\n            jj_la1[180] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(isInterface);\n            break;\n        default :\n            jj_la1[181] = jj_gen;\n    }\n    ClassOrInterfaceBody(isInterface);\n}"}, {"methodBefore": "public final void ClassOrInterfaceDeclaration(int modifiers) throws ParseException {\n    boolean isInterface = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CLASS :\n            jj_consume_token(CLASS);\n            break;\n        case INTERFACE :\n            jj_consume_token(INTERFACE);\n            isInterface = true;\n            break;\n        default :\n            jj_la1[173] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[174] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            ExtendsList(isInterface);\n            break;\n        default :\n            jj_la1[175] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(isInterface);\n            break;\n        default :\n            jj_la1[176] = jj_gen;\n    }\n    ClassOrInterfaceBody(isInterface);\n}", "methodAfter": "public final void ClassOrInterfaceDeclaration(int modifiers) throws ParseException {\n    boolean isInterface = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CLASS :\n            jj_consume_token(CLASS);\n            break;\n        case INTERFACE :\n            jj_consume_token(INTERFACE);\n            isInterface = true;\n            break;\n        default :\n            jj_la1[178] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[179] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            ExtendsList(isInterface);\n            break;\n        default :\n            jj_la1[180] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            ImplementsList(isInterface);\n            break;\n        default :\n            jj_la1[181] = jj_gen;\n    }\n    ClassOrInterfaceBody(isInterface);\n}"}], [{"methodBefore": "public final void UnaryExpressionNotPlusMinus() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BANG :\n        case TILDE :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case TILDE :\n                    jj_consume_token(TILDE);\n                    break;\n                case BANG :\n                    jj_consume_token(BANG);\n                    break;\n                default :\n                    jj_la1[111] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            UnaryExpression();\n            break;\n        default :\n            jj_la1[112] = jj_gen;\n            if (jj_2_27(2147483647)) {\n                CastExpression();\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                        PostfixExpression();\n                        break;\n                    default :\n                        jj_la1[113] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n    }\n}", "methodAfter": "public final void UnaryExpressionNotPlusMinus() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BANG :\n        case TILDE :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case TILDE :\n                    jj_consume_token(TILDE);\n                    break;\n                case BANG :\n                    jj_consume_token(BANG);\n                    break;\n                default :\n                    jj_la1[111] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            UnaryExpression();\n            break;\n        default :\n            jj_la1[112] = jj_gen;\n            if (jj_2_26(2147483647)) {\n                CastExpression();\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                        PostfixExpression();\n                        break;\n                    default :\n                        jj_la1[113] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n    }\n}"}, {"methodBefore": "public final void UnaryExpressionNotPlusMinus() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BANG :\n        case TILDE :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case TILDE :\n                    jj_consume_token(TILDE);\n                    break;\n                case BANG :\n                    jj_consume_token(BANG);\n                    break;\n                default :\n                    jj_la1[111] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            UnaryExpression();\n            break;\n        default :\n            jj_la1[112] = jj_gen;\n            if (jj_2_27(2147483647)) {\n                CastExpression();\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                        PostfixExpression();\n                        break;\n                    default :\n                        jj_la1[113] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n    }\n}", "methodAfter": "public final void UnaryExpressionNotPlusMinus() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BANG :\n        case TILDE :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case TILDE :\n                    jj_consume_token(TILDE);\n                    break;\n                case BANG :\n                    jj_consume_token(BANG);\n                    break;\n                default :\n                    jj_la1[111] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            UnaryExpression();\n            break;\n        default :\n            jj_la1[112] = jj_gen;\n            if (jj_2_26(2147483647)) {\n                CastExpression();\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case ENUM :\n                    case FALSE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case NEW :\n                    case NULL :\n                    case SHORT :\n                    case SUPER :\n                    case THIS :\n                    case TRUE :\n                    case VOID :\n                    case INTEGER_LITERAL :\n                    case FLOATING_POINT_LITERAL :\n                    case CHARACTER_LITERAL :\n                    case STRING_LITERAL :\n                    case IDENTIFIER :\n                    case LPAREN :\n                        PostfixExpression();\n                        break;\n                    default :\n                        jj_la1[113] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n    }\n}"}], [{"methodBefore": "private boolean jj_3_15() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_15() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_15() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_15() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidLines() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getBranchCoverageRate() {\n    synchronizeState();\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}], [{"methodBefore": "private boolean jj_3R_260() {\n    if (jj_scan_token(SC_AND)) {\n        return true;\n    }\n    if (jj_3R_235()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_238() {\n    if (jj_scan_token(SC_AND)) {\n        return true;\n    }\n    if (jj_3R_220()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_260() {\n    if (jj_scan_token(SC_AND)) {\n        return true;\n    }\n    if (jj_3R_235()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_238() {\n    if (jj_scan_token(SC_AND)) {\n        return true;\n    }\n    if (jj_3R_220()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void ConstructorDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int oldSingle;\n    int oldMulti;\n    int jvdcLines = 0;\n    boolean bPublic = false;\n    Token myToken = null;\n    label_34 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[72] = jj_gen;\n                break label_34;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case PUBLIC :\n                    jj_consume_token(PUBLIC);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PROTECTED :\n                    jj_consume_token(PROTECTED);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PRIVATE :\n                    jj_consume_token(PRIVATE);\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                default :\n                    jj_la1[73] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            break;\n        default :\n            jj_la1[74] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[75] = jj_gen;\n    }\n    Identifier();\n    if (tmpToken == null) {\n        tmpToken = getToken(0);\n    }\n    _cyc = 1;\n    _sFunction = ((_sPackage + _sClass) + \".\") + getToken(0).image;\n    FormalParameters();\n    _sFunction += _sParameter;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[76] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    if (jj_2_18(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    if (jj_2_19(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            jvdc++;\n            if ((bPublic && _bPublic) || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                _jvdcLines += jvdcLines;\n                JavaParserTokenManager._iFormalComments += jvdcLines;\n            }\n            JavaParserTokenManager._iMultiComments -= jvdcLines;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            jvdcLines = 0;\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    label_35 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[77] = jj_gen;\n                break label_35;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.name = _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = jvdcLines;\n    functionMetrics.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n    functionMetrics.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}", "methodAfter": "public final void ConstructorDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int oldSingle;\n    int oldMulti;\n    int jvdcLines = 0;\n    boolean bPublic = false;\n    Token myToken = null;\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.firstLine = JavaParserTokenManager.nbligne;\n    label_34 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[72] = jj_gen;\n                break label_34;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case PUBLIC :\n                    jj_consume_token(PUBLIC);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PROTECTED :\n                    jj_consume_token(PROTECTED);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PRIVATE :\n                    jj_consume_token(PRIVATE);\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                default :\n                    jj_la1[73] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            break;\n        default :\n            jj_la1[74] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[75] = jj_gen;\n    }\n    Identifier();\n    if (tmpToken == null) {\n        tmpToken = getToken(0);\n    }\n    _cyc = 1;\n    _sFunction = ((_sPackage + _sClass) + \".\") + getToken(0).image;\n    FormalParameters();\n    _sFunction += _sParameter;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[76] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    if (jj_2_18(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    if (jj_2_19(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            jvdc++;\n            if ((bPublic && _bPublic) || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                _jvdcLines += jvdcLines;\n                JavaParserTokenManager._iFormalComments += jvdcLines;\n            }\n            JavaParserTokenManager._iMultiComments -= jvdcLines;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            jvdcLines = 0;\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    label_35 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[77] = jj_gen;\n                break label_35;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    functionMetrics.name = _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = jvdcLines;\n    functionMetrics.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n    functionMetrics.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}"}, {"methodBefore": "public final void ConstructorDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int oldSingle;\n    int oldMulti;\n    int jvdcLines = 0;\n    boolean bPublic = false;\n    Token myToken = null;\n    label_34 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[72] = jj_gen;\n                break label_34;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case PUBLIC :\n                    jj_consume_token(PUBLIC);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PROTECTED :\n                    jj_consume_token(PROTECTED);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PRIVATE :\n                    jj_consume_token(PRIVATE);\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                default :\n                    jj_la1[73] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            break;\n        default :\n            jj_la1[74] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[75] = jj_gen;\n    }\n    Identifier();\n    if (tmpToken == null) {\n        tmpToken = getToken(0);\n    }\n    _cyc = 1;\n    _sFunction = ((_sPackage + _sClass) + \".\") + getToken(0).image;\n    FormalParameters();\n    _sFunction += _sParameter;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[76] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    if (jj_2_18(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    if (jj_2_19(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            jvdc++;\n            if ((bPublic && _bPublic) || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                _jvdcLines += jvdcLines;\n                JavaParserTokenManager._iFormalComments += jvdcLines;\n            }\n            JavaParserTokenManager._iMultiComments -= jvdcLines;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            jvdcLines = 0;\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    label_35 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[77] = jj_gen;\n                break label_35;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.name = _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = jvdcLines;\n    functionMetrics.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n    functionMetrics.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}", "methodAfter": "public final void ConstructorDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int oldSingle;\n    int oldMulti;\n    int jvdcLines = 0;\n    boolean bPublic = false;\n    Token myToken = null;\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.firstLine = JavaParserTokenManager.nbligne;\n    label_34 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[72] = jj_gen;\n                break label_34;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case PUBLIC :\n                    jj_consume_token(PUBLIC);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PROTECTED :\n                    jj_consume_token(PROTECTED);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PRIVATE :\n                    jj_consume_token(PRIVATE);\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                default :\n                    jj_la1[73] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            break;\n        default :\n            jj_la1[74] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[75] = jj_gen;\n    }\n    Identifier();\n    if (tmpToken == null) {\n        tmpToken = getToken(0);\n    }\n    _cyc = 1;\n    _sFunction = ((_sPackage + _sClass) + \".\") + getToken(0).image;\n    FormalParameters();\n    _sFunction += _sParameter;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[76] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    if (jj_2_18(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    if (jj_2_19(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            jvdc++;\n            if ((bPublic && _bPublic) || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                _jvdcLines += jvdcLines;\n                JavaParserTokenManager._iFormalComments += jvdcLines;\n            }\n            JavaParserTokenManager._iMultiComments -= jvdcLines;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            jvdcLines = 0;\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    label_35 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[77] = jj_gen;\n                break label_35;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    functionMetrics.name = _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = jvdcLines;\n    functionMetrics.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n    functionMetrics.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}"}], [{"methodBefore": "public void execute() throws BuildException {\n    initArgs();\n    if (toDir != null) {\n        addArg(\"-o\");\n        addArg(toDir.toString());\n    }\n    Set filenames = new HashSet();\n    Iterator i = fileSets.iterator();\n    while (i.hasNext()) {\n        FileSet fileSet = ((FileSet) (i.next()));\n        filenames.addAll(Arrays.asList(getFilenames(fileSet)));\n    } \n    merge(((String[]) (filenames.toArray(new String[filenames.size()]))));\n}", "methodAfter": "public void execute() throws BuildException {\n    initArgs();\n    if (toDir != null) {\n        addArg(\"-o\");\n        addArg(toDir.toString());\n    }\n    Set filenames = new HashSet();\n    Iterator i = fileSets.iterator();\n    while (i.hasNext()) {\n        FileSet fileSet = ((FileSet) (i.next()));\n        filenames.addAll(Arrays.asList(getFilenames(fileSet)));\n    } \n    merge(((String[]) (filenames.toArray(new String[filenames.size()]))));\n    unInitArgs();\n}"}, {"methodBefore": "public void execute() throws BuildException {\n    initArgs();\n    if (toDir != null) {\n        addArg(\"-d\");\n        addArg(toDir.toString());\n    }\n    if (ignoreRegex != null) {\n        addArg(\"-ignore\");\n        addArg(ignoreRegex.getRegex());\n    }\n    Set filenames = new HashSet();\n    Iterator i = fileSets.iterator();\n    while (i.hasNext()) {\n        FileSet fileSet = ((FileSet) (i.next()));\n        addArg(\"-basedir\");\n        addArg(baseDir(fileSet));\n        filenames.addAll(Arrays.asList(getFilenames(fileSet)));\n    } \n    coverage(((String[]) (filenames.toArray(new String[filenames.size()]))));\n}", "methodAfter": "public void execute() throws BuildException {\n    initArgs();\n    if (toDir != null) {\n        addArg(\"-d\");\n        addArg(toDir.toString());\n    }\n    if (ignoreRegex != null) {\n        addArg(\"-ignore\");\n        addArg(ignoreRegex.getRegex());\n    }\n    Set filenames = new HashSet();\n    Iterator i = fileSets.iterator();\n    while (i.hasNext()) {\n        FileSet fileSet = ((FileSet) (i.next()));\n        addArg(\"-basedir\");\n        addArg(baseDir(fileSet));\n        filenames.addAll(Arrays.asList(getFilenames(fileSet)));\n    } \n    coverage(((String[]) (filenames.toArray(new String[filenames.size()]))));\n    unInitArgs();\n}"}], [{"methodBefore": "public void ReInit(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 202; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}", "methodAfter": "public void ReInit(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 208; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}"}, {"methodBefore": "public void ReInit(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 202; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}", "methodAfter": "public void ReInit(JavaParserTokenManager tm) {\n    token_source = tm;\n    token = new Token();\n    jj_ntk = -1;\n    jj_gen = 0;\n    for (int i = 0; i < 208; i++) {\n        jj_la1[i] = -1;\n    }\n    for (int i = 0; i < jj_2_rtns.length; i++) {\n        jj_2_rtns[i] = new JJCalls();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_261() {\n    if (jj_3R_123()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_153() {\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_261() {\n    if (jj_3R_123()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_153() {\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_43() {\n    if (jj_3R_118()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_43() {\n    if (jj_3R_122()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_43() {\n    if (jj_3R_118()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_43() {\n    if (jj_3R_122()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_285() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_441()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_288() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_445()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_285() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_441()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_288() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_445()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_89() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_384() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_89() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_384() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_436() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_438() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_436() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_438() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_332() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_332() {\n    if (jj_3R_367()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_332() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_332() {\n    if (jj_3R_367()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void fatalError(SAXParseException exception) {\n    Assert.fail(exception.toString());\n}", "methodAfter": "public void fatalError(SAXParseException exception) {\n    exception.printStackTrace();\n    Assert.fail(exception.toString());\n}"}, {"methodBefore": "public void warning(SAXParseException exception) {\n    Assert.fail(exception.toString());\n}", "methodAfter": "public void warning(SAXParseException exception) {\n    exception.printStackTrace();\n    Assert.fail(exception.toString());\n}"}], [{"methodBefore": "public final void AssignmentOperator() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSIGN :\n            jj_consume_token(ASSIGN);\n            break;\n        case STARASSIGN :\n            jj_consume_token(STARASSIGN);\n            break;\n        case SLASHASSIGN :\n            jj_consume_token(SLASHASSIGN);\n            break;\n        case REMASSIGN :\n            jj_consume_token(REMASSIGN);\n            break;\n        case PLUSASSIGN :\n            jj_consume_token(PLUSASSIGN);\n            break;\n        case MINUSASSIGN :\n            jj_consume_token(MINUSASSIGN);\n            break;\n        case LSHIFTASSIGN :\n            jj_consume_token(LSHIFTASSIGN);\n            break;\n        case RSIGNEDSHIFTASSIGN :\n            jj_consume_token(RSIGNEDSHIFTASSIGN);\n            break;\n        case RUNSIGNEDSHIFTASSIGN :\n            jj_consume_token(RUNSIGNEDSHIFTASSIGN);\n            break;\n        case ANDASSIGN :\n            jj_consume_token(ANDASSIGN);\n            break;\n        case XORASSIGN :\n            jj_consume_token(XORASSIGN);\n            break;\n        case ORASSIGN :\n            jj_consume_token(ORASSIGN);\n            break;\n        default :\n            jj_la1[91] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void AssignmentOperator() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSIGN :\n            jj_consume_token(ASSIGN);\n            break;\n        case STARASSIGN :\n            jj_consume_token(STARASSIGN);\n            break;\n        case SLASHASSIGN :\n            jj_consume_token(SLASHASSIGN);\n            break;\n        case REMASSIGN :\n            jj_consume_token(REMASSIGN);\n            break;\n        case PLUSASSIGN :\n            jj_consume_token(PLUSASSIGN);\n            break;\n        case MINUSASSIGN :\n            jj_consume_token(MINUSASSIGN);\n            break;\n        case LSHIFTASSIGN :\n            jj_consume_token(LSHIFTASSIGN);\n            break;\n        case RSIGNEDSHIFTASSIGN :\n            jj_consume_token(RSIGNEDSHIFTASSIGN);\n            break;\n        case RUNSIGNEDSHIFTASSIGN :\n            jj_consume_token(RUNSIGNEDSHIFTASSIGN);\n            break;\n        case ANDASSIGN :\n            jj_consume_token(ANDASSIGN);\n            break;\n        case XORASSIGN :\n            jj_consume_token(XORASSIGN);\n            break;\n        case ORASSIGN :\n            jj_consume_token(ORASSIGN);\n            break;\n        default :\n            jj_la1[90] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void AssignmentOperator() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSIGN :\n            jj_consume_token(ASSIGN);\n            break;\n        case STARASSIGN :\n            jj_consume_token(STARASSIGN);\n            break;\n        case SLASHASSIGN :\n            jj_consume_token(SLASHASSIGN);\n            break;\n        case REMASSIGN :\n            jj_consume_token(REMASSIGN);\n            break;\n        case PLUSASSIGN :\n            jj_consume_token(PLUSASSIGN);\n            break;\n        case MINUSASSIGN :\n            jj_consume_token(MINUSASSIGN);\n            break;\n        case LSHIFTASSIGN :\n            jj_consume_token(LSHIFTASSIGN);\n            break;\n        case RSIGNEDSHIFTASSIGN :\n            jj_consume_token(RSIGNEDSHIFTASSIGN);\n            break;\n        case RUNSIGNEDSHIFTASSIGN :\n            jj_consume_token(RUNSIGNEDSHIFTASSIGN);\n            break;\n        case ANDASSIGN :\n            jj_consume_token(ANDASSIGN);\n            break;\n        case XORASSIGN :\n            jj_consume_token(XORASSIGN);\n            break;\n        case ORASSIGN :\n            jj_consume_token(ORASSIGN);\n            break;\n        default :\n            jj_la1[91] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void AssignmentOperator() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSIGN :\n            jj_consume_token(ASSIGN);\n            break;\n        case STARASSIGN :\n            jj_consume_token(STARASSIGN);\n            break;\n        case SLASHASSIGN :\n            jj_consume_token(SLASHASSIGN);\n            break;\n        case REMASSIGN :\n            jj_consume_token(REMASSIGN);\n            break;\n        case PLUSASSIGN :\n            jj_consume_token(PLUSASSIGN);\n            break;\n        case MINUSASSIGN :\n            jj_consume_token(MINUSASSIGN);\n            break;\n        case LSHIFTASSIGN :\n            jj_consume_token(LSHIFTASSIGN);\n            break;\n        case RSIGNEDSHIFTASSIGN :\n            jj_consume_token(RSIGNEDSHIFTASSIGN);\n            break;\n        case RUNSIGNEDSHIFTASSIGN :\n            jj_consume_token(RUNSIGNEDSHIFTASSIGN);\n            break;\n        case ANDASSIGN :\n            jj_consume_token(ANDASSIGN);\n            break;\n        case XORASSIGN :\n            jj_consume_token(XORASSIGN);\n            break;\n        case ORASSIGN :\n            jj_consume_token(ORASSIGN);\n            break;\n        default :\n            jj_la1[90] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(mv);\n    this.eventsToTrace = eventsToTrace;\n}", "methodAfter": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(ASM4, mv);\n    this.eventsToTrace = eventsToTrace;\n}"}, {"methodBefore": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}", "methodAfter": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(ASM4, mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}"}, {"methodBefore": "public GenerateCallCoberturaInitMethodVisitor(MethodVisitor arg0, String className) {\n    super(arg0);\n    this.className = className;\n}", "methodAfter": "public GenerateCallCoberturaInitMethodVisitor(MethodVisitor arg0, String className) {\n    super(ASM4, arg0);\n    this.className = className;\n}"}], [{"methodBefore": "private boolean jj_3R_164() {\n    if (jj_3R_190()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_164() {\n    if (jj_3R_192()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_164() {\n    if (jj_3R_190()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_164() {\n    if (jj_3R_192()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_364() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_390()) {\n        jj_scanpos = xsp;\n        if (jj_3R_391()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_367() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_393()) {\n        jj_scanpos = xsp;\n        if (jj_3R_394()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_364() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_390()) {\n        jj_scanpos = xsp;\n        if (jj_3R_391()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_367() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_393()) {\n        jj_scanpos = xsp;\n        if (jj_3R_394()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_345() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_379()) {\n        jj_scanpos = xsp;\n        if (jj_3R_380()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_344() {\n    if (jj_3R_380()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_381()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_345() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_379()) {\n        jj_scanpos = xsp;\n        if (jj_3R_380()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_344() {\n    if (jj_3R_380()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_381()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_5() {\n    if (jj_3R_85()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_5() {\n    if (jj_3R_89()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_5() {\n    if (jj_3R_85()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_5() {\n    if (jj_3R_89()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_81() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_86() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_81() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_86() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void ConditionalExpression() throws ParseException {\n    ConditionalOrExpression();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case HOOK :\n            jj_consume_token(HOOK);\n            Expression();\n            jj_consume_token(COLON);\n            ConditionalExpression();\n            _cyc++;\n            break;\n        default :\n            jj_la1[92] = jj_gen;\n    }\n}", "methodAfter": "public final void ConditionalExpression() throws ParseException {\n    ConditionalOrExpression();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case HOOK :\n            jj_consume_token(HOOK);\n            Expression();\n            jj_consume_token(COLON);\n            ConditionalExpression();\n            _cyc++;\n            break;\n        default :\n            jj_la1[91] = jj_gen;\n    }\n}"}, {"methodBefore": "public final void ConditionalExpression() throws ParseException {\n    ConditionalOrExpression();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case HOOK :\n            jj_consume_token(HOOK);\n            Expression();\n            jj_consume_token(COLON);\n            ConditionalExpression();\n            _cyc++;\n            break;\n        default :\n            jj_la1[92] = jj_gen;\n    }\n}", "methodAfter": "public final void ConditionalExpression() throws ParseException {\n    ConditionalOrExpression();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case HOOK :\n            jj_consume_token(HOOK);\n            Expression();\n            jj_consume_token(COLON);\n            ConditionalExpression();\n            _cyc++;\n            break;\n        default :\n            jj_la1[91] = jj_gen;\n    }\n}"}], [{"methodBefore": "public boolean contains(String name) {\n    return this.children.containsKey(name);\n}", "methodAfter": "public boolean contains(String name) {\n    lock.lock();\n    try {\n        return this.children.containsKey(name);\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public boolean contains(String name) {\n    return this.children.containsKey(name);\n}", "methodAfter": "public boolean contains(String name) {\n    lock.lock();\n    try {\n        return this.children.containsKey(name);\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "public final void MemberValue() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case AT :\n            Annotation();\n            break;\n        case LBRACE :\n            MemberValueArrayInitializer();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            ConditionalExpression();\n            break;\n        default :\n            jj_la1[164] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void MemberValue() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case AT :\n            Annotation();\n            break;\n        case LBRACE :\n            MemberValueArrayInitializer();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            ConditionalExpression();\n            break;\n        default :\n            jj_la1[169] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void MemberValue() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case AT :\n            Annotation();\n            break;\n        case LBRACE :\n            MemberValueArrayInitializer();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            ConditionalExpression();\n            break;\n        default :\n            jj_la1[164] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void MemberValue() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case AT :\n            Annotation();\n            break;\n        case LBRACE :\n            MemberValueArrayInitializer();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            ConditionalExpression();\n            break;\n        default :\n            jj_la1[169] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(cv);\n}", "methodAfter": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, cv);\n}"}, {"methodBefore": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(cv);\n}", "methodAfter": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, cv);\n}"}, {"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}, {"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}], [{"methodBefore": "private boolean jj_3_26() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(110)) {\n        jj_scanpos = xsp;\n        if (jj_3R_107()) {\n            return true;\n        }\n    }\n    if (jj_3R_108()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_55() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_26() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(110)) {\n        jj_scanpos = xsp;\n        if (jj_3R_107()) {\n            return true;\n        }\n    }\n    if (jj_3R_108()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_55() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_27() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_108() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_27() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_108() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_415() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_341()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_418() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_344()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_415() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_341()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_418() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_344()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void generateCountersField(ClassVisitor cv) {\n    FieldVisitor fv = cv.visitField((Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC) | Opcodes.ACC_FINAL, COBERTURA_COUNTERS_FIELD_NAME, COBERTURA_COUNTERS_FIELD_TYPE, null, null);\n    fv.visitEnd();\n}", "methodAfter": "public void generateCountersField(ClassVisitor cv) {\n    FieldVisitor fv = cv.visitField(((Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC) | Opcodes.ACC_FINAL) | Opcodes.ACC_TRANSIENT, COBERTURA_COUNTERS_FIELD_NAME, COBERTURA_COUNTERS_FIELD_TYPE, null, null);\n    fv.visitEnd();\n}"}, {"methodBefore": "public void generateCountersField(ClassVisitor cv) {\n    FieldVisitor fv = cv.visitField((Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC) | Opcodes.ACC_FINAL, COBERTURA_COUNTERS_FIELD_NAME, COBERTURA_COUNTERS_FIELD_TYPE, null, null);\n    fv.visitEnd();\n}", "methodAfter": "public void generateCountersField(ClassVisitor cv) {\n    FieldVisitor fv = cv.visitField(((Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC) | Opcodes.ACC_FINAL) | Opcodes.ACC_TRANSIENT, COBERTURA_COUNTERS_FIELD_NAME, COBERTURA_COUNTERS_FIELD_TYPE, null, null);\n    fv.visitEnd();\n}"}], [{"methodBefore": "LineData(int lineNumber, String methodName, String methodDescriptor) {\n    this.hits = 0;\n    this.jumps = null;\n    this.lineNumber = lineNumber;\n    this.methodName = methodName;\n    this.methodDescriptor = methodDescriptor;\n}", "methodAfter": "LineData(int lineNumber, String methodName, String methodDescriptor) {\n    this.hits = 0;\n    this.jumps = null;\n    this.lineNumber = lineNumber;\n    this.methodName = methodName;\n    this.methodDescriptor = methodDescriptor;\n    initLock();\n}"}, {"methodBefore": "JumpData(int conditionNumber) {\n    super();\n    this.conditionNumber = conditionNumber;\n    this.trueHits = 0L;\n    this.falseHits = 0L;\n}", "methodAfter": "JumpData(int conditionNumber) {\n    super();\n    this.conditionNumber = conditionNumber;\n    this.trueHits = 0L;\n    this.falseHits = 0L;\n    initLock();\n}"}], [{"methodBefore": "public boolean contains(String name) {\n    return this.children.containsKey(name);\n}", "methodAfter": "public boolean contains(String name) {\n    lock.lock();\n    try {\n        return this.children.containsKey(name);\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public boolean contains(String name) {\n    return this.children.containsKey(name);\n}", "methodAfter": "public boolean contains(String name) {\n    lock.lock();\n    try {\n        return this.children.containsKey(name);\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "@Test\npublic void flushCoberturaDataOnly() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"deployCoberturaFlush\", true);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountBefore);\n    System.out.println((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\");\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountAfter);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int finalCount = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    webappServer.killServer();\n    assertEquals(0, finalCount);\n}", "methodAfter": "@Test\npublic void flushCoberturaDataOnly() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    new File(webappServerDir, \"logs\").mkdirs();\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"deployCoberturaFlush\", true);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountBefore);\n    System.out.println((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\");\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountAfter);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int finalCount = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    webappServer.killServer();\n    assertEquals(0, finalCount);\n}"}, {"methodBefore": "public void basicStartAndStopOfWebApp(boolean tomcat) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, tomcat);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertFalse(TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n    webappServer.killServer();\n    Thread.sleep(5 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertTrue(\"doGet has hits=0 in cobertura report\", TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n}", "methodAfter": "public void basicStartAndStopOfWebApp(boolean tomcat) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    new File(webappServerDir, \"logs\").mkdirs();\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, tomcat);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertFalse(TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n    webappServer.killServer();\n    Thread.sleep(5 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertTrue(\"doGet has hits=0 in cobertura report\", TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n}"}, {"methodBefore": "@Test\npublic void flushCoberturaDataOnly() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"deployCoberturaFlush\", true);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountBefore);\n    System.out.println((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\");\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountAfter);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int finalCount = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    webappServer.killServer();\n    assertEquals(0, finalCount);\n}", "methodAfter": "@Test\npublic void flushCoberturaDataOnly() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    new File(webappServerDir, \"logs\").mkdirs();\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"deployCoberturaFlush\", true);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountBefore);\n    System.out.println((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\");\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    assertEquals(0, hitCountAfter);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int finalCount = TestUtils.getHitCount(dom, SIMPLE_SERVLET_CLASSNAME, \"doGet\");\n    webappServer.killServer();\n    assertEquals(0, finalCount);\n}"}, {"methodBefore": "public void basicStartAndStopOfWebApp(boolean tomcat) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, tomcat);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertFalse(TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n    webappServer.killServer();\n    Thread.sleep(5 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertTrue(\"doGet has hits=0 in cobertura report\", TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n}", "methodAfter": "public void basicStartAndStopOfWebApp(boolean tomcat) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    new File(webappServerDir, \"logs\").mkdirs();\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, tomcat);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertFalse(TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n    webappServer.killServer();\n    Thread.sleep(5 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertTrue(\"doGet has hits=0 in cobertura report\", TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n}"}], [{"methodBefore": "private boolean jj_3R_297() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_299() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_297() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_299() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_320() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_320() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_320() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_320() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_289() {\n    if (jj_scan_token(XOR)) {\n        return true;\n    }\n    if (jj_3R_281()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_285() {\n    if (jj_scan_token(XOR)) {\n        return true;\n    }\n    if (jj_3R_260()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_289() {\n    if (jj_scan_token(XOR)) {\n        return true;\n    }\n    if (jj_3R_281()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_285() {\n    if (jj_scan_token(XOR)) {\n        return true;\n    }\n    if (jj_3R_260()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public String printPackageNcss() {\n    String sRetVal = \"  <packages>\\n\";\n    Vector vPackageMetrics = _javancss.getPackageMetrics();\n    int packages = vPackageMetrics.size();\n    int classesSum = 0;\n    int functionsSum = 0;\n    int ncssSum = 0;\n    int javadocSum = 0;\n    int javadocLnSum = 0;\n    int singleLnSum = 0;\n    int multiLnSum = 0;\n    for (Enumeration ePackages = vPackageMetrics.elements(); ePackages.hasMoreElements();) {\n        PackageMetric pPackageMetric = ((PackageMetric) (ePackages.nextElement()));\n        classesSum += pPackageMetric.classes;\n        functionsSum += pPackageMetric.functions;\n        ncssSum += pPackageMetric.ncss;\n        javadocSum += pPackageMetric.javadocs;\n        javadocLnSum += pPackageMetric.javadocsLn;\n        singleLnSum += pPackageMetric.singleLn;\n        multiLnSum += pPackageMetric.multiLn;\n        sRetVal += ((((((((((((((((((((((((\"    <package>\\n\" + \"      <name>\") + pPackageMetric.name) + \"</name>\\n\") + \"      <classes>\") + pPackageMetric.classes) + \"</classes>\\n\") + \"      <functions>\") + pPackageMetric.functions) + \"</functions>\\n\") + \"      <ncss>\") + pPackageMetric.ncss) + \"</ncss>\\n\") + \"      <javadocs>\") + pPackageMetric.javadocs) + \"</javadocs>\\n\") + \"      <javadoc_lines>\") + pPackageMetric.javadocsLn) + \"</javadoc_lines>\\n\") + \"      <single_comment_lines>\") + pPackageMetric.singleLn) + \"</single_comment_lines>\\n\") + \"      <multi_comment_lines>\") + pPackageMetric.multiLn) + \"</multi_comment_lines>\\n\") + \"    </package>\\n\";\n    }\n    sRetVal += (((((((((((((((((((((\"    <total>\\n\" + \"      <classes>\") + classesSum) + \"</classes>\\n\") + \"      <functions>\") + functionsSum) + \"</functions>\\n\") + \"      <ncss>\") + ncssSum) + \"</ncss>\\n\") + \"      <javadocs>\") + javadocSum) + \"</javadocs>\\n\") + \"      <javadoc_lines>\") + javadocLnSum) + \"</javadoc_lines>\\n\") + \"      <single_comment_lines>\") + singleLnSum) + \"</single_comment_lines>\\n\") + \"      <multi_comment_lines>\") + multiLnSum) + \"</multi_comment_lines>\\n\") + \"    </total>\\n\";\n    sRetVal += _formatPackageMatrix(packages, classesSum, functionsSum, ncssSum, javadocSum, javadocLnSum, singleLnSum, multiLnSum);\n    sRetVal += \"  </packages>\\n\";\n    return sRetVal;\n}", "methodAfter": "public String printPackageNcss() {\n    String sRetVal = \"  <packages>\\n\";\n    List vPackageMetrics = _javancss.getPackageMetrics();\n    int packages = vPackageMetrics.size();\n    int classesSum = 0;\n    int functionsSum = 0;\n    int ncssSum = 0;\n    int javadocSum = 0;\n    int javadocLnSum = 0;\n    int singleLnSum = 0;\n    int multiLnSum = 0;\n    for (Iterator ePackages = vPackageMetrics.iterator(); ePackages.hasNext();) {\n        PackageMetric pPackageMetric = ((PackageMetric) (ePackages.next()));\n        classesSum += pPackageMetric.classes;\n        functionsSum += pPackageMetric.functions;\n        ncssSum += pPackageMetric.ncss;\n        javadocSum += pPackageMetric.javadocs;\n        javadocLnSum += pPackageMetric.javadocsLn;\n        singleLnSum += pPackageMetric.singleLn;\n        multiLnSum += pPackageMetric.multiLn;\n        sRetVal += ((((((((((((((((((((((((\"    <package>\\n\" + \"      <name>\") + pPackageMetric.name) + \"</name>\\n\") + \"      <classes>\") + pPackageMetric.classes) + \"</classes>\\n\") + \"      <functions>\") + pPackageMetric.functions) + \"</functions>\\n\") + \"      <ncss>\") + pPackageMetric.ncss) + \"</ncss>\\n\") + \"      <javadocs>\") + pPackageMetric.javadocs) + \"</javadocs>\\n\") + \"      <javadoc_lines>\") + pPackageMetric.javadocsLn) + \"</javadoc_lines>\\n\") + \"      <single_comment_lines>\") + pPackageMetric.singleLn) + \"</single_comment_lines>\\n\") + \"      <multi_comment_lines>\") + pPackageMetric.multiLn) + \"</multi_comment_lines>\\n\") + \"    </package>\\n\";\n    }\n    sRetVal += (((((((((((((((((((((\"    <total>\\n\" + \"      <classes>\") + classesSum) + \"</classes>\\n\") + \"      <functions>\") + functionsSum) + \"</functions>\\n\") + \"      <ncss>\") + ncssSum) + \"</ncss>\\n\") + \"      <javadocs>\") + javadocSum) + \"</javadocs>\\n\") + \"      <javadoc_lines>\") + javadocLnSum) + \"</javadoc_lines>\\n\") + \"      <single_comment_lines>\") + singleLnSum) + \"</single_comment_lines>\\n\") + \"      <multi_comment_lines>\") + multiLnSum) + \"</multi_comment_lines>\\n\") + \"    </total>\\n\";\n    sRetVal += _formatPackageMatrix(packages, classesSum, functionsSum, ncssSum, javadocSum, javadocLnSum, singleLnSum, multiLnSum);\n    sRetVal += \"  </packages>\\n\";\n    return sRetVal;\n}"}, {"methodBefore": "public String printPackageNcss() {\n    Vector vPackageMetrics = _javancss.getPackageMetrics();\n    int packages = vPackageMetrics.size();\n    String sRetVal = _formatListHeader(packages, new String[]{ \"  Classes\", \"Functions\", \"     NCSS\", \" Javadocs\", \"Package\" });\n    int classesSum = 0;\n    int functionsSum = 0;\n    int javadocsSum = 0;\n    int ncssSum = 0;\n    for (Enumeration ePackages = vPackageMetrics.elements(); ePackages.hasMoreElements();) {\n        PackageMetric pPackageMetric = ((PackageMetric) (ePackages.nextElement()));\n        classesSum += pPackageMetric.classes;\n        functionsSum += pPackageMetric.functions;\n        ncssSum += pPackageMetric.ncss;\n        javadocsSum += pPackageMetric.javadocs;\n        sRetVal += _formatListLine(pPackageMetric.name, new int[]{ pPackageMetric.classes, pPackageMetric.functions, pPackageMetric.ncss, pPackageMetric.javadocs });\n    }\n    int packagesLength = Util.itoa(packages).length();\n    int spaces = Math.max(packagesLength, LEN_NR) + 1;\n    sRetVal += (Util.multiplyChar(' ', spaces) + \"--------- --------- --------- ---------\") + NL;\n    sRetVal += (((((((((Util.multiplyChar(' ', spaces) + Util.paddWithSpace(classesSum, 9)) + \" \") + Util.paddWithSpace(functionsSum, 9)) + \" \") + Util.paddWithSpace(ncssSum, 9)) + \" \") + Util.paddWithSpace(javadocsSum, 9)) + \" Total\") + NL) + NL;\n    sRetVal += _formatPackageMatrix(packages, classesSum, functionsSum, javadocsSum, ncssSum);\n    return sRetVal;\n}", "methodAfter": "public String printPackageNcss() {\n    List vPackageMetrics = _javancss.getPackageMetrics();\n    int packages = vPackageMetrics.size();\n    String sRetVal = _formatListHeader(packages, new String[]{ \"  Classes\", \"Functions\", \"     NCSS\", \" Javadocs\", \"Package\" });\n    int classesSum = 0;\n    int functionsSum = 0;\n    int javadocsSum = 0;\n    int ncssSum = 0;\n    for (Iterator ePackages = vPackageMetrics.iterator(); ePackages.hasNext();) {\n        PackageMetric pPackageMetric = ((PackageMetric) (ePackages.next()));\n        classesSum += pPackageMetric.classes;\n        functionsSum += pPackageMetric.functions;\n        ncssSum += pPackageMetric.ncss;\n        javadocsSum += pPackageMetric.javadocs;\n        sRetVal += _formatListLine(pPackageMetric.name, new int[]{ pPackageMetric.classes, pPackageMetric.functions, pPackageMetric.ncss, pPackageMetric.javadocs });\n    }\n    int packagesLength = Util.itoa(packages).length();\n    int spaces = Math.max(packagesLength, LEN_NR) + 1;\n    sRetVal += (Util.multiplyChar(' ', spaces) + \"--------- --------- --------- ---------\") + NL;\n    sRetVal += (((((((((Util.multiplyChar(' ', spaces) + Util.paddWithSpace(classesSum, 9)) + \" \") + Util.paddWithSpace(functionsSum, 9)) + \" \") + Util.paddWithSpace(ncssSum, 9)) + \" \") + Util.paddWithSpace(javadocsSum, 9)) + \" Total\") + NL) + NL;\n    sRetVal += _formatPackageMatrix(packages, classesSum, functionsSum, javadocsSum, ncssSum);\n    return sRetVal;\n}"}], [{"methodBefore": "private boolean jj_3R_251() {\n    if (jj_3R_271()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_249() {\n    if (jj_3R_271()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_251() {\n    if (jj_3R_271()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_249() {\n    if (jj_3R_271()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredLines() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}], [{"methodBefore": "private boolean jj_3R_162() {\n    if (jj_3R_111()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_161() {\n    if (jj_3R_113()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_162() {\n    if (jj_3R_111()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_161() {\n    if (jj_3R_113()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_256() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_254() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_256() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_254() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_338() {\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_338() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_338() {\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_338() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\n    super.visitLookupSwitchInsn(dflt, keys, labels);\n    if (currentLine != 0) {\n        switchTargetLabels.put(dflt, new SwitchHolder(currentLine, currentSwitch, -1));\n        for (int i = labels.length - 1; i >= 0; i--) {\n            switchTargetLabels.put(labels[i], new SwitchHolder(currentLine, currentSwitch, i));\n        }\n        classData.addLineSwitch(currentLine, currentSwitch++, keys);\n    }\n}", "methodAfter": "public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\n    super.visitLookupSwitchInsn(dflt, keys, labels);\n    if (currentLine != 0) {\n        switchTargetLabels.put(dflt, new SwitchHolder(currentLine, currentSwitch, -1));\n        for (int i = labels.length - 1; i >= 0; i--) {\n            switchTargetLabels.put(labels[i], new SwitchHolder(currentLine, currentSwitch, i));\n        }\n        classData.addLineSwitch(currentLine, currentSwitch++, keys);\n    }\n    markNonTrivial();\n}"}, {"methodBefore": "public void visitTableSwitchInsn(int min, int max, Label dflt, Label[] labels) {\n    super.visitTableSwitchInsn(min, max, dflt, labels);\n    if (currentLine != 0) {\n        switchTargetLabels.put(dflt, new SwitchHolder(currentLine, currentSwitch, -1));\n        for (int i = labels.length - 1; i >= 0; i--) {\n            switchTargetLabels.put(labels[i], new SwitchHolder(currentLine, currentSwitch, i));\n        }\n        classData.addLineSwitch(currentLine, currentSwitch++, min, max);\n    }\n}", "methodAfter": "public void visitTableSwitchInsn(int min, int max, Label dflt, Label[] labels) {\n    super.visitTableSwitchInsn(min, max, dflt, labels);\n    if (currentLine != 0) {\n        switchTargetLabels.put(dflt, new SwitchHolder(currentLine, currentSwitch, -1));\n        for (int i = labels.length - 1; i >= 0; i--) {\n            switchTargetLabels.put(labels[i], new SwitchHolder(currentLine, currentSwitch, i));\n        }\n        classData.addLineSwitch(currentLine, currentSwitch++, min, max);\n    }\n    markNonTrivial();\n}"}, {"methodBefore": "public void visitJumpInsn(int opcode, Label label) {\n    if ((((opcode != GOTO) && (opcode != JSR)) && (currentLine != 0)) && (!this.myName.equals(\"<clinit>\"))) {\n        classData.addLineJump(currentLine, currentJump);\n        jumpTargetLabels.put(label, new JumpHolder(currentLine, currentJump++));\n    }\n    super.visitJumpInsn(opcode, label);\n}", "methodAfter": "public void visitJumpInsn(int opcode, Label label) {\n    if ((((opcode != GOTO) && (opcode != JSR)) && (currentLine != 0)) && (!this.myName.equals(\"<clinit>\"))) {\n        classData.addLineJump(currentLine, currentJump);\n        jumpTargetLabels.put(label, new JumpHolder(currentLine, currentJump++));\n    }\n    markNonTrivial();\n    super.visitJumpInsn(opcode, label);\n}"}], [{"methodBefore": "private boolean jj_3R_217() {\n    if (jj_3R_117()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_277()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_291() {\n    if (jj_3R_294()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_305()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_217() {\n    if (jj_3R_117()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_277()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_291() {\n    if (jj_3R_294()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_305()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "public final void TypeParameters() throws ParseException {\n    jj_consume_token(LT);\n    TypeParameter();\n    label_67 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[178] = jj_gen;\n                break label_67;\n        }\n        jj_consume_token(COMMA);\n        TypeParameter();\n    } \n    jj_consume_token(GT);\n}", "methodAfter": "public final void TypeParameters() throws ParseException {\n    jj_consume_token(LT);\n    TypeParameter();\n    label_70 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[183] = jj_gen;\n                break label_70;\n        }\n        jj_consume_token(COMMA);\n        TypeParameter();\n    } \n    jj_consume_token(GT);\n}"}, {"methodBefore": "public final void TypeParameters() throws ParseException {\n    jj_consume_token(LT);\n    TypeParameter();\n    label_67 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[178] = jj_gen;\n                break label_67;\n        }\n        jj_consume_token(COMMA);\n        TypeParameter();\n    } \n    jj_consume_token(GT);\n}", "methodAfter": "public final void TypeParameters() throws ParseException {\n    jj_consume_token(LT);\n    TypeParameter();\n    label_70 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[183] = jj_gen;\n                break label_70;\n        }\n        jj_consume_token(COMMA);\n        TypeParameter();\n    } \n    jj_consume_token(GT);\n}"}], [{"methodBefore": "private boolean jj_3R_371() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_371() {\n    if (jj_scan_token(STATIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_371() {\n    if (jj_scan_token(NATIVE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_371() {\n    if (jj_scan_token(STATIC)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public SortedSet getClasses() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getClasses() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getClasses() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getClasses() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getPackages() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getPackages() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getLines() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getLines() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private static void runTestAntScript(String testName, String target) throws IOException {\n    Java java = new Java();\n    java.setProject(project);\n    java.setTaskName(\"java\");\n    java.setClassname(\"org.apache.tools.ant.launch.Launcher\");\n    java.setFork(true);\n    AntUtil.transferCoberturaDataFileProperty(java);\n    if (forkedJVMDebugPort > 0) {\n        java.createJvmarg().setValue(\"-Xdebug\");\n        java.createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    java.createArg().setValue(\"-f\");\n    java.createArg().setValue(BASEDIR + \"/build.xml\");\n    java.createArg().setValue(target);\n    java.setFailonerror(true);\n    File output = Util.createTemporaryTextFile(\"cobertura-test\");\n    java.setOutput(output);\n    Path classpath = new Path(TestUtils.project);\n    PathElement pathElement = classpath.new PathElement();\n    pathElement.setPath(System.getProperty(\"java.class.path\"));\n    classpath.add(TestUtils.getCoberturaDefaultClasspath());\n    classpath.add(pathElement);\n    try {\n        java.executeJava();\n    } finally {\n        if (output.exists()) {\n            System.out.println((((\"\\n\\n\\nOutput from Ant for \" + testName) + \" test:\\n----------------------------------------\\n\") + Util.getText(output)) + \"----------------------------------------\");\n            output.delete();\n        }\n    }\n}", "methodAfter": "private static void runTestAntScript(String testName, String target) throws IOException {\n    Java java = new Java();\n    java.setProject(project);\n    java.setTaskName(\"java\");\n    java.setClassname(\"org.apache.tools.ant.launch.Launcher\");\n    java.setFork(true);\n    AntUtil.transferCoberturaDataFileProperty(java);\n    if (forkedJVMDebugPort > 0) {\n        java.createJvmarg().setValue(\"-Xdebug\");\n        java.createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    java.createArg().setValue(\"-f\");\n    java.createArg().setValue(BASEDIR + \"/build.xml\");\n    java.createArg().setValue(target);\n    java.setFailonerror(true);\n    File output = Util.createTemporaryTextFile(\"cobertura-test\");\n    java.setOutput(output);\n    Path classpath = new Path(TestUtils.project);\n    PathElement pathElement = classpath.new PathElement();\n    pathElement.setPath(System.getProperty(\"java.class.path\"));\n    classpath.add(TestUtils.getCoberturaDefaultClasspath());\n    classpath.add(pathElement);\n    java.setClasspath(classpath);\n    try {\n        java.executeJava();\n    } finally {\n        if (output.exists()) {\n            System.out.println((((\"\\n\\n\\nOutput from Ant for \" + testName) + \" test:\\n----------------------------------------\\n\") + Util.getText(output)) + \"----------------------------------------\");\n            output.delete();\n        }\n    }\n}"}, {"methodBefore": "private static void runTestAntScript(String testName, String target) throws IOException {\n    Java java = new Java();\n    java.setProject(project);\n    java.setTaskName(\"java\");\n    java.setClassname(\"org.apache.tools.ant.launch.Launcher\");\n    java.setFork(true);\n    AntUtil.transferCoberturaDataFileProperty(java);\n    if (forkedJVMDebugPort > 0) {\n        java.createJvmarg().setValue(\"-Xdebug\");\n        java.createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    java.createArg().setValue(\"-f\");\n    java.createArg().setValue(BASEDIR + \"/build.xml\");\n    java.createArg().setValue(target);\n    java.setFailonerror(true);\n    File output = Util.createTemporaryTextFile(\"cobertura-test\");\n    java.setOutput(output);\n    Path classpath = new Path(TestUtils.project);\n    PathElement pathElement = classpath.new PathElement();\n    pathElement.setPath(System.getProperty(\"java.class.path\"));\n    classpath.add(TestUtils.getCoberturaDefaultClasspath());\n    classpath.add(pathElement);\n    try {\n        java.executeJava();\n    } finally {\n        if (output.exists()) {\n            System.out.println((((\"\\n\\n\\nOutput from Ant for \" + testName) + \" test:\\n----------------------------------------\\n\") + Util.getText(output)) + \"----------------------------------------\");\n            output.delete();\n        }\n    }\n}", "methodAfter": "private static void runTestAntScript(String testName, String target) throws IOException {\n    Java java = new Java();\n    java.setProject(project);\n    java.setTaskName(\"java\");\n    java.setClassname(\"org.apache.tools.ant.launch.Launcher\");\n    java.setFork(true);\n    AntUtil.transferCoberturaDataFileProperty(java);\n    if (forkedJVMDebugPort > 0) {\n        java.createJvmarg().setValue(\"-Xdebug\");\n        java.createJvmarg().setValue((\"-Xrunjdwp:transport=dt_socket,address=\" + forkedJVMDebugPort) + \",server=y,suspend=y\");\n    }\n    java.createArg().setValue(\"-f\");\n    java.createArg().setValue(BASEDIR + \"/build.xml\");\n    java.createArg().setValue(target);\n    java.setFailonerror(true);\n    File output = Util.createTemporaryTextFile(\"cobertura-test\");\n    java.setOutput(output);\n    Path classpath = new Path(TestUtils.project);\n    PathElement pathElement = classpath.new PathElement();\n    pathElement.setPath(System.getProperty(\"java.class.path\"));\n    classpath.add(TestUtils.getCoberturaDefaultClasspath());\n    classpath.add(pathElement);\n    java.setClasspath(classpath);\n    try {\n        java.executeJava();\n    } finally {\n        if (output.exists()) {\n            System.out.println((((\"\\n\\n\\nOutput from Ant for \" + testName) + \" test:\\n----------------------------------------\\n\") + Util.getText(output)) + \"----------------------------------------\");\n            output.delete();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_170() {\n    if (jj_scan_token(HOOK)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_206()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_173() {\n    if (jj_scan_token(HOOK)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_222()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_170() {\n    if (jj_scan_token(HOOK)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_206()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_173() {\n    if (jj_scan_token(HOOK)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_222()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_355() {\n    if (jj_3R_383()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_348() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_382()) {\n        jj_scanpos = xsp;\n        if (jj_3R_383()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_355() {\n    if (jj_3R_383()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_348() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_382()) {\n        jj_scanpos = xsp;\n        if (jj_3R_383()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private void _measureSource(Reader reader) throws IOException, ParseException, TokenMgrError {\n    try {\n        _pJavaParser = new JavaParser(reader);\n        _pJavaParser.CompilationUnit();\n        Util.debug(\"Javancss._measureSource(DataInputStream).SUCCESSFULLY_PARSED\");\n        _ncss += _pJavaParser.getNcss();\n        _loc += _pJavaParser.getLOC();\n        _vFunctionMetrics.addAll(_pJavaParser.getFunction());\n        _vObjectMetrics.addAll(_pJavaParser.getObject());\n        Map htNewPackages = _pJavaParser.getPackage();\n        for (Iterator ePackages = htNewPackages.keySet().iterator(); ePackages.hasNext();) {\n            String sPackage = ((String) (ePackages.next()));\n            PackageMetric pckmNext = ((PackageMetric) (htNewPackages.get(sPackage)));\n            pckmNext.name = sPackage;\n            PackageMetric pckmPrevious = ((PackageMetric) (_htPackages.get(sPackage)));\n            pckmNext.add(pckmPrevious);\n            _htPackages.put(sPackage, pckmNext);\n        }\n    } catch (ParseException pParseException) {\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"ParseException in STDIN\";\n        if (_pJavaParser != null) {\n            _sErrorMessage += (\"\\nLast useful checkpoint: \\\"\" + _pJavaParser.getLastFunction()) + \"\\\"\\n\";\n        }\n        _sErrorMessage += pParseException.getMessage() + \"\\n\";\n        _thrwError = pParseException;\n        throw pParseException;\n    } catch (TokenMgrError pTokenMgrError) {\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"TokenMgrError in STDIN\\n\";\n        _sErrorMessage += pTokenMgrError.getMessage() + \"\\n\";\n        _thrwError = pTokenMgrError;\n        throw pTokenMgrError;\n    }\n}", "methodAfter": "private void _measureSource(Reader reader) throws IOException, ParseException, TokenMgrError {\n    try {\n        _pJavaParser = new JavaParser(reader);\n        _pJavaParser.CompilationUnit();\n        Util.debug(\"Javancss._measureSource(DataInputStream).SUCCESSFULLY_PARSED\");\n        _ncss += _pJavaParser.getNcss();\n        _loc += _pJavaParser.getLOC();\n        _vFunctionMetrics.addAll(_pJavaParser.getFunction());\n        _vObjectMetrics.addAll(_pJavaParser.getObject());\n        Map htNewPackages = _pJavaParser.getPackage();\n        for (Iterator ePackages = htNewPackages.entrySet().iterator(); ePackages.hasNext();) {\n            String sPackage = ((String) (((Map.Entry) (ePackages.next())).getKey()));\n            PackageMetric pckmNext = ((PackageMetric) (htNewPackages.get(sPackage)));\n            pckmNext.name = sPackage;\n            PackageMetric pckmPrevious = ((PackageMetric) (_htPackages.get(sPackage)));\n            pckmNext.add(pckmPrevious);\n            _htPackages.put(sPackage, pckmNext);\n        }\n    } catch (ParseException pParseException) {\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"ParseException in STDIN\";\n        if (_pJavaParser != null) {\n            _sErrorMessage += (\"\\nLast useful checkpoint: \\\"\" + _pJavaParser.getLastFunction()) + \"\\\"\\n\";\n        }\n        _sErrorMessage += pParseException.getMessage() + \"\\n\";\n        _thrwError = pParseException;\n        throw pParseException;\n    } catch (TokenMgrError pTokenMgrError) {\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"TokenMgrError in STDIN\\n\";\n        _sErrorMessage += pTokenMgrError.getMessage() + \"\\n\";\n        _thrwError = pTokenMgrError;\n        throw pTokenMgrError;\n    }\n}"}, {"methodBefore": "private void _measureSource(Reader reader) throws IOException, ParseException, TokenMgrError {\n    try {\n        _pJavaParser = new JavaParser(reader);\n        _pJavaParser.CompilationUnit();\n        Util.debug(\"Javancss._measureSource(DataInputStream).SUCCESSFULLY_PARSED\");\n        _ncss += _pJavaParser.getNcss();\n        _loc += _pJavaParser.getLOC();\n        _vFunctionMetrics.addAll(_pJavaParser.getFunction());\n        _vObjectMetrics.addAll(_pJavaParser.getObject());\n        Map htNewPackages = _pJavaParser.getPackage();\n        for (Iterator ePackages = htNewPackages.keySet().iterator(); ePackages.hasNext();) {\n            String sPackage = ((String) (ePackages.next()));\n            PackageMetric pckmNext = ((PackageMetric) (htNewPackages.get(sPackage)));\n            pckmNext.name = sPackage;\n            PackageMetric pckmPrevious = ((PackageMetric) (_htPackages.get(sPackage)));\n            pckmNext.add(pckmPrevious);\n            _htPackages.put(sPackage, pckmNext);\n        }\n    } catch (ParseException pParseException) {\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"ParseException in STDIN\";\n        if (_pJavaParser != null) {\n            _sErrorMessage += (\"\\nLast useful checkpoint: \\\"\" + _pJavaParser.getLastFunction()) + \"\\\"\\n\";\n        }\n        _sErrorMessage += pParseException.getMessage() + \"\\n\";\n        _thrwError = pParseException;\n        throw pParseException;\n    } catch (TokenMgrError pTokenMgrError) {\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"TokenMgrError in STDIN\\n\";\n        _sErrorMessage += pTokenMgrError.getMessage() + \"\\n\";\n        _thrwError = pTokenMgrError;\n        throw pTokenMgrError;\n    }\n}", "methodAfter": "private void _measureSource(Reader reader) throws IOException, ParseException, TokenMgrError {\n    try {\n        _pJavaParser = new JavaParser(reader);\n        _pJavaParser.CompilationUnit();\n        Util.debug(\"Javancss._measureSource(DataInputStream).SUCCESSFULLY_PARSED\");\n        _ncss += _pJavaParser.getNcss();\n        _loc += _pJavaParser.getLOC();\n        _vFunctionMetrics.addAll(_pJavaParser.getFunction());\n        _vObjectMetrics.addAll(_pJavaParser.getObject());\n        Map htNewPackages = _pJavaParser.getPackage();\n        for (Iterator ePackages = htNewPackages.entrySet().iterator(); ePackages.hasNext();) {\n            String sPackage = ((String) (((Map.Entry) (ePackages.next())).getKey()));\n            PackageMetric pckmNext = ((PackageMetric) (htNewPackages.get(sPackage)));\n            pckmNext.name = sPackage;\n            PackageMetric pckmPrevious = ((PackageMetric) (_htPackages.get(sPackage)));\n            pckmNext.add(pckmPrevious);\n            _htPackages.put(sPackage, pckmNext);\n        }\n    } catch (ParseException pParseException) {\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"ParseException in STDIN\";\n        if (_pJavaParser != null) {\n            _sErrorMessage += (\"\\nLast useful checkpoint: \\\"\" + _pJavaParser.getLastFunction()) + \"\\\"\\n\";\n        }\n        _sErrorMessage += pParseException.getMessage() + \"\\n\";\n        _thrwError = pParseException;\n        throw pParseException;\n    } catch (TokenMgrError pTokenMgrError) {\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"TokenMgrError in STDIN\\n\";\n        _sErrorMessage += pTokenMgrError.getMessage() + \"\\n\";\n        _thrwError = pTokenMgrError;\n        throw pTokenMgrError;\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_191() {\n    if (jj_3R_205()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_219()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_441() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_451()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_191() {\n    if (jj_3R_205()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_219()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_441() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_451()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_199() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_199() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_199() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_199() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public ParseException generateParseException() {\n    jj_expentries.clear();\n    boolean[] la1tokens = new boolean[123];\n    if (jj_kind >= 0) {\n        la1tokens[jj_kind] = true;\n        jj_kind = -1;\n    }\n    for (int i = 0; i < 202; i++) {\n        if (jj_la1[i] == jj_gen) {\n            for (int j = 0; j < 32; j++) {\n                if ((jj_la1_0[i] & (1 << j)) != 0) {\n                    la1tokens[j] = true;\n                }\n                if ((jj_la1_1[i] & (1 << j)) != 0) {\n                    la1tokens[32 + j] = true;\n                }\n                if ((jj_la1_2[i] & (1 << j)) != 0) {\n                    la1tokens[64 + j] = true;\n                }\n                if ((jj_la1_3[i] & (1 << j)) != 0) {\n                    la1tokens[96 + j] = true;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 123; i++) {\n        if (la1tokens[i]) {\n            jj_expentry = new int[1];\n            jj_expentry[0] = i;\n            jj_expentries.add(jj_expentry);\n        }\n    }\n    jj_endpos = 0;\n    jj_rescan_token();\n    jj_add_error_token(0, 0);\n    int[][] exptokseq = new int[jj_expentries.size()][];\n    for (int i = 0; i < jj_expentries.size(); i++) {\n        exptokseq[i] = ((int[]) (jj_expentries.get(i)));\n    }\n    return new ParseException(token, exptokseq, tokenImage);\n}", "methodAfter": "public ParseException generateParseException() {\n    jj_expentries.clear();\n    boolean[] la1tokens = new boolean[124];\n    if (jj_kind >= 0) {\n        la1tokens[jj_kind] = true;\n        jj_kind = -1;\n    }\n    for (int i = 0; i < 208; i++) {\n        if (jj_la1[i] == jj_gen) {\n            for (int j = 0; j < 32; j++) {\n                if ((jj_la1_0[i] & (1 << j)) != 0) {\n                    la1tokens[j] = true;\n                }\n                if ((jj_la1_1[i] & (1 << j)) != 0) {\n                    la1tokens[32 + j] = true;\n                }\n                if ((jj_la1_2[i] & (1 << j)) != 0) {\n                    la1tokens[64 + j] = true;\n                }\n                if ((jj_la1_3[i] & (1 << j)) != 0) {\n                    la1tokens[96 + j] = true;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 124; i++) {\n        if (la1tokens[i]) {\n            jj_expentry = new int[1];\n            jj_expentry[0] = i;\n            jj_expentries.add(jj_expentry);\n        }\n    }\n    jj_endpos = 0;\n    jj_rescan_token();\n    jj_add_error_token(0, 0);\n    int[][] exptokseq = new int[jj_expentries.size()][];\n    for (int i = 0; i < jj_expentries.size(); i++) {\n        exptokseq[i] = ((int[]) (jj_expentries.get(i)));\n    }\n    return new ParseException(token, exptokseq, tokenImage);\n}"}, {"methodBefore": "public ParseException generateParseException() {\n    jj_expentries.clear();\n    boolean[] la1tokens = new boolean[123];\n    if (jj_kind >= 0) {\n        la1tokens[jj_kind] = true;\n        jj_kind = -1;\n    }\n    for (int i = 0; i < 202; i++) {\n        if (jj_la1[i] == jj_gen) {\n            for (int j = 0; j < 32; j++) {\n                if ((jj_la1_0[i] & (1 << j)) != 0) {\n                    la1tokens[j] = true;\n                }\n                if ((jj_la1_1[i] & (1 << j)) != 0) {\n                    la1tokens[32 + j] = true;\n                }\n                if ((jj_la1_2[i] & (1 << j)) != 0) {\n                    la1tokens[64 + j] = true;\n                }\n                if ((jj_la1_3[i] & (1 << j)) != 0) {\n                    la1tokens[96 + j] = true;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 123; i++) {\n        if (la1tokens[i]) {\n            jj_expentry = new int[1];\n            jj_expentry[0] = i;\n            jj_expentries.add(jj_expentry);\n        }\n    }\n    jj_endpos = 0;\n    jj_rescan_token();\n    jj_add_error_token(0, 0);\n    int[][] exptokseq = new int[jj_expentries.size()][];\n    for (int i = 0; i < jj_expentries.size(); i++) {\n        exptokseq[i] = ((int[]) (jj_expentries.get(i)));\n    }\n    return new ParseException(token, exptokseq, tokenImage);\n}", "methodAfter": "public ParseException generateParseException() {\n    jj_expentries.clear();\n    boolean[] la1tokens = new boolean[124];\n    if (jj_kind >= 0) {\n        la1tokens[jj_kind] = true;\n        jj_kind = -1;\n    }\n    for (int i = 0; i < 208; i++) {\n        if (jj_la1[i] == jj_gen) {\n            for (int j = 0; j < 32; j++) {\n                if ((jj_la1_0[i] & (1 << j)) != 0) {\n                    la1tokens[j] = true;\n                }\n                if ((jj_la1_1[i] & (1 << j)) != 0) {\n                    la1tokens[32 + j] = true;\n                }\n                if ((jj_la1_2[i] & (1 << j)) != 0) {\n                    la1tokens[64 + j] = true;\n                }\n                if ((jj_la1_3[i] & (1 << j)) != 0) {\n                    la1tokens[96 + j] = true;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 124; i++) {\n        if (la1tokens[i]) {\n            jj_expentry = new int[1];\n            jj_expentry[0] = i;\n            jj_expentries.add(jj_expentry);\n        }\n    }\n    jj_endpos = 0;\n    jj_rescan_token();\n    jj_add_error_token(0, 0);\n    int[][] exptokseq = new int[jj_expentries.size()][];\n    for (int i = 0; i < jj_expentries.size(); i++) {\n        exptokseq[i] = ((int[]) (jj_expentries.get(i)));\n    }\n    return new ParseException(token, exptokseq, tokenImage);\n}"}], [{"methodBefore": "private boolean jj_3R_132() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_135() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_132() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_135() {\n    if (jj_scan_token(TRANSIENT)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void Statement() throws ParseException {\n    _bReturn = false;\n    if (jj_2_43(2)) {\n        LabeledStatement();\n    } else if (jj_2_44(2147483647)) {\n        AssertStatement();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACE :\n                Block();\n                break;\n            case SEMICOLON :\n                EmptyStatement();\n                break;\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case SHORT :\n            case SUPER :\n            case THIS :\n            case TRUE :\n            case VOID :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case INCR :\n            case DECR :\n                StatementExpression();\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n                break;\n            case SWITCH :\n                SwitchStatement();\n                break;\n            case IF :\n                IfStatement();\n                _cyc++;\n                break;\n            case WHILE :\n                WhileStatement();\n                _cyc++;\n                break;\n            case DO :\n                DoStatement();\n                _cyc++;\n                break;\n            case FOR :\n                ForStatement();\n                _cyc++;\n                break;\n            case BREAK :\n                BreakStatement();\n                break;\n            case CONTINUE :\n                ContinueStatement();\n                break;\n            case RETURN :\n                ReturnStatement();\n                break;\n            case THROW :\n                ThrowStatement();\n                break;\n            case SYNCHRONIZED :\n                SynchronizedStatement();\n                break;\n            case TRY :\n                TryStatement();\n                break;\n            default :\n                jj_la1[137] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void Statement() throws ParseException {\n    _bReturn = false;\n    if (jj_2_42(2)) {\n        LabeledStatement();\n    } else if (jj_2_43(2147483647)) {\n        AssertStatement();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACE :\n                Block();\n                break;\n            case SEMICOLON :\n                EmptyStatement();\n                break;\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case SHORT :\n            case SUPER :\n            case THIS :\n            case TRUE :\n            case VOID :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case INCR :\n            case DECR :\n                StatementExpression();\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n                break;\n            case SWITCH :\n                SwitchStatement();\n                break;\n            case IF :\n                IfStatement();\n                _cyc++;\n                break;\n            case WHILE :\n                WhileStatement();\n                _cyc++;\n                break;\n            case DO :\n                DoStatement();\n                _cyc++;\n                break;\n            case FOR :\n                ForStatement();\n                _cyc++;\n                break;\n            case BREAK :\n                BreakStatement();\n                break;\n            case CONTINUE :\n                ContinueStatement();\n                break;\n            case RETURN :\n                ReturnStatement();\n                break;\n            case THROW :\n                ThrowStatement();\n                break;\n            case SYNCHRONIZED :\n                SynchronizedStatement();\n                break;\n            case TRY :\n                TryStatement();\n                break;\n            default :\n                jj_la1[138] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}, {"methodBefore": "public final void Statement() throws ParseException {\n    _bReturn = false;\n    if (jj_2_43(2)) {\n        LabeledStatement();\n    } else if (jj_2_44(2147483647)) {\n        AssertStatement();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACE :\n                Block();\n                break;\n            case SEMICOLON :\n                EmptyStatement();\n                break;\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case SHORT :\n            case SUPER :\n            case THIS :\n            case TRUE :\n            case VOID :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case INCR :\n            case DECR :\n                StatementExpression();\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n                break;\n            case SWITCH :\n                SwitchStatement();\n                break;\n            case IF :\n                IfStatement();\n                _cyc++;\n                break;\n            case WHILE :\n                WhileStatement();\n                _cyc++;\n                break;\n            case DO :\n                DoStatement();\n                _cyc++;\n                break;\n            case FOR :\n                ForStatement();\n                _cyc++;\n                break;\n            case BREAK :\n                BreakStatement();\n                break;\n            case CONTINUE :\n                ContinueStatement();\n                break;\n            case RETURN :\n                ReturnStatement();\n                break;\n            case THROW :\n                ThrowStatement();\n                break;\n            case SYNCHRONIZED :\n                SynchronizedStatement();\n                break;\n            case TRY :\n                TryStatement();\n                break;\n            default :\n                jj_la1[137] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void Statement() throws ParseException {\n    _bReturn = false;\n    if (jj_2_42(2)) {\n        LabeledStatement();\n    } else if (jj_2_43(2147483647)) {\n        AssertStatement();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACE :\n                Block();\n                break;\n            case SEMICOLON :\n                EmptyStatement();\n                break;\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case SHORT :\n            case SUPER :\n            case THIS :\n            case TRUE :\n            case VOID :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case INCR :\n            case DECR :\n                StatementExpression();\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n                break;\n            case SWITCH :\n                SwitchStatement();\n                break;\n            case IF :\n                IfStatement();\n                _cyc++;\n                break;\n            case WHILE :\n                WhileStatement();\n                _cyc++;\n                break;\n            case DO :\n                DoStatement();\n                _cyc++;\n                break;\n            case FOR :\n                ForStatement();\n                _cyc++;\n                break;\n            case BREAK :\n                BreakStatement();\n                break;\n            case CONTINUE :\n                ContinueStatement();\n                break;\n            case RETURN :\n                ReturnStatement();\n                break;\n            case THROW :\n                ThrowStatement();\n                break;\n            case SYNCHRONIZED :\n                SynchronizedStatement();\n                break;\n            case TRY :\n                TryStatement();\n                break;\n            default :\n                jj_la1[138] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}], [{"methodBefore": "public void basicStartAndStopOfWebApp(boolean tomcat) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, tomcat);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertFalse(TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n    webappServer.killServer();\n    Thread.sleep(5 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertTrue(\"doGet has hits=0 in cobertura report\", TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n}", "methodAfter": "public void basicStartAndStopOfWebApp(boolean tomcat) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    new File(webappServerDir, \"logs\").mkdirs();\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, tomcat);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertFalse(TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n    webappServer.killServer();\n    Thread.sleep(5 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertTrue(\"doGet has hits=0 in cobertura report\", TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n}"}, {"methodBefore": "public void basicStartAndStopOfWebApp(boolean tomcat) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, tomcat);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertFalse(TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n    webappServer.killServer();\n    Thread.sleep(5 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertTrue(\"doGet has hits=0 in cobertura report\", TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n}", "methodAfter": "public void basicStartAndStopOfWebApp(boolean tomcat) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    new File(webappServerDir, \"logs\").mkdirs();\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, tomcat);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentRegEx\", \"com.acme.*\");\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertFalse(TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n    webappServer.killServer();\n    Thread.sleep(5 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    assertTrue(\"doGet has hits=0 in cobertura report\", TestUtils.isMethodHit(dom, \"com.acme.servlet.SimpleServlet\", \"doGet\"));\n}"}], [{"methodBefore": "private boolean jj_3R_178() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_177() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_178() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_177() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_447() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_172() {\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_447() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_172() {\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public int getNumberOfChildren() {\n    lock.lock();\n    try {\n        return this.children.size();\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public int getNumberOfChildren() {\n    synchronizeState();\n    lock.lock();\n    try {\n        return this.children.size();\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public int hashCode() {\n    lock.lock();\n    try {\n        return this.children.size();\n    } finally {\n        lock.unlock();\n    }\n}", "methodAfter": "public int hashCode() {\n    synchronizeState();\n    lock.lock();\n    try {\n        return this.children.size();\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(outputDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/percentagesorttype.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(\"<thead>\");\n        out.println(\"<tr>\");\n        out.println(\"  <td class=\\\"heading\\\">Package</td>\");\n        out.println(\"  <td class=\\\"heading\\\"># Classes</td>\");\n        out.println(generateCommonTableColumns());\n        out.println(\"</tr>\");\n        out.println(\"</thead>\");\n        out.println(\"<tbody>\");\n        Collection packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getChildren();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        if (packages.size() > 0) {\n            Iterator iter = packages.iterator();\n            while (iter.hasNext()) {\n                PackageData subPackageData = ((PackageData) (iter.next()));\n                out.println(generateTableRowForPackage(subPackageData));\n            } \n        }\n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"Number\\\", \\\"Number\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        out.println(\"</p>\");\n        Collection classes;\n        if (packageData == null) {\n            classes = new TreeSet();\n            if (projectData.getNumberOfClasses() > 0) {\n                Iterator iter = projectData.getClasses().iterator();\n                while (iter.hasNext()) {\n                    ClassData classData = ((ClassData) (iter.next()));\n                    if (classData.getPackageName() == null) {\n                        classes.add(classData);\n                    }\n                } \n            }\n        } else {\n            classes = packageData.getChildren();\n        }\n        if (classes.size() > 0) {\n            out.println(\"<p>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeaderForClasses());\n            out.println(\"<tbody>\");\n            Iterator iter = classes.iterator();\n            while (iter.hasNext()) {\n                ClassData classData = ((ClassData) (iter.next()));\n                out.println(generateTableRowForClass(classData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"Number\\\", \\\"Number\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n            out.println(\"</p>\");\n        }\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Report generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/percentagesorttype.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(\"<thead>\");\n        out.println(\"<tr>\");\n        out.println(\"  <td class=\\\"heading\\\">Package</td>\");\n        out.println(\"  <td class=\\\"heading\\\"># Classes</td>\");\n        out.println(generateCommonTableColumns());\n        out.println(\"</tr>\");\n        out.println(\"</thead>\");\n        out.println(\"<tbody>\");\n        Collection packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getChildren();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        if (packages.size() > 0) {\n            Iterator iter = packages.iterator();\n            while (iter.hasNext()) {\n                PackageData subPackageData = ((PackageData) (iter.next()));\n                out.println(generateTableRowForPackage(subPackageData));\n            } \n        }\n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"Number\\\", \\\"Number\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        out.println(\"</p>\");\n        Collection classes;\n        if (packageData == null) {\n            classes = new TreeSet();\n            if (projectData.getNumberOfClasses() > 0) {\n                Iterator iter = projectData.getClasses().iterator();\n                while (iter.hasNext()) {\n                    ClassData classData = ((ClassData) (iter.next()));\n                    if (classData.getPackageName() == null) {\n                        classes.add(classData);\n                    }\n                } \n            }\n        } else {\n            classes = packageData.getChildren();\n        }\n        if (classes.size() > 0) {\n            out.println(\"<p>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeaderForClasses());\n            out.println(\"<tbody>\");\n            Iterator iter = classes.iterator();\n            while (iter.hasNext()) {\n                ClassData classData = ((ClassData) (iter.next()));\n                out.println(generateTableRowForClass(classData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"Number\\\", \\\"Number\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n            out.println(\"</p>\");\n        }\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Report generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateSourceFile(ClassData classData) throws IOException {\n    String filename = classData.getName() + \".html\";\n    File file = new File(outputDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = classData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classData.getPackageName() + \".\");\n        }\n        out.print(classData.getName());\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeaderForClasses());\n        out.println(generateTableRowForClass(classData));\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<p>\");\n        out.println(\"<table cellspacing=\\\"0\\\" cellpadding=\\\"0\\\" class=\\\"src\\\">\");\n        BufferedReader br = null;\n        try {\n            File sourceFile = new File(sourceDir, classData.getSourceFileName());\n            br = new BufferedReader(new FileReader(sourceFile));\n            String lineStr;\n            JavaToHtml javaToHtml = new JavaToHtml();\n            int lineNumber = 1;\n            while ((lineStr = br.readLine()) != null) {\n                out.println(\"<tr>\");\n                if (classData.isValidSourceLineNumber(lineNumber)) {\n                    long numberOfHits = classData.getHitCount(lineNumber);\n                    out.println((\"  <td class=\\\"numLineCover\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    if (numberOfHits > 0) {\n                        out.println((\"  <td class=\\\"nbHitsCovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                    } else {\n                        out.println((\"  <td class=\\\"nbHitsUncovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\"><span class=\\\"srcUncovered\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</span></pre></td>\");\n                    }\n                } else {\n                    out.println((\"  <td class=\\\"numLine\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    out.println(\"  <td class=\\\"nbHits\\\">&nbsp;</td>\");\n                    out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                }\n                out.println(\"</tr>\");\n                lineNumber++;\n            } \n        } finally {\n            if (br != null) {\n                br.close();\n            }\n        }\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Reports generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFile(ClassData classData) throws IOException {\n    String filename = classData.getName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = classData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classData.getPackageName() + \".\");\n        }\n        out.print(classData.getName());\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeaderForClasses());\n        out.println(generateTableRowForClass(classData));\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<p>\");\n        out.println(\"<table cellspacing=\\\"0\\\" cellpadding=\\\"0\\\" class=\\\"src\\\">\");\n        BufferedReader br = null;\n        try {\n            File sourceFile = new File(sourceDir, classData.getSourceFileName());\n            br = new BufferedReader(new FileReader(sourceFile));\n            String lineStr;\n            JavaToHtml javaToHtml = new JavaToHtml();\n            int lineNumber = 1;\n            while ((lineStr = br.readLine()) != null) {\n                out.println(\"<tr>\");\n                if (classData.isValidSourceLineNumber(lineNumber)) {\n                    long numberOfHits = classData.getHitCount(lineNumber);\n                    out.println((\"  <td class=\\\"numLineCover\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    if (numberOfHits > 0) {\n                        out.println((\"  <td class=\\\"nbHitsCovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                    } else {\n                        out.println((\"  <td class=\\\"nbHitsUncovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\"><span class=\\\"srcUncovered\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</span></pre></td>\");\n                    }\n                } else {\n                    out.println((\"  <td class=\\\"numLine\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    out.println(\"  <td class=\\\"nbHits\\\">&nbsp;</td>\");\n                    out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                }\n                out.println(\"</tr>\");\n                lineNumber++;\n            } \n        } finally {\n            if (br != null) {\n                br.close();\n            }\n        }\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Reports generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateClassList(PackageData packageData) throws IOException {\n    String filename;\n    Collection classes;\n    if (packageData == null) {\n        filename = \"frame-classes.html\";\n        classes = projectData.getClasses();\n    } else {\n        filename = (\"frame-classes-\" + packageData.getName()) + \".html\";\n        classes = packageData.getChildren();\n    }\n    File file = new File(outputDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<h5>Classes</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        Iterator iter;\n        Map sortedClassList = new TreeMap();\n        iter = classes.iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            sortedClassList.put(classData.getBaseName(), classData);\n        } \n        iter = sortedClassList.values().iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            out.println(\"<tr>\");\n            String percentCovered;\n            if (classData.getNumberOfValidLines() > 0) {\n                percentCovered = getPercentValue(classData.getLineCoverageRate());\n            } else {\n                percentCovered = \"N/A\";\n            }\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + classData.getName()) + \".html\\\">\") + classData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</td>\");\n        out.println(\"</tr>\");\n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateClassList(PackageData packageData) throws IOException {\n    String filename;\n    Collection classes;\n    if (packageData == null) {\n        filename = \"frame-classes.html\";\n        classes = projectData.getClasses();\n    } else {\n        filename = (\"frame-classes-\" + packageData.getName()) + \".html\";\n        classes = packageData.getChildren();\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<h5>Classes</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        Iterator iter;\n        Map sortedClassList = new TreeMap();\n        iter = classes.iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            sortedClassList.put(classData.getBaseName(), classData);\n        } \n        iter = sortedClassList.values().iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            out.println(\"<tr>\");\n            String percentCovered;\n            if (classData.getNumberOfValidLines() > 0) {\n                percentCovered = getPercentValue(classData.getLineCoverageRate());\n            } else {\n                percentCovered = \"N/A\";\n            }\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + classData.getName()) + \".html\\\">\") + classData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</td>\");\n        out.println(\"</tr>\");\n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_402() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_407() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_314()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_402() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_407() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_314()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_281() {\n    if (jj_3R_288()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_292()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_260() {\n    if (jj_3R_284()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_292()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_281() {\n    if (jj_3R_288()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_292()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_260() {\n    if (jj_3R_284()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_292()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_175() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_197()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_178() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_199()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_175() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_197()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_178() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_199()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_455() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_263()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_464() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_266()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_455() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_263()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_464() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_266()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_82() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_85() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_82() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_85() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void ForInit() throws ParseException {\n    if (jj_2_47(2147483647)) {\n        LocalVariableDeclaration();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case SHORT :\n            case SUPER :\n            case THIS :\n            case TRUE :\n            case VOID :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case INCR :\n            case DECR :\n                StatementExpressionList();\n                break;\n            default :\n                jj_la1[153] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void ForInit() throws ParseException {\n    if (jj_2_46(2147483647)) {\n        LocalVariableDeclaration();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case SHORT :\n            case SUPER :\n            case THIS :\n            case TRUE :\n            case VOID :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case INCR :\n            case DECR :\n                StatementExpressionList();\n                break;\n            default :\n                jj_la1[154] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}, {"methodBefore": "public final void ForInit() throws ParseException {\n    if (jj_2_47(2147483647)) {\n        LocalVariableDeclaration();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case SHORT :\n            case SUPER :\n            case THIS :\n            case TRUE :\n            case VOID :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case INCR :\n            case DECR :\n                StatementExpressionList();\n                break;\n            default :\n                jj_la1[153] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void ForInit() throws ParseException {\n    if (jj_2_46(2147483647)) {\n        LocalVariableDeclaration();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case SHORT :\n            case SUPER :\n            case THIS :\n            case TRUE :\n            case VOID :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case INCR :\n            case DECR :\n                StatementExpressionList();\n                break;\n            default :\n                jj_la1[154] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}], [{"methodBefore": "public static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}", "methodAfter": "@Test\npublic static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}"}, {"methodBefore": "public void testMultiThreadedGetJumpData() throws Throwable {\n    for (int i = 0; i < 100; i++) {\n        runGetJumpDataTestWithTwoThreads();\n    }\n}", "methodAfter": "@Test\npublic void testMultiThreadedGetJumpData() throws Throwable {\n    for (int i = 0; i < 100; i++) {\n        runGetJumpDataTestWithTwoThreads();\n    }\n}"}, {"methodBefore": "public void testMultiThreadedGetSwitchData() throws Throwable {\n    for (int i = 0; i < 100; i++) {\n        runGetSwitchDataTestWithTwoThreads();\n    }\n}", "methodAfter": "@Test\npublic void testMultiThreadedGetSwitchData() throws Throwable {\n    for (int i = 0; i < 100; i++) {\n        runGetSwitchDataTestWithTwoThreads();\n    }\n}"}, {"methodBefore": "public static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}", "methodAfter": "@Test\npublic static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}"}, {"methodBefore": "public static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}"}, {"methodBefore": "public static void testInstrumentUsingClassPath() throws Exception {\n    runTestAntScript(\"classpath\", \"test-classpath\");\n    verify(\"classpath\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingClassPath() throws Exception {\n    runTestAntScript(\"classpath\", \"test-classpath\");\n    verify(\"classpath\");\n}"}, {"methodBefore": "public static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}"}, {"methodBefore": "public static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}"}, {"methodBefore": "public static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}"}, {"methodBefore": "public void testLineCoverage() {\n    assertEquals(0, a.getNumberOfCoveredLines());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(2, b.getNumberOfCoveredLines());\n    assertEquals(5, b.getNumberOfValidLines());\n    assertEquals(0, c.getNumberOfCoveredLines());\n    assertEquals(5, c.getNumberOfValidLines());\n    assertEquals(1.0, a.getLineCoverageRate(), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, b.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, c.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n}", "methodAfter": "@Test\npublic void testLineCoverage() {\n    assertEquals(0, a.getNumberOfCoveredLines());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(2, b.getNumberOfCoveredLines());\n    assertEquals(5, b.getNumberOfValidLines());\n    assertEquals(0, c.getNumberOfCoveredLines());\n    assertEquals(5, c.getNumberOfValidLines());\n    assertEquals(1.0, a.getLineCoverageRate(), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, b.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, c.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n}"}, {"methodBefore": "public static void testInstrumentUsingClassPath() throws Exception {\n    runTestAntScript(\"classpath\", \"test-classpath\");\n    verify(\"classpath\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingClassPath() throws Exception {\n    runTestAntScript(\"classpath\", \"test-classpath\");\n    verify(\"classpath\");\n}"}, {"methodBefore": "public static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}"}, {"methodBefore": "public static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}"}, {"methodBefore": "public void testRemoveLine() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    a.removeLine(3);\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, b.getNumberOfValidLines());\n    b.removeLine(3);\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, b.getNumberOfValidLines());\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 2, Integer.MAX_VALUE);\n    c.addLineJump(3, 0);\n    c.addLineJump(4, 0);\n    assertEquals(9, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, c.getNumberOfValidLines());\n    c.removeLine(3);\n    assertEquals(4, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, c.getNumberOfValidLines());\n}", "methodAfter": "@Test\npublic void testRemoveLine() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    a.removeLine(3);\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, b.getNumberOfValidLines());\n    b.removeLine(3);\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, b.getNumberOfValidLines());\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 2, Integer.MAX_VALUE);\n    c.addLineJump(3, 0);\n    c.addLineJump(4, 0);\n    assertEquals(9, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, c.getNumberOfValidLines());\n    c.removeLine(3);\n    assertEquals(4, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, c.getNumberOfValidLines());\n}"}, {"methodBefore": "public void testBranchCoverage() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(1.0, a.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, a.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.addLineJump(1, 0);\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 3, Integer.MAX_VALUE);\n    c.addLineSwitch(4, 0, 1, 3, Integer.MAX_VALUE);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(0, c.getNumberOfCoveredBranches());\n    assertEquals(0.0, c.getBranchCoverageRate(), 0.0);\n    assertEquals(0.0, c.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.touchJump(1, 0, true, 1);\n    c.touchJump(1, 0, false, 1);\n    c.touchJump(2, 0, true, 1);\n    c.touchJump(2, 0, false, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(4, c.getNumberOfCoveredBranches());\n    assertEquals(0.33, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.33, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n    c.touchSwitch(3, 0, 0, 1);\n    c.touchSwitch(3, 0, 1, 1);\n    c.touchSwitch(4, 0, 2, 1);\n    c.touchSwitch(4, 0, -1, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(8, c.getNumberOfCoveredBranches());\n    assertEquals(0.66, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.66, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n}", "methodAfter": "@Test\npublic void testBranchCoverage() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(1.0, a.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, a.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.addLineJump(1, 0);\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 3, Integer.MAX_VALUE);\n    c.addLineSwitch(4, 0, 1, 3, Integer.MAX_VALUE);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(0, c.getNumberOfCoveredBranches());\n    assertEquals(0.0, c.getBranchCoverageRate(), 0.0);\n    assertEquals(0.0, c.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.touchJump(1, 0, true, 1);\n    c.touchJump(1, 0, false, 1);\n    c.touchJump(2, 0, true, 1);\n    c.touchJump(2, 0, false, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(4, c.getNumberOfCoveredBranches());\n    assertEquals(0.33, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.33, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n    c.touchSwitch(3, 0, 0, 1);\n    c.touchSwitch(3, 0, 1, 1);\n    c.touchSwitch(4, 0, 2, 1);\n    c.touchSwitch(4, 0, -1, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(8, c.getNumberOfCoveredBranches());\n    assertEquals(0.66, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.66, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n}"}, {"methodBefore": "public void testTouch() {\n    int line = 3;\n    assertFalse(a.isValidSourceLineNumber(line));\n    a.touch(line, 1);\n    assertTrue(a.isValidSourceLineNumber(line));\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(0, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(1, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertEquals(2, b.getLineCoverage(line).getHits());\n    assertTrue(b.isValidSourceLineNumber(line));\n}", "methodAfter": "@Test\npublic void testTouch() {\n    int line = 3;\n    assertFalse(a.isValidSourceLineNumber(line));\n    a.touch(line, 1);\n    assertTrue(a.isValidSourceLineNumber(line));\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(0, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(1, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertEquals(2, b.getLineCoverage(line).getHits());\n    assertTrue(b.isValidSourceLineNumber(line));\n}"}], [{"methodBefore": "public void generateCallCoberturaInitMethod(MethodVisitor mv, String className) {\n    mv.visitMethodInsn(INVOKESTATIC, className, COBERTURA_INIT_METHOD_NAME, \"()V\");\n}", "methodAfter": "public void generateCallCoberturaInitMethod(MethodVisitor mv, String className) {\n    mv.visitCode();\n    mv.visitMethodInsn(INVOKESTATIC, className, COBERTURA_INIT_METHOD_NAME, \"()V\");\n}"}, {"methodBefore": "public void generateCallCoberturaInitMethod(MethodVisitor mv, String className) {\n    mv.visitMethodInsn(INVOKESTATIC, className, COBERTURA_INIT_METHOD_NAME, \"()V\");\n}", "methodAfter": "public void generateCallCoberturaInitMethod(MethodVisitor mv, String className) {\n    mv.visitCode();\n    mv.visitMethodInsn(INVOKESTATIC, className, COBERTURA_INIT_METHOD_NAME, \"()V\");\n}"}], [{"methodBefore": "private boolean jj_3R_422() {\n    if (jj_3R_407()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_422() {\n    if (jj_3R_431()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_422() {\n    if (jj_3R_407()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_422() {\n    if (jj_3R_431()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_172() {\n    if (jj_3R_194()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_169() {\n    if (jj_3R_194()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_172() {\n    if (jj_3R_194()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_169() {\n    if (jj_3R_194()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_421() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_341()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_424() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_344()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_421() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_341()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_424() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_344()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_105() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(74)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(14)) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_109() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(75)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(15)) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_105() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(74)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(14)) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_109() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(75)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(15)) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_427() {\n    if (jj_3R_429()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_427() {\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_427() {\n    if (jj_3R_429()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_427() {\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_140() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_169()) {\n        jj_scanpos = xsp;\n        if (jj_3R_170()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_126() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_168()) {\n        jj_scanpos = xsp;\n        if (jj_3R_169()) {\n            jj_scanpos = xsp;\n            if (jj_3R_170()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_140() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_169()) {\n        jj_scanpos = xsp;\n        if (jj_3R_170()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_126() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_168()) {\n        jj_scanpos = xsp;\n        if (jj_3R_169()) {\n            jj_scanpos = xsp;\n            if (jj_3R_170()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "public final void TryStatement() throws ParseException {\n    jj_consume_token(TRY);\n    Block();\n    label_61 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case CATCH :\n                break;\n            default :\n                jj_la1[158] = jj_gen;\n                break label_61;\n        }\n        jj_consume_token(CATCH);\n        jj_consume_token(LPAREN);\n        FormalParameter();\n        jj_consume_token(RPAREN);\n        Block();\n        _ncss++;\n        Util.debug(\"_ncss++\");\n        _cyc++;\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case FINALLY :\n            jj_consume_token(FINALLY);\n            Block();\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[159] = jj_gen;\n    }\n}", "methodAfter": "public final void TryStatement() throws ParseException {\n    jj_consume_token(TRY);\n    TryWithResources();\n    Block();\n    label_62 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case CATCH :\n                break;\n            default :\n                jj_la1[159] = jj_gen;\n                break label_62;\n        }\n        jj_consume_token(CATCH);\n        jj_consume_token(LPAREN);\n        CatchParameter();\n        jj_consume_token(RPAREN);\n        Block();\n        _ncss++;\n        Util.debug(\"_ncss++\");\n        _cyc++;\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case FINALLY :\n            jj_consume_token(FINALLY);\n            Block();\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[160] = jj_gen;\n    }\n}"}, {"methodBefore": "public final void TryStatement() throws ParseException {\n    jj_consume_token(TRY);\n    Block();\n    label_61 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case CATCH :\n                break;\n            default :\n                jj_la1[158] = jj_gen;\n                break label_61;\n        }\n        jj_consume_token(CATCH);\n        jj_consume_token(LPAREN);\n        FormalParameter();\n        jj_consume_token(RPAREN);\n        Block();\n        _ncss++;\n        Util.debug(\"_ncss++\");\n        _cyc++;\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case FINALLY :\n            jj_consume_token(FINALLY);\n            Block();\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[159] = jj_gen;\n    }\n}", "methodAfter": "public final void TryStatement() throws ParseException {\n    jj_consume_token(TRY);\n    TryWithResources();\n    Block();\n    label_62 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case CATCH :\n                break;\n            default :\n                jj_la1[159] = jj_gen;\n                break label_62;\n        }\n        jj_consume_token(CATCH);\n        jj_consume_token(LPAREN);\n        CatchParameter();\n        jj_consume_token(RPAREN);\n        Block();\n        _ncss++;\n        Util.debug(\"_ncss++\");\n        _cyc++;\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case FINALLY :\n            jj_consume_token(FINALLY);\n            Block();\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[160] = jj_gen;\n    }\n}"}], [{"methodBefore": "public void tearDown() {\n    tmpDir = new File(pathToTestOutput);\n    File files[] = tmpDir.listFiles();\n    for (int i = 0; i < files.length; i++) {\n        files[i].delete();\n    }\n    tmpDir.delete();\n}", "methodAfter": "public void tearDown() {\n    tmpDir = new File(PATH_TO_TEST_OUTPUT);\n    File files[] = tmpDir.listFiles();\n    for (int i = 0; i < files.length; i++) {\n        files[i].delete();\n    }\n    tmpDir.delete();\n}"}, {"methodBefore": "public void setUp() {\n    tmpDir = new File(pathToTestOutput);\n    tmpDir.mkdirs();\n}", "methodAfter": "public void setUp() {\n    tmpDir = new File(PATH_TO_TEST_OUTPUT);\n    tmpDir.mkdirs();\n}"}], [{"methodBefore": "private boolean jj_3R_220() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_237()) {\n        jj_scanpos = xsp;\n        if (jj_3R_238()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_220() {\n    if (jj_3R_237()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_261()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_220() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_237()) {\n        jj_scanpos = xsp;\n        if (jj_3R_238()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_220() {\n    if (jj_3R_237()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_261()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintWriter out = null;\n    try {\n        out = IOUtil.getPrintWriter(file);\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        LOGGER.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classPackageName + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowsForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(generateHtmlizedJavaSource(sourceFileData));\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        LOGGER.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintWriter out = null;\n    try {\n        out = IOUtil.getPrintWriter(file);\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classPackageName + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowsForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(generateHtmlizedJavaSource(sourceFileData));\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintWriter out = null;\n    try {\n        out = IOUtil.getPrintWriter(file);\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generatePackageList() throws IOException {\n    File file = new File(destinationDir, \"frame-packages.html\");\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xml:lang=\\\"en\\\" lang=\\\"en\\\">\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onclick=\\'parent.sourceFileList.location.href=\\\"frame-sourcefiles.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        Iterator iter = projectData.getPackages().iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generatePackageList() throws IOException {\n    File file = new File(destinationDir, \"frame-packages.html\");\n    PrintWriter out = null;\n    try {\n        out = IOUtil.getPrintWriter(file);\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xml:lang=\\\"en\\\" lang=\\\"en\\\">\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onclick=\\'parent.sourceFileList.location.href=\\\"frame-sourcefiles.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        Iterator iter = projectData.getPackages().iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_392() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_395() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_392() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_395() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void ConstructorDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int oldSingle;\n    int oldMulti;\n    int jvdcLines = 0;\n    boolean bPublic = false;\n    Token myToken = null;\n    label_34 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[72] = jj_gen;\n                break label_34;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case PUBLIC :\n                    jj_consume_token(PUBLIC);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PROTECTED :\n                    jj_consume_token(PROTECTED);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PRIVATE :\n                    jj_consume_token(PRIVATE);\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                default :\n                    jj_la1[73] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            break;\n        default :\n            jj_la1[74] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[75] = jj_gen;\n    }\n    Identifier();\n    if (tmpToken == null) {\n        tmpToken = getToken(0);\n    }\n    _cyc = 1;\n    _sFunction = ((_sPackage + _sClass) + \".\") + getToken(0).image;\n    FormalParameters();\n    _sFunction += _sParameter;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[76] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    if (jj_2_18(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    if (jj_2_19(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            jvdc++;\n            if ((bPublic && _bPublic) || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                _jvdcLines += jvdcLines;\n                JavaParserTokenManager._iFormalComments += jvdcLines;\n            }\n            JavaParserTokenManager._iMultiComments -= jvdcLines;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            jvdcLines = 0;\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    label_35 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[77] = jj_gen;\n                break label_35;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.name = _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = jvdcLines;\n    functionMetrics.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n    functionMetrics.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}", "methodAfter": "public final void ConstructorDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int oldSingle;\n    int oldMulti;\n    int jvdcLines = 0;\n    boolean bPublic = false;\n    Token myToken = null;\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.firstLine = JavaParserTokenManager.nbligne;\n    label_34 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[72] = jj_gen;\n                break label_34;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case PUBLIC :\n                    jj_consume_token(PUBLIC);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PROTECTED :\n                    jj_consume_token(PROTECTED);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PRIVATE :\n                    jj_consume_token(PRIVATE);\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                default :\n                    jj_la1[73] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            break;\n        default :\n            jj_la1[74] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[75] = jj_gen;\n    }\n    Identifier();\n    if (tmpToken == null) {\n        tmpToken = getToken(0);\n    }\n    _cyc = 1;\n    _sFunction = ((_sPackage + _sClass) + \".\") + getToken(0).image;\n    FormalParameters();\n    _sFunction += _sParameter;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[76] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    if (jj_2_18(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    if (jj_2_19(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            jvdc++;\n            if ((bPublic && _bPublic) || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                _jvdcLines += jvdcLines;\n                JavaParserTokenManager._iFormalComments += jvdcLines;\n            }\n            JavaParserTokenManager._iMultiComments -= jvdcLines;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            jvdcLines = 0;\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    label_35 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[77] = jj_gen;\n                break label_35;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    functionMetrics.name = _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = jvdcLines;\n    functionMetrics.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n    functionMetrics.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}"}, {"methodBefore": "public final void ConstructorDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int oldSingle;\n    int oldMulti;\n    int jvdcLines = 0;\n    boolean bPublic = false;\n    Token myToken = null;\n    label_34 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[72] = jj_gen;\n                break label_34;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case PUBLIC :\n                    jj_consume_token(PUBLIC);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PROTECTED :\n                    jj_consume_token(PROTECTED);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PRIVATE :\n                    jj_consume_token(PRIVATE);\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                default :\n                    jj_la1[73] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            break;\n        default :\n            jj_la1[74] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[75] = jj_gen;\n    }\n    Identifier();\n    if (tmpToken == null) {\n        tmpToken = getToken(0);\n    }\n    _cyc = 1;\n    _sFunction = ((_sPackage + _sClass) + \".\") + getToken(0).image;\n    FormalParameters();\n    _sFunction += _sParameter;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[76] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    if (jj_2_18(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    if (jj_2_19(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            jvdc++;\n            if ((bPublic && _bPublic) || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                _jvdcLines += jvdcLines;\n                JavaParserTokenManager._iFormalComments += jvdcLines;\n            }\n            JavaParserTokenManager._iMultiComments -= jvdcLines;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            jvdcLines = 0;\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    label_35 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[77] = jj_gen;\n                break label_35;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.name = _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = jvdcLines;\n    functionMetrics.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n    functionMetrics.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}", "methodAfter": "public final void ConstructorDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int oldSingle;\n    int oldMulti;\n    int jvdcLines = 0;\n    boolean bPublic = false;\n    Token myToken = null;\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.firstLine = JavaParserTokenManager.nbligne;\n    label_34 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[72] = jj_gen;\n                break label_34;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case PUBLIC :\n                    jj_consume_token(PUBLIC);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PROTECTED :\n                    jj_consume_token(PROTECTED);\n                    bPublic = true;\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                case PRIVATE :\n                    jj_consume_token(PRIVATE);\n                    if (tmpToken == null) {\n                        tmpToken = getToken(0);\n                    }\n                    break;\n                default :\n                    jj_la1[73] = jj_gen;\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            break;\n        default :\n            jj_la1[74] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[75] = jj_gen;\n    }\n    Identifier();\n    if (tmpToken == null) {\n        tmpToken = getToken(0);\n    }\n    _cyc = 1;\n    _sFunction = ((_sPackage + _sClass) + \".\") + getToken(0).image;\n    FormalParameters();\n    _sFunction += _sParameter;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[76] = jj_gen;\n    }\n    jj_consume_token(LBRACE);\n    if (jj_2_18(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    if (jj_2_19(2147483647)) {\n        ExplicitConstructorInvocation();\n    } else {\n    }\n    while (tmpToken.specialToken != null) {\n        if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n            _javadocs++;\n            jvdc++;\n            if ((bPublic && _bPublic) || _bPrivate) {\n                Util.debug(\"_jvdc++\");\n                _jvdc++;\n                jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                _jvdcLines += jvdcLines;\n                JavaParserTokenManager._iFormalComments += jvdcLines;\n            }\n            JavaParserTokenManager._iMultiComments -= jvdcLines;\n            break;\n        } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n            jvdcLines = 0;\n            break;\n        }\n        tmpToken = tmpToken.specialToken;\n    } \n    oldSingle = JavaParserTokenManager._iSingleComments;\n    oldMulti = JavaParserTokenManager._iMultiComments;\n    label_35 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[77] = jj_gen;\n                break label_35;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    functionMetrics.name = _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = jvdcLines;\n    functionMetrics.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n    functionMetrics.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}"}], [{"methodBefore": "private void generateClassList(PackageData packageData) throws IOException {\n    String filename;\n    Collection classes;\n    if (packageData == null) {\n        filename = \"frame-classes.html\";\n        classes = projectData.getClasses();\n    } else {\n        filename = (\"frame-classes-\" + packageData.getName()) + \".html\";\n        classes = packageData.getChildren();\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<h5>Classes</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        Map sortedClassList = new TreeMap();\n        for (Iterator iter = classes.iterator(); iter.hasNext();) {\n            ClassData classData = ((ClassData) (iter.next()));\n            sortedClassList.put(classData.getBaseName(), classData);\n        }\n        for (Iterator iter = sortedClassList.values().iterator(); iter.hasNext();) {\n            ClassData classData = ((ClassData) (iter.next()));\n            out.println(\"<tr>\");\n            String percentCovered;\n            if (classData.getNumberOfValidLines() > 0) {\n                percentCovered = getPercentValue(classData.getLineCoverageRate());\n            } else {\n                percentCovered = \"N/A\";\n            }\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + classData.getName()) + \".html\\\">\") + classData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n            out.println(\"</tr>\");\n        }\n        out.println(\"</td>\");\n        out.println(\"</tr>\");\n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateClassList(PackageData packageData) throws IOException {\n    String filename;\n    Collection classes;\n    if (packageData == null) {\n        filename = \"frame-classes.html\";\n        classes = projectData.getClasses();\n    } else {\n        filename = (\"frame-classes-\" + packageData.getName()) + \".html\";\n        classes = packageData.getClasses();\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<h5>Classes</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        Map sortedClassList = new TreeMap();\n        for (Iterator iter = classes.iterator(); iter.hasNext();) {\n            ClassData classData = ((ClassData) (iter.next()));\n            sortedClassList.put(classData.getBaseName(), classData);\n        }\n        for (Iterator iter = sortedClassList.values().iterator(); iter.hasNext();) {\n            ClassData classData = ((ClassData) (iter.next()));\n            out.println(\"<tr>\");\n            String percentCovered;\n            if (classData.getNumberOfValidLines() > 0) {\n                percentCovered = getPercentValue(classData.getLineCoverageRate());\n            } else {\n                percentCovered = \"N/A\";\n            }\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + classData.getName()) + \".html\\\">\") + classData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n            out.println(\"</tr>\");\n        }\n        out.println(\"</td>\");\n        out.println(\"</tr>\");\n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(\"<thead>\");\n        out.println(\"<tr>\");\n        out.println(\"  <td class=\\\"heading\\\">Package</td>\");\n        out.println(\"  <td class=\\\"heading\\\"># Classes</td>\");\n        out.println(generateCommonTableColumns());\n        out.println(\"</tr>\");\n        out.println(\"</thead>\");\n        out.println(\"<tbody>\");\n        Collection packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getChildren();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"LocalizedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        out.println(\"</p>\");\n        Collection classes;\n        if (packageData == null) {\n            classes = new TreeSet();\n            if (projectData.getNumberOfClasses() > 0) {\n                iter = projectData.getClasses().iterator();\n                while (iter.hasNext()) {\n                    ClassData classData = ((ClassData) (iter.next()));\n                    if (classData.getPackageName() == null) {\n                        classes.add(classData);\n                    }\n                } \n            }\n        } else {\n            classes = packageData.getChildren();\n        }\n        if (classes.size() > 0) {\n            out.println(\"<p>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeaderForClasses());\n            out.println(\"<tbody>\");\n            iter = classes.iterator();\n            while (iter.hasNext()) {\n                ClassData classData = ((ClassData) (iter.next()));\n                out.println(generateTableRowForClass(classData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"LocalizedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n            out.println(\"</p>\");\n        }\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Report generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(\"<thead>\");\n        out.println(\"<tr>\");\n        out.println(\"  <td class=\\\"heading\\\">Package</td>\");\n        out.println(\"  <td class=\\\"heading\\\"># Classes</td>\");\n        out.println(generateCommonTableColumns());\n        out.println(\"</tr>\");\n        out.println(\"</thead>\");\n        out.println(\"<tbody>\");\n        Collection packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getChildren();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"LocalizedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        out.println(\"</p>\");\n        Collection classes;\n        if (packageData == null) {\n            classes = new TreeSet();\n            if (projectData.getNumberOfClasses() > 0) {\n                iter = projectData.getClasses().iterator();\n                while (iter.hasNext()) {\n                    ClassData classData = ((ClassData) (iter.next()));\n                    if (classData.getPackageName() == null) {\n                        classes.add(classData);\n                    }\n                } \n            }\n        } else {\n            classes = packageData.getClasses();\n        }\n        if (classes.size() > 0) {\n            out.println(\"<p>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeaderForClasses());\n            out.println(\"<tbody>\");\n            iter = classes.iterator();\n            while (iter.hasNext()) {\n                ClassData classData = ((ClassData) (iter.next()));\n                out.println(generateTableRowForClass(classData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"LocalizedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n            out.println(\"</p>\");\n        }\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Report generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "public final void InclusiveOrExpression() throws ParseException {\n    ExclusiveOrExpression();\n    label_42 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_OR :\n                break;\n            default :\n                jj_la1[95] = jj_gen;\n                break label_42;\n        }\n        jj_consume_token(BIT_OR);\n        ExclusiveOrExpression();\n    } \n}", "methodAfter": "public final void InclusiveOrExpression() throws ParseException {\n    ExclusiveOrExpression();\n    label_42 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_OR :\n                break;\n            default :\n                jj_la1[94] = jj_gen;\n                break label_42;\n        }\n        jj_consume_token(BIT_OR);\n        ExclusiveOrExpression();\n    } \n}"}, {"methodBefore": "public final void InclusiveOrExpression() throws ParseException {\n    ExclusiveOrExpression();\n    label_42 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_OR :\n                break;\n            default :\n                jj_la1[95] = jj_gen;\n                break label_42;\n        }\n        jj_consume_token(BIT_OR);\n        ExclusiveOrExpression();\n    } \n}", "methodAfter": "public final void InclusiveOrExpression() throws ParseException {\n    ExclusiveOrExpression();\n    label_42 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case BIT_OR :\n                break;\n            default :\n                jj_la1[94] = jj_gen;\n                break label_42;\n        }\n        jj_consume_token(BIT_OR);\n        ExclusiveOrExpression();\n    } \n}"}], [{"methodBefore": "public static void main(String[] args) {\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufferedReader = null;\n        try {\n            bufferedReader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufferedReader != null) {\n                try {\n                    bufferedReader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Instrument time: \" + (stopTime - startTime)) + \"ms\");\n}", "methodAfter": "public static void main(String[] args) {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufferedReader = null;\n        try {\n            bufferedReader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufferedReader != null) {\n                try {\n                    bufferedReader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Instrument time: \" + (stopTime - startTime)) + \"ms\");\n}"}, {"methodBefore": "public static void main(String[] args) throws Exception {\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufferedReader = null;\n        try {\n            bufferedReader = new BufferedReader(new FileReader(commandsFileName));\n            String line = null;\n            while ((line = bufferedReader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            LOGGER.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\", e);\n        } finally {\n            if (bufferedReader != null) {\n                try {\n                    bufferedReader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Report time: \" + (stopTime - startTime)) + \"ms\");\n}", "methodAfter": "public static void main(String[] args) throws Exception {\n    Header.print(System.out);\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufferedReader = null;\n        try {\n            bufferedReader = new BufferedReader(new FileReader(commandsFileName));\n            String line = null;\n            while ((line = bufferedReader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            LOGGER.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\", e);\n        } finally {\n            if (bufferedReader != null) {\n                try {\n                    bufferedReader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Report time: \" + (stopTime - startTime)) + \"ms\");\n}"}], [{"methodBefore": "protected void generateRegisterClass(MethodVisitor mv, String className) {\n    mv.visitLdcInsn(Type.getObjectType(className));\n    mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(TouchCollector.class), \"registerClass\", \"(Ljava/lang/Class;)V\");\n}", "methodAfter": "protected void generateRegisterClass(MethodVisitor mv, String className) {\n    mv.visitLdcInsn(className);\n    mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(TouchCollector.class), \"registerClass\", \"(Ljava/lang/String;)V\");\n}"}, {"methodBefore": "protected void generateRegisterClass(MethodVisitor mv, String className) {\n    mv.visitLdcInsn(Type.getObjectType(className));\n    mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(TouchCollector.class), \"registerClass\", \"(Ljava/lang/Class;)V\");\n}", "methodAfter": "protected void generateRegisterClass(MethodVisitor mv, String className) {\n    mv.visitLdcInsn(className);\n    mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(TouchCollector.class), \"registerClass\", \"(Ljava/lang/String;)V\");\n}"}], [{"methodBefore": "private boolean jj_3R_453() {\n    if (jj_3R_454()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_453() {\n    if (jj_3R_460()) {\n        return true;\n    }\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_453() {\n    if (jj_3R_454()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_453() {\n    if (jj_3R_460()) {\n        return true;\n    }\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_1() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_81()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(PACKAGE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_1() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_85()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(PACKAGE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_1() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_81()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(PACKAGE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_1() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_85()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(PACKAGE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_395() {\n    if (jj_3R_411()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_413() {\n    if (jj_3R_419()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_395() {\n    if (jj_3R_411()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_413() {\n    if (jj_3R_419()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void BooleanLiteral() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case TRUE :\n            jj_consume_token(TRUE);\n            break;\n        case FALSE :\n            jj_consume_token(FALSE);\n            break;\n        default :\n            jj_la1[128] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void BooleanLiteral() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case TRUE :\n            jj_consume_token(TRUE);\n            break;\n        case FALSE :\n            jj_consume_token(FALSE);\n            break;\n        default :\n            jj_la1[129] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void BooleanLiteral() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case TRUE :\n            jj_consume_token(TRUE);\n            break;\n        case FALSE :\n            jj_consume_token(FALSE);\n            break;\n        default :\n            jj_la1[128] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void BooleanLiteral() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case TRUE :\n            jj_consume_token(TRUE);\n            break;\n        case FALSE :\n            jj_consume_token(FALSE);\n            break;\n        default :\n            jj_la1[129] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_183() {\n    if (jj_3R_94()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_33()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_186() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_32()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_183() {\n    if (jj_3R_94()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_33()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_186() {\n    if (jj_3R_98()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_32()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "public static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}"}, {"methodBefore": "public static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}"}, {"methodBefore": "public static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}", "methodAfter": "@Test\npublic static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}"}, {"methodBefore": "public static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}"}], [{"methodBefore": "private boolean jj_3R_381() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_358() {\n    if (jj_3R_386()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_381() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_358() {\n    if (jj_3R_386()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void ArrayDimsAndInits() throws ParseException {\n    if (jj_2_42(2)) {\n        label_53 : while (true) {\n            jj_consume_token(LBRACKET);\n            Expression();\n            jj_consume_token(RBRACKET);\n            if (jj_2_40(2)) {\n            } else {\n                break label_53;\n            }\n        } \n        label_54 : while (true) {\n            if (jj_2_41(2)) {\n            } else {\n                break label_54;\n            }\n            jj_consume_token(LBRACKET);\n            jj_consume_token(RBRACKET);\n        } \n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                label_55 : while (true) {\n                    jj_consume_token(LBRACKET);\n                    jj_consume_token(RBRACKET);\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case LBRACKET :\n                            break;\n                        default :\n                            jj_la1[135] = jj_gen;\n                            break label_55;\n                    }\n                } \n                ArrayInitializer();\n                break;\n            default :\n                jj_la1[136] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void ArrayDimsAndInits() throws ParseException {\n    if (jj_2_41(2)) {\n        label_54 : while (true) {\n            jj_consume_token(LBRACKET);\n            Expression();\n            jj_consume_token(RBRACKET);\n            if (jj_2_39(2)) {\n            } else {\n                break label_54;\n            }\n        } \n        label_55 : while (true) {\n            if (jj_2_40(2)) {\n            } else {\n                break label_55;\n            }\n            jj_consume_token(LBRACKET);\n            jj_consume_token(RBRACKET);\n        } \n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                label_56 : while (true) {\n                    jj_consume_token(LBRACKET);\n                    jj_consume_token(RBRACKET);\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case LBRACKET :\n                            break;\n                        default :\n                            jj_la1[136] = jj_gen;\n                            break label_56;\n                    }\n                } \n                ArrayInitializer();\n                break;\n            default :\n                jj_la1[137] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}, {"methodBefore": "public final void ArrayDimsAndInits() throws ParseException {\n    if (jj_2_42(2)) {\n        label_53 : while (true) {\n            jj_consume_token(LBRACKET);\n            Expression();\n            jj_consume_token(RBRACKET);\n            if (jj_2_40(2)) {\n            } else {\n                break label_53;\n            }\n        } \n        label_54 : while (true) {\n            if (jj_2_41(2)) {\n            } else {\n                break label_54;\n            }\n            jj_consume_token(LBRACKET);\n            jj_consume_token(RBRACKET);\n        } \n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                label_55 : while (true) {\n                    jj_consume_token(LBRACKET);\n                    jj_consume_token(RBRACKET);\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case LBRACKET :\n                            break;\n                        default :\n                            jj_la1[135] = jj_gen;\n                            break label_55;\n                    }\n                } \n                ArrayInitializer();\n                break;\n            default :\n                jj_la1[136] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void ArrayDimsAndInits() throws ParseException {\n    if (jj_2_41(2)) {\n        label_54 : while (true) {\n            jj_consume_token(LBRACKET);\n            Expression();\n            jj_consume_token(RBRACKET);\n            if (jj_2_39(2)) {\n            } else {\n                break label_54;\n            }\n        } \n        label_55 : while (true) {\n            if (jj_2_40(2)) {\n            } else {\n                break label_55;\n            }\n            jj_consume_token(LBRACKET);\n            jj_consume_token(RBRACKET);\n        } \n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                label_56 : while (true) {\n                    jj_consume_token(LBRACKET);\n                    jj_consume_token(RBRACKET);\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case LBRACKET :\n                            break;\n                        default :\n                            jj_la1[136] = jj_gen;\n                            break label_56;\n                    }\n                } \n                ArrayInitializer();\n                break;\n            default :\n                jj_la1[137] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_305() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_316()) {\n        jj_scanpos = xsp;\n    }\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_317()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_318()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_305() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_294()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_305() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_316()) {\n        jj_scanpos = xsp;\n    }\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_317()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_318()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_305() {\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    if (jj_3R_294()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_425() {\n    if (jj_3R_308()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_425() {\n    if (jj_3R_410()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_425() {\n    if (jj_3R_308()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_425() {\n    if (jj_3R_410()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void AnnotationTypeMemberDeclaration() throws ParseException {\n    int modifiers;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case CLASS :\n        case DOUBLE :\n        case ENUM :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case INTERFACE :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            modifiers = Modifiers();\n            if (jj_2_51(2147483647)) {\n                Type();\n                jj_consume_token(IDENTIFIER);\n                jj_consume_token(LPAREN);\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case _DEFAULT :\n                        DefaultValue();\n                        break;\n                    default :\n                        jj_la1[169] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    case AT :\n                        AnnotationTypeDeclaration(modifiers);\n                        break;\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case SHORT :\n                    case IDENTIFIER :\n                        FieldDeclaration15(modifiers);\n                        break;\n                    default :\n                        jj_la1[170] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[171] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void AnnotationTypeMemberDeclaration() throws ParseException {\n    int modifiers;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case CLASS :\n        case DOUBLE :\n        case ENUM :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case INTERFACE :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            modifiers = Modifiers();\n            if (jj_2_50(2147483647)) {\n                Type();\n                jj_consume_token(IDENTIFIER);\n                jj_consume_token(LPAREN);\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case _DEFAULT :\n                        DefaultValue();\n                        break;\n                    default :\n                        jj_la1[174] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    case AT :\n                        AnnotationTypeDeclaration(modifiers);\n                        break;\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case SHORT :\n                    case IDENTIFIER :\n                        FieldDeclaration15(modifiers);\n                        break;\n                    default :\n                        jj_la1[175] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[176] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void AnnotationTypeMemberDeclaration() throws ParseException {\n    int modifiers;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case CLASS :\n        case DOUBLE :\n        case ENUM :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case INTERFACE :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            modifiers = Modifiers();\n            if (jj_2_51(2147483647)) {\n                Type();\n                jj_consume_token(IDENTIFIER);\n                jj_consume_token(LPAREN);\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case _DEFAULT :\n                        DefaultValue();\n                        break;\n                    default :\n                        jj_la1[169] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    case AT :\n                        AnnotationTypeDeclaration(modifiers);\n                        break;\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case SHORT :\n                    case IDENTIFIER :\n                        FieldDeclaration15(modifiers);\n                        break;\n                    default :\n                        jj_la1[170] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[171] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void AnnotationTypeMemberDeclaration() throws ParseException {\n    int modifiers;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case CLASS :\n        case DOUBLE :\n        case ENUM :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case INTERFACE :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            modifiers = Modifiers();\n            if (jj_2_50(2147483647)) {\n                Type();\n                jj_consume_token(IDENTIFIER);\n                jj_consume_token(LPAREN);\n                jj_consume_token(RPAREN);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case _DEFAULT :\n                        DefaultValue();\n                        break;\n                    default :\n                        jj_la1[174] = jj_gen;\n                }\n                jj_consume_token(SEMICOLON);\n                _ncss++;\n                Util.debug(\"_ncss++\");\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case CLASS :\n                    case INTERFACE :\n                        ClassOrInterfaceDeclaration(modifiers);\n                        break;\n                    case ENUM :\n                        EnumDeclaration(modifiers);\n                        break;\n                    case AT :\n                        AnnotationTypeDeclaration(modifiers);\n                        break;\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case DOUBLE :\n                    case FLOAT :\n                    case INT :\n                    case LONG :\n                    case SHORT :\n                    case IDENTIFIER :\n                        FieldDeclaration15(modifiers);\n                        break;\n                    default :\n                        jj_la1[175] = jj_gen;\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[176] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "public final void SwitchLabel() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CASE :\n            jj_consume_token(CASE);\n            Expression();\n            jj_consume_token(COLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            _localCases++;\n            _cyc++;\n            break;\n        case _DEFAULT :\n            jj_consume_token(_DEFAULT);\n            jj_consume_token(COLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[147] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void SwitchLabel() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CASE :\n            jj_consume_token(CASE);\n            Expression();\n            jj_consume_token(COLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            _localCases++;\n            _cyc++;\n            break;\n        case _DEFAULT :\n            jj_consume_token(_DEFAULT);\n            jj_consume_token(COLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[148] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void SwitchLabel() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CASE :\n            jj_consume_token(CASE);\n            Expression();\n            jj_consume_token(COLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            _localCases++;\n            _cyc++;\n            break;\n        case _DEFAULT :\n            jj_consume_token(_DEFAULT);\n            jj_consume_token(COLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[147] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void SwitchLabel() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case CASE :\n            jj_consume_token(CASE);\n            Expression();\n            jj_consume_token(COLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            _localCases++;\n            _cyc++;\n            break;\n        case _DEFAULT :\n            jj_consume_token(_DEFAULT);\n            jj_consume_token(COLON);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            break;\n        default :\n            jj_la1[148] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_85() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(52)) {\n        jj_scanpos = xsp;\n    }\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_89() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(53)) {\n        jj_scanpos = xsp;\n    }\n    if (jj_3R_145()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_85() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(52)) {\n        jj_scanpos = xsp;\n    }\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_89() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(53)) {\n        jj_scanpos = xsp;\n    }\n    if (jj_3R_145()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredLines() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}], [{"methodBefore": "private boolean jj_3R_294() {\n    if (jj_3R_304()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_294() {\n    if (jj_3R_304()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_316()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_294() {\n    if (jj_3R_304()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_294() {\n    if (jj_3R_304()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_316()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_312() {\n    if (jj_3R_108()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_26()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_315() {\n    if (jj_3R_111()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_25()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_312() {\n    if (jj_3R_108()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_26()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_315() {\n    if (jj_3R_111()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_25()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_197() {\n    if (jj_3R_212()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_191() {\n    if (jj_3R_200()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_197() {\n    if (jj_3R_212()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_191() {\n    if (jj_3R_200()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public Main(String[] args) throws MalformedPatternException {\n    int exitStatus = 0;\n    Header.print();\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    double branchCoverageRate = -1.0;\n    double lineCoverageRate = -1.0;\n    double packageBranchCoverageRate = -1.0;\n    double packageLineCoverageRate = -1.0;\n    double totalBranchCoverageRate = -1.0;\n    double totalLineCoverageRate = -1.0;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--branch\")) {\n            branchCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        } else if (args[i].equals(\"--datafile\")) {\n            dataFile = new File(args[++i]);\n        } else if (args[i].equals(\"--line\")) {\n            lineCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        } else if (args[i].equals(\"--regex\")) {\n            setMinimumCoverageRate(args[++i]);\n        } else if (args[i].equals(\"--packagebranch\")) {\n            packageBranchCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        } else if (args[i].equals(\"--packageline\")) {\n            packageLineCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        } else if (args[i].equals(\"--totalbranch\")) {\n            totalBranchCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        } else if (args[i].equals(\"--totalline\")) {\n            totalLineCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        }\n    }\n    ProjectData projectData = CoverageDataFileHandler.loadCoverageData(dataFile);\n    if (projectData == null) {\n        System.err.println(\"Error: Unable to read from data file \" + dataFile.getAbsolutePath());\n        System.exit(1);\n    }\n    if (((((((branchCoverageRate == (-1.0)) && (lineCoverageRate == (-1.0))) && (packageLineCoverageRate == (-1.0))) && (packageBranchCoverageRate == (-1.0))) && (totalLineCoverageRate == (-1.0))) && (totalBranchCoverageRate == (-1.0))) && (this.minimumCoverageRates.size() == 0)) {\n        branchCoverageRate = 0.5;\n        lineCoverageRate = 0.5;\n        packageBranchCoverageRate = 0.5;\n        packageLineCoverageRate = 0.5;\n        totalBranchCoverageRate = 0.5;\n        totalLineCoverageRate = 0.5;\n    } else {\n        if (branchCoverageRate == (-1.0)) {\n            branchCoverageRate = 0.0;\n        }\n        if (lineCoverageRate == (-1.0)) {\n            lineCoverageRate = 0.0;\n        }\n        if (packageLineCoverageRate == (-1.0)) {\n            packageLineCoverageRate = 0.0;\n        }\n        if (packageBranchCoverageRate == (-1.0)) {\n            packageBranchCoverageRate = 0.0;\n        }\n        if (totalLineCoverageRate == (-1.0)) {\n            totalLineCoverageRate = 0.0;\n        }\n        if (totalBranchCoverageRate == (-1.0)) {\n            totalBranchCoverageRate = 0.0;\n        }\n    }\n    this.minimumCoverageRate = new CoverageRate(lineCoverageRate, branchCoverageRate);\n    double totalLines = 0;\n    double totalLinesCovered = 0;\n    double totalBranches = 0;\n    double totalBranchesCovered = 0;\n    Iterator iter = projectData.getClasses().iterator();\n    while (iter.hasNext()) {\n        ClassData classData = ((ClassData) (iter.next()));\n        CoverageRate coverageRate = findMinimumCoverageRate(classData.getName());\n        if (totalBranchCoverageRate > 0.0) {\n            totalBranches += classData.getNumberOfValidBranches();\n            totalBranchesCovered += classData.getNumberOfCoveredBranches();\n        }\n        if (totalLineCoverageRate > 0.0) {\n            totalLines += classData.getNumberOfValidLines();\n            totalLinesCovered += classData.getNumberOfCoveredLines();\n        }\n        PackageCoverage packageCoverage = getPackageCoverage(classData.getPackageName());\n        if (packageBranchCoverageRate > 0.0) {\n            packageCoverage.addBranchCount(classData.getNumberOfValidBranches());\n            packageCoverage.addBranchCoverage(classData.getNumberOfCoveredBranches());\n        }\n        if (packageLineCoverageRate > 0.0) {\n            packageCoverage.addLineCount(classData.getNumberOfValidLines());\n            packageCoverage.addLineCoverage(classData.getNumberOfCoveredLines());\n        }\n        logger.debug((((((\"Class \" + classData.getName()) + \", line coverage rate: \") + percentage(classData.getLineCoverageRate())) + \"%, branch coverage rate: \") + percentage(classData.getBranchCoverageRate())) + \"%\");\n        if (classData.getBranchCoverageRate() < coverageRate.getBranchCoverageRate()) {\n            System.err.println(((((classData.getName() + \" failed check. Branch coverage rate of \") + percentage(classData.getBranchCoverageRate())) + \"% is below \") + percentage(coverageRate.getBranchCoverageRate())) + \"%\");\n            exitStatus |= 2;\n        }\n        if (classData.getLineCoverageRate() < coverageRate.getLineCoverageRate()) {\n            System.err.println(((((classData.getName() + \" failed check. Line coverage rate of \") + percentage(classData.getLineCoverageRate())) + \"% is below \") + percentage(coverageRate.getLineCoverageRate())) + \"%\");\n            exitStatus |= 4;\n        }\n    } \n    exitStatus |= checkPackageCoverageLevels(packageBranchCoverageRate, packageLineCoverageRate);\n    if ((totalBranches > 0) && (totalBranchCoverageRate > (totalBranchesCovered / totalBranches))) {\n        System.err.println(((((\"Project failed check. \" + \"Total branch coverage rate of \") + percentage(totalBranchesCovered / totalBranches)) + \"% is below \") + percentage(totalBranchCoverageRate)) + \"%\");\n        exitStatus |= 8;\n    }\n    if ((totalLines > 0) && (totalLineCoverageRate > (totalLinesCovered / totalLines))) {\n        System.err.println(((((\"Project failed check. \" + \"Total line coverage rate of \") + percentage(totalLinesCovered / totalLines)) + \"% is below \") + percentage(totalLineCoverageRate)) + \"%\");\n        exitStatus |= 16;\n    }\n    System.exit(exitStatus);\n}", "methodAfter": "public Main(String[] args) throws MalformedPatternException {\n    int exitStatus = 0;\n    Header.print(System.out);\n    File dataFile = CoverageDataFileHandler.getDefaultDataFile();\n    double branchCoverageRate = -1.0;\n    double lineCoverageRate = -1.0;\n    double packageBranchCoverageRate = -1.0;\n    double packageLineCoverageRate = -1.0;\n    double totalBranchCoverageRate = -1.0;\n    double totalLineCoverageRate = -1.0;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--branch\")) {\n            branchCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        } else if (args[i].equals(\"--datafile\")) {\n            dataFile = new File(args[++i]);\n        } else if (args[i].equals(\"--line\")) {\n            lineCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        } else if (args[i].equals(\"--regex\")) {\n            setMinimumCoverageRate(args[++i]);\n        } else if (args[i].equals(\"--packagebranch\")) {\n            packageBranchCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        } else if (args[i].equals(\"--packageline\")) {\n            packageLineCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        } else if (args[i].equals(\"--totalbranch\")) {\n            totalBranchCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        } else if (args[i].equals(\"--totalline\")) {\n            totalLineCoverageRate = inRangeAndDivideByOneHundred(args[++i]);\n        }\n    }\n    ProjectData projectData = CoverageDataFileHandler.loadCoverageData(dataFile);\n    if (projectData == null) {\n        System.err.println(\"Error: Unable to read from data file \" + dataFile.getAbsolutePath());\n        System.exit(1);\n    }\n    if (((((((branchCoverageRate == (-1.0)) && (lineCoverageRate == (-1.0))) && (packageLineCoverageRate == (-1.0))) && (packageBranchCoverageRate == (-1.0))) && (totalLineCoverageRate == (-1.0))) && (totalBranchCoverageRate == (-1.0))) && (this.minimumCoverageRates.size() == 0)) {\n        branchCoverageRate = 0.5;\n        lineCoverageRate = 0.5;\n        packageBranchCoverageRate = 0.5;\n        packageLineCoverageRate = 0.5;\n        totalBranchCoverageRate = 0.5;\n        totalLineCoverageRate = 0.5;\n    } else {\n        if (branchCoverageRate == (-1.0)) {\n            branchCoverageRate = 0.0;\n        }\n        if (lineCoverageRate == (-1.0)) {\n            lineCoverageRate = 0.0;\n        }\n        if (packageLineCoverageRate == (-1.0)) {\n            packageLineCoverageRate = 0.0;\n        }\n        if (packageBranchCoverageRate == (-1.0)) {\n            packageBranchCoverageRate = 0.0;\n        }\n        if (totalLineCoverageRate == (-1.0)) {\n            totalLineCoverageRate = 0.0;\n        }\n        if (totalBranchCoverageRate == (-1.0)) {\n            totalBranchCoverageRate = 0.0;\n        }\n    }\n    this.minimumCoverageRate = new CoverageRate(lineCoverageRate, branchCoverageRate);\n    double totalLines = 0;\n    double totalLinesCovered = 0;\n    double totalBranches = 0;\n    double totalBranchesCovered = 0;\n    Iterator iter = projectData.getClasses().iterator();\n    while (iter.hasNext()) {\n        ClassData classData = ((ClassData) (iter.next()));\n        CoverageRate coverageRate = findMinimumCoverageRate(classData.getName());\n        if (totalBranchCoverageRate > 0.0) {\n            totalBranches += classData.getNumberOfValidBranches();\n            totalBranchesCovered += classData.getNumberOfCoveredBranches();\n        }\n        if (totalLineCoverageRate > 0.0) {\n            totalLines += classData.getNumberOfValidLines();\n            totalLinesCovered += classData.getNumberOfCoveredLines();\n        }\n        PackageCoverage packageCoverage = getPackageCoverage(classData.getPackageName());\n        if (packageBranchCoverageRate > 0.0) {\n            packageCoverage.addBranchCount(classData.getNumberOfValidBranches());\n            packageCoverage.addBranchCoverage(classData.getNumberOfCoveredBranches());\n        }\n        if (packageLineCoverageRate > 0.0) {\n            packageCoverage.addLineCount(classData.getNumberOfValidLines());\n            packageCoverage.addLineCoverage(classData.getNumberOfCoveredLines());\n        }\n        logger.debug((((((\"Class \" + classData.getName()) + \", line coverage rate: \") + percentage(classData.getLineCoverageRate())) + \"%, branch coverage rate: \") + percentage(classData.getBranchCoverageRate())) + \"%\");\n        if (classData.getBranchCoverageRate() < coverageRate.getBranchCoverageRate()) {\n            System.err.println(((((classData.getName() + \" failed check. Branch coverage rate of \") + percentage(classData.getBranchCoverageRate())) + \"% is below \") + percentage(coverageRate.getBranchCoverageRate())) + \"%\");\n            exitStatus |= 2;\n        }\n        if (classData.getLineCoverageRate() < coverageRate.getLineCoverageRate()) {\n            System.err.println(((((classData.getName() + \" failed check. Line coverage rate of \") + percentage(classData.getLineCoverageRate())) + \"% is below \") + percentage(coverageRate.getLineCoverageRate())) + \"%\");\n            exitStatus |= 4;\n        }\n    } \n    exitStatus |= checkPackageCoverageLevels(packageBranchCoverageRate, packageLineCoverageRate);\n    if ((totalBranches > 0) && (totalBranchCoverageRate > (totalBranchesCovered / totalBranches))) {\n        System.err.println(((((\"Project failed check. \" + \"Total branch coverage rate of \") + percentage(totalBranchesCovered / totalBranches)) + \"% is below \") + percentage(totalBranchCoverageRate)) + \"%\");\n        exitStatus |= 8;\n    }\n    if ((totalLines > 0) && (totalLineCoverageRate > (totalLinesCovered / totalLines))) {\n        System.err.println(((((\"Project failed check. \" + \"Total line coverage rate of \") + percentage(totalLinesCovered / totalLines)) + \"% is below \") + percentage(totalLineCoverageRate)) + \"%\");\n        exitStatus |= 16;\n    }\n    System.exit(exitStatus);\n}"}, {"methodBefore": "public static void main(String[] args) {\n    Header.print();\n    try {\n        args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    } catch (Exception ex) {\n        System.err.println(\"Error: Cannot process arguments: \" + ex.getMessage());\n        System.exit(1);\n    }\n    new Main(args);\n}", "methodAfter": "public static void main(String[] args) {\n    Header.print(System.out);\n    try {\n        args = CommandLineBuilder.preprocessCommandLineArguments(args);\n    } catch (Exception ex) {\n        System.err.println(\"Error: Cannot process arguments: \" + ex.getMessage());\n        System.exit(1);\n    }\n    new Main(args);\n}"}], [{"methodBefore": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidLines() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getBranchCoverageRate() {\n    synchronizeState();\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}, {"methodBefore": "public int getNumberOfCoveredLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredLines() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getLineCoverageRate() {\n    synchronizeState();\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}, {"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}], [{"methodBefore": "private boolean jj_3R_319() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_319() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_320() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_320() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_319() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_319() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_320() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_320() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void visitTableSwitchInsn(int min, int max, Label dflt, Label[] labels) {\n    super.visitTableSwitchInsn(min, max, dflt, labels);\n    if (currentLine != 0) {\n        switchTargetLabels.put(dflt, new SwitchHolder(currentLine, currentSwitch, -1));\n        for (int i = labels.length - 1; i >= 0; i--) {\n            switchTargetLabels.put(labels[i], new SwitchHolder(currentLine, currentSwitch, i));\n        }\n        classData.addLineSwitch(currentLine, currentSwitch++, min, max);\n    }\n}", "methodAfter": "public void visitTableSwitchInsn(int min, int max, Label dflt, Label[] labels) {\n    super.visitTableSwitchInsn(min, max, dflt, labels);\n    if (currentLine != 0) {\n        switchTargetLabels.put(dflt, new SwitchHolder(currentLine, currentSwitch, -1));\n        for (int i = labels.length - 1; i >= 0; i--) {\n            switchTargetLabels.put(labels[i], new SwitchHolder(currentLine, currentSwitch, i));\n        }\n        classData.addLineSwitch(currentLine, currentSwitch++, min, max);\n    }\n    markNonTrivial();\n}"}, {"methodBefore": "public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\n    super.visitLookupSwitchInsn(dflt, keys, labels);\n    if (currentLine != 0) {\n        switchTargetLabels.put(dflt, new SwitchHolder(currentLine, currentSwitch, -1));\n        for (int i = labels.length - 1; i >= 0; i--) {\n            switchTargetLabels.put(labels[i], new SwitchHolder(currentLine, currentSwitch, i));\n        }\n        classData.addLineSwitch(currentLine, currentSwitch++, keys);\n    }\n}", "methodAfter": "public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\n    super.visitLookupSwitchInsn(dflt, keys, labels);\n    if (currentLine != 0) {\n        switchTargetLabels.put(dflt, new SwitchHolder(currentLine, currentSwitch, -1));\n        for (int i = labels.length - 1; i >= 0; i--) {\n            switchTargetLabels.put(labels[i], new SwitchHolder(currentLine, currentSwitch, i));\n        }\n        classData.addLineSwitch(currentLine, currentSwitch++, keys);\n    }\n    markNonTrivial();\n}"}], [{"methodBefore": "private boolean jj_3R_122() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_125() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_122() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_125() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_253() {\n    if (jj_3R_273()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_251() {\n    if (jj_3R_273()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_253() {\n    if (jj_3R_273()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_251() {\n    if (jj_3R_273()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void generateOverviews() throws IOException {\n    generateOverview(null);\n    Iterator iter = projectData.getChildren().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateOverview(packageData);\n    } \n}", "methodAfter": "private void generateOverviews() throws IOException {\n    generateOverview(null);\n    Iterator iter = projectData.getPackages().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateOverview(packageData);\n    } \n}"}, {"methodBefore": "private void generateSourceFileLists() throws IOException {\n    generateSourceFileList(null);\n    Iterator iter = projectData.getChildren().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateSourceFileList(packageData);\n    } \n}", "methodAfter": "private void generateSourceFileLists() throws IOException {\n    generateSourceFileList(null);\n    Iterator iter = projectData.getPackages().iterator();\n    while (iter.hasNext()) {\n        PackageData packageData = ((PackageData) (iter.next()));\n        generateSourceFileList(packageData);\n    } \n}"}, {"methodBefore": "private void dumpPackages(ProjectData projectData) {\n    println(\"<packages>\");\n    increaseIndentation();\n    Iterator it = projectData.getChildren().iterator();\n    while (it.hasNext()) {\n        dumpPackage(((PackageData) (it.next())));\n    } \n    decreaseIndentation();\n    println(\"</packages>\");\n}", "methodAfter": "private void dumpPackages(ProjectData projectData) {\n    println(\"<packages>\");\n    increaseIndentation();\n    Iterator it = projectData.getPackages().iterator();\n    while (it.hasNext()) {\n        dumpPackage(((PackageData) (it.next())));\n    } \n    decreaseIndentation();\n    println(\"</packages>\");\n}"}], [{"methodBefore": "public final void EqualityExpression() throws ParseException {\n    InstanceOfExpression();\n    label_45 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case EQ :\n            case NE :\n                break;\n            default :\n                jj_la1[98] = jj_gen;\n                break label_45;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case EQ :\n                jj_consume_token(EQ);\n                break;\n            case NE :\n                jj_consume_token(NE);\n                break;\n            default :\n                jj_la1[99] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        InstanceOfExpression();\n    } \n}", "methodAfter": "public final void EqualityExpression() throws ParseException {\n    AssigmentExpression();\n    label_45 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case EQ :\n            case NE :\n                break;\n            default :\n                jj_la1[97] = jj_gen;\n                break label_45;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case EQ :\n                jj_consume_token(EQ);\n                break;\n            case NE :\n                jj_consume_token(NE);\n                break;\n            default :\n                jj_la1[98] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        AssigmentExpression();\n    } \n}"}, {"methodBefore": "public final void EqualityExpression() throws ParseException {\n    InstanceOfExpression();\n    label_45 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case EQ :\n            case NE :\n                break;\n            default :\n                jj_la1[98] = jj_gen;\n                break label_45;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case EQ :\n                jj_consume_token(EQ);\n                break;\n            case NE :\n                jj_consume_token(NE);\n                break;\n            default :\n                jj_la1[99] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        InstanceOfExpression();\n    } \n}", "methodAfter": "public final void EqualityExpression() throws ParseException {\n    AssigmentExpression();\n    label_45 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case EQ :\n            case NE :\n                break;\n            default :\n                jj_la1[97] = jj_gen;\n                break label_45;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case EQ :\n                jj_consume_token(EQ);\n                break;\n            case NE :\n                jj_consume_token(NE);\n                break;\n            default :\n                jj_la1[98] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        AssigmentExpression();\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_236() {\n    if (jj_scan_token(SC_OR)) {\n        return true;\n    }\n    if (jj_3R_218()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_221() {\n    if (jj_scan_token(SC_OR)) {\n        return true;\n    }\n    if (jj_3R_207()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_236() {\n    if (jj_scan_token(SC_OR)) {\n        return true;\n    }\n    if (jj_3R_218()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_221() {\n    if (jj_scan_token(SC_OR)) {\n        return true;\n    }\n    if (jj_3R_207()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void LocalVariableDeclaration() throws ParseException {\n    Modifiers();\n    Type();\n    VariableDeclarator();\n    label_57 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[141] = jj_gen;\n                break label_57;\n        }\n        jj_consume_token(COMMA);\n        VariableDeclarator();\n    } \n}", "methodAfter": "public final void LocalVariableDeclaration() throws ParseException {\n    Modifiers();\n    Type();\n    VariableDeclarator();\n    label_58 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[142] = jj_gen;\n                break label_58;\n        }\n        jj_consume_token(COMMA);\n        VariableDeclarator();\n    } \n}"}, {"methodBefore": "public final void LocalVariableDeclaration() throws ParseException {\n    Modifiers();\n    Type();\n    VariableDeclarator();\n    label_57 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[141] = jj_gen;\n                break label_57;\n        }\n        jj_consume_token(COMMA);\n        VariableDeclarator();\n    } \n}", "methodAfter": "public final void LocalVariableDeclaration() throws ParseException {\n    Modifiers();\n    Type();\n    VariableDeclarator();\n    label_58 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[142] = jj_gen;\n                break label_58;\n        }\n        jj_consume_token(COMMA);\n        VariableDeclarator();\n    } \n}"}], [{"methodBefore": "public final void ImplementsList(boolean isInterface) throws ParseException {\n    jj_consume_token(IMPLEMENTS);\n    ClassOrInterfaceType();\n    label_69 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[180] = jj_gen;\n                break label_69;\n        }\n        jj_consume_token(COMMA);\n        ClassOrInterfaceType();\n    } \n    if (isInterface) {\n        if (true) {\n            throw new ParseException(\"An interface cannot implement other interfaces\");\n        }\n    }\n}", "methodAfter": "public final void ImplementsList(boolean isInterface) throws ParseException {\n    jj_consume_token(IMPLEMENTS);\n    ClassOrInterfaceType();\n    label_72 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[185] = jj_gen;\n                break label_72;\n        }\n        jj_consume_token(COMMA);\n        ClassOrInterfaceType();\n    } \n    if (isInterface) {\n        if (true) {\n            throw new ParseException(\"An interface cannot implement other interfaces\");\n        }\n    }\n}"}, {"methodBefore": "public final void ImplementsList(boolean isInterface) throws ParseException {\n    jj_consume_token(IMPLEMENTS);\n    ClassOrInterfaceType();\n    label_69 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[180] = jj_gen;\n                break label_69;\n        }\n        jj_consume_token(COMMA);\n        ClassOrInterfaceType();\n    } \n    if (isInterface) {\n        if (true) {\n            throw new ParseException(\"An interface cannot implement other interfaces\");\n        }\n    }\n}", "methodAfter": "public final void ImplementsList(boolean isInterface) throws ParseException {\n    jj_consume_token(IMPLEMENTS);\n    ClassOrInterfaceType();\n    label_72 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[185] = jj_gen;\n                break label_72;\n        }\n        jj_consume_token(COMMA);\n        ClassOrInterfaceType();\n    } \n    if (isInterface) {\n        if (true) {\n            throw new ParseException(\"An interface cannot implement other interfaces\");\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_342() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_341()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_345() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_344()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_342() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_341()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_345() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_344()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void testExistingDestinationFile() throws IOException {\n    greenProject.addClassData(firstClass);\n    redProject.addClassData(secondClass);\n    File greenFile = createTempSerFile();\n    File dataFile = createTempSerFile();\n    CoverageDataFileHandler.saveCoverageData(greenProject, greenFile);\n    CoverageDataFileHandler.saveCoverageData(redProject, dataFile);\n    String[] args = new String[]{ \"--datafile\", dataFile.getAbsolutePath(), greenFile.getAbsolutePath() };\n    Main.main(args);\n    ProjectData merged = CoverageDataFileHandler.loadCoverageData(dataFile);\n    assertEquals(2, merged.getNumberOfClasses());\n    assertNotNull(merged.getClassData(\"test.First\"));\n    assertNotNull(merged.getClassData(\"test.Second\"));\n}", "methodAfter": "public void testExistingDestinationFile() throws IOException {\n    greenProject.addClassData(firstClass);\n    redProject.addClassData(secondClass);\n    File greenFile = createTempSerFile();\n    File dataFile = createTempSerFile();\n    CoverageDataFileHandler.saveCoverageData(greenProject, greenFile);\n    CoverageDataFileHandler.saveCoverageData(redProject, dataFile);\n    String[] args = new String[]{ \"--datafile\", dataFile.getAbsolutePath(), greenFile.getAbsolutePath() };\n    MergeMain.main(args);\n    ProjectData merged = CoverageDataFileHandler.loadCoverageData(dataFile);\n    assertEquals(2, merged.getNumberOfClasses());\n    assertNotNull(merged.getClassData(\"test.First\"));\n    assertNotNull(merged.getClassData(\"test.Second\"));\n}"}, {"methodBefore": "public void testBaseDir() throws IOException {\n    greenProject.addClassData(firstClass);\n    redProject.addClassData(seventhClass);\n    blueProject.addClassData(secondClass);\n    File greenFile = createTempSerFile();\n    File redFile = createTempSerFile();\n    File blueFile = createTempSerFile();\n    File dataFile = createTempSerFile();\n    dataFile.delete();\n    CoverageDataFileHandler.saveCoverageData(greenProject, greenFile);\n    CoverageDataFileHandler.saveCoverageData(redProject, redFile);\n    CoverageDataFileHandler.saveCoverageData(blueProject, blueFile);\n    String[] args = new String[]{ \"--datafile\", dataFile.getAbsolutePath(), greenFile.getAbsolutePath(), \"--basedir\", redFile.getParent(), redFile.getName(), blueFile.getName() };\n    Main.main(args);\n    ProjectData merged = CoverageDataFileHandler.loadCoverageData(dataFile);\n    assertEquals(3, merged.getNumberOfClasses());\n    assertNotNull(merged.getClassData(\"test.First\"));\n    assertNotNull(merged.getClassData(\"test.Second\"));\n    assertNotNull(merged.getClassData(\"Seventh\"));\n}", "methodAfter": "public void testBaseDir() throws IOException {\n    greenProject.addClassData(firstClass);\n    redProject.addClassData(seventhClass);\n    blueProject.addClassData(secondClass);\n    File greenFile = createTempSerFile();\n    File redFile = createTempSerFile();\n    File blueFile = createTempSerFile();\n    File dataFile = createTempSerFile();\n    dataFile.delete();\n    CoverageDataFileHandler.saveCoverageData(greenProject, greenFile);\n    CoverageDataFileHandler.saveCoverageData(redProject, redFile);\n    CoverageDataFileHandler.saveCoverageData(blueProject, blueFile);\n    String[] args = new String[]{ \"--datafile\", dataFile.getAbsolutePath(), greenFile.getAbsolutePath(), \"--basedir\", redFile.getParent(), redFile.getName(), blueFile.getName() };\n    MergeMain.main(args);\n    ProjectData merged = CoverageDataFileHandler.loadCoverageData(dataFile);\n    assertEquals(3, merged.getNumberOfClasses());\n    assertNotNull(merged.getClassData(\"test.First\"));\n    assertNotNull(merged.getClassData(\"test.Second\"));\n    assertNotNull(merged.getClassData(\"Seventh\"));\n}"}, {"methodBefore": "public void testNewDestinationFile() throws IOException {\n    greenProject.addClassData(firstClass);\n    redProject.addClassData(secondClass);\n    redProject.addClassData(seventhClass);\n    File greenFile = createTempSerFile();\n    File redFile = createTempSerFile();\n    File dataFile = createTempSerFile();\n    CoverageDataFileHandler.saveCoverageData(greenProject, greenFile);\n    CoverageDataFileHandler.saveCoverageData(redProject, redFile);\n    String[] args = new String[]{ \"--datafile\", dataFile.getAbsolutePath(), greenFile.getAbsolutePath(), redFile.getAbsolutePath() };\n    Main.main(args);\n    ProjectData merged = CoverageDataFileHandler.loadCoverageData(dataFile);\n    assertEquals(3, merged.getNumberOfClasses());\n    assertNotNull(merged.getClassData(\"test.First\"));\n    assertNotNull(merged.getClassData(\"test.Second\"));\n    assertNotNull(merged.getClassData(\"Seventh\"));\n    assertNull(merged.getClassData(\"test.Third\"));\n}", "methodAfter": "public void testNewDestinationFile() throws IOException {\n    greenProject.addClassData(firstClass);\n    redProject.addClassData(secondClass);\n    redProject.addClassData(seventhClass);\n    File greenFile = createTempSerFile();\n    File redFile = createTempSerFile();\n    File dataFile = createTempSerFile();\n    CoverageDataFileHandler.saveCoverageData(greenProject, greenFile);\n    CoverageDataFileHandler.saveCoverageData(redProject, redFile);\n    String[] args = new String[]{ \"--datafile\", dataFile.getAbsolutePath(), greenFile.getAbsolutePath(), redFile.getAbsolutePath() };\n    MergeMain.main(args);\n    ProjectData merged = CoverageDataFileHandler.loadCoverageData(dataFile);\n    assertEquals(3, merged.getNumberOfClasses());\n    assertNotNull(merged.getClassData(\"test.First\"));\n    assertNotNull(merged.getClassData(\"test.Second\"));\n    assertNotNull(merged.getClassData(\"Seventh\"));\n    assertNull(merged.getClassData(\"test.Third\"));\n}"}], [{"methodBefore": "private boolean jj_3R_353() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_356() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_353() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_356() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void testHashCode() {\n    assertEquals(a.hashCode(), a.hashCode());\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 });\n    assertEquals(a.hashCode(), aPrime.hashCode());\n}", "methodAfter": "public void testHashCode() {\n    assertEquals(a.hashCode(), a.hashCode());\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 }, Integer.MAX_VALUE);\n    assertEquals(a.hashCode(), aPrime.hashCode());\n}"}, {"methodBefore": "public void testEquals() {\n    assertFalse(a.equals(null));\n    assertFalse(a.equals(Integer.valueOf(4)));\n    assertTrue(a.equals(a));\n    assertFalse(a.equals(b));\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 });\n    assertTrue(a.equals(aPrime));\n}", "methodAfter": "public void testEquals() {\n    assertFalse(a.equals(null));\n    assertFalse(a.equals(Integer.valueOf(4)));\n    assertTrue(a.equals(a));\n    assertFalse(a.equals(b));\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 }, Integer.MAX_VALUE);\n    assertTrue(a.equals(aPrime));\n}"}, {"methodBefore": "private static void getSwitchDataIteratively(LineData data) {\n    for (int i = 0; i < 2000; i++) {\n        Thread.yield();\n        data.getSwitchData(i, new SwitchData(1));\n    }\n}", "methodAfter": "private static void getSwitchDataIteratively(LineData data) {\n    for (int i = 0; i < 2000; i++) {\n        Thread.yield();\n        data.getSwitchData(i, new SwitchData(1, Integer.MAX_VALUE));\n    }\n}"}], [{"methodBefore": "public final void BlockStatement() throws ParseException {\n    if (jj_2_45(2147483647)) {\n        LocalVariableDeclaration();\n        jj_consume_token(SEMICOLON);\n        _ncss++;\n        Util.debug(\"_ncss++\");\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case RETURN :\n            case SHORT :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case INCR :\n            case DECR :\n                Statement();\n                break;\n            case ABSTRACT :\n            case CLASS :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case TRANSIENT :\n            case VOLATILE :\n            case AT :\n                UnmodifiedClassDeclaration();\n                break;\n            case INTERFACE :\n                UnmodifiedInterfaceDeclaration();\n                break;\n            default :\n                jj_la1[140] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void BlockStatement() throws ParseException {\n    if (jj_2_44(2147483647)) {\n        LocalVariableDeclaration();\n        jj_consume_token(SEMICOLON);\n        _ncss++;\n        Util.debug(\"_ncss++\");\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case RETURN :\n            case SHORT :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case INCR :\n            case DECR :\n                Statement();\n                break;\n            case ABSTRACT :\n            case CLASS :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case TRANSIENT :\n            case VOLATILE :\n            case AT :\n                UnmodifiedClassDeclaration();\n                break;\n            case INTERFACE :\n                UnmodifiedInterfaceDeclaration();\n                break;\n            default :\n                jj_la1[141] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}, {"methodBefore": "public final void BlockStatement() throws ParseException {\n    if (jj_2_45(2147483647)) {\n        LocalVariableDeclaration();\n        jj_consume_token(SEMICOLON);\n        _ncss++;\n        Util.debug(\"_ncss++\");\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case RETURN :\n            case SHORT :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case INCR :\n            case DECR :\n                Statement();\n                break;\n            case ABSTRACT :\n            case CLASS :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case TRANSIENT :\n            case VOLATILE :\n            case AT :\n                UnmodifiedClassDeclaration();\n                break;\n            case INTERFACE :\n                UnmodifiedInterfaceDeclaration();\n                break;\n            default :\n                jj_la1[140] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void BlockStatement() throws ParseException {\n    if (jj_2_44(2147483647)) {\n        LocalVariableDeclaration();\n        jj_consume_token(SEMICOLON);\n        _ncss++;\n        Util.debug(\"_ncss++\");\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case LONG :\n            case NEW :\n            case NULL :\n            case RETURN :\n            case SHORT :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case INCR :\n            case DECR :\n                Statement();\n                break;\n            case ABSTRACT :\n            case CLASS :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case TRANSIENT :\n            case VOLATILE :\n            case AT :\n                UnmodifiedClassDeclaration();\n                break;\n            case INTERFACE :\n                UnmodifiedInterfaceDeclaration();\n                break;\n            default :\n                jj_la1[141] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_88() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_402() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_88() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_402() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void Arguments() throws ParseException {\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            ArgumentList();\n            break;\n        default :\n            jj_la1[129] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}", "methodAfter": "public final void Arguments() throws ParseException {\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            ArgumentList();\n            break;\n        default :\n            jj_la1[130] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}"}, {"methodBefore": "public final void Arguments() throws ParseException {\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            ArgumentList();\n            break;\n        default :\n            jj_la1[129] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}", "methodAfter": "public final void Arguments() throws ParseException {\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n        case BANG :\n        case TILDE :\n        case INCR :\n        case DECR :\n        case PLUS :\n        case MINUS :\n            ArgumentList();\n            break;\n        default :\n            jj_la1[130] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}"}], [{"methodBefore": "private boolean jj_3_9() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_9() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_9() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_9() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_62() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_60() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_62() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_60() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_101() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_105() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_101() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_105() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_187() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_124() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_187() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_124() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_358() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_385()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_361() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_388()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_358() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_385()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_361() {\n    if (jj_scan_token(SEMICOLON)) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_388()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_252() {\n    if (jj_3R_272()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_250() {\n    if (jj_3R_272()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_252() {\n    if (jj_3R_272()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_250() {\n    if (jj_3R_272()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public List<TouchPointDescriptor> getTouchPointsInLineOrder() {\n    LinkedList<TouchPointDescriptor> res = new LinkedList<TouchPointDescriptor>();\n    for (List<TouchPointDescriptor> tpd : currentLine2touchPoints.values()) {\n        for (TouchPointDescriptor t : tpd) {\n            if (tpd instanceof LineTouchPointDescriptor) {\n                res.add(t);\n            }\n        }\n        for (TouchPointDescriptor t : tpd) {\n            if (!(tpd instanceof LineTouchPointDescriptor)) {\n                res.add(t);\n            }\n        }\n    }\n    return res;\n}", "methodAfter": "public List<TouchPointDescriptor> getTouchPointsInLineOrder() {\n    LinkedList<TouchPointDescriptor> res = new LinkedList<TouchPointDescriptor>();\n    for (List<TouchPointDescriptor> tpd : line2touchPoints.values()) {\n        for (TouchPointDescriptor t : tpd) {\n            if (tpd instanceof LineTouchPointDescriptor) {\n                res.add(t);\n            }\n        }\n        for (TouchPointDescriptor t : tpd) {\n            if (!(tpd instanceof LineTouchPointDescriptor)) {\n                res.add(t);\n            }\n        }\n    }\n    return res;\n}"}, {"methodBefore": "public void assignCounterIds() {\n    AtomicInteger idGenerator = new AtomicInteger(0);\n    for (List<TouchPointDescriptor> tpd : currentLine2touchPoints.values()) {\n        for (TouchPointDescriptor t : tpd) {\n            t.assignCounters(idGenerator);\n        }\n    }\n    maxCounterId = idGenerator.get();\n}", "methodAfter": "public void assignCounterIds() {\n    AtomicInteger idGenerator = new AtomicInteger(0);\n    for (List<TouchPointDescriptor> tpd : line2touchPoints.values()) {\n        for (TouchPointDescriptor t : tpd) {\n            t.assignCounters(idGenerator);\n        }\n    }\n    maxCounterId = idGenerator.get();\n}"}], [{"methodBefore": "private boolean jj_3R_173() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_174() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_173() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_174() {\n    if (jj_3R_195()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void StatementExpression() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INCR :\n            PreIncrementExpression();\n            break;\n        case DECR :\n            PreDecrementExpression();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n            PrimaryExpression();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN :\n                case INCR :\n                case DECR :\n                case PLUSASSIGN :\n                case MINUSASSIGN :\n                case STARASSIGN :\n                case SLASHASSIGN :\n                case ANDASSIGN :\n                case ORASSIGN :\n                case XORASSIGN :\n                case REMASSIGN :\n                case LSHIFTASSIGN :\n                case RSIGNEDSHIFTASSIGN :\n                case RUNSIGNEDSHIFTASSIGN :\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case INCR :\n                            jj_consume_token(INCR);\n                            break;\n                        case DECR :\n                            jj_consume_token(DECR);\n                            break;\n                        case ASSIGN :\n                        case PLUSASSIGN :\n                        case MINUSASSIGN :\n                        case STARASSIGN :\n                        case SLASHASSIGN :\n                        case ANDASSIGN :\n                        case ORASSIGN :\n                        case XORASSIGN :\n                        case REMASSIGN :\n                        case LSHIFTASSIGN :\n                        case RSIGNEDSHIFTASSIGN :\n                        case RUNSIGNEDSHIFTASSIGN :\n                            AssignmentOperator();\n                            Expression();\n                            break;\n                        default :\n                            jj_la1[142] = jj_gen;\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default :\n                    jj_la1[143] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[144] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void StatementExpression() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INCR :\n            PreIncrementExpression();\n            break;\n        case DECR :\n            PreDecrementExpression();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n            PrimaryExpression();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN :\n                case INCR :\n                case DECR :\n                case PLUSASSIGN :\n                case MINUSASSIGN :\n                case STARASSIGN :\n                case SLASHASSIGN :\n                case ANDASSIGN :\n                case ORASSIGN :\n                case XORASSIGN :\n                case REMASSIGN :\n                case LSHIFTASSIGN :\n                case RSIGNEDSHIFTASSIGN :\n                case RUNSIGNEDSHIFTASSIGN :\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case INCR :\n                            jj_consume_token(INCR);\n                            break;\n                        case DECR :\n                            jj_consume_token(DECR);\n                            break;\n                        case ASSIGN :\n                        case PLUSASSIGN :\n                        case MINUSASSIGN :\n                        case STARASSIGN :\n                        case SLASHASSIGN :\n                        case ANDASSIGN :\n                        case ORASSIGN :\n                        case XORASSIGN :\n                        case REMASSIGN :\n                        case LSHIFTASSIGN :\n                        case RSIGNEDSHIFTASSIGN :\n                        case RUNSIGNEDSHIFTASSIGN :\n                            AssignmentOperator();\n                            Expression();\n                            break;\n                        default :\n                            jj_la1[143] = jj_gen;\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default :\n                    jj_la1[144] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[145] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void StatementExpression() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INCR :\n            PreIncrementExpression();\n            break;\n        case DECR :\n            PreDecrementExpression();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n            PrimaryExpression();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN :\n                case INCR :\n                case DECR :\n                case PLUSASSIGN :\n                case MINUSASSIGN :\n                case STARASSIGN :\n                case SLASHASSIGN :\n                case ANDASSIGN :\n                case ORASSIGN :\n                case XORASSIGN :\n                case REMASSIGN :\n                case LSHIFTASSIGN :\n                case RSIGNEDSHIFTASSIGN :\n                case RUNSIGNEDSHIFTASSIGN :\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case INCR :\n                            jj_consume_token(INCR);\n                            break;\n                        case DECR :\n                            jj_consume_token(DECR);\n                            break;\n                        case ASSIGN :\n                        case PLUSASSIGN :\n                        case MINUSASSIGN :\n                        case STARASSIGN :\n                        case SLASHASSIGN :\n                        case ANDASSIGN :\n                        case ORASSIGN :\n                        case XORASSIGN :\n                        case REMASSIGN :\n                        case LSHIFTASSIGN :\n                        case RSIGNEDSHIFTASSIGN :\n                        case RUNSIGNEDSHIFTASSIGN :\n                            AssignmentOperator();\n                            Expression();\n                            break;\n                        default :\n                            jj_la1[142] = jj_gen;\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default :\n                    jj_la1[143] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[144] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void StatementExpression() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INCR :\n            PreIncrementExpression();\n            break;\n        case DECR :\n            PreDecrementExpression();\n            break;\n        case ASSERT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case ENUM :\n        case FALSE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NEW :\n        case NULL :\n        case SHORT :\n        case SUPER :\n        case THIS :\n        case TRUE :\n        case VOID :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n        case IDENTIFIER :\n        case LPAREN :\n            PrimaryExpression();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN :\n                case INCR :\n                case DECR :\n                case PLUSASSIGN :\n                case MINUSASSIGN :\n                case STARASSIGN :\n                case SLASHASSIGN :\n                case ANDASSIGN :\n                case ORASSIGN :\n                case XORASSIGN :\n                case REMASSIGN :\n                case LSHIFTASSIGN :\n                case RSIGNEDSHIFTASSIGN :\n                case RUNSIGNEDSHIFTASSIGN :\n                    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                        case INCR :\n                            jj_consume_token(INCR);\n                            break;\n                        case DECR :\n                            jj_consume_token(DECR);\n                            break;\n                        case ASSIGN :\n                        case PLUSASSIGN :\n                        case MINUSASSIGN :\n                        case STARASSIGN :\n                        case SLASHASSIGN :\n                        case ANDASSIGN :\n                        case ORASSIGN :\n                        case XORASSIGN :\n                        case REMASSIGN :\n                        case LSHIFTASSIGN :\n                        case RSIGNEDSHIFTASSIGN :\n                        case RUNSIGNEDSHIFTASSIGN :\n                            AssignmentOperator();\n                            Expression();\n                            break;\n                        default :\n                            jj_la1[143] = jj_gen;\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default :\n                    jj_la1[144] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[145] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_326() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_327() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_326() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_327() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_300() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_310()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_311()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_303() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_313()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_314()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_300() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_310()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_311()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_303() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_313()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_314()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_444() {\n    if (jj_3R_450()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_449() {\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_444() {\n    if (jj_3R_450()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_449() {\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_229() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_290() {\n    if (jj_3R_293()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_229() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_290() {\n    if (jj_3R_293()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void testTouch() {\n    int line = 3;\n    assertFalse(a.isValidSourceLineNumber(line));\n    a.touch(line, 1);\n    assertTrue(a.isValidSourceLineNumber(line));\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(0, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(1, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertEquals(2, b.getLineCoverage(line).getHits());\n    assertTrue(b.isValidSourceLineNumber(line));\n}", "methodAfter": "@Test\npublic void testTouch() {\n    int line = 3;\n    assertFalse(a.isValidSourceLineNumber(line));\n    a.touch(line, 1);\n    assertTrue(a.isValidSourceLineNumber(line));\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(0, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(1, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertEquals(2, b.getLineCoverage(line).getHits());\n    assertTrue(b.isValidSourceLineNumber(line));\n}"}, {"methodBefore": "public static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}"}], [{"methodBefore": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}", "methodAfter": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(ASM4, mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}"}, {"methodBefore": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(mv);\n    this.eventsToTrace = eventsToTrace;\n}", "methodAfter": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(ASM4, mv);\n    this.eventsToTrace = eventsToTrace;\n}"}], [{"methodBefore": "private boolean jj_3_3() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_3() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_3() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_3() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_scan_token(ENUM)) {\n        return true;\n    }\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void EnumBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case FINAL :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            EnumConstant();\n            label_71 : while (true) {\n                if (jj_2_53(2)) {\n                } else {\n                    break label_71;\n                }\n                jj_consume_token(COMMA);\n                EnumConstant();\n            } \n            break;\n        default :\n            jj_la1[182] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[183] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            label_72 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case CLASS :\n                    case DOUBLE :\n                    case ENUM :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case INTERFACE :\n                    case LONG :\n                    case NATIVE :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SYNCHRONIZED :\n                    case TRANSIENT :\n                    case VOID :\n                    case VOLATILE :\n                    case IDENTIFIER :\n                    case LBRACE :\n                    case SEMICOLON :\n                    case AT :\n                    case LT :\n                        break;\n                    default :\n                        jj_la1[184] = jj_gen;\n                        break label_72;\n                }\n                ClassOrInterfaceBodyDeclaration(false);\n            } \n            break;\n        default :\n            jj_la1[185] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void EnumBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case FINAL :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            EnumConstant();\n            label_74 : while (true) {\n                if (jj_2_52(2)) {\n                } else {\n                    break label_74;\n                }\n                jj_consume_token(COMMA);\n                EnumConstant();\n            } \n            break;\n        default :\n            jj_la1[187] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[188] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            label_75 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case CLASS :\n                    case DOUBLE :\n                    case ENUM :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case INTERFACE :\n                    case LONG :\n                    case NATIVE :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SYNCHRONIZED :\n                    case TRANSIENT :\n                    case VOID :\n                    case VOLATILE :\n                    case IDENTIFIER :\n                    case LBRACE :\n                    case SEMICOLON :\n                    case AT :\n                    case LT :\n                        break;\n                    default :\n                        jj_la1[189] = jj_gen;\n                        break label_75;\n                }\n                ClassOrInterfaceBodyDeclaration(false);\n            } \n            break;\n        default :\n            jj_la1[190] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}"}, {"methodBefore": "public final void EnumBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case FINAL :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            EnumConstant();\n            label_71 : while (true) {\n                if (jj_2_53(2)) {\n                } else {\n                    break label_71;\n                }\n                jj_consume_token(COMMA);\n                EnumConstant();\n            } \n            break;\n        default :\n            jj_la1[182] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[183] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            label_72 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case CLASS :\n                    case DOUBLE :\n                    case ENUM :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case INTERFACE :\n                    case LONG :\n                    case NATIVE :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SYNCHRONIZED :\n                    case TRANSIENT :\n                    case VOID :\n                    case VOLATILE :\n                    case IDENTIFIER :\n                    case LBRACE :\n                    case SEMICOLON :\n                    case AT :\n                    case LT :\n                        break;\n                    default :\n                        jj_la1[184] = jj_gen;\n                        break label_72;\n                }\n                ClassOrInterfaceBodyDeclaration(false);\n            } \n            break;\n        default :\n            jj_la1[185] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void EnumBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case FINAL :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            EnumConstant();\n            label_74 : while (true) {\n                if (jj_2_52(2)) {\n                } else {\n                    break label_74;\n                }\n                jj_consume_token(COMMA);\n                EnumConstant();\n            } \n            break;\n        default :\n            jj_la1[187] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[188] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            label_75 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case CLASS :\n                    case DOUBLE :\n                    case ENUM :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case INTERFACE :\n                    case LONG :\n                    case NATIVE :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SYNCHRONIZED :\n                    case TRANSIENT :\n                    case VOID :\n                    case VOLATILE :\n                    case IDENTIFIER :\n                    case LBRACE :\n                    case SEMICOLON :\n                    case AT :\n                    case LT :\n                        break;\n                    default :\n                        jj_la1[189] = jj_gen;\n                        break label_75;\n                }\n                ClassOrInterfaceBodyDeclaration(false);\n            } \n            break;\n        default :\n            jj_la1[190] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}"}], [{"methodBefore": "private boolean jj_3R_344() {\n    if (jj_3R_345()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_347() {\n    if (jj_3R_348()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_344() {\n    if (jj_3R_345()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_347() {\n    if (jj_3R_348()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_153() {\n    if (jj_3R_184()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_62()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_157() {\n    if (jj_3R_188()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_189()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_153() {\n    if (jj_3R_184()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_62()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_157() {\n    if (jj_3R_188()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_189()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_38() {\n    if (jj_3R_116()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_31() {\n    if (jj_3R_115()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_38() {\n    if (jj_3R_116()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_31() {\n    if (jj_3R_115()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_214() {\n    if (jj_scan_token(INCR)) {\n        return true;\n    }\n    if (jj_3R_102()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_216() {\n    if (jj_scan_token(INCR)) {\n        return true;\n    }\n    if (jj_3R_106()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_214() {\n    if (jj_scan_token(INCR)) {\n        return true;\n    }\n    if (jj_3R_102()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_216() {\n    if (jj_scan_token(INCR)) {\n        return true;\n    }\n    if (jj_3R_106()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void MethodDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int jvdcLines = 0;\n    int oldSingle;\n    int oldMulti;\n    boolean bPublic = false;\n    Token myToken = null;\n    _tmpToken = null;\n    if (_tmpToken != null) {\n        tmpToken = _tmpToken;\n    }\n    label_29 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[61] = jj_gen;\n                break label_29;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    label_30 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n                break;\n            default :\n                jj_la1[62] = jj_gen;\n                break label_30;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PROTECTED :\n                jj_consume_token(PROTECTED);\n                bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PRIVATE :\n                jj_consume_token(PRIVATE);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case STATIC :\n                jj_consume_token(STATIC);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case FINAL :\n                jj_consume_token(FINAL);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case NATIVE :\n                jj_consume_token(NATIVE);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case SYNCHRONIZED :\n                jj_consume_token(SYNCHRONIZED);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            default :\n                jj_la1[63] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    label_31 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[64] = jj_gen;\n                break label_31;\n        }\n        Annotation();\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[65] = jj_gen;\n    }\n    _tmpResultToken = null;\n    ResultType();\n    if (tmpToken == null) {\n        tmpToken = _tmpResultToken;\n        if (tmpToken == null) {\n            tmpToken = getToken(0);\n        }\n        Util.debug(\"result type tmpToken: \" + tmpToken);\n    }\n    MethodDeclarator();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[66] = jj_gen;\n    }\n    _cyc = 1;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LBRACE :\n            Block();\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            break;\n        default :\n            jj_la1[67] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    {\n        Util.debug(\"Token: \" + String.valueOf(tmpToken.image));\n        while (tmpToken.specialToken != null) {\n            Util.debug(\"Token comment: \" + String.valueOf(tmpToken.specialToken.image));\n            if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n                _javadocs++;\n                Util.debug(\"MethodDeclaration()._javadocs++\");\n                jvdc++;\n                if ((bPublic && _bPublic) || _bPrivate) {\n                    Util.debug(\"_jvdc++\");\n                    _jvdc++;\n                    jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                    _jvdcLines += jvdcLines;\n                    JavaParserTokenManager._iFormalComments += jvdcLines;\n                }\n                JavaParserTokenManager._iMultiComments -= jvdcLines;\n                break;\n            } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n                jvdcLines = 0;\n                break;\n            }\n            tmpToken = tmpToken.specialToken;\n        } \n        oldSingle = JavaParserTokenManager._iSingleComments;\n        oldMulti = JavaParserTokenManager._iMultiComments;\n    }\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"MethodDeclaration()._ncss++\");\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.name = (_sPackage + _sClass) + _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = 0;\n    functionMetrics.singleLn = 0;\n    functionMetrics.multiLn = 0;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}", "methodAfter": "public final void MethodDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int jvdcLines = 0;\n    int oldSingle;\n    int oldMulti;\n    boolean bPublic = false;\n    Token myToken = null;\n    _tmpToken = null;\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.firstLine = JavaParserTokenManager.nbligne;\n    if (_tmpToken != null) {\n        tmpToken = _tmpToken;\n    }\n    label_29 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[61] = jj_gen;\n                break label_29;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    label_30 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n                break;\n            default :\n                jj_la1[62] = jj_gen;\n                break label_30;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PROTECTED :\n                jj_consume_token(PROTECTED);\n                bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PRIVATE :\n                jj_consume_token(PRIVATE);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case STATIC :\n                jj_consume_token(STATIC);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case FINAL :\n                jj_consume_token(FINAL);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case NATIVE :\n                jj_consume_token(NATIVE);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case SYNCHRONIZED :\n                jj_consume_token(SYNCHRONIZED);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            default :\n                jj_la1[63] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    label_31 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[64] = jj_gen;\n                break label_31;\n        }\n        Annotation();\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[65] = jj_gen;\n    }\n    _tmpResultToken = null;\n    ResultType();\n    if (tmpToken == null) {\n        tmpToken = _tmpResultToken;\n        if (tmpToken == null) {\n            tmpToken = getToken(0);\n        }\n        Util.debug(\"result type tmpToken: \" + tmpToken);\n    }\n    MethodDeclarator();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[66] = jj_gen;\n    }\n    _cyc = 1;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LBRACE :\n            Block();\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            break;\n        default :\n            jj_la1[67] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    {\n        Util.debug(\"Token: \" + String.valueOf(tmpToken.image));\n        while (tmpToken.specialToken != null) {\n            Util.debug(\"Token comment: \" + String.valueOf(tmpToken.specialToken.image));\n            if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n                _javadocs++;\n                Util.debug(\"MethodDeclaration()._javadocs++\");\n                jvdc++;\n                if ((bPublic && _bPublic) || _bPrivate) {\n                    Util.debug(\"_jvdc++\");\n                    _jvdc++;\n                    jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                    _jvdcLines += jvdcLines;\n                    JavaParserTokenManager._iFormalComments += jvdcLines;\n                }\n                JavaParserTokenManager._iMultiComments -= jvdcLines;\n                break;\n            } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n                jvdcLines = 0;\n                break;\n            }\n            tmpToken = tmpToken.specialToken;\n        } \n        oldSingle = JavaParserTokenManager._iSingleComments;\n        oldMulti = JavaParserTokenManager._iMultiComments;\n    }\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"MethodDeclaration()._ncss++\");\n    functionMetrics.name = (_sPackage + _sClass) + _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = 0;\n    functionMetrics.singleLn = 0;\n    functionMetrics.multiLn = 0;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}"}, {"methodBefore": "public final void MethodDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int jvdcLines = 0;\n    int oldSingle;\n    int oldMulti;\n    boolean bPublic = false;\n    Token myToken = null;\n    _tmpToken = null;\n    if (_tmpToken != null) {\n        tmpToken = _tmpToken;\n    }\n    label_29 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[61] = jj_gen;\n                break label_29;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    label_30 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n                break;\n            default :\n                jj_la1[62] = jj_gen;\n                break label_30;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PROTECTED :\n                jj_consume_token(PROTECTED);\n                bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PRIVATE :\n                jj_consume_token(PRIVATE);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case STATIC :\n                jj_consume_token(STATIC);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case FINAL :\n                jj_consume_token(FINAL);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case NATIVE :\n                jj_consume_token(NATIVE);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case SYNCHRONIZED :\n                jj_consume_token(SYNCHRONIZED);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            default :\n                jj_la1[63] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    label_31 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[64] = jj_gen;\n                break label_31;\n        }\n        Annotation();\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[65] = jj_gen;\n    }\n    _tmpResultToken = null;\n    ResultType();\n    if (tmpToken == null) {\n        tmpToken = _tmpResultToken;\n        if (tmpToken == null) {\n            tmpToken = getToken(0);\n        }\n        Util.debug(\"result type tmpToken: \" + tmpToken);\n    }\n    MethodDeclarator();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[66] = jj_gen;\n    }\n    _cyc = 1;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LBRACE :\n            Block();\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            break;\n        default :\n            jj_la1[67] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    {\n        Util.debug(\"Token: \" + String.valueOf(tmpToken.image));\n        while (tmpToken.specialToken != null) {\n            Util.debug(\"Token comment: \" + String.valueOf(tmpToken.specialToken.image));\n            if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n                _javadocs++;\n                Util.debug(\"MethodDeclaration()._javadocs++\");\n                jvdc++;\n                if ((bPublic && _bPublic) || _bPrivate) {\n                    Util.debug(\"_jvdc++\");\n                    _jvdc++;\n                    jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                    _jvdcLines += jvdcLines;\n                    JavaParserTokenManager._iFormalComments += jvdcLines;\n                }\n                JavaParserTokenManager._iMultiComments -= jvdcLines;\n                break;\n            } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n                jvdcLines = 0;\n                break;\n            }\n            tmpToken = tmpToken.specialToken;\n        } \n        oldSingle = JavaParserTokenManager._iSingleComments;\n        oldMulti = JavaParserTokenManager._iMultiComments;\n    }\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"MethodDeclaration()._ncss++\");\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.name = (_sPackage + _sClass) + _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = 0;\n    functionMetrics.singleLn = 0;\n    functionMetrics.multiLn = 0;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}", "methodAfter": "public final void MethodDeclaration() throws ParseException {\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    String sOldFunction = _sFunction;\n    int oldcyc = _cyc;\n    boolean bOldReturn = _bReturn;\n    Token tmpToken = null;\n    int jvdc = 0;\n    int jvdcLines = 0;\n    int oldSingle;\n    int oldMulti;\n    boolean bPublic = false;\n    Token myToken = null;\n    _tmpToken = null;\n    FunctionMetric functionMetrics = new FunctionMetric();\n    functionMetrics.firstLine = JavaParserTokenManager.nbligne;\n    if (_tmpToken != null) {\n        tmpToken = _tmpToken;\n    }\n    label_29 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[61] = jj_gen;\n                break label_29;\n        }\n        myToken = getToken(1);\n        Annotation();\n        if (tmpToken == null) {\n            tmpToken = myToken;\n        }\n    } \n    label_30 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case FINAL :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n                break;\n            default :\n                jj_la1[62] = jj_gen;\n                break label_30;\n        }\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PUBLIC :\n                jj_consume_token(PUBLIC);\n                bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PROTECTED :\n                jj_consume_token(PROTECTED);\n                bPublic = true;\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case PRIVATE :\n                jj_consume_token(PRIVATE);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case STATIC :\n                jj_consume_token(STATIC);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case ABSTRACT :\n                jj_consume_token(ABSTRACT);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case FINAL :\n                jj_consume_token(FINAL);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case NATIVE :\n                jj_consume_token(NATIVE);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case SYNCHRONIZED :\n                jj_consume_token(SYNCHRONIZED);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            case TESTAAAA :\n                jj_consume_token(TESTAAAA);\n                if (tmpToken == null) {\n                    tmpToken = getToken(0);\n                }\n                break;\n            default :\n                jj_la1[63] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    } \n    label_31 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case AT :\n                break;\n            default :\n                jj_la1[64] = jj_gen;\n                break label_31;\n        }\n        Annotation();\n    } \n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[65] = jj_gen;\n    }\n    _tmpResultToken = null;\n    ResultType();\n    if (tmpToken == null) {\n        tmpToken = _tmpResultToken;\n        if (tmpToken == null) {\n            tmpToken = getToken(0);\n        }\n        Util.debug(\"result type tmpToken: \" + tmpToken);\n    }\n    MethodDeclarator();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case THROWS :\n            jj_consume_token(THROWS);\n            NameList();\n            break;\n        default :\n            jj_la1[66] = jj_gen;\n    }\n    _cyc = 1;\n    _bReturn = false;\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LBRACE :\n            Block();\n            break;\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            break;\n        default :\n            jj_la1[67] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n    {\n        Util.debug(\"Token: \" + String.valueOf(tmpToken.image));\n        while (tmpToken.specialToken != null) {\n            Util.debug(\"Token comment: \" + String.valueOf(tmpToken.specialToken.image));\n            if (tmpToken.specialToken.image.startsWith(\"/**\")) {\n                _javadocs++;\n                Util.debug(\"MethodDeclaration()._javadocs++\");\n                jvdc++;\n                if ((bPublic && _bPublic) || _bPrivate) {\n                    Util.debug(\"_jvdc++\");\n                    _jvdc++;\n                    jvdcLines = JavaParserTokenManager._iMultiCommentsLast;\n                    _jvdcLines += jvdcLines;\n                    JavaParserTokenManager._iFormalComments += jvdcLines;\n                }\n                JavaParserTokenManager._iMultiComments -= jvdcLines;\n                break;\n            } else if (tmpToken.specialToken.image.startsWith(\"/*\")) {\n                jvdcLines = 0;\n                break;\n            }\n            tmpToken = tmpToken.specialToken;\n        } \n        oldSingle = JavaParserTokenManager._iSingleComments;\n        oldMulti = JavaParserTokenManager._iMultiComments;\n    }\n    if (_bReturn) {\n        _cyc--;\n    }\n    _ncss++;\n    Util.debug(\"MethodDeclaration()._ncss++\");\n    functionMetrics.name = (_sPackage + _sClass) + _sFunction;\n    functionMetrics.ncss = _ncss - oldNcss;\n    functionMetrics.ccn = _cyc;\n    functionMetrics.javadocs = jvdc;\n    functionMetrics.javadocsLn = 0;\n    functionMetrics.singleLn = 0;\n    functionMetrics.multiLn = 0;\n    _vFunctions.add(functionMetrics);\n    _sFunction = sOldFunction;\n    _functions = oldFunctions + 1;\n    _cyc = oldcyc;\n    _bReturn = bOldReturn;\n    _tmpToken = null;\n}"}], [{"methodBefore": "public void visitJumpInsn(int opcode, Label label) {\n    if ((((opcode != GOTO) && (opcode != JSR)) && (currentLine != 0)) && (!this.myName.equals(\"<clinit>\"))) {\n        classData.addLineJump(currentLine, currentJump);\n        jumpTargetLabels.put(label, new JumpHolder(currentLine, currentJump++));\n    }\n    super.visitJumpInsn(opcode, label);\n}", "methodAfter": "public void visitJumpInsn(int opcode, Label label) {\n    if ((((opcode != GOTO) && (opcode != JSR)) && (currentLine != 0)) && (!this.myName.equals(\"<clinit>\"))) {\n        classData.addLineJump(currentLine, currentJump);\n        jumpTargetLabels.put(label, new JumpHolder(currentLine, currentJump++));\n    }\n    markNonTrivial();\n    super.visitJumpInsn(opcode, label);\n}"}, {"methodBefore": "public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\n    super.visitLookupSwitchInsn(dflt, keys, labels);\n    if (currentLine != 0) {\n        switchTargetLabels.put(dflt, new SwitchHolder(currentLine, currentSwitch, -1));\n        for (int i = labels.length - 1; i >= 0; i--) {\n            switchTargetLabels.put(labels[i], new SwitchHolder(currentLine, currentSwitch, i));\n        }\n        classData.addLineSwitch(currentLine, currentSwitch++, keys);\n    }\n}", "methodAfter": "public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\n    super.visitLookupSwitchInsn(dflt, keys, labels);\n    if (currentLine != 0) {\n        switchTargetLabels.put(dflt, new SwitchHolder(currentLine, currentSwitch, -1));\n        for (int i = labels.length - 1; i >= 0; i--) {\n            switchTargetLabels.put(labels[i], new SwitchHolder(currentLine, currentSwitch, i));\n        }\n        classData.addLineSwitch(currentLine, currentSwitch++, keys);\n    }\n    markNonTrivial();\n}"}], [{"methodBefore": "public double getBranchCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = conditionals.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndDescriptor)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}", "methodAfter": "public double getBranchCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = conditionals.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (methodNameAndDescriptor.equals(next.getMethodName() + next.getMethodDescriptor())) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}"}, {"methodBefore": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = lines.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (next.getMethodName().equals(methodNameAndDescriptor)) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}", "methodAfter": "public double getLineCoverageRate(String methodNameAndDescriptor) {\n    int total = 0;\n    int hits = 0;\n    Iterator iter = lines.values().iterator();\n    while (iter.hasNext()) {\n        LineInformation next = ((LineInformation) (iter.next()));\n        if (methodNameAndDescriptor.equals(next.getMethodName() + next.getMethodDescriptor())) {\n            total++;\n            if (next.getHits() > 0) {\n                hits++;\n            }\n        }\n    } \n    return ((double) (hits)) / total;\n}"}], [{"methodBefore": "private void runTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    BufferedWriter bw = null;\n    try {\n        bw = new BufferedWriter(new FileWriter(mainSourceFile));\n        bw.write(getMainCode(instrumentDir));\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    File calledSourceFile = new File(srcDir, \"mypackage/Called.java\");\n    try {\n        bw = new BufferedWriter(new FileWriter(calledSourceFile));\n        bw.write(CALLED_CODE);\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    DirSet dirSet = new DirSet();\n    dirSet.setDir(srcDir);\n    dirSet.setProject(project);\n    Path classpath = new Path(TestUtils.project);\n    classpath.addDirset(dirSet);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    List<Node> lines = TestUtils.getLineCounts(dom, \"mypackage.Called\", \"callThis\", null);\n    assertEquals(1, lines.size());\n    for (int i = 0; i < lines.size(); i++) {\n        assertEquals(\"hit count incorrect\", \"2\", lines.get(i).attribute(\"hits\"));\n    }\n}", "methodAfter": "private void runTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    BufferedWriter bw = null;\n    try {\n        bw = new BufferedWriter(new FileWriter(mainSourceFile));\n        bw.write(getMainCode(instrumentDir));\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    File calledSourceFile = new File(srcDir, \"mypackage/Called.java\");\n    try {\n        bw = new BufferedWriter(new FileWriter(calledSourceFile));\n        bw.write(CALLED_CODE);\n    } catch (IOException e) {\n        e.printStackTrace();\n        fail();\n    } finally {\n        IOUtils.closeQuietly(bw);\n    }\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    DirSet dirSet = new DirSet();\n    dirSet.setDir(srcDir);\n    dirSet.setProject(project);\n    Path classpath = new Path(TestUtils.project);\n    classpath.addDirset(dirSet);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.execute();\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    List<Node> lines = TestUtils.getLineCounts(dom, \"mypackage.Called\", \"callThis\", null);\n    assertEquals(1, lines.size());\n    for (int i = 0; i < lines.size(); i++) {\n        assertEquals(\"hit count incorrect\", \"2\", lines.get(i).attribute(\"hits\"));\n    }\n}"}, {"methodBefore": "@Test\npublic void performanceTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(mainSourceFile, (((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tlong start = System.nanoTime();\") + \"\\n \\t\\tint j = 0;\") + \"\\n \\t\\tfor (int i = 0; i < 100000; i++) {\") + \"\\n \\t\\t   if (i % 2 == 0) { j+=2; };\") + \"\\n \\t\\t   switch (i % 4) {\") + \"\\n \\t\\t      case 0 : \") + \"\\n \\t\\t      case 1 : j++;\") + \"\\n \\t\\t      case 2 : j+=2;\") + \"\\n \\t\\t      default: j+=3;\") + \"\\n \\t\\t   } \") + \"\\n \\t\\t}\") + \"\\n \\t\\tlong stop = System.nanoTime();\") + \"\\n \\t\\tSystem.out.println(\\\"Test took:\\\" + (stop - start)/100000.0 + \\\" milis\\\");\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    System.out.println(\"Run without instrumentation:\\n\");\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetSrcDir);\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setOutput(new File(tempDir, \"PT_uninstrumented.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_uninstrumented.log\")));\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    System.out.println(\"Run with instrumentation (not threadsafe-rigorous):\\n\");\n    classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\")).toString());\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"threadsafeRigorous\", true);\n        }\n    });\n    System.out.println(\"Run with instrumentation (threadsafe-rigorous):\\n\");\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedThreadSafe.log\")));\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n}", "methodAfter": "@Test\npublic void performanceTest() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    FileUtils.deleteDirectory(tempDir);\n    File srcDir = new File(tempDir, \"src\");\n    File instrumentDir = new File(tempDir, \"instrument\");\n    File mainSourceFile = new File(srcDir, \"mypackage/Main.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    mainSourceFile.getParentFile().mkdirs();\n    FileUtils.write(mainSourceFile, (((((((((((((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Main extends Thread {\") + \"\\n \\tpublic static void main(String[] args) {\") + \"\\n \\t\\tlong start = System.nanoTime();\") + \"\\n \\t\\tint j = 0;\") + \"\\n \\t\\tfor (int i = 0; i < 100000; i++) {\") + \"\\n \\t\\t   if (i % 2 == 0) { j+=2; };\") + \"\\n \\t\\t   switch (i % 4) {\") + \"\\n \\t\\t      case 0 : \") + \"\\n \\t\\t      case 1 : j++;\") + \"\\n \\t\\t      case 2 : j+=2;\") + \"\\n \\t\\t      default: j+=3;\") + \"\\n \\t\\t   } \") + \"\\n \\t\\t}\") + \"\\n \\t\\tlong stop = System.nanoTime();\") + \"\\n \\t\\tSystem.out.println(\\\"Test took:\\\" + (stop - start)/100000.0 + \\\" milis\\\");\") + \"\\n \\t}\") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    System.out.println(\"Run without instrumentation:\\n\");\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetSrcDir);\n    Java java = new Java();\n    java.setProject(project);\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setOutput(new File(tempDir, \"PT_uninstrumented.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_uninstrumented.log\")));\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir);\n    System.out.println(\"Run with instrumentation (not threadsafe-rigorous):\\n\");\n    classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(instrumentDir);\n    dirSetSrcDir.setDir(srcDir);\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedNonThreadSafe.log\")).toString());\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"threadsafeRigorous\", true);\n        }\n    });\n    System.out.println(\"Run with instrumentation (threadsafe-rigorous):\\n\");\n    java = new Java();\n    java.setClassname(\"mypackage.Main\");\n    java.setDir(srcDir);\n    java.setFork(true);\n    java.setFailonerror(true);\n    java.setClasspath(classpath);\n    java.setProject(project);\n    java.setOutput(new File(tempDir, \"PT_instrumentedThreadSafe.log\"));\n    java.execute();\n    System.out.println(FileUtils.readFileToString(new File(tempDir, \"PT_instrumentedThreadSafe.log\")));\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n}"}, {"methodBefore": "public static Path getCoberturaDefaultClasspath() {\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(new File(getTempDir(), \"instrument\"));\n    dirSetSrcDir.setDir(new File(getTempDir(), \"src\"));\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    return classpath;\n}", "methodAfter": "public static Path getCoberturaDefaultClasspath() {\n    Path classpath = new Path(TestUtils.project);\n    DirSet dirSetInstrumentDir = new DirSet();\n    DirSet dirSetSrcDir = new DirSet();\n    dirSetInstrumentDir.setDir(new File(getTempDir(), \"instrument\"));\n    dirSetSrcDir.setDir(new File(getTempDir(), \"src\"));\n    classpath.addDirset(dirSetInstrumentDir);\n    classpath.addDirset(dirSetSrcDir);\n    classpath.addDirset(TestUtils.getCoberturaClassDirSet());\n    classpath.add(createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    return classpath;\n}"}, {"methodBefore": "private void runTest(String code) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    final File srcDir = new File(tempDir, \"src\");\n    File sourceFile = new File(srcDir, \"mypackage/MyThreads.java\");\n    final File datafile = new File(srcDir, \"cobertura.ser\");\n    sourceFile.getParentFile().mkdirs();\n    BufferedWriter bw = null;\n    try {\n        bw = new BufferedWriter(new FileWriter(sourceFile));\n        bw.write(getThreadedCode(code));\n    } finally {\n        bw.close();\n    }\n    compileSource(srcDir);\n    instrumentClasses(srcDir, datafile);\n    Path p = new Path(TestUtils.project);\n    DirSet dirSet = new DirSet();\n    FileSet fileSet = new FileSet();\n    dirSet.setDir(srcDir);\n    fileSet.setDir(new File(\"src/test/resources/antLibrary/common/groovy\"));\n    fileSet.setIncludes(\"*.jar\");\n    p.addFileset(fileSet);\n    p.addDirset(dirSet);\n    p.setProject(project);\n    p.addDirset(TestUtils.getCoberturaClassDirSet());\n    for (int i = 0; i < numberOfRetries; i++) {\n        System.out.println(\"Executing build: \" + i);\n        Java java = new Java();\n        java.setClassname(\"mypackage.MyThreads\");\n        java.setDir(srcDir);\n        java.setFork(true);\n        java.setProject(project);\n        java.setFailonerror(true);\n        java.setClasspath(p);\n        java.execute();\n    }\n    System.out.println(\"Starting reporting task.\");\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    System.out.println(\"Finish reporting task.\");\n    Node dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    int hitCount = TestUtils.getHitCount(dom, \"mypackage.MyThreads\", \"acall\");\n    assertEquals(\"hit count incorrect\", (numberOfRetries * numberOfThreads) * numberOfCalls, hitCount);\n}", "methodAfter": "private void runTest(String code) throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    final File srcDir = new File(tempDir, \"src\");\n    File sourceFile = new File(srcDir, \"mypackage/MyThreads.java\");\n    final File datafile = new File(srcDir, \"cobertura.ser\");\n    sourceFile.getParentFile().mkdirs();\n    BufferedWriter bw = null;\n    try {\n        bw = new BufferedWriter(new FileWriter(sourceFile));\n        bw.write(getThreadedCode(code));\n    } finally {\n        bw.close();\n    }\n    compileSource(srcDir);\n    instrumentClasses(srcDir, datafile);\n    Path p = new Path(TestUtils.project);\n    DirSet dirSet = new DirSet();\n    FileSet fileSet = new FileSet();\n    dirSet.setDir(srcDir);\n    fileSet.setDir(new File(\"src/test/resources/antLibrary/common/groovy\"));\n    fileSet.setIncludes(\"*.jar\");\n    p.addFileset(fileSet);\n    p.addDirset(dirSet);\n    p.setProject(project);\n    p.addDirset(TestUtils.getCoberturaClassDirSet());\n    p.add(TestUtils.createDependencyPath(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"));\n    for (int i = 0; i < numberOfRetries; i++) {\n        System.out.println(\"Executing build: \" + i);\n        Java java = new Java();\n        java.setClassname(\"mypackage.MyThreads\");\n        java.setDir(srcDir);\n        java.setFork(true);\n        java.setProject(project);\n        java.setFailonerror(true);\n        java.setClasspath(p);\n        java.execute();\n    }\n    System.out.println(\"Starting reporting task.\");\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    System.out.println(\"Finish reporting task.\");\n    Node dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    int hitCount = TestUtils.getHitCount(dom, \"mypackage.MyThreads\", \"acall\");\n    assertEquals(\"hit count incorrect\", (numberOfRetries * numberOfThreads) * numberOfCalls, hitCount);\n}"}], [{"methodBefore": "private boolean jj_3_56() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_53() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_56() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_53() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_367() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_364() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_367() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_364() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_246() {\n    if (jj_3R_266()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_264() {\n    if (jj_3R_126()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_246() {\n    if (jj_3R_266()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_264() {\n    if (jj_3R_126()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_235() {\n    if (jj_3R_259()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_282()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_237() {\n    if (jj_3R_260()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_285()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_235() {\n    if (jj_3R_259()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_282()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_237() {\n    if (jj_3R_260()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_285()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_452() {\n    if (jj_3R_222()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_452() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_107()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_459()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_380()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_452() {\n    if (jj_3R_222()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_452() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_107()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_459()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_380()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_284() {\n    if (jj_3R_215()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_286() {\n    if (jj_3R_216()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_284() {\n    if (jj_3R_215()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_286() {\n    if (jj_3R_216()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_98() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_95() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_98() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_95() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_167() {\n    if (jj_3R_192()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_92() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_167() {\n    if (jj_3R_192()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_92() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void instrumentWar(File war, String instrumentRegEx) {\n    InstrumentTask instrumentTask = new InstrumentTask();\n    instrumentTask.setProject(project);\n    instrumentTask.setDataFile(dir.getAbsolutePath() + \"/cobertura.ser\");\n    instrumentTask.createIncludeClasses().setRegex(instrumentRegEx);\n    instrumentTask.createExcludeClasses().setRegex(\".*Test.*\");\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(war.getParentFile());\n    fileSet.setIncludes(\"**/*.war\");\n    instrumentTask.addFileset(fileSet);\n    instrumentTask.execute();\n}", "methodAfter": "private void instrumentWar(File war, String instrumentRegEx) {\n    InstrumentTask instrumentTask = new InstrumentTask();\n    instrumentTask.setProject(project);\n    instrumentTask.setDataFile(dir.getAbsolutePath() + \"/cobertura.ser\");\n    instrumentTask.createIncludeClasses().setRegex(instrumentRegEx);\n    instrumentTask.createExcludeClasses().setRegex(\".*Test.*\");\n    System.out.println(war.getAbsolutePath());\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(war.getParentFile());\n    fileSet.setIncludes(\"**/*.war\");\n    instrumentTask.addFileset(fileSet);\n    instrumentTask.execute();\n}"}, {"methodBefore": "private void instrumentWar(File war, String instrumentRegEx) {\n    InstrumentTask instrumentTask = new InstrumentTask();\n    instrumentTask.setProject(project);\n    instrumentTask.setDataFile(dir.getAbsolutePath() + \"/cobertura.ser\");\n    instrumentTask.createIncludeClasses().setRegex(instrumentRegEx);\n    instrumentTask.createExcludeClasses().setRegex(\".*Test.*\");\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(war.getParentFile());\n    fileSet.setIncludes(\"**/*.war\");\n    instrumentTask.addFileset(fileSet);\n    instrumentTask.execute();\n}", "methodAfter": "private void instrumentWar(File war, String instrumentRegEx) {\n    InstrumentTask instrumentTask = new InstrumentTask();\n    instrumentTask.setProject(project);\n    instrumentTask.setDataFile(dir.getAbsolutePath() + \"/cobertura.ser\");\n    instrumentTask.createIncludeClasses().setRegex(instrumentRegEx);\n    instrumentTask.createExcludeClasses().setRegex(\".*Test.*\");\n    System.out.println(war.getAbsolutePath());\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(war.getParentFile());\n    fileSet.setIncludes(\"**/*.war\");\n    instrumentTask.addFileset(fileSet);\n    instrumentTask.execute();\n}"}], [{"methodBefore": "private boolean jj_3R_453() {\n    if (jj_3R_454()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_453() {\n    if (jj_3R_460()) {\n        return true;\n    }\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_453() {\n    if (jj_3R_454()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_453() {\n    if (jj_3R_460()) {\n        return true;\n    }\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public GenerateCallCoberturaInitMethodVisitor(MethodVisitor arg0, String className) {\n    super(arg0);\n    this.className = className;\n}", "methodAfter": "public GenerateCallCoberturaInitMethodVisitor(MethodVisitor arg0, String className) {\n    super(ASM4, arg0);\n    this.className = className;\n}"}, {"methodBefore": "public GenerateCallCoberturaInitMethodVisitor(MethodVisitor arg0, String className) {\n    super(arg0);\n    this.className = className;\n}", "methodAfter": "public GenerateCallCoberturaInitMethodVisitor(MethodVisitor arg0, String className) {\n    super(ASM4, arg0);\n    this.className = className;\n}"}], [{"methodBefore": "public final void UnmodifiedClassDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    int oldJavadocs = _javadocs;\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(2).image;\n    _classLevel++;\n    Modifiers();\n    jj_consume_token(CLASS);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[19] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            Name();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case LT :\n                    TypeArguments();\n                    break;\n                default :\n                    jj_la1[20] = jj_gen;\n            }\n            label_11 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case DOT :\n                        break;\n                    default :\n                        jj_la1[21] = jj_gen;\n                        break label_11;\n                }\n                jj_consume_token(DOT);\n                Name();\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LT :\n                        TypeArguments();\n                        break;\n                    default :\n                        jj_la1[22] = jj_gen;\n                }\n            } \n            break;\n        default :\n            jj_la1[23] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            jj_consume_token(IMPLEMENTS);\n            NameList();\n            break;\n        default :\n            jj_la1[24] = jj_gen;\n    }\n    ClassBody();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        ObjectMetric metric = new ObjectMetric();\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    } else {\n        ObjectMetric metric1 = new ObjectMetric();\n        metric1.name = _sPackage + _sClass;\n        metric1.ncss = _ncss - oldNcss;\n        metric1.functions = _functions - oldFunctions;\n        metric1.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        _vClasses.add(metric1);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        metric1.javadocs = _javadocs - oldJavadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}", "methodAfter": "public final void UnmodifiedClassDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    ObjectMetric metric = new ObjectMetric();\n    if (_classLevel == 0) {\n        metric.firstLine = JavaParserTokenManager.nbligne;\n    }\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(2).image;\n    _classLevel++;\n    Modifiers();\n    jj_consume_token(CLASS);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[19] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            Name();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case LT :\n                    TypeArguments();\n                    break;\n                default :\n                    jj_la1[20] = jj_gen;\n            }\n            label_11 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case DOT :\n                        break;\n                    default :\n                        jj_la1[21] = jj_gen;\n                        break label_11;\n                }\n                jj_consume_token(DOT);\n                Name();\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LT :\n                        TypeArguments();\n                        break;\n                    default :\n                        jj_la1[22] = jj_gen;\n                }\n            } \n            break;\n        default :\n            jj_la1[23] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            jj_consume_token(IMPLEMENTS);\n            NameList();\n            break;\n        default :\n            jj_la1[24] = jj_gen;\n    }\n    ClassBody();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}"}, {"methodBefore": "public final void UnmodifiedClassDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    int oldJavadocs = _javadocs;\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(2).image;\n    _classLevel++;\n    Modifiers();\n    jj_consume_token(CLASS);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[19] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            Name();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case LT :\n                    TypeArguments();\n                    break;\n                default :\n                    jj_la1[20] = jj_gen;\n            }\n            label_11 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case DOT :\n                        break;\n                    default :\n                        jj_la1[21] = jj_gen;\n                        break label_11;\n                }\n                jj_consume_token(DOT);\n                Name();\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LT :\n                        TypeArguments();\n                        break;\n                    default :\n                        jj_la1[22] = jj_gen;\n                }\n            } \n            break;\n        default :\n            jj_la1[23] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            jj_consume_token(IMPLEMENTS);\n            NameList();\n            break;\n        default :\n            jj_la1[24] = jj_gen;\n    }\n    ClassBody();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        ObjectMetric metric = new ObjectMetric();\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    } else {\n        ObjectMetric metric1 = new ObjectMetric();\n        metric1.name = _sPackage + _sClass;\n        metric1.ncss = _ncss - oldNcss;\n        metric1.functions = _functions - oldFunctions;\n        metric1.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        _vClasses.add(metric1);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        metric1.javadocs = _javadocs - oldJavadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}", "methodAfter": "public final void UnmodifiedClassDeclaration() throws ParseException {\n    String sOldClass = _sClass;\n    int oldNcss = _ncss;\n    int oldFunctions = _functions;\n    int oldClasses = _classes;\n    ObjectMetric metric = new ObjectMetric();\n    if (_classLevel == 0) {\n        metric.firstLine = JavaParserTokenManager.nbligne;\n    }\n    if (!_sClass.equals(\"\")) {\n        _sClass += \".\";\n    }\n    _sClass += getToken(2).image;\n    _classLevel++;\n    Modifiers();\n    jj_consume_token(CLASS);\n    Identifier();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LT :\n            TypeParameters();\n            break;\n        default :\n            jj_la1[19] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            jj_consume_token(EXTENDS);\n            Name();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case LT :\n                    TypeArguments();\n                    break;\n                default :\n                    jj_la1[20] = jj_gen;\n            }\n            label_11 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case DOT :\n                        break;\n                    default :\n                        jj_la1[21] = jj_gen;\n                        break label_11;\n                }\n                jj_consume_token(DOT);\n                Name();\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LT :\n                        TypeArguments();\n                        break;\n                    default :\n                        jj_la1[22] = jj_gen;\n                }\n            } \n            break;\n        default :\n            jj_la1[23] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IMPLEMENTS :\n            jj_consume_token(IMPLEMENTS);\n            NameList();\n            break;\n        default :\n            jj_la1[24] = jj_gen;\n    }\n    ClassBody();\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    _classLevel--;\n    if (_classLevel == 0) {\n        metric.name = _sPackage + _sClass;\n        metric.ncss = _ncss - oldNcss;\n        metric.functions = _functions - oldFunctions;\n        metric.classes = _classes - oldClasses;\n        Token lastToken = getToken(0);\n        _vClasses.add(metric);\n        _pPackageMetric.functions += _functions - oldFunctions;\n        _pPackageMetric.classes++;\n        _pPackageMetric.javadocs += _javadocs;\n    }\n    _functions = oldFunctions;\n    _classes = oldClasses + 1;\n    _sClass = sOldClass;\n}"}], [{"methodBefore": "private boolean jj_3R_376() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_376() {\n    if (jj_scan_token(TESTAAAA)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_376() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_376() {\n    if (jj_scan_token(TESTAAAA)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void CastExpression() throws ParseException {\n    if (jj_2_31(2147483647)) {\n        jj_consume_token(LPAREN);\n        Type();\n        jj_consume_token(RPAREN);\n        UnaryExpression();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LPAREN :\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(RPAREN);\n                UnaryExpressionNotPlusMinus();\n                break;\n            default :\n                jj_la1[118] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void CastExpression() throws ParseException {\n    if (jj_2_30(2147483647)) {\n        jj_consume_token(LPAREN);\n        Type();\n        jj_consume_token(RPAREN);\n        UnaryExpression();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LPAREN :\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(RPAREN);\n                UnaryExpressionNotPlusMinus();\n                break;\n            default :\n                jj_la1[118] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}, {"methodBefore": "public final void CastExpression() throws ParseException {\n    if (jj_2_31(2147483647)) {\n        jj_consume_token(LPAREN);\n        Type();\n        jj_consume_token(RPAREN);\n        UnaryExpression();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LPAREN :\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(RPAREN);\n                UnaryExpressionNotPlusMinus();\n                break;\n            default :\n                jj_la1[118] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void CastExpression() throws ParseException {\n    if (jj_2_30(2147483647)) {\n        jj_consume_token(LPAREN);\n        Type();\n        jj_consume_token(RPAREN);\n        UnaryExpression();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LPAREN :\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(RPAREN);\n                UnaryExpressionNotPlusMinus();\n                break;\n            default :\n                jj_la1[118] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_242() {\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_421() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_242() {\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_421() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void error(SAXParseException exception) {\n    Assert.fail(exception.toString());\n}", "methodAfter": "public void error(SAXParseException exception) {\n    exception.printStackTrace();\n    Assert.fail(exception.toString());\n}"}, {"methodBefore": "public void warning(SAXParseException exception) {\n    Assert.fail(exception.toString());\n}", "methodAfter": "public void warning(SAXParseException exception) {\n    exception.printStackTrace();\n    Assert.fail(exception.toString());\n}"}, {"methodBefore": "public void fatalError(SAXParseException exception) {\n    Assert.fail(exception.toString());\n}", "methodAfter": "public void fatalError(SAXParseException exception) {\n    exception.printStackTrace();\n    Assert.fail(exception.toString());\n}"}], [{"methodBefore": "public final void ReferenceType() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n            PrimitiveType();\n            label_76 : while (true) {\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n                _sName += \"[]\";\n                if (jj_2_61(2)) {\n                } else {\n                    break label_76;\n                }\n            } \n            break;\n        case IDENTIFIER :\n            ClassOrInterfaceType();\n            label_77 : while (true) {\n                if (jj_2_62(2)) {\n                } else {\n                    break label_77;\n                }\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n                _sName += \"[]\";\n            } \n            break;\n        default :\n            jj_la1[195] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void ReferenceType() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n            PrimitiveType();\n            label_80 : while (true) {\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n                _sName += \"[]\";\n                if (jj_2_60(2)) {\n                } else {\n                    break label_80;\n                }\n            } \n            break;\n        case IDENTIFIER :\n            ClassOrInterfaceType();\n            label_81 : while (true) {\n                if (jj_2_61(2)) {\n                } else {\n                    break label_81;\n                }\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n                _sName += \"[]\";\n            } \n            break;\n        default :\n            jj_la1[201] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void ReferenceType() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n            PrimitiveType();\n            label_76 : while (true) {\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n                _sName += \"[]\";\n                if (jj_2_61(2)) {\n                } else {\n                    break label_76;\n                }\n            } \n            break;\n        case IDENTIFIER :\n            ClassOrInterfaceType();\n            label_77 : while (true) {\n                if (jj_2_62(2)) {\n                } else {\n                    break label_77;\n                }\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n                _sName += \"[]\";\n            } \n            break;\n        default :\n            jj_la1[195] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void ReferenceType() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n            PrimitiveType();\n            label_80 : while (true) {\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n                _sName += \"[]\";\n                if (jj_2_60(2)) {\n                } else {\n                    break label_80;\n                }\n            } \n            break;\n        case IDENTIFIER :\n            ClassOrInterfaceType();\n            label_81 : while (true) {\n                if (jj_2_61(2)) {\n                } else {\n                    break label_81;\n                }\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n                _sName += \"[]\";\n            } \n            break;\n        default :\n            jj_la1[201] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "public final void ExclusiveOrExpression() throws ParseException {\n    AndExpression();\n    label_43 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case XOR :\n                break;\n            default :\n                jj_la1[96] = jj_gen;\n                break label_43;\n        }\n        jj_consume_token(XOR);\n        AndExpression();\n    } \n}", "methodAfter": "public final void ExclusiveOrExpression() throws ParseException {\n    AndExpression();\n    label_43 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case XOR :\n                break;\n            default :\n                jj_la1[95] = jj_gen;\n                break label_43;\n        }\n        jj_consume_token(XOR);\n        AndExpression();\n    } \n}"}, {"methodBefore": "public final void ExclusiveOrExpression() throws ParseException {\n    AndExpression();\n    label_43 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case XOR :\n                break;\n            default :\n                jj_la1[96] = jj_gen;\n                break label_43;\n        }\n        jj_consume_token(XOR);\n        AndExpression();\n    } \n}", "methodAfter": "public final void ExclusiveOrExpression() throws ParseException {\n    AndExpression();\n    label_43 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case XOR :\n                break;\n            default :\n                jj_la1[95] = jj_gen;\n                break label_43;\n        }\n        jj_consume_token(XOR);\n        AndExpression();\n    } \n}"}], [{"methodBefore": "private boolean jj_3_53() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_136()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_52() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_139()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_53() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_136()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_52() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_139()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public SwitchData(int switchNumber, int[] keys) {\n    super();\n    this.switchNumber = switchNumber;\n    defaultHits = 0;\n    hits = new long[keys.length];\n    Arrays.fill(hits, 0);\n    this.keys = new int[keys.length];\n    System.arraycopy(keys, 0, this.keys, 0, keys.length);\n}", "methodAfter": "public SwitchData(int switchNumber, int[] keys) {\n    super();\n    this.switchNumber = switchNumber;\n    defaultHits = 0;\n    hits = new long[keys.length];\n    Arrays.fill(hits, 0);\n    this.keys = new int[keys.length];\n    System.arraycopy(keys, 0, this.keys, 0, keys.length);\n    initLock();\n}"}, {"methodBefore": "public SwitchData(int switchNumber, int min, int max) {\n    super();\n    this.switchNumber = switchNumber;\n    defaultHits = 0;\n    hits = new long[(max - min) + 1];\n    Arrays.fill(hits, 0);\n    this.keys = new int[(max - min) + 1];\n    for (int i = 0; min <= max; keys[i++] = min++);\n}", "methodAfter": "public SwitchData(int switchNumber, int min, int max) {\n    super();\n    this.switchNumber = switchNumber;\n    defaultHits = 0;\n    hits = new long[(max - min) + 1];\n    Arrays.fill(hits, 0);\n    this.keys = new int[(max - min) + 1];\n    for (int i = 0; min <= max; keys[i++] = min++);\n    initLock();\n}"}], [{"methodBefore": "private boolean jj_3_32() {\n    if (jj_3R_112()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_26() {\n    if (jj_3R_112()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_32() {\n    if (jj_3R_112()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_26() {\n    if (jj_3R_112()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_12() {\n    if (jj_3R_95()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_12() {\n    if (jj_3R_99()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_12() {\n    if (jj_3R_95()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_12() {\n    if (jj_3R_99()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public double getBranchCoverageRate() {\n    return ((double) (getNumberOfCoveredBranches())) / getNumberOfValidBranches();\n}", "methodAfter": "public double getBranchCoverageRate() {\n    lock.lock();\n    try {\n        return ((double) (getNumberOfCoveredBranches())) / getNumberOfValidBranches();\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public double getBranchCoverageRate() {\n    if (getNumberOfValidBranches() == 0) {\n        return 1.0;\n    }\n    return ((double) (getNumberOfCoveredBranches())) / getNumberOfValidBranches();\n}", "methodAfter": "public double getBranchCoverageRate() {\n    if (getNumberOfValidBranches() == 0) {\n        return 1.0;\n    }\n    lock.lock();\n    try {\n        return ((double) (getNumberOfCoveredBranches())) / getNumberOfValidBranches();\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "public final void EnumBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case FINAL :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            EnumConstant();\n            label_71 : while (true) {\n                if (jj_2_53(2)) {\n                } else {\n                    break label_71;\n                }\n                jj_consume_token(COMMA);\n                EnumConstant();\n            } \n            break;\n        default :\n            jj_la1[182] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[183] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            label_72 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case CLASS :\n                    case DOUBLE :\n                    case ENUM :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case INTERFACE :\n                    case LONG :\n                    case NATIVE :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SYNCHRONIZED :\n                    case TRANSIENT :\n                    case VOID :\n                    case VOLATILE :\n                    case IDENTIFIER :\n                    case LBRACE :\n                    case SEMICOLON :\n                    case AT :\n                    case LT :\n                        break;\n                    default :\n                        jj_la1[184] = jj_gen;\n                        break label_72;\n                }\n                ClassOrInterfaceBodyDeclaration(false);\n            } \n            break;\n        default :\n            jj_la1[185] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void EnumBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case FINAL :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            EnumConstant();\n            label_74 : while (true) {\n                if (jj_2_52(2)) {\n                } else {\n                    break label_74;\n                }\n                jj_consume_token(COMMA);\n                EnumConstant();\n            } \n            break;\n        default :\n            jj_la1[187] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[188] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            label_75 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case CLASS :\n                    case DOUBLE :\n                    case ENUM :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case INTERFACE :\n                    case LONG :\n                    case NATIVE :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SYNCHRONIZED :\n                    case TRANSIENT :\n                    case VOID :\n                    case VOLATILE :\n                    case IDENTIFIER :\n                    case LBRACE :\n                    case SEMICOLON :\n                    case AT :\n                    case LT :\n                        break;\n                    default :\n                        jj_la1[189] = jj_gen;\n                        break label_75;\n                }\n                ClassOrInterfaceBodyDeclaration(false);\n            } \n            break;\n        default :\n            jj_la1[190] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}"}, {"methodBefore": "public final void EnumBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case FINAL :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            EnumConstant();\n            label_71 : while (true) {\n                if (jj_2_53(2)) {\n                } else {\n                    break label_71;\n                }\n                jj_consume_token(COMMA);\n                EnumConstant();\n            } \n            break;\n        default :\n            jj_la1[182] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[183] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            label_72 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case CLASS :\n                    case DOUBLE :\n                    case ENUM :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case INTERFACE :\n                    case LONG :\n                    case NATIVE :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SYNCHRONIZED :\n                    case TRANSIENT :\n                    case VOID :\n                    case VOLATILE :\n                    case IDENTIFIER :\n                    case LBRACE :\n                    case SEMICOLON :\n                    case AT :\n                    case LT :\n                        break;\n                    default :\n                        jj_la1[184] = jj_gen;\n                        break label_72;\n                }\n                ClassOrInterfaceBodyDeclaration(false);\n            } \n            break;\n        default :\n            jj_la1[185] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void EnumBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case FINAL :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            EnumConstant();\n            label_74 : while (true) {\n                if (jj_2_52(2)) {\n                } else {\n                    break label_74;\n                }\n                jj_consume_token(COMMA);\n                EnumConstant();\n            } \n            break;\n        default :\n            jj_la1[187] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case COMMA :\n            jj_consume_token(COMMA);\n            break;\n        default :\n            jj_la1[188] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case SEMICOLON :\n            jj_consume_token(SEMICOLON);\n            label_75 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT :\n                    case ASSERT :\n                    case BOOLEAN :\n                    case BYTE :\n                    case CHAR :\n                    case CLASS :\n                    case DOUBLE :\n                    case ENUM :\n                    case FINAL :\n                    case FLOAT :\n                    case INT :\n                    case INTERFACE :\n                    case LONG :\n                    case NATIVE :\n                    case PRIVATE :\n                    case PROTECTED :\n                    case PUBLIC :\n                    case SHORT :\n                    case STATIC :\n                    case TESTAAAA :\n                    case SYNCHRONIZED :\n                    case TRANSIENT :\n                    case VOID :\n                    case VOLATILE :\n                    case IDENTIFIER :\n                    case LBRACE :\n                    case SEMICOLON :\n                    case AT :\n                    case LT :\n                        break;\n                    default :\n                        jj_la1[189] = jj_gen;\n                        break label_75;\n                }\n                ClassOrInterfaceBodyDeclaration(false);\n            } \n            break;\n        default :\n            jj_la1[190] = jj_gen;\n    }\n    jj_consume_token(RBRACE);\n}"}], [{"methodBefore": "private boolean jj_3R_416() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_3R_123()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_419() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_3R_126()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_416() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_3R_123()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_419() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_3R_126()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_288() {\n    if (jj_3R_291()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_302()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_284() {\n    if (jj_3R_291()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_295()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_288() {\n    if (jj_3R_291()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_302()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_284() {\n    if (jj_3R_291()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_295()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "public void visitLineNumber(int line, Label start) {\n    currentLine = line;\n    currentJump = 0;\n    instrumentGetClassData();\n    mv.visitIntInsn(SIPUSH, line);\n    mv.visitMethodInsn(INVOKESTATIC, TOUCH_COLLECTOR_CLASS, \"touch\", \"(Ljava/lang/String;I)V\");\n    super.visitLineNumber(line, start);\n}", "methodAfter": "public void visitLineNumber(int line, Label start) {\n    currentLine = line;\n    currentJump = 0;\n    instrumentOwnerClass();\n    mv.visitIntInsn(SIPUSH, line);\n    mv.visitMethodInsn(INVOKESTATIC, TOUCH_COLLECTOR_CLASS, \"touch\", \"(Ljava/lang/String;I)V\");\n    super.visitLineNumber(line, start);\n}"}, {"methodBefore": "private void instrumentJumpHit(boolean branch) {\n    instrumentGetClassData();\n    instrumentPutLineAndBranchNumbers();\n    mv.visitInsn(branch ? BOOLEAN_TRUE : BOOLEAN_FALSE);\n    instrumentInvokeTouchJump();\n}", "methodAfter": "private void instrumentJumpHit(boolean branch) {\n    instrumentOwnerClass();\n    instrumentPutLineAndBranchNumbers();\n    mv.visitInsn(branch ? BOOLEAN_TRUE : BOOLEAN_FALSE);\n    instrumentInvokeTouchJump();\n}"}, {"methodBefore": "private void instrumentSwitchHit(int lineNumber, int switchNumber, int branch) {\n    instrumentGetClassData();\n    mv.visitIntInsn(SIPUSH, lineNumber);\n    mv.visitIntInsn(SIPUSH, switchNumber);\n    mv.visitIntInsn(SIPUSH, branch);\n    instrumentInvokeTouchSwitch();\n}", "methodAfter": "private void instrumentSwitchHit(int lineNumber, int switchNumber, int branch) {\n    instrumentOwnerClass();\n    mv.visitIntInsn(SIPUSH, lineNumber);\n    mv.visitIntInsn(SIPUSH, switchNumber);\n    mv.visitIntInsn(SIPUSH, branch);\n    instrumentInvokeTouchSwitch();\n}"}], [{"methodBefore": "public static void junit(HashMap hashMap) throws Exception {\n    Path classpath = new Path(project);\n    PathElement instDirPathElement = classpath.new PathElement();\n    PathElement buildDirPathElement = classpath.new PathElement();\n    PathElement coberturaClassDirPathElement = classpath.new PathElement();\n    PathElement computerClasspath = classpath.new PathElement();\n    FileSet fileSet = new FileSet();\n    instDirPathElement.setLocation(((File) (hashMap.get(\"instrumentDir\"))));\n    buildDirPathElement.setLocation(((File) (hashMap.get(\"buildDir\"))));\n    coberturaClassDirPathElement.setLocation(getCoberturaClassDir());\n    computerClasspath.setPath(System.getProperty(\"java.class.path\"));\n    fileSet.setDir(new File(\"antLibrary/common/groovy\"));\n    fileSet.setIncludes(\"*.jar\");\n    classpath.add(instDirPathElement);\n    classpath.add(buildDirPathElement);\n    classpath.add(coberturaClassDirPathElement);\n    classpath.add(computerClasspath);\n    classpath.addFileset(fileSet);\n    JUnitTask junit = new JUnitTask();\n    junit.setProject(project);\n    junit.setHaltonfailure(true);\n    junit.setDir(((File) (hashMap.get(\"buildDir\"))));\n    junit.setFork(true);\n    FormatterElement formatter = new FormatterElement();\n    TypeAttribute type = new TypeAttribute();\n    type.setValue(\"xml\");\n    formatter.setType(type);\n    junit.addFormatter(formatter);\n    JUnitTest test = new JUnitTest(((String) (hashMap.get(\"testClass\"))));\n    test.setTodir(((File) (hashMap.get(\"reportDir\"))));\n    junit.addTest(test);\n    junit.setShowOutput(true);\n    junit.createClasspath().add(classpath);\n    System.out.println(System.getProperty(\"java.class.path\"));\n    junit.execute();\n}", "methodAfter": "public static void junit(HashMap hashMap) throws Exception {\n    Path classpath = new Path(project);\n    PathElement instDirPathElement = classpath.new PathElement();\n    PathElement buildDirPathElement = classpath.new PathElement();\n    PathElement coberturaClassDirPathElement = classpath.new PathElement();\n    PathElement computerClasspath = classpath.new PathElement();\n    FileSet fileSet = new FileSet();\n    instDirPathElement.setLocation(((File) (hashMap.get(\"instrumentDir\"))));\n    buildDirPathElement.setLocation(((File) (hashMap.get(\"buildDir\"))));\n    coberturaClassDirPathElement.setLocation(getCoberturaClassDir());\n    computerClasspath.setPath(System.getProperty(\"java.class.path\"));\n    fileSet.setDir(new File(\"antLibrary/common/groovy\"));\n    fileSet.setIncludes(\"*.jar\");\n    classpath.add(instDirPathElement);\n    classpath.add(buildDirPathElement);\n    classpath.add(coberturaClassDirPathElement);\n    classpath.add(computerClasspath);\n    classpath.addFileset(fileSet);\n    JUnitTask junit = new JUnitTask();\n    junit.setProject(project);\n    junit.setHaltonfailure(true);\n    junit.setDir(((File) (hashMap.get(\"buildDir\"))));\n    junit.setFork(true);\n    FormatterElement formatter = new FormatterElement();\n    TypeAttribute type = new TypeAttribute();\n    type.setValue(\"xml\");\n    formatter.setType(type);\n    junit.addFormatter(formatter);\n    JUnitTest test = new JUnitTest(((String) (hashMap.get(\"testClass\"))));\n    test.setTodir(((File) (hashMap.get(\"reportDir\"))));\n    junit.addTest(test);\n    junit.setShowOutput(true);\n    junit.createClasspath().add(classpath);\n    System.out.println(classpath);\n    junit.execute();\n}"}, {"methodBefore": "public static void junit(HashMap hashMap) throws Exception {\n    Path classpath = new Path(project);\n    PathElement instDirPathElement = classpath.new PathElement();\n    PathElement buildDirPathElement = classpath.new PathElement();\n    PathElement coberturaClassDirPathElement = classpath.new PathElement();\n    PathElement computerClasspath = classpath.new PathElement();\n    FileSet fileSet = new FileSet();\n    instDirPathElement.setLocation(((File) (hashMap.get(\"instrumentDir\"))));\n    buildDirPathElement.setLocation(((File) (hashMap.get(\"buildDir\"))));\n    coberturaClassDirPathElement.setLocation(getCoberturaClassDir());\n    computerClasspath.setPath(System.getProperty(\"java.class.path\"));\n    fileSet.setDir(new File(\"antLibrary/common/groovy\"));\n    fileSet.setIncludes(\"*.jar\");\n    classpath.add(instDirPathElement);\n    classpath.add(buildDirPathElement);\n    classpath.add(coberturaClassDirPathElement);\n    classpath.add(computerClasspath);\n    classpath.addFileset(fileSet);\n    JUnitTask junit = new JUnitTask();\n    junit.setProject(project);\n    junit.setHaltonfailure(true);\n    junit.setDir(((File) (hashMap.get(\"buildDir\"))));\n    junit.setFork(true);\n    FormatterElement formatter = new FormatterElement();\n    TypeAttribute type = new TypeAttribute();\n    type.setValue(\"xml\");\n    formatter.setType(type);\n    junit.addFormatter(formatter);\n    JUnitTest test = new JUnitTest(((String) (hashMap.get(\"testClass\"))));\n    test.setTodir(((File) (hashMap.get(\"reportDir\"))));\n    junit.addTest(test);\n    junit.setShowOutput(true);\n    junit.createClasspath().add(classpath);\n    System.out.println(System.getProperty(\"java.class.path\"));\n    junit.execute();\n}", "methodAfter": "public static void junit(HashMap hashMap) throws Exception {\n    Path classpath = new Path(project);\n    PathElement instDirPathElement = classpath.new PathElement();\n    PathElement buildDirPathElement = classpath.new PathElement();\n    PathElement coberturaClassDirPathElement = classpath.new PathElement();\n    PathElement computerClasspath = classpath.new PathElement();\n    FileSet fileSet = new FileSet();\n    instDirPathElement.setLocation(((File) (hashMap.get(\"instrumentDir\"))));\n    buildDirPathElement.setLocation(((File) (hashMap.get(\"buildDir\"))));\n    coberturaClassDirPathElement.setLocation(getCoberturaClassDir());\n    computerClasspath.setPath(System.getProperty(\"java.class.path\"));\n    fileSet.setDir(new File(\"antLibrary/common/groovy\"));\n    fileSet.setIncludes(\"*.jar\");\n    classpath.add(instDirPathElement);\n    classpath.add(buildDirPathElement);\n    classpath.add(coberturaClassDirPathElement);\n    classpath.add(computerClasspath);\n    classpath.addFileset(fileSet);\n    JUnitTask junit = new JUnitTask();\n    junit.setProject(project);\n    junit.setHaltonfailure(true);\n    junit.setDir(((File) (hashMap.get(\"buildDir\"))));\n    junit.setFork(true);\n    FormatterElement formatter = new FormatterElement();\n    TypeAttribute type = new TypeAttribute();\n    type.setValue(\"xml\");\n    formatter.setType(type);\n    junit.addFormatter(formatter);\n    JUnitTest test = new JUnitTest(((String) (hashMap.get(\"testClass\"))));\n    test.setTodir(((File) (hashMap.get(\"reportDir\"))));\n    junit.addTest(test);\n    junit.setShowOutput(true);\n    junit.createClasspath().add(classpath);\n    System.out.println(classpath);\n    junit.execute();\n}"}], [{"methodBefore": "private boolean jj_3R_240() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_239()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_241() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_240()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_240() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_239()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_241() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_240()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_149() {\n    if (jj_3R_177()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_170() {\n    if (jj_3R_167()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_149() {\n    if (jj_3R_177()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_170() {\n    if (jj_3R_167()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public ParseException generateParseException() {\n    jj_expentries.clear();\n    boolean[] la1tokens = new boolean[123];\n    if (jj_kind >= 0) {\n        la1tokens[jj_kind] = true;\n        jj_kind = -1;\n    }\n    for (int i = 0; i < 202; i++) {\n        if (jj_la1[i] == jj_gen) {\n            for (int j = 0; j < 32; j++) {\n                if ((jj_la1_0[i] & (1 << j)) != 0) {\n                    la1tokens[j] = true;\n                }\n                if ((jj_la1_1[i] & (1 << j)) != 0) {\n                    la1tokens[32 + j] = true;\n                }\n                if ((jj_la1_2[i] & (1 << j)) != 0) {\n                    la1tokens[64 + j] = true;\n                }\n                if ((jj_la1_3[i] & (1 << j)) != 0) {\n                    la1tokens[96 + j] = true;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 123; i++) {\n        if (la1tokens[i]) {\n            jj_expentry = new int[1];\n            jj_expentry[0] = i;\n            jj_expentries.add(jj_expentry);\n        }\n    }\n    jj_endpos = 0;\n    jj_rescan_token();\n    jj_add_error_token(0, 0);\n    int[][] exptokseq = new int[jj_expentries.size()][];\n    for (int i = 0; i < jj_expentries.size(); i++) {\n        exptokseq[i] = ((int[]) (jj_expentries.get(i)));\n    }\n    return new ParseException(token, exptokseq, tokenImage);\n}", "methodAfter": "public ParseException generateParseException() {\n    jj_expentries.clear();\n    boolean[] la1tokens = new boolean[124];\n    if (jj_kind >= 0) {\n        la1tokens[jj_kind] = true;\n        jj_kind = -1;\n    }\n    for (int i = 0; i < 208; i++) {\n        if (jj_la1[i] == jj_gen) {\n            for (int j = 0; j < 32; j++) {\n                if ((jj_la1_0[i] & (1 << j)) != 0) {\n                    la1tokens[j] = true;\n                }\n                if ((jj_la1_1[i] & (1 << j)) != 0) {\n                    la1tokens[32 + j] = true;\n                }\n                if ((jj_la1_2[i] & (1 << j)) != 0) {\n                    la1tokens[64 + j] = true;\n                }\n                if ((jj_la1_3[i] & (1 << j)) != 0) {\n                    la1tokens[96 + j] = true;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 124; i++) {\n        if (la1tokens[i]) {\n            jj_expentry = new int[1];\n            jj_expentry[0] = i;\n            jj_expentries.add(jj_expentry);\n        }\n    }\n    jj_endpos = 0;\n    jj_rescan_token();\n    jj_add_error_token(0, 0);\n    int[][] exptokseq = new int[jj_expentries.size()][];\n    for (int i = 0; i < jj_expentries.size(); i++) {\n        exptokseq[i] = ((int[]) (jj_expentries.get(i)));\n    }\n    return new ParseException(token, exptokseq, tokenImage);\n}"}, {"methodBefore": "public ParseException generateParseException() {\n    jj_expentries.clear();\n    boolean[] la1tokens = new boolean[123];\n    if (jj_kind >= 0) {\n        la1tokens[jj_kind] = true;\n        jj_kind = -1;\n    }\n    for (int i = 0; i < 202; i++) {\n        if (jj_la1[i] == jj_gen) {\n            for (int j = 0; j < 32; j++) {\n                if ((jj_la1_0[i] & (1 << j)) != 0) {\n                    la1tokens[j] = true;\n                }\n                if ((jj_la1_1[i] & (1 << j)) != 0) {\n                    la1tokens[32 + j] = true;\n                }\n                if ((jj_la1_2[i] & (1 << j)) != 0) {\n                    la1tokens[64 + j] = true;\n                }\n                if ((jj_la1_3[i] & (1 << j)) != 0) {\n                    la1tokens[96 + j] = true;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 123; i++) {\n        if (la1tokens[i]) {\n            jj_expentry = new int[1];\n            jj_expentry[0] = i;\n            jj_expentries.add(jj_expentry);\n        }\n    }\n    jj_endpos = 0;\n    jj_rescan_token();\n    jj_add_error_token(0, 0);\n    int[][] exptokseq = new int[jj_expentries.size()][];\n    for (int i = 0; i < jj_expentries.size(); i++) {\n        exptokseq[i] = ((int[]) (jj_expentries.get(i)));\n    }\n    return new ParseException(token, exptokseq, tokenImage);\n}", "methodAfter": "public ParseException generateParseException() {\n    jj_expentries.clear();\n    boolean[] la1tokens = new boolean[124];\n    if (jj_kind >= 0) {\n        la1tokens[jj_kind] = true;\n        jj_kind = -1;\n    }\n    for (int i = 0; i < 208; i++) {\n        if (jj_la1[i] == jj_gen) {\n            for (int j = 0; j < 32; j++) {\n                if ((jj_la1_0[i] & (1 << j)) != 0) {\n                    la1tokens[j] = true;\n                }\n                if ((jj_la1_1[i] & (1 << j)) != 0) {\n                    la1tokens[32 + j] = true;\n                }\n                if ((jj_la1_2[i] & (1 << j)) != 0) {\n                    la1tokens[64 + j] = true;\n                }\n                if ((jj_la1_3[i] & (1 << j)) != 0) {\n                    la1tokens[96 + j] = true;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 124; i++) {\n        if (la1tokens[i]) {\n            jj_expentry = new int[1];\n            jj_expentry[0] = i;\n            jj_expentries.add(jj_expentry);\n        }\n    }\n    jj_endpos = 0;\n    jj_rescan_token();\n    jj_add_error_token(0, 0);\n    int[][] exptokseq = new int[jj_expentries.size()][];\n    for (int i = 0; i < jj_expentries.size(); i++) {\n        exptokseq[i] = ((int[]) (jj_expentries.get(i)));\n    }\n    return new ParseException(token, exptokseq, tokenImage);\n}"}], [{"methodBefore": "private boolean jj_3R_393() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_396() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_393() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_396() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_317() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_313() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_317() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_313() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_25() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_3R_106()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_25() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(111)) {\n        jj_scanpos = xsp;\n        if (jj_3R_110()) {\n            return true;\n        }\n    }\n    if (jj_3R_111()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_25() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_3R_106()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_25() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(111)) {\n        jj_scanpos = xsp;\n        if (jj_3R_110()) {\n            return true;\n        }\n    }\n    if (jj_3R_111()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_226() {\n    if (jj_scan_token(BIT_AND)) {\n        return true;\n    }\n    if (jj_3R_184()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_228() {\n    if (jj_scan_token(BIT_AND)) {\n        return true;\n    }\n    if (jj_3R_187()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_226() {\n    if (jj_scan_token(BIT_AND)) {\n        return true;\n    }\n    if (jj_3R_184()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_228() {\n    if (jj_scan_token(BIT_AND)) {\n        return true;\n    }\n    if (jj_3R_187()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_359() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_354() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_359() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_354() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_115() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_39()) {\n        jj_scanpos = xsp;\n        if (jj_3R_163()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_118() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_38()) {\n        jj_scanpos = xsp;\n        if (jj_3R_166()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_115() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_39()) {\n        jj_scanpos = xsp;\n        if (jj_3R_163()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_118() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_38()) {\n        jj_scanpos = xsp;\n        if (jj_3R_166()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (destDir != null) {\n            builder.addArg(\"--destination\", destDir.getAbsolutePath());\n        }\n        if (format != null) {\n            builder.addArg(\"--format\", format);\n        }\n        if (encoding != null) {\n            builder.addArg(\"--encoding\", encoding);\n        }\n        if (srcDir != null) {\n            builder.addArg(srcDir);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error running reports. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (destDir != null) {\n            builder.addArg(\"--destination\", destDir.getAbsolutePath());\n        }\n        if (format != null) {\n            builder.addArg(\"--format\", format);\n        }\n        if (encoding != null) {\n            builder.addArg(\"--encoding\", encoding);\n        }\n        if (srcDir != null) {\n            builder.addArg(srcDir);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    createCommandsFileAndExecute(builder);\n}"}, {"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error running reports. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    createCommandsFileAndExecute(builder);\n}"}], [{"methodBefore": "private boolean jj_3R_242() {\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_421() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_242() {\n    if (jj_3R_142()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_421() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_237() {\n    if (jj_scan_token(EXTENDS)) {\n        return true;\n    }\n    if (jj_3R_103()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_262() {\n    if (jj_scan_token(EXTENDS)) {\n        return true;\n    }\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_237() {\n    if (jj_scan_token(EXTENDS)) {\n        return true;\n    }\n    if (jj_3R_103()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_262() {\n    if (jj_scan_token(EXTENDS)) {\n        return true;\n    }\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_396() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_297() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_396() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_297() {\n    if (jj_3R_307()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_121() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_120() {\n    if (jj_3R_167()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_121() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_120() {\n    if (jj_3R_167()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void FormalParameters15() throws ParseException {\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            FormalParameter15();\n            label_80 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case COMMA :\n                        break;\n                    default :\n                        jj_la1[199] = jj_gen;\n                        break label_80;\n                }\n                jj_consume_token(COMMA);\n                FormalParameter15();\n            } \n            break;\n        default :\n            jj_la1[200] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}", "methodAfter": "public final void FormalParameters15() throws ParseException {\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            FormalParameter15();\n            label_84 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case COMMA :\n                        break;\n                    default :\n                        jj_la1[205] = jj_gen;\n                        break label_84;\n                }\n                jj_consume_token(COMMA);\n                FormalParameter15();\n            } \n            break;\n        default :\n            jj_la1[206] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}"}, {"methodBefore": "public final void FormalParameters15() throws ParseException {\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            FormalParameter15();\n            label_80 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case COMMA :\n                        break;\n                    default :\n                        jj_la1[199] = jj_gen;\n                        break label_80;\n                }\n                jj_consume_token(COMMA);\n                FormalParameter15();\n            } \n            break;\n        default :\n            jj_la1[200] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}", "methodAfter": "public final void FormalParameters15() throws ParseException {\n    jj_consume_token(LPAREN);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ABSTRACT :\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FINAL :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case NATIVE :\n        case PRIVATE :\n        case PROTECTED :\n        case PUBLIC :\n        case SHORT :\n        case STATIC :\n        case TESTAAAA :\n        case SYNCHRONIZED :\n        case TRANSIENT :\n        case VOLATILE :\n        case IDENTIFIER :\n        case AT :\n            FormalParameter15();\n            label_84 : while (true) {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case COMMA :\n                        break;\n                    default :\n                        jj_la1[205] = jj_gen;\n                        break label_84;\n                }\n                jj_consume_token(COMMA);\n                FormalParameter15();\n            } \n            break;\n        default :\n            jj_la1[206] = jj_gen;\n    }\n    jj_consume_token(RPAREN);\n}"}], [{"methodBefore": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(cv);\n}", "methodAfter": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, cv);\n}"}, {"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}], [{"methodBefore": "public final void ClassOrInterfaceType() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    _sName = getToken(0).image;\n    if (_tmpResultToken == null) {\n        _tmpResultToken = getToken(0);\n        Util.debug(\"ClassOrInterfaceType._tmpResultToken: \" + _tmpResultToken);\n    }\n    if (jj_2_54(4)) {\n        TypeArguments();\n    } else {\n    }\n    label_73 : while (true) {\n        if (jj_2_55(2)) {\n        } else {\n            break label_73;\n        }\n        jj_consume_token(DOT);\n        jj_consume_token(IDENTIFIER);\n        _sName += \".\" + getToken(0).image;\n        if (jj_2_56(2)) {\n            TypeArguments();\n        } else {\n        }\n    } \n}", "methodAfter": "public final void ClassOrInterfaceType() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    _sName = getToken(0).image;\n    if (_tmpResultToken == null) {\n        _tmpResultToken = getToken(0);\n        Util.debug(\"ClassOrInterfaceType._tmpResultToken: \" + _tmpResultToken);\n    }\n    if (jj_2_53(4)) {\n        TypeArguments();\n    } else {\n    }\n    label_76 : while (true) {\n        if (jj_2_54(2)) {\n        } else {\n            break label_76;\n        }\n        jj_consume_token(DOT);\n        jj_consume_token(IDENTIFIER);\n        _sName += \".\" + getToken(0).image;\n        if (jj_2_55(2)) {\n            TypeArguments();\n        } else {\n        }\n    } \n}"}, {"methodBefore": "public final void ClassOrInterfaceType() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    _sName = getToken(0).image;\n    if (_tmpResultToken == null) {\n        _tmpResultToken = getToken(0);\n        Util.debug(\"ClassOrInterfaceType._tmpResultToken: \" + _tmpResultToken);\n    }\n    if (jj_2_54(4)) {\n        TypeArguments();\n    } else {\n    }\n    label_73 : while (true) {\n        if (jj_2_55(2)) {\n        } else {\n            break label_73;\n        }\n        jj_consume_token(DOT);\n        jj_consume_token(IDENTIFIER);\n        _sName += \".\" + getToken(0).image;\n        if (jj_2_56(2)) {\n            TypeArguments();\n        } else {\n        }\n    } \n}", "methodAfter": "public final void ClassOrInterfaceType() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    _sName = getToken(0).image;\n    if (_tmpResultToken == null) {\n        _tmpResultToken = getToken(0);\n        Util.debug(\"ClassOrInterfaceType._tmpResultToken: \" + _tmpResultToken);\n    }\n    if (jj_2_53(4)) {\n        TypeArguments();\n    } else {\n    }\n    label_76 : while (true) {\n        if (jj_2_54(2)) {\n        } else {\n            break label_76;\n        }\n        jj_consume_token(DOT);\n        jj_consume_token(IDENTIFIER);\n        _sName += \".\" + getToken(0).image;\n        if (jj_2_55(2)) {\n            TypeArguments();\n        } else {\n        }\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_319() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_319() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_320() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_320() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_319() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_319() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_320() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_320() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_238() {\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_3R_103()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_263() {\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_238() {\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_3R_103()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_263() {\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_361() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_132() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_361() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_132() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_423() {\n    if (jj_3R_411()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_423() {\n    if (jj_3R_359()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_423() {\n    if (jj_3R_411()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_423() {\n    if (jj_3R_359()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_418() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_141() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_418() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_141() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_231() {\n    if (jj_3R_189()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_256()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_233() {\n    if (jj_3R_192()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_257()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_231() {\n    if (jj_3R_189()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_256()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_233() {\n    if (jj_3R_192()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_257()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "public void testEquals() {\n    assertFalse(a.equals(null));\n    assertFalse(a.equals(Integer.valueOf(4)));\n    assertTrue(a.equals(a));\n    assertFalse(a.equals(b));\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 });\n    assertTrue(a.equals(aPrime));\n}", "methodAfter": "public void testEquals() {\n    assertFalse(a.equals(null));\n    assertFalse(a.equals(Integer.valueOf(4)));\n    assertTrue(a.equals(a));\n    assertFalse(a.equals(b));\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 }, Integer.MAX_VALUE);\n    assertTrue(a.equals(aPrime));\n}"}, {"methodBefore": "public void testHashCode() {\n    assertEquals(a.hashCode(), a.hashCode());\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 });\n    assertEquals(a.hashCode(), aPrime.hashCode());\n}", "methodAfter": "public void testHashCode() {\n    assertEquals(a.hashCode(), a.hashCode());\n    SwitchData aPrime = new SwitchData(0, new int[]{ 0, 1, 2, 3 }, Integer.MAX_VALUE);\n    assertEquals(a.hashCode(), aPrime.hashCode());\n}"}], [{"methodBefore": "private boolean jj_3R_117() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_164()) {\n        jj_scanpos = xsp;\n        if (jj_3R_165()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_117() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(64)) {\n        jj_scanpos = xsp;\n        if (jj_3R_165()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_117() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_164()) {\n        jj_scanpos = xsp;\n        if (jj_3R_165()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_117() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(64)) {\n        jj_scanpos = xsp;\n        if (jj_3R_165()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_25() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_3R_106()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_25() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(111)) {\n        jj_scanpos = xsp;\n        if (jj_3R_110()) {\n            return true;\n        }\n    }\n    if (jj_3R_111()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_25() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_3R_106()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_25() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(111)) {\n        jj_scanpos = xsp;\n        if (jj_3R_110()) {\n            return true;\n        }\n    }\n    if (jj_3R_111()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_24() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_24() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_24() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_24() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_372() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_372() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_372() {\n    if (jj_scan_token(SYNCHRONIZED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_372() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_62 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[163] = jj_gen;\n                break label_62;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}", "methodAfter": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}"}, {"methodBefore": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_62 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[163] = jj_gen;\n                break label_62;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}", "methodAfter": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}"}], [{"methodBefore": "private boolean jj_3R_102() {\n    if (jj_3R_151()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_32()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_106() {\n    if (jj_3R_154()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_31()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_102() {\n    if (jj_3R_151()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_32()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_106() {\n    if (jj_3R_154()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_31()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_315() {\n    if (jj_3R_345()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_448() {\n    if (jj_3R_456()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_315() {\n    if (jj_3R_345()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_448() {\n    if (jj_3R_456()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_168() {\n    if (jj_3R_191()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_176() {\n    if (jj_3R_197()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_168() {\n    if (jj_3R_191()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_176() {\n    if (jj_3R_197()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_350() {\n    if (jj_scan_token(IMPLEMENTS)) {\n        return true;\n    }\n    if (jj_3R_363()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_353() {\n    if (jj_scan_token(IMPLEMENTS)) {\n        return true;\n    }\n    if (jj_3R_366()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_350() {\n    if (jj_scan_token(IMPLEMENTS)) {\n        return true;\n    }\n    if (jj_3R_363()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_353() {\n    if (jj_scan_token(IMPLEMENTS)) {\n        return true;\n    }\n    if (jj_3R_366()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void execute() throws BuildException {\n    Copyright.print(System.out);\n    getJava().createArg().setValue(\"-i\");\n    getJava().createArg().setValue(coverageDataFileName);\n    getJava().createArg().setValue(\"-s\");\n    getJava().createArg().setValue(src.toString());\n    getJava().createArg().setValue(\"-o\");\n    getJava().createArg().setValue(destDir.toString());\n    getJava().createArg().setValue(\"-f\");\n    getJava().createArg().setValue(format);\n    if (getJava().executeJava() != 0) {\n        throw new BuildException();\n    }\n}", "methodAfter": "public void execute() throws BuildException {\n    Header.print(System.out);\n    getJava().createArg().setValue(\"-i\");\n    getJava().createArg().setValue(coverageDataFileName);\n    getJava().createArg().setValue(\"-s\");\n    getJava().createArg().setValue(src.toString());\n    getJava().createArg().setValue(\"-o\");\n    getJava().createArg().setValue(destDir.toString());\n    getJava().createArg().setValue(\"-f\");\n    getJava().createArg().setValue(format);\n    if (getJava().executeJava() != 0) {\n        throw new BuildException();\n    }\n}"}, {"methodBefore": "void coverage(String[] filenames) {\n    if (filenames.length == 0) {\n        return;\n    }\n    for (int i = 0; i < filenames.length; i++) {\n        getProject().log((\"Adding \" + filenames[i]) + \" to list\", MSG_VERBOSE);\n        addArg(filenames[i]);\n    }\n    saveArgs();\n    Copyright.print(System.out);\n    System.out.println((((\"instrumenting \" + filenames.length) + \" \") + (filenames.length == 1 ? \"class\" : \"classes\")) + (toDir != null ? \" to \" + toDir : \"\"));\n    if (getJava().executeJava() != 0) {\n        throw new BuildException();\n    }\n}", "methodAfter": "void coverage(String[] filenames) {\n    if (filenames.length == 0) {\n        return;\n    }\n    for (int i = 0; i < filenames.length; i++) {\n        getProject().log((\"Adding \" + filenames[i]) + \" to list\", MSG_VERBOSE);\n        addArg(filenames[i]);\n    }\n    saveArgs();\n    Header.print(System.out);\n    System.out.println((((\"instrumenting \" + filenames.length) + \" \") + (filenames.length == 1 ? \"class\" : \"classes\")) + (toDir != null ? \" to \" + toDir : \"\"));\n    if (getJava().executeJava() != 0) {\n        throw new BuildException();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_245() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_242() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_245() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_242() {\n    if (jj_3R_265()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_404() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_311()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_405() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_404() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_311()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_405() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_84() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_52()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_360() {\n    if (jj_3R_139()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_52()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_84() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_52()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_360() {\n    if (jj_3R_139()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_52()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_215() {\n    if (jj_scan_token(DECR)) {\n        return true;\n    }\n    if (jj_3R_102()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_217() {\n    if (jj_scan_token(DECR)) {\n        return true;\n    }\n    if (jj_3R_106()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_215() {\n    if (jj_scan_token(DECR)) {\n        return true;\n    }\n    if (jj_3R_102()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_217() {\n    if (jj_scan_token(DECR)) {\n        return true;\n    }\n    if (jj_3R_106()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_370() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_370() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_370() {\n    if (jj_scan_token(FINAL)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_370() {\n    if (jj_scan_token(PRIVATE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_437() {\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_428() {\n    if (jj_3R_311()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_437() {\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_428() {\n    if (jj_3R_311()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_93() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_93() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_93() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_93() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public Javancss(InputStream isJavaSource_) {\n    Util.debug(\"Javancss.<init>(InputStream).sJavaSourceFile_: \" + isJavaSource_);\n    _sErrorMessage = null;\n    _vJavaSourceFiles = new ArrayList();\n    try {\n        _measureRoot(newReader(isJavaSource_));\n    } catch (Exception e) {\n        Util.debug(\"Javancss.<init>(InputStream).e: \" + e);\n        e.printStackTrace();\n    } catch (TokenMgrError pError) {\n        Util.debug(\"Javancss.<init>(InputStream).pError: \" + pError);\n        pError.printStackTrace();\n    }\n}", "methodAfter": "public Javancss(InputStream isJavaSource_) {\n    Util.debug(\"Javancss.<init>(InputStream).sJavaSourceFile_: \" + isJavaSource_);\n    _sErrorMessage = null;\n    _vJavaSourceFiles = null;\n    try {\n        _measureRoot(newReader(isJavaSource_));\n    } catch (Exception e) {\n        Util.debug(\"Javancss.<init>(InputStream).e: \" + e);\n        e.printStackTrace();\n    } catch (TokenMgrError pError) {\n        Util.debug(\"Javancss.<init>(InputStream).pError: \" + pError);\n        pError.printStackTrace();\n    }\n}"}, {"methodBefore": "public Javancss(InputStream isJavaSource_) {\n    Util.debug(\"Javancss.<init>(InputStream).sJavaSourceFile_: \" + isJavaSource_);\n    _sErrorMessage = null;\n    _vJavaSourceFiles = new ArrayList();\n    try {\n        _measureRoot(newReader(isJavaSource_));\n    } catch (Exception e) {\n        Util.debug(\"Javancss.<init>(InputStream).e: \" + e);\n        e.printStackTrace();\n    } catch (TokenMgrError pError) {\n        Util.debug(\"Javancss.<init>(InputStream).pError: \" + pError);\n        pError.printStackTrace();\n    }\n}", "methodAfter": "public Javancss(InputStream isJavaSource_) {\n    Util.debug(\"Javancss.<init>(InputStream).sJavaSourceFile_: \" + isJavaSource_);\n    _sErrorMessage = null;\n    _vJavaSourceFiles = null;\n    try {\n        _measureRoot(newReader(isJavaSource_));\n    } catch (Exception e) {\n        Util.debug(\"Javancss.<init>(InputStream).e: \" + e);\n        e.printStackTrace();\n    } catch (TokenMgrError pError) {\n        Util.debug(\"Javancss.<init>(InputStream).pError: \" + pError);\n        pError.printStackTrace();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_258() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_280()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_259() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_283()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_258() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_280()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_259() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_283()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "private void generateClassList(PackageData packageData) throws IOException {\n    String filename;\n    Collection classes;\n    if (packageData == null) {\n        filename = \"frame-classes.html\";\n        classes = projectData.getClasses();\n    } else {\n        filename = (\"frame-classes-\" + packageData.getName()) + \".html\";\n        classes = packageData.getChildren();\n    }\n    File file = new File(outputDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<h5>Classes</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        Iterator iter;\n        Map sortedClassList = new TreeMap();\n        iter = classes.iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            sortedClassList.put(classData.getBaseName(), classData);\n        } \n        iter = sortedClassList.values().iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            out.println(\"<tr>\");\n            String percentCovered;\n            if (classData.getNumberOfValidLines() > 0) {\n                percentCovered = getPercentValue(classData.getLineCoverageRate());\n            } else {\n                percentCovered = \"N/A\";\n            }\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + classData.getName()) + \".html\\\">\") + classData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</td>\");\n        out.println(\"</tr>\");\n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateClassList(PackageData packageData) throws IOException {\n    String filename;\n    Collection classes;\n    if (packageData == null) {\n        filename = \"frame-classes.html\";\n        classes = projectData.getClasses();\n    } else {\n        filename = (\"frame-classes-\" + packageData.getName()) + \".html\";\n        classes = packageData.getChildren();\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<h5>Classes</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        Iterator iter;\n        Map sortedClassList = new TreeMap();\n        iter = classes.iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            sortedClassList.put(classData.getBaseName(), classData);\n        } \n        iter = sortedClassList.values().iterator();\n        while (iter.hasNext()) {\n            ClassData classData = ((ClassData) (iter.next()));\n            out.println(\"<tr>\");\n            String percentCovered;\n            if (classData.getNumberOfValidLines() > 0) {\n                percentCovered = getPercentValue(classData.getLineCoverageRate());\n            } else {\n                percentCovered = \"N/A\";\n            }\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + classData.getName()) + \".html\\\">\") + classData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</td>\");\n        out.println(\"</tr>\");\n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateSourceFile(ClassData classData) throws IOException {\n    String filename = classData.getName() + \".html\";\n    File file = new File(outputDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = classData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classData.getPackageName() + \".\");\n        }\n        out.print(classData.getName());\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeaderForClasses());\n        out.println(generateTableRowForClass(classData));\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<p>\");\n        out.println(\"<table cellspacing=\\\"0\\\" cellpadding=\\\"0\\\" class=\\\"src\\\">\");\n        BufferedReader br = null;\n        try {\n            File sourceFile = new File(sourceDir, classData.getSourceFileName());\n            br = new BufferedReader(new FileReader(sourceFile));\n            String lineStr;\n            JavaToHtml javaToHtml = new JavaToHtml();\n            int lineNumber = 1;\n            while ((lineStr = br.readLine()) != null) {\n                out.println(\"<tr>\");\n                if (classData.isValidSourceLineNumber(lineNumber)) {\n                    long numberOfHits = classData.getHitCount(lineNumber);\n                    out.println((\"  <td class=\\\"numLineCover\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    if (numberOfHits > 0) {\n                        out.println((\"  <td class=\\\"nbHitsCovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                    } else {\n                        out.println((\"  <td class=\\\"nbHitsUncovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\"><span class=\\\"srcUncovered\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</span></pre></td>\");\n                    }\n                } else {\n                    out.println((\"  <td class=\\\"numLine\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    out.println(\"  <td class=\\\"nbHits\\\">&nbsp;</td>\");\n                    out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                }\n                out.println(\"</tr>\");\n                lineNumber++;\n            } \n        } finally {\n            if (br != null) {\n                br.close();\n            }\n        }\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Reports generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFile(ClassData classData) throws IOException {\n    String filename = classData.getName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = classData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classData.getPackageName() + \".\");\n        }\n        out.print(classData.getName());\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeaderForClasses());\n        out.println(generateTableRowForClass(classData));\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<p>\");\n        out.println(\"<table cellspacing=\\\"0\\\" cellpadding=\\\"0\\\" class=\\\"src\\\">\");\n        BufferedReader br = null;\n        try {\n            File sourceFile = new File(sourceDir, classData.getSourceFileName());\n            br = new BufferedReader(new FileReader(sourceFile));\n            String lineStr;\n            JavaToHtml javaToHtml = new JavaToHtml();\n            int lineNumber = 1;\n            while ((lineStr = br.readLine()) != null) {\n                out.println(\"<tr>\");\n                if (classData.isValidSourceLineNumber(lineNumber)) {\n                    long numberOfHits = classData.getHitCount(lineNumber);\n                    out.println((\"  <td class=\\\"numLineCover\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    if (numberOfHits > 0) {\n                        out.println((\"  <td class=\\\"nbHitsCovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                    } else {\n                        out.println((\"  <td class=\\\"nbHitsUncovered\\\">&nbsp;\" + numberOfHits) + \"</td>\");\n                        out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\"><span class=\\\"srcUncovered\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</span></pre></td>\");\n                    }\n                } else {\n                    out.println((\"  <td class=\\\"numLine\\\">&nbsp;\" + lineNumber) + \"</td>\");\n                    out.println(\"  <td class=\\\"nbHits\\\">&nbsp;</td>\");\n                    out.println((\"  <td class=\\\"src\\\"><pre class=\\\"src\\\">&nbsp;\" + javaToHtml.process(lineStr)) + \"</pre></td>\");\n                }\n                out.println(\"</tr>\");\n                lineNumber++;\n            } \n        } finally {\n            if (br != null) {\n                br.close();\n            }\n        }\n        out.println(\"</table>\");\n        out.println(\"</p>\");\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Reports generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generatePackageList() throws IOException {\n    File file = new File(outputDir, \"frame-packages.html\");\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onClick=\\'parent.classList.location.href=\\\"frame-classes.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        SortedSet sortedPackages = new TreeSet();\n        sortedPackages.addAll(projectData.getChildren());\n        Iterator iter = sortedPackages.iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-classes-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onClick=\\'parent.classList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generatePackageList() throws IOException {\n    File file = new File(destinationDir, \"frame-packages.html\");\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onClick=\\'parent.classList.location.href=\\\"frame-classes.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        SortedSet sortedPackages = new TreeSet();\n        sortedPackages.addAll(projectData.getChildren());\n        Iterator iter = sortedPackages.iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-classes-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onClick=\\'parent.classList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "public HTMLReport(ProjectData projectData, File outputDir, File sourceDir) throws Exception {\n    this.outputDir = outputDir;\n    this.sourceDir = sourceDir;\n    this.projectData = projectData;\n    CopyFiles.copy(outputDir);\n    generatePackageList();\n    generateClassLists();\n    generateOverviews();\n    generateSourceFiles();\n}", "methodAfter": "public HTMLReport(ProjectData projectData, File outputDir, File sourceDir) throws Exception {\n    this.destinationDir = outputDir;\n    this.sourceDir = sourceDir;\n    this.projectData = projectData;\n    CopyFiles.copy(outputDir);\n    generatePackageList();\n    generateClassLists();\n    generateOverviews();\n    generateSourceFiles();\n}"}, {"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(outputDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/percentagesorttype.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(\"<thead>\");\n        out.println(\"<tr>\");\n        out.println(\"  <td class=\\\"heading\\\">Package</td>\");\n        out.println(\"  <td class=\\\"heading\\\"># Classes</td>\");\n        out.println(generateCommonTableColumns());\n        out.println(\"</tr>\");\n        out.println(\"</thead>\");\n        out.println(\"<tbody>\");\n        Collection packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getChildren();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        if (packages.size() > 0) {\n            Iterator iter = packages.iterator();\n            while (iter.hasNext()) {\n                PackageData subPackageData = ((PackageData) (iter.next()));\n                out.println(generateTableRowForPackage(subPackageData));\n            } \n        }\n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"Number\\\", \\\"Number\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        out.println(\"</p>\");\n        Collection classes;\n        if (packageData == null) {\n            classes = new TreeSet();\n            if (projectData.getNumberOfClasses() > 0) {\n                Iterator iter = projectData.getClasses().iterator();\n                while (iter.hasNext()) {\n                    ClassData classData = ((ClassData) (iter.next()));\n                    if (classData.getPackageName() == null) {\n                        classes.add(classData);\n                    }\n                } \n            }\n        } else {\n            classes = packageData.getChildren();\n        }\n        if (classes.size() > 0) {\n            out.println(\"<p>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeaderForClasses());\n            out.println(\"<tbody>\");\n            Iterator iter = classes.iterator();\n            while (iter.hasNext()) {\n                ClassData classData = ((ClassData) (iter.next()));\n                out.println(generateTableRowForClass(classData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"Number\\\", \\\"Number\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n            out.println(\"</p>\");\n        }\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Report generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/percentagesorttype.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(\"<thead>\");\n        out.println(\"<tr>\");\n        out.println(\"  <td class=\\\"heading\\\">Package</td>\");\n        out.println(\"  <td class=\\\"heading\\\"># Classes</td>\");\n        out.println(generateCommonTableColumns());\n        out.println(\"</tr>\");\n        out.println(\"</thead>\");\n        out.println(\"<tbody>\");\n        Collection packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getChildren();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        if (packages.size() > 0) {\n            Iterator iter = packages.iterator();\n            while (iter.hasNext()) {\n                PackageData subPackageData = ((PackageData) (iter.next()));\n                out.println(generateTableRowForPackage(subPackageData));\n            } \n        }\n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"Number\\\", \\\"Number\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        out.println(\"</p>\");\n        Collection classes;\n        if (packageData == null) {\n            classes = new TreeSet();\n            if (projectData.getNumberOfClasses() > 0) {\n                Iterator iter = projectData.getClasses().iterator();\n                while (iter.hasNext()) {\n                    ClassData classData = ((ClassData) (iter.next()));\n                    if (classData.getPackageName() == null) {\n                        classes.add(classData);\n                    }\n                } \n            }\n        } else {\n            classes = packageData.getChildren();\n        }\n        if (classes.size() > 0) {\n            out.println(\"<p>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeaderForClasses());\n            out.println(\"<tbody>\");\n            Iterator iter = classes.iterator();\n            while (iter.hasNext()) {\n                ClassData classData = ((ClassData) (iter.next()));\n                out.println(generateTableRowForClass(classData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"Number\\\", \\\"Number\\\", \\\"Number\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n            out.println(\"</p>\");\n        }\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Report generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3_36() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_scan_token(THIS)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_35() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_scan_token(THIS)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_36() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_scan_token(THIS)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_35() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_scan_token(THIS)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_398() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_398() {\n    if (jj_3R_414()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_398() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_398() {\n    if (jj_3R_414()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_426() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_426() {\n    if (jj_3R_414()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_426() {\n    if (jj_3R_412()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_426() {\n    if (jj_3R_414()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_37() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_115()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_36() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_118()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_37() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_115()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_36() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_118()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_417() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_420() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_417() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_420() {\n    if (jj_scan_token(INTERFACE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_282() {\n    if (jj_scan_token(BIT_OR)) {\n        return true;\n    }\n    if (jj_3R_259()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_261() {\n    if (jj_scan_token(BIT_OR)) {\n        return true;\n    }\n    if (jj_3R_237()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_282() {\n    if (jj_scan_token(BIT_OR)) {\n        return true;\n    }\n    if (jj_3R_259()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_261() {\n    if (jj_scan_token(BIT_OR)) {\n        return true;\n    }\n    if (jj_3R_237()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_206() {\n    if (jj_3R_220()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_206() {\n    if (jj_3R_219()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_206() {\n    if (jj_3R_220()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_206() {\n    if (jj_3R_219()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_104() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_100() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_104() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_100() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_165() {\n    if (jj_3R_191()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_165() {\n    if (jj_3R_114()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_165() {\n    if (jj_3R_191()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_165() {\n    if (jj_3R_114()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_176() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_175()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_280() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_176() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_175()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_280() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_113() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_102() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_113() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_102() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getLineCoverageRate() {\n    synchronizeState();\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}, {"methodBefore": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidLines() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getBranchCoverageRate() {\n    synchronizeState();\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}], [{"methodBefore": "public int hashCode() {\n    return this.children.size();\n}", "methodAfter": "public int hashCode() {\n    lock.lock();\n    try {\n        return this.children.size();\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public int getNumberOfChildren() {\n    return this.children.size();\n}", "methodAfter": "public int getNumberOfChildren() {\n    lock.lock();\n    try {\n        return this.children.size();\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private boolean jj_3_22() {\n    if (jj_3R_103()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_22() {\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_22() {\n    if (jj_3R_103()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_22() {\n    if (jj_3R_107()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "@Test\npublic void flushCoberturaData() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentCobertura\", true);\n            put(\"deployCoberturaFlush\", true);\n            put(\"modifyMainCoberturaDataFile\", true);\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SAVE_DATA_CLASSNAME, SAVE_DATA_METHOD_NAME);\n    assertEquals(0, hitCountBefore);\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SAVE_DATA_CLASSNAME, SAVE_DATA_METHOD_NAME);\n    webappServer.killServer();\n    assertEquals(\"hit count should have increased by one\", hitCountBefore + 1, hitCountAfter);\n}", "methodAfter": "@Test\npublic void flushCoberturaData() throws Exception {\n    Logger.getRootLogger().setLevel(Level.ALL);\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    new File(webappServerDir, \"logs\").mkdirs();\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentCobertura\", true);\n            put(\"deployCoberturaFlush\", true);\n            put(\"modifyMainCoberturaDataFile\", true);\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SAVE_DATA_CLASSNAME, SAVE_DATA_METHOD_NAME);\n    assertEquals(0, hitCountBefore);\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SAVE_DATA_CLASSNAME, SAVE_DATA_METHOD_NAME);\n    webappServer.killServer();\n    assertEquals(\"hit count should have increased by one\", hitCountBefore + 1, hitCountAfter);\n}"}, {"methodBefore": "@Test\npublic void flushCoberturaData() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentCobertura\", true);\n            put(\"deployCoberturaFlush\", true);\n            put(\"modifyMainCoberturaDataFile\", true);\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SAVE_DATA_CLASSNAME, SAVE_DATA_METHOD_NAME);\n    assertEquals(0, hitCountBefore);\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SAVE_DATA_CLASSNAME, SAVE_DATA_METHOD_NAME);\n    webappServer.killServer();\n    assertEquals(\"hit count should have increased by one\", hitCountBefore + 1, hitCountAfter);\n}", "methodAfter": "@Test\npublic void flushCoberturaData() throws Exception {\n    Logger.getRootLogger().setLevel(Level.ALL);\n    File tempDir = TestUtils.getTempDir();\n    File webappServerDir = new File(tempDir, \"webserver\");\n    final File srcDir = new File(tempDir, SRC_DIR);\n    new File(webappServerDir, \"logs\").mkdirs();\n    WebappServer.writeSimpleServletSource(srcDir);\n    final String appName = \"simple\";\n    WebappServer webappServer = new WebappServer(webappServerDir, false);\n    webappServer.deployApp(new HashMap() {\n        {\n            put(\"webInfText\", SIMPLE_SERVLET_WEB_XML_TEXT);\n            put(\"srcDir\", srcDir);\n            put(\"appName\", appName);\n            put(\"instrumentCobertura\", true);\n            put(\"deployCoberturaFlush\", true);\n            put(\"modifyMainCoberturaDataFile\", true);\n        }\n    });\n    Map data = webappServer.withRunningServer(new Closure(null) {\n        public void doCall(HashMap values) {\n        }\n    });\n    String webappResponse = IOUtils.toString(new URL((((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/\") + appName) + \"/SimpleServlet\").openConnection().getInputStream());\n    assertEquals(\"Webapp response was incorrect\", \"Hi\", webappResponse.trim());\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    Node dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountBefore = TestUtils.getHitCount(dom, SAVE_DATA_CLASSNAME, SAVE_DATA_METHOD_NAME);\n    assertEquals(0, hitCountBefore);\n    String flushing = IOUtils.toString(new URL((((\"http://\" + data.get(\"hostname\")) + \":\") + data.get(\"webappPort\")) + \"/coberturaFlush/flushCobertura\").openConnection().getInputStream());\n    assertEquals(\"\", flushing);\n    Thread.sleep(10 * 1000);\n    reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(((File) (data.get(\"datafile\"))).getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(new File(((File) (data.get(\"xmlReport\"))).getParent()));\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(((File) (data.get(\"xmlReport\"))).getAbsolutePath());\n    int hitCountAfter = TestUtils.getHitCount(dom, SAVE_DATA_CLASSNAME, SAVE_DATA_METHOD_NAME);\n    webappServer.killServer();\n    assertEquals(\"hit count should have increased by one\", hitCountBefore + 1, hitCountAfter);\n}"}], [{"methodBefore": "public final void IfStatement() throws ParseException {\n    jj_consume_token(IF);\n    jj_consume_token(LPAREN);\n    Expression();\n    jj_consume_token(RPAREN);\n    Statement();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ELSE :\n            jj_consume_token(ELSE);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            Statement();\n            break;\n        default :\n            jj_la1[148] = jj_gen;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void IfStatement() throws ParseException {\n    jj_consume_token(IF);\n    jj_consume_token(LPAREN);\n    Expression();\n    jj_consume_token(RPAREN);\n    Statement();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ELSE :\n            jj_consume_token(ELSE);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            Statement();\n            break;\n        default :\n            jj_la1[149] = jj_gen;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}, {"methodBefore": "public final void IfStatement() throws ParseException {\n    jj_consume_token(IF);\n    jj_consume_token(LPAREN);\n    Expression();\n    jj_consume_token(RPAREN);\n    Statement();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ELSE :\n            jj_consume_token(ELSE);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            Statement();\n            break;\n        default :\n            jj_la1[148] = jj_gen;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}", "methodAfter": "public final void IfStatement() throws ParseException {\n    jj_consume_token(IF);\n    jj_consume_token(LPAREN);\n    Expression();\n    jj_consume_token(RPAREN);\n    Statement();\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case ELSE :\n            jj_consume_token(ELSE);\n            _ncss++;\n            Util.debug(\"_ncss++\");\n            Statement();\n            break;\n        default :\n            jj_la1[149] = jj_gen;\n    }\n    _ncss++;\n    Util.debug(\"_ncss++\");\n}"}], [{"methodBefore": "private boolean jj_3R_275() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_278() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_275() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_278() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_430() {\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_433() {\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_430() {\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_433() {\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    if (jj_3R_120()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_13() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_96()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_97()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(CLASS)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_13() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_100()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_101()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(CLASS)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_13() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_96()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_97()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(CLASS)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_13() {\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_100()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_101()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_scan_token(CLASS)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_388() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_388() {\n    if (jj_3R_410()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_388() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_388() {\n    if (jj_3R_410()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public SwitchData(int switchNumber, int[] keys) {\n    super();\n    this.switchNumber = switchNumber;\n    defaultHits = 0;\n    hits = new long[keys.length];\n    Arrays.fill(hits, 0);\n    this.keys = new int[keys.length];\n    System.arraycopy(keys, 0, this.keys, 0, keys.length);\n}", "methodAfter": "public SwitchData(int switchNumber, int[] keys) {\n    super();\n    this.switchNumber = switchNumber;\n    defaultHits = 0;\n    hits = new long[keys.length];\n    Arrays.fill(hits, 0);\n    this.keys = new int[keys.length];\n    System.arraycopy(keys, 0, this.keys, 0, keys.length);\n    initLock();\n}"}, {"methodBefore": "public SwitchData(int switchNumber, int min, int max) {\n    super();\n    this.switchNumber = switchNumber;\n    defaultHits = 0;\n    hits = new long[(max - min) + 1];\n    Arrays.fill(hits, 0);\n    this.keys = new int[(max - min) + 1];\n    for (int i = 0; min <= max; keys[i++] = min++);\n}", "methodAfter": "public SwitchData(int switchNumber, int min, int max) {\n    super();\n    this.switchNumber = switchNumber;\n    defaultHits = 0;\n    hits = new long[(max - min) + 1];\n    Arrays.fill(hits, 0);\n    this.keys = new int[(max - min) + 1];\n    for (int i = 0; min <= max; keys[i++] = min++);\n    initLock();\n}"}, {"methodBefore": "JumpData(int conditionNumber) {\n    super();\n    this.conditionNumber = conditionNumber;\n    this.trueHits = 0L;\n    this.falseHits = 0L;\n}", "methodAfter": "JumpData(int conditionNumber) {\n    super();\n    this.conditionNumber = conditionNumber;\n    this.trueHits = 0L;\n    this.falseHits = 0L;\n    initLock();\n}"}, {"methodBefore": "LineData(int lineNumber, String methodName, String methodDescriptor) {\n    this.hits = 0;\n    this.jumps = null;\n    this.lineNumber = lineNumber;\n    this.methodName = methodName;\n    this.methodDescriptor = methodDescriptor;\n}", "methodAfter": "LineData(int lineNumber, String methodName, String methodDescriptor) {\n    this.hits = 0;\n    this.jumps = null;\n    this.lineNumber = lineNumber;\n    this.methodName = methodName;\n    this.methodDescriptor = methodDescriptor;\n    initLock();\n}"}], [{"methodBefore": "private String generateTableRowForTotal() {\n    StringBuffer ret = new StringBuffer();\n    double lineCoverage = -1;\n    double branchCoverage = -1;\n    double ccn = Util.getCCN(sourceDir, true);\n    if (projectData.getNumberOfValidLines() > 0) {\n        lineCoverage = projectData.getLineCoverageRate();\n    }\n    if (projectData.getNumberOfValidBranches() > 0) {\n        branchCoverage = projectData.getBranchCoverageRate();\n    }\n    ret.append(\"  <tr>\");\n    ret.append(\"<td class=\\\"text\\\"><b>All Packages</b></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + projectData.getNumberOfClasses()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(lineCoverage, branchCoverage, ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}", "methodAfter": "private String generateTableRowForTotal() {\n    StringBuffer ret = new StringBuffer();\n    double lineCoverage = -1;\n    double branchCoverage = -1;\n    double ccn = Util.getCCN(sourceDir, true);\n    if (projectData.getNumberOfValidLines() > 0) {\n        lineCoverage = projectData.getLineCoverageRate();\n    }\n    if (projectData.getNumberOfValidBranches() > 0) {\n        branchCoverage = projectData.getBranchCoverageRate();\n    }\n    ret.append(\"  <tr>\");\n    ret.append(\"<td class=\\\"text\\\"><b>All Packages</b></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + projectData.getNumberOfSourceFiles()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(lineCoverage, branchCoverage, ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}"}, {"methodBefore": "private String generateTableRowForTotal() {\n    StringBuffer ret = new StringBuffer();\n    double ccn = complexity.getCCNForProject(projectData);\n    ret.append(\"  <tr>\");\n    ret.append(\"<td><b>All Packages</b></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + projectData.getNumberOfClasses()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(projectData, ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}", "methodAfter": "private String generateTableRowForTotal() {\n    StringBuffer ret = new StringBuffer();\n    double ccn = complexity.getCCNForProject(projectData);\n    ret.append(\"  <tr>\");\n    ret.append(\"<td><b>All Packages</b></td>\");\n    ret.append((\"<td class=\\\"value\\\">\" + projectData.getNumberOfSourceFiles()) + \"</td>\");\n    ret.append(generateTableColumnsFromData(projectData, ccn));\n    ret.append(\"</tr>\");\n    return ret.toString();\n}"}], [{"methodBefore": "private boolean jj_3R_144() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_147() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_144() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_147() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_334() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_337() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_334() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_337() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_405() {\n    if (jj_3R_189()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_152() {\n    if (jj_3R_180()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_405() {\n    if (jj_3R_189()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_152() {\n    if (jj_3R_180()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_231() {\n    if (jj_3R_189()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_256()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_233() {\n    if (jj_3R_192()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_257()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_231() {\n    if (jj_3R_189()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_256()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_233() {\n    if (jj_3R_192()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_257()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}", "methodAfter": "public DetectIgnoredCodeClassVisitor(ClassVisitor cv, boolean ignoreTrivial, Set<String> ignoreAnnotations) {\n    super(ASM4, cv);\n    this.ignoreTrivial = ignoreTrivial;\n    this.ignoreAnnotations = ignoreAnnotations;\n}"}, {"methodBefore": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(cv);\n}", "methodAfter": "public DetectDuplicatedCodeClassVisitor(ClassVisitor cv) {\n    super(ASM4, cv);\n}"}], [{"methodBefore": "private boolean jj_3R_259() {\n    if (jj_3R_281()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_289()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_219() {\n    if (jj_3R_120()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_280()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_259() {\n    if (jj_3R_281()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_289()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_219() {\n    if (jj_3R_120()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_280()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private void compileSourceFiles(File srcDir, File classesDir) {\n    Mkdir mkdir = new Mkdir();\n    mkdir.setProject(project);\n    mkdir.setDir(classesDir);\n    mkdir.execute();\n    Javac javac = new Javac();\n    javac.setProject(project);\n    javac.setSrcdir(new Path(TestUtils.project, srcDir.getAbsolutePath()));\n    javac.setDestdir(classesDir);\n    javac.setDebug(true);\n    javac.setTarget(\"1.5\");\n    Path classpath = new Path(TestUtils.project);\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(new File(JETTY_DIR));\n    fileSet.setIncludes(\"**/*.jar\");\n    classpath.addFileset(fileSet);\n    javac.setClasspath(classpath);\n    javac.execute();\n}", "methodAfter": "private void compileSourceFiles(File srcDir, File classesDir) {\n    Mkdir mkdir = new Mkdir();\n    mkdir.setProject(project);\n    mkdir.setDir(classesDir);\n    mkdir.execute();\n    Javac javac = new Javac();\n    javac.setProject(project);\n    javac.setSrcdir(new Path(TestUtils.project, srcDir.getAbsolutePath()));\n    javac.setDestdir(classesDir);\n    javac.setDebug(true);\n    javac.setTarget(\"1.7\");\n    Path classpath = new Path(TestUtils.project);\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(new File(JETTY_DIR));\n    fileSet.setIncludes(\"**/*.jar\");\n    classpath.addFileset(fileSet);\n    javac.setClasspath(classpath);\n    javac.execute();\n}"}, {"methodBefore": "private void compileSourceFiles(File srcDir, File classesDir) {\n    Mkdir mkdir = new Mkdir();\n    mkdir.setProject(project);\n    mkdir.setDir(classesDir);\n    mkdir.execute();\n    Javac javac = new Javac();\n    javac.setProject(project);\n    javac.setSrcdir(new Path(TestUtils.project, srcDir.getAbsolutePath()));\n    javac.setDestdir(classesDir);\n    javac.setDebug(true);\n    javac.setTarget(\"1.5\");\n    Path classpath = new Path(TestUtils.project);\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(new File(JETTY_DIR));\n    fileSet.setIncludes(\"**/*.jar\");\n    classpath.addFileset(fileSet);\n    javac.setClasspath(classpath);\n    javac.execute();\n}", "methodAfter": "private void compileSourceFiles(File srcDir, File classesDir) {\n    Mkdir mkdir = new Mkdir();\n    mkdir.setProject(project);\n    mkdir.setDir(classesDir);\n    mkdir.execute();\n    Javac javac = new Javac();\n    javac.setProject(project);\n    javac.setSrcdir(new Path(TestUtils.project, srcDir.getAbsolutePath()));\n    javac.setDestdir(classesDir);\n    javac.setDebug(true);\n    javac.setTarget(\"1.7\");\n    Path classpath = new Path(TestUtils.project);\n    FileSet fileSet = new FileSet();\n    fileSet.setDir(new File(JETTY_DIR));\n    fileSet.setIncludes(\"**/*.jar\");\n    classpath.addFileset(fileSet);\n    javac.setClasspath(classpath);\n    javac.execute();\n}"}], [{"methodBefore": "private boolean jj_3R_435() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_439() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_435() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_439() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_256() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_254() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_256() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_254() {\n    if (jj_3R_276()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_248() {\n    if (jj_3R_268()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_246() {\n    if (jj_3R_268()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_248() {\n    if (jj_3R_268()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_246() {\n    if (jj_3R_268()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_19() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_101()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_19() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_105()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_19() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_101()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_19() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_105()) {\n        jj_scanpos = xsp;\n    }\n    if (jj_scan_token(SUPER)) {\n        return true;\n    }\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_133() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_136() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_133() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_136() {\n    if (jj_scan_token(VOLATILE)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_401() {\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_401() {\n    if (jj_3R_415()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_401() {\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_401() {\n    if (jj_3R_415()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_348() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_343() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_348() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_343() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_100() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_149()) {\n        jj_scanpos = xsp;\n        if (jj_3R_150()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_107() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_155()) {\n        jj_scanpos = xsp;\n        if (jj_3R_156()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_100() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_149()) {\n        jj_scanpos = xsp;\n        if (jj_3R_150()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_107() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_155()) {\n        jj_scanpos = xsp;\n        if (jj_3R_156()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_159() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_159() {\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    if (jj_3R_114()) {\n        return true;\n    }\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_159() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_159() {\n    if (jj_scan_token(LPAREN)) {\n        return true;\n    }\n    if (jj_3R_114()) {\n        return true;\n    }\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_293() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_303()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_300() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_293() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_303()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_300() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_310()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void _measureRoot(Reader reader) throws IOException, ParseException, TokenMgrError {\n    _htPackages = new HashMap();\n    if (_vJavaSourceFiles.size() == 0) {\n        _measureSource(reader);\n    } else {\n        _measureFiles(_vJavaSourceFiles);\n    }\n    _vPackageMetrics = new ArrayList();\n    for (Iterator ePackages = _htPackages.keySet().iterator(); ePackages.hasNext();) {\n        String sPackage = ((String) (ePackages.next()));\n        PackageMetric pckmNext = ((PackageMetric) (_htPackages.get(sPackage)));\n        _vPackageMetrics.add(pckmNext);\n    }\n}", "methodAfter": "private void _measureRoot(Reader reader) throws IOException, Exception, Error {\n    _htPackages = new HashMap();\n    if (_vJavaSourceFiles == null) {\n        _measureSource(reader);\n    } else {\n        _measureFiles(_vJavaSourceFiles);\n    }\n    _vPackageMetrics = new ArrayList();\n    for (Iterator ePackages = _htPackages.keySet().iterator(); ePackages.hasNext();) {\n        String sPackage = ((String) (ePackages.next()));\n        PackageMetric pckmNext = ((PackageMetric) (_htPackages.get(sPackage)));\n        _vPackageMetrics.add(pckmNext);\n    }\n}"}, {"methodBefore": "private void _measureRoot(Reader reader) throws IOException, ParseException, TokenMgrError {\n    _htPackages = new HashMap();\n    if (_vJavaSourceFiles.size() == 0) {\n        _measureSource(reader);\n    } else {\n        _measureFiles(_vJavaSourceFiles);\n    }\n    _vPackageMetrics = new ArrayList();\n    for (Iterator ePackages = _htPackages.keySet().iterator(); ePackages.hasNext();) {\n        String sPackage = ((String) (ePackages.next()));\n        PackageMetric pckmNext = ((PackageMetric) (_htPackages.get(sPackage)));\n        _vPackageMetrics.add(pckmNext);\n    }\n    Collections.sort(_vPackageMetrics);\n}", "methodAfter": "private void _measureRoot(Reader reader) throws IOException, Exception, Error {\n    _htPackages = new HashMap();\n    if (_vJavaSourceFiles == null) {\n        _measureSource(reader);\n    } else {\n        _measureFiles(_vJavaSourceFiles);\n    }\n    _vPackageMetrics = new ArrayList();\n    for (Iterator ePackages = _htPackages.keySet().iterator(); ePackages.hasNext();) {\n        String sPackage = ((String) (ePackages.next()));\n        PackageMetric pckmNext = ((PackageMetric) (_htPackages.get(sPackage)));\n        _vPackageMetrics.add(pckmNext);\n    }\n    Collections.sort(_vPackageMetrics);\n}"}], [{"methodBefore": "public final void EnumConstant() throws ParseException {\n    Modifiers();\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LPAREN :\n            Arguments();\n            break;\n        default :\n            jj_la1[190] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LBRACE :\n            ClassOrInterfaceBody(false);\n            break;\n        default :\n            jj_la1[191] = jj_gen;\n    }\n}", "methodAfter": "public final void EnumConstant() throws ParseException {\n    Modifiers();\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LPAREN :\n            Arguments();\n            break;\n        default :\n            jj_la1[195] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LBRACE :\n            ClassOrInterfaceBody(false);\n            break;\n        default :\n            jj_la1[196] = jj_gen;\n    }\n}"}, {"methodBefore": "public final void EnumConstant() throws ParseException {\n    Modifiers();\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LPAREN :\n            Arguments();\n            break;\n        default :\n            jj_la1[190] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LBRACE :\n            ClassOrInterfaceBody(false);\n            break;\n        default :\n            jj_la1[191] = jj_gen;\n    }\n}", "methodAfter": "public final void EnumConstant() throws ParseException {\n    Modifiers();\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LPAREN :\n            Arguments();\n            break;\n        default :\n            jj_la1[195] = jj_gen;\n    }\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case LBRACE :\n            ClassOrInterfaceBody(false);\n            break;\n        default :\n            jj_la1[196] = jj_gen;\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_400() {\n    if (jj_3R_305()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_400() {\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_400() {\n    if (jj_3R_305()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_400() {\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_329() {\n    if (jj_3R_364()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_329() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_329() {\n    if (jj_3R_364()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_329() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintWriter out = null;\n    try {\n        out = IOUtil.getPrintWriter(file);\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generatePackageList() throws IOException {\n    File file = new File(destinationDir, \"frame-packages.html\");\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xml:lang=\\\"en\\\" lang=\\\"en\\\">\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onclick=\\'parent.sourceFileList.location.href=\\\"frame-sourcefiles.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        Iterator iter = projectData.getPackages().iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generatePackageList() throws IOException {\n    File file = new File(destinationDir, \"frame-packages.html\");\n    PrintWriter out = null;\n    try {\n        out = IOUtil.getPrintWriter(file);\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xml:lang=\\\"en\\\" lang=\\\"en\\\">\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>Packages</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        out.println(\"<tr>\");\n        out.println(\"<td nowrap=\\\"nowrap\\\"><a href=\\\"frame-summary.html\\\" onclick=\\'parent.sourceFileList.location.href=\\\"frame-sourcefiles.html\\\"\\' target=\\\"summary\\\">All</a></td>\");\n        out.println(\"</tr>\");\n        Iterator iter = projectData.getPackages().iterator();\n        while (iter.hasNext()) {\n            PackageData packageData = ((PackageData) (iter.next()));\n            String url1 = (\"frame-summary-\" + packageData.getName()) + \".html\";\n            String url2 = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n            out.println(\"<tr>\");\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a href=\\\"\" + url1) + \"\\\" onclick=\\'parent.sourceFileList.location.href=\\\"\") + url2) + \"\\\"\\' target=\\\"summary\\\">\") + generatePackageName(packageData)) + \"</a></td>\");\n            out.println(\"</tr>\");\n        } \n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}", "methodAfter": "public ContextMethodAwareMethodAdapter(MethodVisitor mv, String className, String methodName, String methodSignature, AtomicInteger lineIdGenerator) {\n    super(ASM4, mv);\n    this.className = className;\n    this.methodName = methodName;\n    this.methodSignature = methodSignature;\n    lastLineId = 0;\n    this.lineIdGenerator = lineIdGenerator;\n}"}, {"methodBefore": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(mv);\n    this.eventsToTrace = eventsToTrace;\n}", "methodAfter": "public HistoryMethodAdapter(MethodVisitor mv, int eventsToTrace) {\n    super(ASM4, mv);\n    this.eventsToTrace = eventsToTrace;\n}"}], [{"methodBefore": "public static void compileSource(AntBuilder ant, File srcDir) {\n    Javac javac = new Javac();\n    javac.setDebug(true);\n    Groovyc groovyc = new Groovyc();\n    groovyc.setProject(project);\n    groovyc.setSrcdir(new Path(project, srcDir.getAbsolutePath()));\n    groovyc.setDestdir(srcDir);\n    groovyc.addConfiguredJavac(javac);\n    groovyc.execute();\n}", "methodAfter": "public static void compileSource(AntBuilder ant, File srcDir) {\n    compileSource(ant, srcDir, \"1.7\");\n}"}, {"methodBefore": "public static void compileSource(AntBuilder ant, File srcDir) {\n    Javac javac = new Javac();\n    javac.setDebug(true);\n    Groovyc groovyc = new Groovyc();\n    groovyc.setProject(project);\n    groovyc.setSrcdir(new Path(project, srcDir.getAbsolutePath()));\n    groovyc.setDestdir(srcDir);\n    groovyc.addConfiguredJavac(javac);\n    groovyc.execute();\n}", "methodAfter": "public static void compileSource(AntBuilder ant, File srcDir) {\n    compileSource(ant, srcDir, \"1.7\");\n}"}], [{"methodBefore": "private boolean jj_3R_397() {\n    if (jj_3R_303()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_302() {\n    if (jj_3R_312()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_397() {\n    if (jj_3R_303()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_302() {\n    if (jj_3R_312()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private Cobertura() {\n}", "methodAfter": "private Cobertura() {\n    report = new CompositeReport();\n}"}, {"methodBefore": "public Cobertura(Arguments arguments) {\n    args = arguments;\n    instrumentationTask = new CodeInstrumentationTask();\n    checkCoverageTask = new CheckCoverageTask();\n    mergeProjectDataFilesTask = new MergeProjectDataFilesTask();\n    didApplyInstrumentationResults = new AtomicBoolean(false);\n}", "methodAfter": "public Cobertura(Arguments arguments) {\n    report = new CompositeReport();\n    args = arguments;\n    instrumentationTask = new CodeInstrumentationTask();\n    checkCoverageTask = new CheckCoverageTask();\n    mergeProjectDataFilesTask = new MergeProjectDataFilesTask();\n    didApplyInstrumentationResults = new AtomicBoolean(false);\n}"}], [{"methodBefore": "private boolean jj_3_23() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(28)) {\n        jj_scanpos = xsp;\n        if (jj_3R_104()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_23() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(29)) {\n        jj_scanpos = xsp;\n        if (jj_3R_108()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_23() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(28)) {\n        jj_scanpos = xsp;\n        if (jj_3R_104()) {\n            return true;\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_23() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(29)) {\n        jj_scanpos = xsp;\n        if (jj_3R_108()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_62 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[163] = jj_gen;\n                break label_62;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}", "methodAfter": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}"}, {"methodBefore": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_62 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[163] = jj_gen;\n                break label_62;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}", "methodAfter": "public final void MemberValuePairs() throws ParseException {\n    MemberValuePair();\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        jj_consume_token(COMMA);\n        MemberValuePair();\n    } \n}"}, {"methodBefore": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_62 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[156] = jj_gen;\n                break label_62;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}"}], [{"methodBefore": "private boolean jj_3R_201() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_201() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_201() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_201() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void PrimarySuffix() throws ParseException {\n    if (jj_2_36(2)) {\n        jj_consume_token(DOT);\n        jj_consume_token(THIS);\n    } else if (jj_2_37(2)) {\n        jj_consume_token(DOT);\n        AllocationExpression();\n    } else if (jj_2_38(3)) {\n        MemberSelector();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                jj_consume_token(LBRACKET);\n                Expression();\n                jj_consume_token(RBRACKET);\n                break;\n            case DOT :\n                jj_consume_token(DOT);\n                Identifier();\n                break;\n            case LPAREN :\n                Arguments();\n                break;\n            default :\n                jj_la1[126] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void PrimarySuffix() throws ParseException {\n    if (jj_2_35(2)) {\n        jj_consume_token(DOT);\n        jj_consume_token(THIS);\n    } else if (jj_2_36(2)) {\n        jj_consume_token(DOT);\n        AllocationExpression();\n    } else if (jj_2_37(3)) {\n        MemberSelector();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                jj_consume_token(LBRACKET);\n                Expression();\n                jj_consume_token(RBRACKET);\n                break;\n            case DOT :\n                jj_consume_token(DOT);\n                Identifier();\n                break;\n            case LPAREN :\n                Arguments();\n                break;\n            default :\n                jj_la1[127] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}, {"methodBefore": "public final void PrimarySuffix() throws ParseException {\n    if (jj_2_36(2)) {\n        jj_consume_token(DOT);\n        jj_consume_token(THIS);\n    } else if (jj_2_37(2)) {\n        jj_consume_token(DOT);\n        AllocationExpression();\n    } else if (jj_2_38(3)) {\n        MemberSelector();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                jj_consume_token(LBRACKET);\n                Expression();\n                jj_consume_token(RBRACKET);\n                break;\n            case DOT :\n                jj_consume_token(DOT);\n                Identifier();\n                break;\n            case LPAREN :\n                Arguments();\n                break;\n            default :\n                jj_la1[126] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}", "methodAfter": "public final void PrimarySuffix() throws ParseException {\n    if (jj_2_35(2)) {\n        jj_consume_token(DOT);\n        jj_consume_token(THIS);\n    } else if (jj_2_36(2)) {\n        jj_consume_token(DOT);\n        AllocationExpression();\n    } else if (jj_2_37(3)) {\n        MemberSelector();\n    } else {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case LBRACKET :\n                jj_consume_token(LBRACKET);\n                Expression();\n                jj_consume_token(RBRACKET);\n                break;\n            case DOT :\n                jj_consume_token(DOT);\n                Identifier();\n                break;\n            case LPAREN :\n                Arguments();\n                break;\n            default :\n                jj_la1[127] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_218() {\n    if (jj_3R_235()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_260()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_258() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_281()) {\n        jj_scanpos = xsp;\n        if (jj_3R_282()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_218() {\n    if (jj_3R_235()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_260()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_258() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_281()) {\n        jj_scanpos = xsp;\n        if (jj_3R_282()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "public boolean parseImports() {\n    if (_sJavaSourceFile == null) {\n        Util.debug(\"Javancss.parseImports().NO_FILE\");\n        return true;\n    }\n    Reader reader = createSourceReader(_sJavaSourceFile);\n    if (reader == null) {\n        Util.debug(\"Javancss.parseImports().NO_DIS\");\n        return true;\n    }\n    try {\n        Util.debug(\"Javancss.parseImports().START_PARSING\");\n        _pJavaParser = new JavaParser(reader);\n        _pJavaParser.ImportUnit();\n        _vImports = _pJavaParser.getImports();\n        _aoPackage = _pJavaParser.getPackageObjects();\n        Util.debug(\"Javancss.parseImports().END_PARSING\");\n    } catch (ParseException pParseException) {\n        Util.debug(\"Javancss.parseImports().PARSE_EXCEPTION\");\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"ParseException in STDIN\";\n        if (_pJavaParser != null) {\n            _sErrorMessage += (\"\\nLast useful checkpoint: \\\"\" + _pJavaParser.getLastFunction()) + \"\\\"\\n\";\n        }\n        _sErrorMessage += pParseException.getMessage() + \"\\n\";\n        _thrwError = pParseException;\n        return true;\n    } catch (TokenMgrError pTokenMgrError) {\n        Util.debug(\"Javancss.parseImports().TOKEN_ERROR\");\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"TokenMgrError in STDIN\\n\";\n        _sErrorMessage += pTokenMgrError.getMessage() + \"\\n\";\n        _thrwError = pTokenMgrError;\n        return true;\n    }\n    return false;\n}", "methodAfter": "public boolean parseImports() {\n    if (_sJavaSourceFile == null) {\n        Util.debug(\"Javancss.parseImports().NO_FILE\");\n        return true;\n    }\n    Reader reader = createSourceReader(_sJavaSourceFile);\n    if (reader == null) {\n        Util.debug(\"Javancss.parseImports().NO_DIS\");\n        return true;\n    }\n    try {\n        Util.debug(\"Javancss.parseImports().START_PARSING\");\n        if (Util.isDebug() == false) {\n            _pJavaParser = ((JavaParserInterface) (new JavaParser(reader)));\n        } else {\n            _pJavaParser = ((JavaParserInterface) (new JavaParserDebug(reader)));\n        }\n        _pJavaParser.parseImportUnit();\n        _vImports = _pJavaParser.getImports();\n        _aoPackage = _pJavaParser.getPackageObjects();\n        Util.debug(\"Javancss.parseImports().END_PARSING\");\n    } catch (Exception pParseException) {\n        Util.debug(\"Javancss.parseImports().PARSE_EXCEPTION\");\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"ParseException in STDIN\";\n        if (_pJavaParser != null) {\n            _sErrorMessage += (\"\\nLast useful checkpoint: \\\"\" + _pJavaParser.getLastFunction()) + \"\\\"\\n\";\n        }\n        _sErrorMessage += pParseException.getMessage() + \"\\n\";\n        _thrwError = pParseException;\n        return true;\n    } catch (Error pTokenMgrError) {\n        Util.debug(\"Javancss.parseImports().TOKEN_ERROR\");\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"TokenMgrError in STDIN\\n\";\n        _sErrorMessage += pTokenMgrError.getMessage() + \"\\n\";\n        _thrwError = pTokenMgrError;\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "public boolean parseImports() {\n    if (_sJavaSourceFile == null) {\n        Util.debug(\"Javancss.parseImports().NO_FILE\");\n        return true;\n    }\n    Reader reader = createSourceReader(_sJavaSourceFile);\n    if (reader == null) {\n        Util.debug(\"Javancss.parseImports().NO_DIS\");\n        return true;\n    }\n    try {\n        Util.debug(\"Javancss.parseImports().START_PARSING\");\n        _pJavaParser = new JavaParser(reader);\n        _pJavaParser.ImportUnit();\n        _vImports = _pJavaParser.getImports();\n        _aoPackage = _pJavaParser.getPackageObjects();\n        Util.debug(\"Javancss.parseImports().END_PARSING\");\n    } catch (ParseException pParseException) {\n        Util.debug(\"Javancss.parseImports().PARSE_EXCEPTION\");\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"ParseException in STDIN\";\n        if (_pJavaParser != null) {\n            _sErrorMessage += (\"\\nLast useful checkpoint: \\\"\" + _pJavaParser.getLastFunction()) + \"\\\"\\n\";\n        }\n        _sErrorMessage += pParseException.getMessage() + \"\\n\";\n        _thrwError = pParseException;\n        return true;\n    } catch (TokenMgrError pTokenMgrError) {\n        Util.debug(\"Javancss.parseImports().TOKEN_ERROR\");\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"TokenMgrError in STDIN\\n\";\n        _sErrorMessage += pTokenMgrError.getMessage() + \"\\n\";\n        _thrwError = pTokenMgrError;\n        return true;\n    }\n    return false;\n}", "methodAfter": "public boolean parseImports() {\n    if (_sJavaSourceFile == null) {\n        Util.debug(\"Javancss.parseImports().NO_FILE\");\n        return true;\n    }\n    Reader reader = createSourceReader(_sJavaSourceFile);\n    if (reader == null) {\n        Util.debug(\"Javancss.parseImports().NO_DIS\");\n        return true;\n    }\n    try {\n        Util.debug(\"Javancss.parseImports().START_PARSING\");\n        if (Util.isDebug() == false) {\n            _pJavaParser = ((JavaParserInterface) (new JavaParser(reader)));\n        } else {\n            _pJavaParser = ((JavaParserInterface) (new JavaParserDebug(reader)));\n        }\n        _pJavaParser.parseImportUnit();\n        _vImports = _pJavaParser.getImports();\n        _aoPackage = _pJavaParser.getPackageObjects();\n        Util.debug(\"Javancss.parseImports().END_PARSING\");\n    } catch (Exception pParseException) {\n        Util.debug(\"Javancss.parseImports().PARSE_EXCEPTION\");\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"ParseException in STDIN\";\n        if (_pJavaParser != null) {\n            _sErrorMessage += (\"\\nLast useful checkpoint: \\\"\" + _pJavaParser.getLastFunction()) + \"\\\"\\n\";\n        }\n        _sErrorMessage += pParseException.getMessage() + \"\\n\";\n        _thrwError = pParseException;\n        return true;\n    } catch (Error pTokenMgrError) {\n        Util.debug(\"Javancss.parseImports().TOKEN_ERROR\");\n        if (_sErrorMessage == null) {\n            _sErrorMessage = \"\";\n        }\n        _sErrorMessage += \"TokenMgrError in STDIN\\n\";\n        _sErrorMessage += pTokenMgrError.getMessage() + \"\\n\";\n        _thrwError = pTokenMgrError;\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void testMultiThreadedGetJumpData() throws Throwable {\n    for (int i = 0; i < 100; i++) {\n        runGetJumpDataTestWithTwoThreads();\n    }\n}", "methodAfter": "@Test\npublic void testMultiThreadedGetJumpData() throws Throwable {\n    for (int i = 0; i < 100; i++) {\n        runGetJumpDataTestWithTwoThreads();\n    }\n}"}, {"methodBefore": "public void testRemoveLine() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    a.removeLine(3);\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, b.getNumberOfValidLines());\n    b.removeLine(3);\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, b.getNumberOfValidLines());\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 2, Integer.MAX_VALUE);\n    c.addLineJump(3, 0);\n    c.addLineJump(4, 0);\n    assertEquals(9, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, c.getNumberOfValidLines());\n    c.removeLine(3);\n    assertEquals(4, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, c.getNumberOfValidLines());\n}", "methodAfter": "@Test\npublic void testRemoveLine() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    a.removeLine(3);\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, b.getNumberOfValidLines());\n    b.removeLine(3);\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, b.getNumberOfValidLines());\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 2, Integer.MAX_VALUE);\n    c.addLineJump(3, 0);\n    c.addLineJump(4, 0);\n    assertEquals(9, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(5, c.getNumberOfValidLines());\n    c.removeLine(3);\n    assertEquals(4, c.getNumberOfValidBranches());\n    assertEquals(0, a.getNumberOfCoveredBranches());\n    assertEquals(4, c.getNumberOfValidLines());\n}"}, {"methodBefore": "public void testBranchCoverage() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(1.0, a.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, a.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.addLineJump(1, 0);\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 3, Integer.MAX_VALUE);\n    c.addLineSwitch(4, 0, 1, 3, Integer.MAX_VALUE);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(0, c.getNumberOfCoveredBranches());\n    assertEquals(0.0, c.getBranchCoverageRate(), 0.0);\n    assertEquals(0.0, c.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.touchJump(1, 0, true, 1);\n    c.touchJump(1, 0, false, 1);\n    c.touchJump(2, 0, true, 1);\n    c.touchJump(2, 0, false, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(4, c.getNumberOfCoveredBranches());\n    assertEquals(0.33, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.33, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n    c.touchSwitch(3, 0, 0, 1);\n    c.touchSwitch(3, 0, 1, 1);\n    c.touchSwitch(4, 0, 2, 1);\n    c.touchSwitch(4, 0, -1, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(8, c.getNumberOfCoveredBranches());\n    assertEquals(0.66, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.66, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n}", "methodAfter": "@Test\npublic void testBranchCoverage() {\n    assertEquals(0, a.getNumberOfValidBranches());\n    assertEquals(0, b.getNumberOfValidBranches());\n    assertEquals(1.0, a.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(), 0.0);\n    assertEquals(1.0, a.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, b.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.addLineJump(1, 0);\n    c.addLineJump(2, 0);\n    c.addLineSwitch(3, 0, 1, 3, Integer.MAX_VALUE);\n    c.addLineSwitch(4, 0, 1, 3, Integer.MAX_VALUE);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(0, c.getNumberOfCoveredBranches());\n    assertEquals(0.0, c.getBranchCoverageRate(), 0.0);\n    assertEquals(0.0, c.getBranchCoverageRate(\"test(I)B\"), 0.0);\n    c.touchJump(1, 0, true, 1);\n    c.touchJump(1, 0, false, 1);\n    c.touchJump(2, 0, true, 1);\n    c.touchJump(2, 0, false, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(4, c.getNumberOfCoveredBranches());\n    assertEquals(0.33, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.33, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n    c.touchSwitch(3, 0, 0, 1);\n    c.touchSwitch(3, 0, 1, 1);\n    c.touchSwitch(4, 0, 2, 1);\n    c.touchSwitch(4, 0, -1, 1);\n    assertEquals(12, c.getNumberOfValidBranches());\n    assertEquals(8, c.getNumberOfCoveredBranches());\n    assertEquals(0.66, c.getBranchCoverageRate(), 0.01);\n    assertEquals(0.66, c.getBranchCoverageRate(\"test(I)B\"), 0.01);\n}"}, {"methodBefore": "public void testMultiThreadedGetSwitchData() throws Throwable {\n    for (int i = 0; i < 100; i++) {\n        runGetSwitchDataTestWithTwoThreads();\n    }\n}", "methodAfter": "@Test\npublic void testMultiThreadedGetSwitchData() throws Throwable {\n    for (int i = 0; i < 100; i++) {\n        runGetSwitchDataTestWithTwoThreads();\n    }\n}"}, {"methodBefore": "public static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}"}, {"methodBefore": "public static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}", "methodAfter": "@Test\npublic static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}"}, {"methodBefore": "public void testLineCoverage() {\n    assertEquals(0, a.getNumberOfCoveredLines());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(2, b.getNumberOfCoveredLines());\n    assertEquals(5, b.getNumberOfValidLines());\n    assertEquals(0, c.getNumberOfCoveredLines());\n    assertEquals(5, c.getNumberOfValidLines());\n    assertEquals(1.0, a.getLineCoverageRate(), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, b.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, c.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n}", "methodAfter": "@Test\npublic void testLineCoverage() {\n    assertEquals(0, a.getNumberOfCoveredLines());\n    assertEquals(0, a.getNumberOfValidLines());\n    assertEquals(2, b.getNumberOfCoveredLines());\n    assertEquals(5, b.getNumberOfValidLines());\n    assertEquals(0, c.getNumberOfCoveredLines());\n    assertEquals(5, c.getNumberOfValidLines());\n    assertEquals(1.0, a.getLineCoverageRate(), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.4, b.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(0.0, c.getLineCoverageRate(\"test(I)B\"), 0.0);\n    assertEquals(1.0, a.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, b.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n    assertEquals(1.0, c.getLineCoverageRate(\"notReal(I)B\"), 0.0);\n}"}, {"methodBefore": "public static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}"}, {"methodBefore": "public static void testInstrumentUsingClassPath() throws Exception {\n    runTestAntScript(\"classpath\", \"test-classpath\");\n    verify(\"classpath\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingClassPath() throws Exception {\n    runTestAntScript(\"classpath\", \"test-classpath\");\n    verify(\"classpath\");\n}"}, {"methodBefore": "public void testTouch() {\n    int line = 3;\n    assertFalse(a.isValidSourceLineNumber(line));\n    a.touch(line, 1);\n    assertTrue(a.isValidSourceLineNumber(line));\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(0, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(1, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertEquals(2, b.getLineCoverage(line).getHits());\n    assertTrue(b.isValidSourceLineNumber(line));\n}", "methodAfter": "@Test\npublic void testTouch() {\n    int line = 3;\n    assertFalse(a.isValidSourceLineNumber(line));\n    a.touch(line, 1);\n    assertTrue(a.isValidSourceLineNumber(line));\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(0, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertTrue(b.isValidSourceLineNumber(line));\n    assertEquals(1, b.getLineCoverage(line).getHits());\n    b.touch(line, 1);\n    assertEquals(2, b.getLineCoverage(line).getHits());\n    assertTrue(b.isValidSourceLineNumber(line));\n}"}, {"methodBefore": "public static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}"}, {"methodBefore": "public static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingIncludesAndExcludes() throws Exception {\n    runTestAntScript(\"includes-and-excludes\", \"test-includes-and-excludes\");\n    verify(\"includes-and-excludes\");\n}"}, {"methodBefore": "public static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingWar() throws Exception {\n    runTestAntScript(\"classpath\", \"test-war\");\n    verify(\"war\");\n}"}, {"methodBefore": "public static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}", "methodAfter": "@Test\npublic static void testConditionCoverage() throws Exception {\n    runTestAntScript(\"condition-coverage\", \"test-condition-coverage\");\n    verify(\"condition-coverage\");\n}"}, {"methodBefore": "public static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingDirSet() throws Exception {\n    runTestAntScript(\"dirset\", \"test-dirset\");\n    verify(\"dirset\");\n}"}, {"methodBefore": "public static void testInstrumentUsingClassPath() throws Exception {\n    runTestAntScript(\"classpath\", \"test-classpath\");\n    verify(\"classpath\");\n}", "methodAfter": "@Test\npublic static void testInstrumentUsingClassPath() throws Exception {\n    runTestAntScript(\"classpath\", \"test-classpath\");\n    verify(\"classpath\");\n}"}], [{"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(\"<thead>\");\n        out.println(\"<tr>\");\n        out.println(\"  <td class=\\\"heading\\\">Package</td>\");\n        out.println(\"  <td class=\\\"heading\\\"># Classes</td>\");\n        out.println(generateCommonTableColumns());\n        out.println(\"</tr>\");\n        out.println(\"</thead>\");\n        out.println(\"<tbody>\");\n        Collection packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getChildren();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"LocalizedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        out.println(\"</p>\");\n        Collection classes;\n        if (packageData == null) {\n            classes = new TreeSet();\n            if (projectData.getNumberOfClasses() > 0) {\n                iter = projectData.getClasses().iterator();\n                while (iter.hasNext()) {\n                    ClassData classData = ((ClassData) (iter.next()));\n                    if (classData.getPackageName() == null) {\n                        classes.add(classData);\n                    }\n                } \n            }\n        } else {\n            classes = packageData.getChildren();\n        }\n        if (classes.size() > 0) {\n            out.println(\"<p>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeaderForClasses());\n            out.println(\"<tbody>\");\n            iter = classes.iterator();\n            while (iter.hasNext()) {\n                ClassData classData = ((ClassData) (iter.next()));\n                out.println(generateTableRowForClass(classData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"LocalizedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n            out.println(\"</p>\");\n        }\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Report generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<p>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(\"<thead>\");\n        out.println(\"<tr>\");\n        out.println(\"  <td class=\\\"heading\\\">Package</td>\");\n        out.println(\"  <td class=\\\"heading\\\"># Classes</td>\");\n        out.println(generateCommonTableColumns());\n        out.println(\"</tr>\");\n        out.println(\"</thead>\");\n        out.println(\"<tbody>\");\n        Collection packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getChildren();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"LocalizedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        out.println(\"</p>\");\n        Collection classes;\n        if (packageData == null) {\n            classes = new TreeSet();\n            if (projectData.getNumberOfClasses() > 0) {\n                iter = projectData.getClasses().iterator();\n                while (iter.hasNext()) {\n                    ClassData classData = ((ClassData) (iter.next()));\n                    if (classData.getPackageName() == null) {\n                        classes.add(classData);\n                    }\n                } \n            }\n        } else {\n            classes = packageData.getClasses();\n        }\n        if (classes.size() > 0) {\n            out.println(\"<p>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeaderForClasses());\n            out.println(\"<tbody>\");\n            iter = classes.iterator();\n            while (iter.hasNext()) {\n                ClassData classData = ((ClassData) (iter.next()));\n                out.println(generateTableRowForClass(classData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"LocalizedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n            out.println(\"</p>\");\n        }\n        out.println(\"<div class=\\\"footer\\\">\");\n        out.println(\"Report generated by <a href=\\\"http://cobertura.sourceforge.net/\\\" target=\\\"_top\\\">Cobertura</a>.\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateClassList(PackageData packageData) throws IOException {\n    String filename;\n    Collection classes;\n    if (packageData == null) {\n        filename = \"frame-classes.html\";\n        classes = projectData.getClasses();\n    } else {\n        filename = (\"frame-classes-\" + packageData.getName()) + \".html\";\n        classes = packageData.getChildren();\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<h5>Classes</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        Map sortedClassList = new TreeMap();\n        for (Iterator iter = classes.iterator(); iter.hasNext();) {\n            ClassData classData = ((ClassData) (iter.next()));\n            sortedClassList.put(classData.getBaseName(), classData);\n        }\n        for (Iterator iter = sortedClassList.values().iterator(); iter.hasNext();) {\n            ClassData classData = ((ClassData) (iter.next()));\n            out.println(\"<tr>\");\n            String percentCovered;\n            if (classData.getNumberOfValidLines() > 0) {\n                percentCovered = getPercentValue(classData.getLineCoverageRate());\n            } else {\n                percentCovered = \"N/A\";\n            }\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + classData.getName()) + \".html\\\">\") + classData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n            out.println(\"</tr>\");\n        }\n        out.println(\"</td>\");\n        out.println(\"</tr>\");\n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateClassList(PackageData packageData) throws IOException {\n    String filename;\n    Collection classes;\n    if (packageData == null) {\n        filename = \"frame-classes.html\";\n        classes = projectData.getClasses();\n    } else {\n        filename = (\"frame-classes-\" + packageData.getName()) + \".html\";\n        classes = packageData.getClasses();\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file));\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\" />\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<h5>Classes</h5>\");\n        out.println(\"<table width=\\\"100%\\\">\");\n        Map sortedClassList = new TreeMap();\n        for (Iterator iter = classes.iterator(); iter.hasNext();) {\n            ClassData classData = ((ClassData) (iter.next()));\n            sortedClassList.put(classData.getBaseName(), classData);\n        }\n        for (Iterator iter = sortedClassList.values().iterator(); iter.hasNext();) {\n            ClassData classData = ((ClassData) (iter.next()));\n            out.println(\"<tr>\");\n            String percentCovered;\n            if (classData.getNumberOfValidLines() > 0) {\n                percentCovered = getPercentValue(classData.getLineCoverageRate());\n            } else {\n                percentCovered = \"N/A\";\n            }\n            out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + classData.getName()) + \".html\\\">\") + classData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n            out.println(\"</tr>\");\n        }\n        out.println(\"</td>\");\n        out.println(\"</tr>\");\n        out.println(\"</table>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_368() {\n    if (jj_scan_token(STATIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_368() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_368() {\n    if (jj_scan_token(STATIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_368() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_17() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_100()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_17() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_104()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_17() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_100()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_17() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_104()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_429() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_429() {\n    if (jj_3R_415()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_429() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_429() {\n    if (jj_3R_415()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_202() {\n    if (jj_3R_215()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_222() {\n    if (jj_3R_239()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_202() {\n    if (jj_3R_215()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_222() {\n    if (jj_3R_239()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_351() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_378() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_351() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_378() {\n    if (jj_scan_token(PUBLIC)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_56() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_53() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_56() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_53() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void Block() throws ParseException {\n    jj_consume_token(LBRACE);\n    label_56 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[139] = jj_gen;\n                break label_56;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void Block() throws ParseException {\n    jj_consume_token(LBRACE);\n    label_57 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[140] = jj_gen;\n                break label_57;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n}"}, {"methodBefore": "public final void Block() throws ParseException {\n    jj_consume_token(LBRACE);\n    label_56 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[139] = jj_gen;\n                break label_56;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void Block() throws ParseException {\n    jj_consume_token(LBRACE);\n    label_57 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BREAK :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case CONTINUE :\n            case DO :\n            case DOUBLE :\n            case ENUM :\n            case FALSE :\n            case FINAL :\n            case FLOAT :\n            case FOR :\n            case IF :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case NEW :\n            case NULL :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case RETURN :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SUPER :\n            case SWITCH :\n            case SYNCHRONIZED :\n            case THIS :\n            case THROW :\n            case TRANSIENT :\n            case TRUE :\n            case TRY :\n            case VOID :\n            case VOLATILE :\n            case WHILE :\n            case INTEGER_LITERAL :\n            case FLOATING_POINT_LITERAL :\n            case CHARACTER_LITERAL :\n            case STRING_LITERAL :\n            case IDENTIFIER :\n            case LPAREN :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case INCR :\n            case DECR :\n                break;\n            default :\n                jj_la1[140] = jj_gen;\n                break label_57;\n        }\n        BlockStatement();\n    } \n    jj_consume_token(RBRACE);\n}"}], [{"methodBefore": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_68 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[173] = jj_gen;\n                break label_68;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}"}, {"methodBefore": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_65 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[168] = jj_gen;\n                break label_65;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void AnnotationTypeBody() throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"_ncss++\");\n    label_68 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case IDENTIFIER :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[173] = jj_gen;\n                break label_68;\n        }\n        AnnotationTypeMemberDeclaration();\n    } \n    jj_consume_token(RBRACE);\n}"}], [{"methodBefore": "private boolean jj_3R_152() {\n    if (jj_3R_110()) {\n        return true;\n    }\n    Token xsp;\n    if (jj_3_61()) {\n        return true;\n    }\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_61()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_156() {\n    if (jj_3R_187()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_61()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_152() {\n    if (jj_3R_110()) {\n        return true;\n    }\n    Token xsp;\n    if (jj_3_61()) {\n        return true;\n    }\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_61()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_156() {\n    if (jj_3R_187()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_61()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_16() {\n    if (jj_3R_95()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_16() {\n    if (jj_3R_99()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_16() {\n    if (jj_3R_95()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_16() {\n    if (jj_3R_99()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void CompilationUnit() throws ParseException {\n    int oldNcss = 0;\n    int oldFormal = 0;\n    int oldSingle = 0;\n    int oldMulti = 0;\n    JavaParserTokenManager._iSingleComments = 0;\n    JavaParserTokenManager._iMultiComments = 0;\n    JavaParserTokenManager._iFormalComments = 0;\n    JavaParserTokenManager._iMultiCommentsLast = 0;\n    _bPrivate = true;\n    _sPackage = \"\";\n    _pPackageMetric = new PackageMetric();\n    if (jj_2_1(2147483647)) {\n        PackageDeclaration();\n    } else {\n    }\n    label_1 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case IMPORT :\n                break;\n            default :\n                jj_la1[0] = jj_gen;\n                break label_1;\n        }\n        ImportDeclaration();\n    } \n    label_2 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case CLASS :\n            case ENUM :\n            case FINAL :\n            case INTERFACE :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[1] = jj_gen;\n                break label_2;\n        }\n        TypeDeclaration();\n    } \n    _pPackageMetric.ncss = _ncss;\n    _pPackageMetric.javadocsLn = JavaParserTokenManager._iFormalComments;\n    _pPackageMetric.singleLn = JavaParserTokenManager._iSingleComments;\n    _pPackageMetric.multiLn = JavaParserTokenManager._iMultiComments;\n    _htPackage.put(_formatPackage(_sPackage), _pPackageMetric);\n    label_3 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case IMPORT :\n            case PACKAGE :\n            case AT :\n                break;\n            default :\n                jj_la1[2] = jj_gen;\n                break label_3;\n        }\n        oldNcss = _ncss;\n        _sPackage = \"\";\n        _pPackageMetric = new PackageMetric();\n        oldFormal = JavaParserTokenManager._iFormalComments;\n        oldSingle = JavaParserTokenManager._iSingleComments;\n        oldMulti = JavaParserTokenManager._iMultiComments;\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PACKAGE :\n            case AT :\n                PackageDeclaration();\n                break;\n            case IMPORT :\n                ImportDeclaration();\n                break;\n            default :\n                jj_la1[3] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        label_4 : while (true) {\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case IMPORT :\n                    break;\n                default :\n                    jj_la1[4] = jj_gen;\n                    break label_4;\n            }\n            ImportDeclaration();\n        } \n        label_5 : while (true) {\n            TypeDeclaration();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ABSTRACT :\n                case CLASS :\n                case ENUM :\n                case FINAL :\n                case INTERFACE :\n                case NATIVE :\n                case PRIVATE :\n                case PROTECTED :\n                case PUBLIC :\n                case STATIC :\n                case TESTAAAA :\n                case SYNCHRONIZED :\n                case TRANSIENT :\n                case VOLATILE :\n                case SEMICOLON :\n                case AT :\n                    break;\n                default :\n                    jj_la1[5] = jj_gen;\n                    break label_5;\n            }\n        } \n        _pPackageMetric.ncss = _ncss - oldNcss;\n        _pPackageMetric.javadocsLn = JavaParserTokenManager._iFormalComments - oldFormal;\n        _pPackageMetric.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n        _pPackageMetric.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n        PackageMetric pckmPrevious = ((PackageMetric) (_htPackage.get(_formatPackage(_sPackage))));\n        _pPackageMetric.add(pckmPrevious);\n        _htPackage.put(_formatPackage(_sPackage), _pPackageMetric);\n    } \n    jj_consume_token(0);\n    Token pToken = getToken(1);\n    _loc = pToken.endLine;\n}", "methodAfter": "public final void CompilationUnit() throws ParseException {\n    int oldNcss = 0;\n    int oldFormal = 0;\n    int oldSingle = 0;\n    int oldMulti = 0;\n    JavaParserTokenManager._iSingleComments = 0;\n    JavaParserTokenManager._iMultiComments = 0;\n    JavaParserTokenManager._iFormalComments = 0;\n    JavaParserTokenManager._iMultiCommentsLast = 0;\n    _bPrivate = true;\n    JavaParserTokenManager.nbligne = 1;\n    _sPackage = \"\";\n    _pPackageMetric = new PackageMetric();\n    if (jj_2_1(2147483647)) {\n        PackageDeclaration();\n    } else {\n    }\n    label_1 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case IMPORT :\n                break;\n            default :\n                jj_la1[0] = jj_gen;\n                break label_1;\n        }\n        ImportDeclaration();\n    } \n    label_2 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case CLASS :\n            case ENUM :\n            case FINAL :\n            case INTERFACE :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[1] = jj_gen;\n                break label_2;\n        }\n        TypeDeclaration();\n    } \n    _pPackageMetric.ncss = _ncss;\n    _pPackageMetric.javadocsLn = JavaParserTokenManager._iFormalComments;\n    _pPackageMetric.singleLn = JavaParserTokenManager._iSingleComments;\n    _pPackageMetric.multiLn = JavaParserTokenManager._iMultiComments;\n    _htPackage.put(_formatPackage(_sPackage), _pPackageMetric);\n    label_3 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case IMPORT :\n            case PACKAGE :\n            case AT :\n                break;\n            default :\n                jj_la1[2] = jj_gen;\n                break label_3;\n        }\n        oldNcss = _ncss;\n        _sPackage = \"\";\n        _pPackageMetric = new PackageMetric();\n        oldFormal = JavaParserTokenManager._iFormalComments;\n        oldSingle = JavaParserTokenManager._iSingleComments;\n        oldMulti = JavaParserTokenManager._iMultiComments;\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PACKAGE :\n            case AT :\n                PackageDeclaration();\n                break;\n            case IMPORT :\n                ImportDeclaration();\n                break;\n            default :\n                jj_la1[3] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        label_4 : while (true) {\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case IMPORT :\n                    break;\n                default :\n                    jj_la1[4] = jj_gen;\n                    break label_4;\n            }\n            ImportDeclaration();\n        } \n        label_5 : while (true) {\n            TypeDeclaration();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ABSTRACT :\n                case CLASS :\n                case ENUM :\n                case FINAL :\n                case INTERFACE :\n                case NATIVE :\n                case PRIVATE :\n                case PROTECTED :\n                case PUBLIC :\n                case STATIC :\n                case TESTAAAA :\n                case SYNCHRONIZED :\n                case TRANSIENT :\n                case VOLATILE :\n                case SEMICOLON :\n                case AT :\n                    break;\n                default :\n                    jj_la1[5] = jj_gen;\n                    break label_5;\n            }\n        } \n        _pPackageMetric.ncss = _ncss - oldNcss;\n        _pPackageMetric.javadocsLn = JavaParserTokenManager._iFormalComments - oldFormal;\n        _pPackageMetric.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n        _pPackageMetric.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n        PackageMetric pckmPrevious = ((PackageMetric) (_htPackage.get(_formatPackage(_sPackage))));\n        _pPackageMetric.add(pckmPrevious);\n        _htPackage.put(_formatPackage(_sPackage), _pPackageMetric);\n    } \n    jj_consume_token(0);\n    Token pToken = getToken(1);\n    _loc = pToken.endLine;\n    _nbligne = JavaParserTokenManager.nbligne;\n}"}, {"methodBefore": "public final void CompilationUnit() throws ParseException {\n    int oldNcss = 0;\n    int oldFormal = 0;\n    int oldSingle = 0;\n    int oldMulti = 0;\n    JavaParserTokenManager._iSingleComments = 0;\n    JavaParserTokenManager._iMultiComments = 0;\n    JavaParserTokenManager._iFormalComments = 0;\n    JavaParserTokenManager._iMultiCommentsLast = 0;\n    _bPrivate = true;\n    _sPackage = \"\";\n    _pPackageMetric = new PackageMetric();\n    if (jj_2_1(2147483647)) {\n        PackageDeclaration();\n    } else {\n    }\n    label_1 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case IMPORT :\n                break;\n            default :\n                jj_la1[0] = jj_gen;\n                break label_1;\n        }\n        ImportDeclaration();\n    } \n    label_2 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case CLASS :\n            case ENUM :\n            case FINAL :\n            case INTERFACE :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[1] = jj_gen;\n                break label_2;\n        }\n        TypeDeclaration();\n    } \n    _pPackageMetric.ncss = _ncss;\n    _pPackageMetric.javadocsLn = JavaParserTokenManager._iFormalComments;\n    _pPackageMetric.singleLn = JavaParserTokenManager._iSingleComments;\n    _pPackageMetric.multiLn = JavaParserTokenManager._iMultiComments;\n    _htPackage.put(_formatPackage(_sPackage), _pPackageMetric);\n    label_3 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case IMPORT :\n            case PACKAGE :\n            case AT :\n                break;\n            default :\n                jj_la1[2] = jj_gen;\n                break label_3;\n        }\n        oldNcss = _ncss;\n        _sPackage = \"\";\n        _pPackageMetric = new PackageMetric();\n        oldFormal = JavaParserTokenManager._iFormalComments;\n        oldSingle = JavaParserTokenManager._iSingleComments;\n        oldMulti = JavaParserTokenManager._iMultiComments;\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PACKAGE :\n            case AT :\n                PackageDeclaration();\n                break;\n            case IMPORT :\n                ImportDeclaration();\n                break;\n            default :\n                jj_la1[3] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        label_4 : while (true) {\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case IMPORT :\n                    break;\n                default :\n                    jj_la1[4] = jj_gen;\n                    break label_4;\n            }\n            ImportDeclaration();\n        } \n        label_5 : while (true) {\n            TypeDeclaration();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ABSTRACT :\n                case CLASS :\n                case ENUM :\n                case FINAL :\n                case INTERFACE :\n                case NATIVE :\n                case PRIVATE :\n                case PROTECTED :\n                case PUBLIC :\n                case STATIC :\n                case TESTAAAA :\n                case SYNCHRONIZED :\n                case TRANSIENT :\n                case VOLATILE :\n                case SEMICOLON :\n                case AT :\n                    break;\n                default :\n                    jj_la1[5] = jj_gen;\n                    break label_5;\n            }\n        } \n        _pPackageMetric.ncss = _ncss - oldNcss;\n        _pPackageMetric.javadocsLn = JavaParserTokenManager._iFormalComments - oldFormal;\n        _pPackageMetric.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n        _pPackageMetric.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n        PackageMetric pckmPrevious = ((PackageMetric) (_htPackage.get(_formatPackage(_sPackage))));\n        _pPackageMetric.add(pckmPrevious);\n        _htPackage.put(_formatPackage(_sPackage), _pPackageMetric);\n    } \n    jj_consume_token(0);\n    Token pToken = getToken(1);\n    _loc = pToken.endLine;\n}", "methodAfter": "public final void CompilationUnit() throws ParseException {\n    int oldNcss = 0;\n    int oldFormal = 0;\n    int oldSingle = 0;\n    int oldMulti = 0;\n    JavaParserTokenManager._iSingleComments = 0;\n    JavaParserTokenManager._iMultiComments = 0;\n    JavaParserTokenManager._iFormalComments = 0;\n    JavaParserTokenManager._iMultiCommentsLast = 0;\n    _bPrivate = true;\n    JavaParserTokenManager.nbligne = 1;\n    _sPackage = \"\";\n    _pPackageMetric = new PackageMetric();\n    if (jj_2_1(2147483647)) {\n        PackageDeclaration();\n    } else {\n    }\n    label_1 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case IMPORT :\n                break;\n            default :\n                jj_la1[0] = jj_gen;\n                break label_1;\n        }\n        ImportDeclaration();\n    } \n    label_2 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case CLASS :\n            case ENUM :\n            case FINAL :\n            case INTERFACE :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOLATILE :\n            case SEMICOLON :\n            case AT :\n                break;\n            default :\n                jj_la1[1] = jj_gen;\n                break label_2;\n        }\n        TypeDeclaration();\n    } \n    _pPackageMetric.ncss = _ncss;\n    _pPackageMetric.javadocsLn = JavaParserTokenManager._iFormalComments;\n    _pPackageMetric.singleLn = JavaParserTokenManager._iSingleComments;\n    _pPackageMetric.multiLn = JavaParserTokenManager._iMultiComments;\n    _htPackage.put(_formatPackage(_sPackage), _pPackageMetric);\n    label_3 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case IMPORT :\n            case PACKAGE :\n            case AT :\n                break;\n            default :\n                jj_la1[2] = jj_gen;\n                break label_3;\n        }\n        oldNcss = _ncss;\n        _sPackage = \"\";\n        _pPackageMetric = new PackageMetric();\n        oldFormal = JavaParserTokenManager._iFormalComments;\n        oldSingle = JavaParserTokenManager._iSingleComments;\n        oldMulti = JavaParserTokenManager._iMultiComments;\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case PACKAGE :\n            case AT :\n                PackageDeclaration();\n                break;\n            case IMPORT :\n                ImportDeclaration();\n                break;\n            default :\n                jj_la1[3] = jj_gen;\n                jj_consume_token(-1);\n                throw new ParseException();\n        }\n        label_4 : while (true) {\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case IMPORT :\n                    break;\n                default :\n                    jj_la1[4] = jj_gen;\n                    break label_4;\n            }\n            ImportDeclaration();\n        } \n        label_5 : while (true) {\n            TypeDeclaration();\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ABSTRACT :\n                case CLASS :\n                case ENUM :\n                case FINAL :\n                case INTERFACE :\n                case NATIVE :\n                case PRIVATE :\n                case PROTECTED :\n                case PUBLIC :\n                case STATIC :\n                case TESTAAAA :\n                case SYNCHRONIZED :\n                case TRANSIENT :\n                case VOLATILE :\n                case SEMICOLON :\n                case AT :\n                    break;\n                default :\n                    jj_la1[5] = jj_gen;\n                    break label_5;\n            }\n        } \n        _pPackageMetric.ncss = _ncss - oldNcss;\n        _pPackageMetric.javadocsLn = JavaParserTokenManager._iFormalComments - oldFormal;\n        _pPackageMetric.singleLn = JavaParserTokenManager._iSingleComments - oldSingle;\n        _pPackageMetric.multiLn = JavaParserTokenManager._iMultiComments - oldMulti;\n        PackageMetric pckmPrevious = ((PackageMetric) (_htPackage.get(_formatPackage(_sPackage))));\n        _pPackageMetric.add(pckmPrevious);\n        _htPackage.put(_formatPackage(_sPackage), _pPackageMetric);\n    } \n    jj_consume_token(0);\n    Token pToken = getToken(1);\n    _loc = pToken.endLine;\n    _nbligne = JavaParserTokenManager.nbligne;\n}"}], [{"methodBefore": "private boolean jj_3R_289() {\n    if (jj_scan_token(XOR)) {\n        return true;\n    }\n    if (jj_3R_281()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_285() {\n    if (jj_scan_token(XOR)) {\n        return true;\n    }\n    if (jj_3R_260()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_289() {\n    if (jj_scan_token(XOR)) {\n        return true;\n    }\n    if (jj_3R_281()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_285() {\n    if (jj_scan_token(XOR)) {\n        return true;\n    }\n    if (jj_3R_260()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void Identifier() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IDENTIFIER :\n            jj_consume_token(IDENTIFIER);\n            break;\n        case ASSERT :\n            jj_consume_token(ASSERT);\n            break;\n        default :\n            jj_la1[160] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void Identifier() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IDENTIFIER :\n            jj_consume_token(IDENTIFIER);\n            break;\n        case ASSERT :\n            jj_consume_token(ASSERT);\n            break;\n        default :\n            jj_la1[165] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void Identifier() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IDENTIFIER :\n            jj_consume_token(IDENTIFIER);\n            break;\n        case ASSERT :\n            jj_consume_token(ASSERT);\n            break;\n        default :\n            jj_la1[160] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void Identifier() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case IDENTIFIER :\n            jj_consume_token(IDENTIFIER);\n            break;\n        case ASSERT :\n            jj_consume_token(ASSERT);\n            break;\n        default :\n            jj_la1[165] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_248() {\n    if (jj_3R_268()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_246() {\n    if (jj_3R_268()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_248() {\n    if (jj_3R_268()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_246() {\n    if (jj_3R_268()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_316() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_391() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_316() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_391() {\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_210() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_461() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_210() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_461() {\n    if (jj_3R_224()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_188() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_447() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_188() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_447() {\n    if (jj_3R_198()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_181() {\n    if (jj_3R_115()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_181() {\n    if (jj_3R_200()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_181() {\n    if (jj_3R_115()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_181() {\n    if (jj_3R_200()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_299() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_404() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_299() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_404() {\n    if (jj_3R_309()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_387() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_386()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_390() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_389()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_387() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_386()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_390() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_389()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_449() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_455() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_449() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_455() {\n    if (jj_scan_token(_DEFAULT)) {\n        return true;\n    }\n    if (jj_scan_token(COLON)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_455() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_263()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_464() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_266()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_455() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_263()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_464() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_266()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_408() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_408() {\n    if (jj_3R_192()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_408() {\n    if (jj_3R_137()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_408() {\n    if (jj_3R_192()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_221() {\n    if (jj_3R_239()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_240()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_223() {\n    if (jj_3R_240()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_241()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_221() {\n    if (jj_3R_239()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_240()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_223() {\n    if (jj_3R_240()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_241()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_199() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_199() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_199() {\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_199() {\n    if (jj_3R_214()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void FieldDeclaration15(int modifiers) throws ParseException {\n    Type();\n    VariableDeclarator();\n    label_78 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[197] = jj_gen;\n                break label_78;\n        }\n        jj_consume_token(COMMA);\n        VariableDeclarator();\n    } \n    jj_consume_token(SEMICOLON);\n}", "methodAfter": "public final void FieldDeclaration15(int modifiers) throws ParseException {\n    Type();\n    VariableDeclarator();\n    label_82 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[203] = jj_gen;\n                break label_82;\n        }\n        jj_consume_token(COMMA);\n        VariableDeclarator();\n    } \n    jj_consume_token(SEMICOLON);\n}"}, {"methodBefore": "public final void FieldDeclaration15(int modifiers) throws ParseException {\n    Type();\n    VariableDeclarator();\n    label_78 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[197] = jj_gen;\n                break label_78;\n        }\n        jj_consume_token(COMMA);\n        VariableDeclarator();\n    } \n    jj_consume_token(SEMICOLON);\n}", "methodAfter": "public final void FieldDeclaration15(int modifiers) throws ParseException {\n    Type();\n    VariableDeclarator();\n    label_82 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[203] = jj_gen;\n                break label_82;\n        }\n        jj_consume_token(COMMA);\n        VariableDeclarator();\n    } \n    jj_consume_token(SEMICOLON);\n}"}], [{"methodBefore": "private boolean jj_3R_234() {\n    if (jj_3R_258()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_235() {\n    if (jj_3R_258()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_234() {\n    if (jj_3R_258()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_235() {\n    if (jj_3R_258()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_352() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_350() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_352() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_350() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void TypeParameter() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            TypeBound();\n            break;\n        default :\n            jj_la1[186] = jj_gen;\n    }\n}", "methodAfter": "public final void TypeParameter() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            TypeBound();\n            break;\n        default :\n            jj_la1[191] = jj_gen;\n    }\n}"}, {"methodBefore": "public final void TypeParameter() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            TypeBound();\n            break;\n        default :\n            jj_la1[186] = jj_gen;\n    }\n}", "methodAfter": "public final void TypeParameter() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case EXTENDS :\n            TypeBound();\n            break;\n        default :\n            jj_la1[191] = jj_gen;\n    }\n}"}], [{"methodBefore": "private void instrumentSwitchHit(int lineNumber, int switchNumber, int branch) {\n    instrumentGetClassData();\n    mv.visitIntInsn(SIPUSH, lineNumber);\n    mv.visitIntInsn(SIPUSH, switchNumber);\n    mv.visitIntInsn(SIPUSH, branch);\n    instrumentInvokeTouchSwitch();\n}", "methodAfter": "private void instrumentSwitchHit(int lineNumber, int switchNumber, int branch) {\n    instrumentOwnerClass();\n    mv.visitIntInsn(SIPUSH, lineNumber);\n    mv.visitIntInsn(SIPUSH, switchNumber);\n    mv.visitIntInsn(SIPUSH, branch);\n    instrumentInvokeTouchSwitch();\n}"}, {"methodBefore": "public void visitLineNumber(int line, Label start) {\n    currentLine = line;\n    currentJump = 0;\n    instrumentGetClassData();\n    mv.visitIntInsn(SIPUSH, line);\n    mv.visitMethodInsn(INVOKESTATIC, TOUCH_COLLECTOR_CLASS, \"touch\", \"(Ljava/lang/String;I)V\");\n    super.visitLineNumber(line, start);\n}", "methodAfter": "public void visitLineNumber(int line, Label start) {\n    currentLine = line;\n    currentJump = 0;\n    instrumentOwnerClass();\n    mv.visitIntInsn(SIPUSH, line);\n    mv.visitMethodInsn(INVOKESTATIC, TOUCH_COLLECTOR_CLASS, \"touch\", \"(Ljava/lang/String;I)V\");\n    super.visitLineNumber(line, start);\n}"}, {"methodBefore": "private void instrumentJumpHit(boolean branch) {\n    instrumentGetClassData();\n    instrumentPutLineAndBranchNumbers();\n    mv.visitInsn(branch ? BOOLEAN_TRUE : BOOLEAN_FALSE);\n    instrumentInvokeTouchJump();\n}", "methodAfter": "private void instrumentJumpHit(boolean branch) {\n    instrumentOwnerClass();\n    instrumentPutLineAndBranchNumbers();\n    mv.visitInsn(branch ? BOOLEAN_TRUE : BOOLEAN_FALSE);\n    instrumentInvokeTouchJump();\n}"}], [{"methodBefore": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[193] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[194] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[199] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[200] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[193] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[194] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void TypeArgument() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case BOOLEAN :\n        case BYTE :\n        case CHAR :\n        case DOUBLE :\n        case FLOAT :\n        case INT :\n        case LONG :\n        case SHORT :\n        case IDENTIFIER :\n            ReferenceType();\n            break;\n        case HOOK :\n            jj_consume_token(HOOK);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS :\n                case SUPER :\n                    WildcardBounds();\n                    break;\n                default :\n                    jj_la1[199] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[200] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "public final void TypeParameters() throws ParseException {\n    jj_consume_token(LT);\n    TypeParameter();\n    label_67 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[178] = jj_gen;\n                break label_67;\n        }\n        jj_consume_token(COMMA);\n        TypeParameter();\n    } \n    jj_consume_token(GT);\n}", "methodAfter": "public final void TypeParameters() throws ParseException {\n    jj_consume_token(LT);\n    TypeParameter();\n    label_70 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[183] = jj_gen;\n                break label_70;\n        }\n        jj_consume_token(COMMA);\n        TypeParameter();\n    } \n    jj_consume_token(GT);\n}"}, {"methodBefore": "public final void TypeParameters() throws ParseException {\n    jj_consume_token(LT);\n    TypeParameter();\n    label_67 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[178] = jj_gen;\n                break label_67;\n        }\n        jj_consume_token(COMMA);\n        TypeParameter();\n    } \n    jj_consume_token(GT);\n}", "methodAfter": "public final void TypeParameters() throws ParseException {\n    jj_consume_token(LT);\n    TypeParameter();\n    label_70 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case COMMA :\n                break;\n            default :\n                jj_la1[183] = jj_gen;\n                break label_70;\n        }\n        jj_consume_token(COMMA);\n        TypeParameter();\n    } \n    jj_consume_token(GT);\n}"}], [{"methodBefore": "private boolean jj_3R_374() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_377() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_374() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_377() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "@Override\npublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n    MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n    if (\"<clinit>\".equals(name)) {\n        mv = new GenerateCLINITMethodVisitor(mv, classMap.getClassName(), classMap.getMaxCounterId() + 1);\n        wasStaticInitMethodVisited = true;\n    }\n    FindTouchPointsMethodAdapter instrumenter = new FindTouchPointsMethodAdapter(mv, classMap.getClassName(), name, desc, eventIdGenerator, duplicatedLinesMap, lineIdGenerator);\n    instrumenter.setTouchPointListener(touchPointListener);\n    instrumenter.setIgnoreRegexp(getIgnoreRegexp());\n    touchPointListener.setLastJumpIdVariableIndex(ShiftVariableMethodAdapter.calculateFirstStackVariable(access, desc));\n    return new ShiftVariableMethodAdapter(instrumenter, access, desc, 1);\n}", "methodAfter": "@Override\npublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n    MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n    if (ignoredMethods.contains(name + desc)) {\n        return mv;\n    }\n    if (\"<clinit>\".equals(name)) {\n        mv = new GenerateCLINITMethodVisitor(mv, classMap.getClassName(), classMap.getMaxCounterId() + 1);\n        wasStaticInitMethodVisited = true;\n    }\n    FindTouchPointsMethodAdapter instrumenter = new FindTouchPointsMethodAdapter(mv, classMap.getClassName(), name, desc, eventIdGenerator, duplicatedLinesMap, lineIdGenerator);\n    instrumenter.setTouchPointListener(touchPointListener);\n    instrumenter.setIgnoreRegexp(getIgnoreRegexp());\n    touchPointListener.setLastJumpIdVariableIndex(ShiftVariableMethodAdapter.calculateFirstStackVariable(access, desc));\n    return new ShiftVariableMethodAdapter(instrumenter, access, desc, 1);\n}"}, {"methodBefore": "@Override\npublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n    MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n    FindTouchPointsMethodAdapter instrumenter = new FindTouchPointsMethodAdapter(mv, classMap.getClassName(), name, desc, eventIdGenerator, duplicatedLinesMap, lineIdGenerator);\n    instrumenter.setTouchPointListener(touchPointListener);\n    instrumenter.setIgnoreRegexp(getIgnoreRegexp());\n    return instrumenter;\n}", "methodAfter": "@Override\npublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n    MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n    if (ignoredMethods.contains(name + desc)) {\n        return mv;\n    }\n    FindTouchPointsMethodAdapter instrumenter = new FindTouchPointsMethodAdapter(mv, classMap.getClassName(), name, desc, eventIdGenerator, duplicatedLinesMap, lineIdGenerator);\n    instrumenter.setTouchPointListener(touchPointListener);\n    instrumenter.setIgnoreRegexp(getIgnoreRegexp());\n    return instrumenter;\n}"}], [{"methodBefore": "public final void Literal() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INTEGER_LITERAL :\n            jj_consume_token(INTEGER_LITERAL);\n            break;\n        case FLOATING_POINT_LITERAL :\n            jj_consume_token(FLOATING_POINT_LITERAL);\n            break;\n        case CHARACTER_LITERAL :\n            jj_consume_token(CHARACTER_LITERAL);\n            break;\n        case STRING_LITERAL :\n            jj_consume_token(STRING_LITERAL);\n            break;\n        case FALSE :\n        case TRUE :\n            BooleanLiteral();\n            break;\n        case NULL :\n            NullLiteral();\n            break;\n        default :\n            jj_la1[127] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void Literal() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INTEGER_LITERAL :\n            jj_consume_token(INTEGER_LITERAL);\n            break;\n        case FLOATING_POINT_LITERAL :\n            jj_consume_token(FLOATING_POINT_LITERAL);\n            break;\n        case CHARACTER_LITERAL :\n            jj_consume_token(CHARACTER_LITERAL);\n            break;\n        case STRING_LITERAL :\n            jj_consume_token(STRING_LITERAL);\n            break;\n        case FALSE :\n        case TRUE :\n            BooleanLiteral();\n            break;\n        case NULL :\n            NullLiteral();\n            break;\n        default :\n            jj_la1[128] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}, {"methodBefore": "public final void Literal() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INTEGER_LITERAL :\n            jj_consume_token(INTEGER_LITERAL);\n            break;\n        case FLOATING_POINT_LITERAL :\n            jj_consume_token(FLOATING_POINT_LITERAL);\n            break;\n        case CHARACTER_LITERAL :\n            jj_consume_token(CHARACTER_LITERAL);\n            break;\n        case STRING_LITERAL :\n            jj_consume_token(STRING_LITERAL);\n            break;\n        case FALSE :\n        case TRUE :\n            BooleanLiteral();\n            break;\n        case NULL :\n            NullLiteral();\n            break;\n        default :\n            jj_la1[127] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}", "methodAfter": "public final void Literal() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case INTEGER_LITERAL :\n            jj_consume_token(INTEGER_LITERAL);\n            break;\n        case FLOATING_POINT_LITERAL :\n            jj_consume_token(FLOATING_POINT_LITERAL);\n            break;\n        case CHARACTER_LITERAL :\n            jj_consume_token(CHARACTER_LITERAL);\n            break;\n        case STRING_LITERAL :\n            jj_consume_token(STRING_LITERAL);\n            break;\n        case FALSE :\n        case TRUE :\n            BooleanLiteral();\n            break;\n        case NULL :\n            NullLiteral();\n            break;\n        default :\n            jj_la1[128] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_296() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_296() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_296() {\n    if (jj_3R_84()) {\n        return true;\n    }\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_296() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_306()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void ClassOrInterfaceBody(boolean isInterface) throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"ClassOrInterfaceBody()._ncss++\");\n    label_70 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case LT :\n                break;\n            default :\n                jj_la1[181] = jj_gen;\n                break label_70;\n        }\n        ClassOrInterfaceBodyDeclaration(isInterface);\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void ClassOrInterfaceBody(boolean isInterface) throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"ClassOrInterfaceBody()._ncss++\");\n    label_73 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case LT :\n                break;\n            default :\n                jj_la1[186] = jj_gen;\n                break label_73;\n        }\n        ClassOrInterfaceBodyDeclaration(isInterface);\n    } \n    jj_consume_token(RBRACE);\n}"}, {"methodBefore": "public final void ClassOrInterfaceBody(boolean isInterface) throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"ClassOrInterfaceBody()._ncss++\");\n    label_70 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case LT :\n                break;\n            default :\n                jj_la1[181] = jj_gen;\n                break label_70;\n        }\n        ClassOrInterfaceBodyDeclaration(isInterface);\n    } \n    jj_consume_token(RBRACE);\n}", "methodAfter": "public final void ClassOrInterfaceBody(boolean isInterface) throws ParseException {\n    jj_consume_token(LBRACE);\n    _ncss++;\n    Util.debug(\"ClassOrInterfaceBody()._ncss++\");\n    label_73 : while (true) {\n        switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n            case ABSTRACT :\n            case ASSERT :\n            case BOOLEAN :\n            case BYTE :\n            case CHAR :\n            case CLASS :\n            case DOUBLE :\n            case ENUM :\n            case FINAL :\n            case FLOAT :\n            case INT :\n            case INTERFACE :\n            case LONG :\n            case NATIVE :\n            case PRIVATE :\n            case PROTECTED :\n            case PUBLIC :\n            case SHORT :\n            case STATIC :\n            case TESTAAAA :\n            case SYNCHRONIZED :\n            case TRANSIENT :\n            case VOID :\n            case VOLATILE :\n            case IDENTIFIER :\n            case LBRACE :\n            case SEMICOLON :\n            case AT :\n            case LT :\n                break;\n            default :\n                jj_la1[186] = jj_gen;\n                break label_73;\n        }\n        ClassOrInterfaceBodyDeclaration(isInterface);\n    } \n    jj_consume_token(RBRACE);\n}"}], [{"methodBefore": "private boolean jj_3R_141() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_171()) {\n        jj_scanpos = xsp;\n        if (jj_3R_172()) {\n            jj_scanpos = xsp;\n            if (jj_3R_173()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_143() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_172()) {\n        jj_scanpos = xsp;\n        if (jj_3R_173()) {\n            return true;\n        }\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_141() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_171()) {\n        jj_scanpos = xsp;\n        if (jj_3R_172()) {\n            jj_scanpos = xsp;\n            if (jj_3R_173()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_143() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_172()) {\n        jj_scanpos = xsp;\n        if (jj_3R_173()) {\n            return true;\n        }\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_122() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_125() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_122() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_125() {\n    if (jj_scan_token(IDENTIFIER)) {\n        return true;\n    }\n    if (jj_scan_token(ASSIGN)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "void coverage(String[] filenames) {\n    if (filenames.length == 0) {\n        return;\n    }\n    for (int i = 0; i < filenames.length; i++) {\n        getProject().log((\"Adding \" + filenames[i]) + \" to list\", MSG_VERBOSE);\n        addArg(filenames[i]);\n    }\n    saveArgs();\n    Copyright.print(System.out);\n    System.out.println((((\"instrumenting \" + filenames.length) + \" \") + (filenames.length == 1 ? \"class\" : \"classes\")) + (toDir != null ? \" to \" + toDir : \"\"));\n    if (getJava().executeJava() != 0) {\n        throw new BuildException();\n    }\n}", "methodAfter": "void coverage(String[] filenames) {\n    if (filenames.length == 0) {\n        return;\n    }\n    for (int i = 0; i < filenames.length; i++) {\n        getProject().log((\"Adding \" + filenames[i]) + \" to list\", MSG_VERBOSE);\n        addArg(filenames[i]);\n    }\n    saveArgs();\n    Header.print(System.out);\n    System.out.println((((\"instrumenting \" + filenames.length) + \" \") + (filenames.length == 1 ? \"class\" : \"classes\")) + (toDir != null ? \" to \" + toDir : \"\"));\n    if (getJava().executeJava() != 0) {\n        throw new BuildException();\n    }\n}"}, {"methodBefore": "public void execute() throws BuildException {\n    Copyright.print(System.out);\n    getJava().createArg().setValue(\"-i\");\n    getJava().createArg().setValue(coverageDataFileName);\n    getJava().createArg().setValue(\"-s\");\n    getJava().createArg().setValue(src.toString());\n    getJava().createArg().setValue(\"-o\");\n    getJava().createArg().setValue(destDir.toString());\n    getJava().createArg().setValue(\"-f\");\n    getJava().createArg().setValue(format);\n    if (getJava().executeJava() != 0) {\n        throw new BuildException();\n    }\n}", "methodAfter": "public void execute() throws BuildException {\n    Header.print(System.out);\n    getJava().createArg().setValue(\"-i\");\n    getJava().createArg().setValue(coverageDataFileName);\n    getJava().createArg().setValue(\"-s\");\n    getJava().createArg().setValue(src.toString());\n    getJava().createArg().setValue(\"-o\");\n    getJava().createArg().setValue(destDir.toString());\n    getJava().createArg().setValue(\"-f\");\n    getJava().createArg().setValue(format);\n    if (getJava().executeJava() != 0) {\n        throw new BuildException();\n    }\n}"}, {"methodBefore": "public Main(String[] args) throws IOException {\n    Copyright.print(System.out);\n    System.out.println(\"Cobertura coverage check\");\n    LongOpt[] longOpts = new LongOpt[4];\n    longOpts[0] = new LongOpt(\"branch\", LongOpt.REQUIRED_ARGUMENT, null, 'b');\n    longOpts[1] = new LongOpt(\"line\", LongOpt.REQUIRED_ARGUMENT, null, 'l');\n    longOpts[2] = new LongOpt(\"directory\", LongOpt.REQUIRED_ARGUMENT, null, 'd');\n    longOpts[3] = new LongOpt(\"regex\", LongOpt.REQUIRED_ARGUMENT, null, 'r');\n    Getopt g = new Getopt(getClass().getName(), args, \":b:l:d:r:\", longOpts);\n    int c;\n    double branchCoverageRate = 0.8;\n    double lineCoverageRate = 0.7;\n    while ((c = g.getopt()) != (-1)) {\n        switch (c) {\n            case 'b' :\n                branchCoverageRate = inRangeAndDivideByOneHundred(g.getOptarg());\n                break;\n            case 'l' :\n                lineCoverageRate = inRangeAndDivideByOneHundred(g.getOptarg());\n                break;\n            case 'd' :\n                setInstrumentationDirectory(new File(g.getOptarg()));\n                break;\n            case 'r' :\n                setMinimumCoverageRate(g.getOptarg());\n                break;\n        }\n    } \n    minimumCoverageRate = new CoverageRate(lineCoverageRate, branchCoverageRate);\n    if (logger.isInfoEnabled()) {\n        logger.info(\"instrumentation directory: \" + instrumentationDirectory);\n    }\n    merge(loadInstrumentation(new FileInputStream(new File(instrumentationDirectory, InstrumentationPersistence.FILE_NAME))));\n    if (logger.isInfoEnabled()) {\n        logger.info((\"instrumentation has \" + keySet().size()) + \" entries\");\n    }\n    Iterator i = keySet().iterator();\n    while (i.hasNext()) {\n        String key = ((String) (i.next()));\n        CoverageRate coverageRate = findMinimumCoverageRate(key);\n        CoverageData instrumentation = getInstrumentation(key);\n        if (logger.isInfoEnabled()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\", line: \");\n            sb.append(percentage(instrumentation.getLineCoverageRate()));\n            sb.append(\"% (\");\n            sb.append(percentage(coverageRate.getLineCoverageRate()));\n            sb.append(\"%), branch: \");\n            sb.append(percentage(instrumentation.getBranchCoverageRate()));\n            sb.append(\"% (\");\n            sb.append(percentage(coverageRate.getBranchCoverageRate()));\n            sb.append(\"%)\");\n            logger.info(sb.toString());\n        }\n        if (instrumentation.getLineCoverageRate() < coverageRate.getLineCoverageRate()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\" line coverage rate of: \");\n            sb.append(percentage(instrumentation.getLineCoverageRate()));\n            sb.append(\"% (required: \");\n            sb.append(percentage(coverageRate.getLineCoverageRate()));\n            sb.append(\"%)\");\n            System.out.println(sb.toString());\n        }\n        if (instrumentation.getBranchCoverageRate() < coverageRate.getBranchCoverageRate()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\" branch coverage rate of: \");\n            sb.append(percentage(instrumentation.getBranchCoverageRate()));\n            sb.append(\"% (required: \");\n            sb.append(percentage(coverageRate.getBranchCoverageRate()));\n            sb.append(\"%)\");\n            System.out.println(sb.toString());\n        }\n    } \n}", "methodAfter": "public Main(String[] args) throws IOException {\n    Header.print(System.out);\n    System.out.println(\"Cobertura coverage check\");\n    LongOpt[] longOpts = new LongOpt[4];\n    longOpts[0] = new LongOpt(\"branch\", LongOpt.REQUIRED_ARGUMENT, null, 'b');\n    longOpts[1] = new LongOpt(\"line\", LongOpt.REQUIRED_ARGUMENT, null, 'l');\n    longOpts[2] = new LongOpt(\"directory\", LongOpt.REQUIRED_ARGUMENT, null, 'd');\n    longOpts[3] = new LongOpt(\"regex\", LongOpt.REQUIRED_ARGUMENT, null, 'r');\n    Getopt g = new Getopt(getClass().getName(), args, \":b:l:d:r:\", longOpts);\n    int c;\n    double branchCoverageRate = 0.8;\n    double lineCoverageRate = 0.7;\n    while ((c = g.getopt()) != (-1)) {\n        switch (c) {\n            case 'b' :\n                branchCoverageRate = inRangeAndDivideByOneHundred(g.getOptarg());\n                break;\n            case 'l' :\n                lineCoverageRate = inRangeAndDivideByOneHundred(g.getOptarg());\n                break;\n            case 'd' :\n                setInstrumentationDirectory(new File(g.getOptarg()));\n                break;\n            case 'r' :\n                setMinimumCoverageRate(g.getOptarg());\n                break;\n        }\n    } \n    minimumCoverageRate = new CoverageRate(lineCoverageRate, branchCoverageRate);\n    if (logger.isInfoEnabled()) {\n        logger.info(\"instrumentation directory: \" + instrumentationDirectory);\n    }\n    merge(loadInstrumentation(new FileInputStream(new File(instrumentationDirectory, InstrumentationPersistence.FILE_NAME))));\n    if (logger.isInfoEnabled()) {\n        logger.info((\"instrumentation has \" + keySet().size()) + \" entries\");\n    }\n    Iterator i = keySet().iterator();\n    while (i.hasNext()) {\n        String key = ((String) (i.next()));\n        CoverageRate coverageRate = findMinimumCoverageRate(key);\n        CoverageData instrumentation = getInstrumentation(key);\n        if (logger.isInfoEnabled()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\", line: \");\n            sb.append(percentage(instrumentation.getLineCoverageRate()));\n            sb.append(\"% (\");\n            sb.append(percentage(coverageRate.getLineCoverageRate()));\n            sb.append(\"%), branch: \");\n            sb.append(percentage(instrumentation.getBranchCoverageRate()));\n            sb.append(\"% (\");\n            sb.append(percentage(coverageRate.getBranchCoverageRate()));\n            sb.append(\"%)\");\n            logger.info(sb.toString());\n        }\n        if (instrumentation.getLineCoverageRate() < coverageRate.getLineCoverageRate()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\" line coverage rate of: \");\n            sb.append(percentage(instrumentation.getLineCoverageRate()));\n            sb.append(\"% (required: \");\n            sb.append(percentage(coverageRate.getLineCoverageRate()));\n            sb.append(\"%)\");\n            System.out.println(sb.toString());\n        }\n        if (instrumentation.getBranchCoverageRate() < coverageRate.getBranchCoverageRate()) {\n            StringBuffer sb = new StringBuffer();\n            sb.append(key);\n            sb.append(\" branch coverage rate of: \");\n            sb.append(percentage(instrumentation.getBranchCoverageRate()));\n            sb.append(\"% (required: \");\n            sb.append(percentage(coverageRate.getBranchCoverageRate()));\n            sb.append(\"%)\");\n            System.out.println(sb.toString());\n        }\n    } \n}"}, {"methodBefore": "public static void main(String[] args) {\n    Copyright.print(System.out);\n    System.out.println(\"Cobertura instrumentation merge tool\");\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufreader = null;\n        try {\n            bufreader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufreader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufreader != null) {\n                try {\n                    bufreader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    new Main(args);\n}", "methodAfter": "public static void main(String[] args) {\n    Header.print(System.out);\n    System.out.println(\"Cobertura instrumentation merge tool\");\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufreader = null;\n        try {\n            bufreader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufreader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufreader != null) {\n                try {\n                    bufreader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    new Main(args);\n}"}], [{"methodBefore": "private boolean jj_3_59() {\n    if (jj_3R_85()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_58() {\n    if (jj_3R_89()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_59() {\n    if (jj_3R_85()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_58() {\n    if (jj_3R_89()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_179() {\n    if (jj_scan_token(THIS)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(85)) {\n        jj_scanpos = xsp;\n    }\n    xsp = jj_scanpos;\n    if (jj_3R_199()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_179() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_178()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_179() {\n    if (jj_scan_token(THIS)) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(85)) {\n        jj_scanpos = xsp;\n    }\n    xsp = jj_scanpos;\n    if (jj_3R_199()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_179() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_178()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "@Test\npublic void callJunit() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    final File srcDir = new File(tempDir, \"src\");\n    final File reportDir = new File(tempDir, \"report\");\n    reportDir.mkdirs();\n    final File instrumentDir = new File(tempDir, \"instrument\");\n    instrumentDir.mkdirs();\n    File buildDir = new File(tempDir, \"build\");\n    buildDir.mkdirs();\n    File testSourceFile = new File(srcDir, \"mypackage/MyTest.groovy\");\n    testSourceFile.getParentFile().mkdirs();\n    FileUtils.write(testSourceFile, (((((((((((((((((\"\\n package mypackage\" + \"\\n \") + \"\\n import junit.framework.TestSuite\") + \"\\n import junit.framework.Test\") + \"\\n \") + \"\\n \") + \"\\n public class MyTest extends TestSuite {\") + \"\\n public MyTest(String arg0) {\") + \"\\n \\tsuper(arg0);\") + \"\\n }\") + \"\\n \") + \"\\n public static Test suite() {\") + \"\\n \\t\") + \"\\n \\t// do something that will cause Sub\\'s static initializer to run\") + \"\\n \\tSub.class\") + \"\\n \") + \"\\n \\treturn new TestSuite(\\\"Empty Suite\\\")\") + \"\\n }\") + \"\\n }\");\n    File superSourceFile = new File(srcDir, \"mypackage/Super.java\");\n    File subSourceFile = new File(srcDir, \"mypackage/Sub.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    FileUtils.write(superSourceFile, (((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Super {\") + \"\\n  static {\") + \"\\n   Sub.aStaticMethod();\") + \"\\n  };\") + \"\\n }\");\n    FileUtils.write(subSourceFile, (((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Sub extends Super {\") + \"\\n  \") + \"\\n  public static void aStaticMethod() {\") + \"\\n   System.out.println(\\\"aStaticMethod called\\\");\") + \"\\n  }\") + \"\\n  \") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"excludeClassesRegexList\", \"mypackage.MyTest\");\n        }\n    });\n    TestUtils.junit(new HashMap() {\n        {\n            put(\"testClass\", \"mypackage.MyTest\");\n            put(\"ant\", ant);\n            put(\"buildDir\", srcDir);\n            put(\"instrumentDir\", instrumentDir);\n            put(\"reportDir\", reportDir);\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    List<Node> lines = TestUtils.getLineCounts(dom, \"mypackage.Sub\", \"aStaticMethod\");\n    Node aStaticMethodLine = null;\n    for (Node line : lines) {\n        if (\"7\".equals(line.attribute(\"number\"))) {\n            aStaticMethodLine = line;\n            break;\n        }\n    }\n    assertEquals(1, Integer.valueOf(aStaticMethodLine.attribute(\"hits\").toString()).intValue());\n}", "methodAfter": "@Test\npublic void callJunit() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    final File srcDir = new File(tempDir, \"src\");\n    final File reportDir = new File(tempDir, \"report\");\n    reportDir.mkdirs();\n    final File instrumentDir = new File(tempDir, \"instrument\");\n    instrumentDir.mkdirs();\n    File buildDir = new File(tempDir, \"build\");\n    buildDir.mkdirs();\n    File testSourceFile = new File(srcDir, \"mypackage/MyTest.groovy\");\n    testSourceFile.getParentFile().mkdirs();\n    FileUtils.write(testSourceFile, (((((((((((((((((\"\\n package mypackage\" + \"\\n \") + \"\\n import junit.framework.TestSuite\") + \"\\n import junit.framework.Test\") + \"\\n \") + \"\\n \") + \"\\n public class MyTest extends TestSuite {\") + \"\\n public MyTest(String arg0) {\") + \"\\n \\tsuper(arg0);\") + \"\\n }\") + \"\\n \") + \"\\n public static Test suite() {\") + \"\\n \\t\") + \"\\n \\t// do something that will cause Sub\\'s static initializer to run\") + \"\\n \\tSub.class\") + \"\\n \") + \"\\n \\treturn new TestSuite(\\\"Empty Suite\\\")\") + \"\\n }\") + \"\\n }\");\n    File superSourceFile = new File(srcDir, \"mypackage/Super.java\");\n    File subSourceFile = new File(srcDir, \"mypackage/Sub.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    FileUtils.write(superSourceFile, (((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Super {\") + \"\\n  static {\") + \"\\n   Sub.aStaticMethod();\") + \"\\n  };\") + \"\\n }\");\n    FileUtils.write(subSourceFile, (((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Sub extends Super {\") + \"\\n  \") + \"\\n  public static void aStaticMethod() {\") + \"\\n   System.out.println(\\\"aStaticMethod called\\\");\") + \"\\n  }\") + \"\\n  \") + \"\\n }\");\n    TestUtils.compileGroovy(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"excludeClassesRegexList\", \"mypackage.MyTest\");\n        }\n    });\n    TestUtils.junit(new HashMap() {\n        {\n            put(\"testClass\", \"mypackage.MyTest\");\n            put(\"ant\", ant);\n            put(\"buildDir\", srcDir);\n            put(\"instrumentDir\", instrumentDir);\n            put(\"reportDir\", reportDir);\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    List<Node> lines = TestUtils.getLineCounts(dom, \"mypackage.Sub\", \"aStaticMethod\");\n    Node aStaticMethodLine = null;\n    for (Node line : lines) {\n        if (\"7\".equals(line.attribute(\"number\"))) {\n            aStaticMethodLine = line;\n            break;\n        }\n    }\n    assertEquals(1, Integer.valueOf(aStaticMethodLine.attribute(\"hits\").toString()).intValue());\n}"}, {"methodBefore": "@Test\npublic void callJunit() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    final File srcDir = new File(tempDir, \"src\");\n    final File reportDir = new File(tempDir, \"report\");\n    reportDir.mkdirs();\n    final File instrumentDir = new File(tempDir, \"instrument\");\n    instrumentDir.mkdirs();\n    File buildDir = new File(tempDir, \"build\");\n    buildDir.mkdirs();\n    File testSourceFile = new File(srcDir, \"mypackage/MyTest.groovy\");\n    testSourceFile.getParentFile().mkdirs();\n    FileUtils.write(testSourceFile, (((((((((((((((((\"\\n package mypackage\" + \"\\n \") + \"\\n import junit.framework.TestSuite\") + \"\\n import junit.framework.Test\") + \"\\n \") + \"\\n \") + \"\\n public class MyTest extends TestSuite {\") + \"\\n public MyTest(String arg0) {\") + \"\\n \\tsuper(arg0);\") + \"\\n }\") + \"\\n \") + \"\\n public static Test suite() {\") + \"\\n \\t\") + \"\\n \\t// do something that will cause Sub\\'s static initializer to run\") + \"\\n \\tSub.class\") + \"\\n \") + \"\\n \\treturn new TestSuite(\\\"Empty Suite\\\")\") + \"\\n }\") + \"\\n }\");\n    File superSourceFile = new File(srcDir, \"mypackage/Super.java\");\n    File subSourceFile = new File(srcDir, \"mypackage/Sub.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    FileUtils.write(superSourceFile, (((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Super {\") + \"\\n  static {\") + \"\\n   Sub.aStaticMethod();\") + \"\\n  };\") + \"\\n }\");\n    FileUtils.write(subSourceFile, (((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Sub extends Super {\") + \"\\n  \") + \"\\n  public static void aStaticMethod() {\") + \"\\n   System.out.println(\\\"aStaticMethod called\\\");\") + \"\\n  }\") + \"\\n  \") + \"\\n }\");\n    TestUtils.compileSource(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"excludeClassesRegexList\", \"mypackage.MyTest\");\n        }\n    });\n    TestUtils.junit(new HashMap() {\n        {\n            put(\"testClass\", \"mypackage.MyTest\");\n            put(\"ant\", ant);\n            put(\"buildDir\", srcDir);\n            put(\"instrumentDir\", instrumentDir);\n            put(\"reportDir\", reportDir);\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    List<Node> lines = TestUtils.getLineCounts(dom, \"mypackage.Sub\", \"aStaticMethod\");\n    Node aStaticMethodLine = null;\n    for (Node line : lines) {\n        if (\"7\".equals(line.attribute(\"number\"))) {\n            aStaticMethodLine = line;\n            break;\n        }\n    }\n    assertEquals(1, Integer.valueOf(aStaticMethodLine.attribute(\"hits\").toString()).intValue());\n}", "methodAfter": "@Test\npublic void callJunit() throws Exception {\n    File tempDir = TestUtils.getTempDir();\n    final File srcDir = new File(tempDir, \"src\");\n    final File reportDir = new File(tempDir, \"report\");\n    reportDir.mkdirs();\n    final File instrumentDir = new File(tempDir, \"instrument\");\n    instrumentDir.mkdirs();\n    File buildDir = new File(tempDir, \"build\");\n    buildDir.mkdirs();\n    File testSourceFile = new File(srcDir, \"mypackage/MyTest.groovy\");\n    testSourceFile.getParentFile().mkdirs();\n    FileUtils.write(testSourceFile, (((((((((((((((((\"\\n package mypackage\" + \"\\n \") + \"\\n import junit.framework.TestSuite\") + \"\\n import junit.framework.Test\") + \"\\n \") + \"\\n \") + \"\\n public class MyTest extends TestSuite {\") + \"\\n public MyTest(String arg0) {\") + \"\\n \\tsuper(arg0);\") + \"\\n }\") + \"\\n \") + \"\\n public static Test suite() {\") + \"\\n \\t\") + \"\\n \\t// do something that will cause Sub\\'s static initializer to run\") + \"\\n \\tSub.class\") + \"\\n \") + \"\\n \\treturn new TestSuite(\\\"Empty Suite\\\")\") + \"\\n }\") + \"\\n }\");\n    File superSourceFile = new File(srcDir, \"mypackage/Super.java\");\n    File subSourceFile = new File(srcDir, \"mypackage/Sub.java\");\n    File datafile = new File(srcDir, \"cobertura.ser\");\n    FileUtils.write(superSourceFile, (((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Super {\") + \"\\n  static {\") + \"\\n   Sub.aStaticMethod();\") + \"\\n  };\") + \"\\n }\");\n    FileUtils.write(subSourceFile, (((((((\"\\n package mypackage;\" + \"\\n \") + \"\\n public class Sub extends Super {\") + \"\\n  \") + \"\\n  public static void aStaticMethod() {\") + \"\\n   System.out.println(\\\"aStaticMethod called\\\");\") + \"\\n  }\") + \"\\n  \") + \"\\n }\");\n    TestUtils.compileGroovy(ant, srcDir);\n    TestUtils.instrumentClasses(ant, srcDir, datafile, instrumentDir, new HashMap() {\n        {\n            put(\"excludeClassesRegexList\", \"mypackage.MyTest\");\n        }\n    });\n    TestUtils.junit(new HashMap() {\n        {\n            put(\"testClass\", \"mypackage.MyTest\");\n            put(\"ant\", ant);\n            put(\"buildDir\", srcDir);\n            put(\"instrumentDir\", instrumentDir);\n            put(\"reportDir\", reportDir);\n        }\n    });\n    ReportTask reportTask = new ReportTask();\n    reportTask.setProject(project);\n    reportTask.setDataFile(datafile.getAbsolutePath());\n    reportTask.setFormat(\"xml\");\n    reportTask.setDestDir(srcDir);\n    reportTask.execute();\n    dom = TestUtils.getXMLReportDOM(srcDir.getAbsolutePath() + \"/coverage.xml\");\n    List<Node> lines = TestUtils.getLineCounts(dom, \"mypackage.Sub\", \"aStaticMethod\");\n    Node aStaticMethodLine = null;\n    for (Node line : lines) {\n        if (\"7\".equals(line.attribute(\"number\"))) {\n            aStaticMethodLine = line;\n            break;\n        }\n    }\n    assertEquals(1, Integer.valueOf(aStaticMethodLine.attribute(\"hits\").toString()).intValue());\n}"}], [{"methodBefore": "private boolean jj_3R_160() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_163() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_160() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_105()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_163() {\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_369() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_369() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_369() {\n    if (jj_scan_token(ABSTRACT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_369() {\n    if (jj_scan_token(PROTECTED)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_445() {\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_301() {\n    if (jj_3R_311()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_445() {\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_301() {\n    if (jj_3R_311()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_440() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_184()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_444() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_187()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_440() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_184()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_444() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_187()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public int getNumberOfCoveredBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfCoveredBranches() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfValidBranches() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidBranches() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public int getNumberOfValidLines() {\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}", "methodAfter": "public int getNumberOfValidLines() {\n    synchronizeState();\n    int number = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    return number;\n}"}, {"methodBefore": "public double getBranchCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getBranchCoverageRate() {\n    synchronizeState();\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidBranches();\n            numberCovered += coverageContainer.getNumberOfCoveredBranches();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}, {"methodBefore": "public double getLineCoverageRate() {\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = iter.next();\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}", "methodAfter": "public double getLineCoverageRate() {\n    synchronizeState();\n    int number = 0;\n    int numberCovered = 0;\n    lock.lock();\n    try {\n        Iterator<CoverageData> iter = this.children.values().iterator();\n        while (iter.hasNext()) {\n            CoverageData coverageContainer = ((CoverageData) (iter.next()));\n            number += coverageContainer.getNumberOfValidLines();\n            numberCovered += coverageContainer.getNumberOfCoveredLines();\n        } \n    } finally {\n        lock.unlock();\n    }\n    if (number == 0) {\n        return 1.0;\n    }\n    return ((double) (numberCovered)) / number;\n}"}], [{"methodBefore": "private boolean jj_3R_145() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_151() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_145() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_151() {\n    if (jj_3R_146()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_452() {\n    if (jj_3R_222()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_452() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_107()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_459()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_380()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_452() {\n    if (jj_3R_222()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_452() {\n    if (jj_3R_88()) {\n        return true;\n    }\n    if (jj_3R_107()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_459()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    if (jj_3R_380()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_138() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_138() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_148() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_148() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_138() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_138() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_335() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_335() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_93() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_93() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_93() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_93() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_148() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_148() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_335() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_335() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3_20() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_20() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_20() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_20() {\n    if (jj_3R_106()) {\n        return true;\n    }\n    if (jj_scan_token(DOT)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_357() {\n    if (jj_3R_136()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_53()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_171() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_59()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_357() {\n    if (jj_3R_136()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_53()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_171() {\n    if (jj_3R_143()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3_59()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_322() {\n    if (jj_3R_356()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_322() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_322() {\n    if (jj_3R_356()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_322() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public SortedSet getClasses() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getClasses() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getClasses() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getClasses() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getPackages() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getPackages() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}, {"methodBefore": "public SortedSet getLines() {\n    return new TreeSet(this.children.values());\n}", "methodAfter": "public SortedSet getLines() {\n    lock.lock();\n    try {\n        return new TreeSet(this.children.values());\n    } finally {\n        lock.unlock();\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_139() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_142() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_139() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_142() {\n    if (jj_scan_token(LBRACKET)) {\n        return true;\n    }\n    if (jj_scan_token(RBRACKET)) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_318() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(52)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(13)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(31)) {\n                jj_scanpos = xsp;\n                if (jj_3R_346()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_347()) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(47)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(53)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_318() {\n    if (jj_3R_348()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_318() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(52)) {\n        jj_scanpos = xsp;\n        if (jj_scan_token(13)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(31)) {\n                jj_scanpos = xsp;\n                if (jj_3R_346()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_347()) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(47)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(53)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_318() {\n    if (jj_3R_348()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_341() {\n    if (jj_3R_377()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_378()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_167() {\n    if (jj_3R_193()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_208()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_341() {\n    if (jj_3R_377()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_378()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_167() {\n    if (jj_3R_193()) {\n        return true;\n    }\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_208()) {\n        jj_scanpos = xsp;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_301() {\n    if (jj_3R_312()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_343()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_304() {\n    if (jj_3R_315()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_346()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_301() {\n    if (jj_3R_312()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_343()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}", "methodAfter": "private boolean jj_3R_304() {\n    if (jj_3R_315()) {\n        return true;\n    }\n    Token xsp;\n    while (true) {\n        xsp = jj_scanpos;\n        if (jj_3R_346()) {\n            jj_scanpos = xsp;\n            break;\n        }\n    } \n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_446() {\n    if (jj_3R_451()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_462() {\n    if (jj_3R_463()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_446() {\n    if (jj_3R_451()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_462() {\n    if (jj_3R_463()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_195() {\n    if (jj_scan_token(AT)) {\n        return true;\n    }\n    if (jj_3R_94()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_197() {\n    if (jj_scan_token(AT)) {\n        return true;\n    }\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_195() {\n    if (jj_scan_token(AT)) {\n        return true;\n    }\n    if (jj_3R_94()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_197() {\n    if (jj_scan_token(AT)) {\n        return true;\n    }\n    if (jj_3R_98()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error running reports. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    createCommandsFileAndExecute(builder);\n}"}, {"methodBefore": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (destDir != null) {\n            builder.addArg(\"--destination\", destDir.getAbsolutePath());\n        }\n        if (format != null) {\n            builder.addArg(\"--format\", format);\n        }\n        if (encoding != null) {\n            builder.addArg(\"--encoding\", encoding);\n        }\n        if (srcDir != null) {\n            builder.addArg(srcDir);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    getJava().createArg().setValue(\"--commandsfile\");\n    getJava().createArg().setValue(builder.getCommandLineFile());\n    AntUtil.transferCoberturaDataFileProperty(getJava());\n    if (getJava().executeJava() != 0) {\n        throw new BuildException(\"Error running reports. See messages above.\");\n    }\n    builder.dispose();\n}", "methodAfter": "public void execute() throws BuildException {\n    CommandLineBuilder builder = null;\n    try {\n        builder = new CommandLineBuilder();\n        if (dataFile != null) {\n            builder.addArg(\"--datafile\", dataFile);\n        }\n        if (destDir != null) {\n            builder.addArg(\"--destination\", destDir.getAbsolutePath());\n        }\n        if (format != null) {\n            builder.addArg(\"--format\", format);\n        }\n        if (encoding != null) {\n            builder.addArg(\"--encoding\", encoding);\n        }\n        if (srcDir != null) {\n            builder.addArg(srcDir);\n        }\n        createArgumentsForFilesets(builder);\n        builder.saveArgs();\n    } catch (IOException ioe) {\n        getProject().log(\"Error creating commands file.\", MSG_ERR);\n        throw new BuildException(\"Unable to create the commands file.\", ioe);\n    }\n    createCommandsFileAndExecute(builder);\n}"}], [{"methodBefore": "public static void main(String[] args) {\n    Header.print(System.out);\n    System.out.println(\"Cobertura instrumentation merge tool\");\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufreader = null;\n        try {\n            bufreader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufreader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufreader != null) {\n                try {\n                    bufreader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    new Main(args);\n}", "methodAfter": "public static void main(String[] args) {\n    Header.print(System.out);\n    System.out.println(\"Cobertura instrumentation merge tool\");\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufreader = null;\n        try {\n            bufreader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufreader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufreader != null) {\n                try {\n                    bufreader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    new Main(args);\n}"}, {"methodBefore": "public static void main(String[] args) {\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufferedReader = null;\n        try {\n            bufferedReader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufferedReader != null) {\n                try {\n                    bufferedReader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Instrument time: \" + (stopTime - startTime)) + \"ms\");\n}", "methodAfter": "public static void main(String[] args) {\n    long startTime = System.currentTimeMillis();\n    Main main = new Main();\n    boolean hasCommandsFile = false;\n    String commandsFileName = null;\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"--commandsfile\")) {\n            hasCommandsFile = true;\n            commandsFileName = args[++i];\n        }\n    }\n    if (hasCommandsFile) {\n        List arglist = new ArrayList();\n        BufferedReader bufferedReader = null;\n        try {\n            bufferedReader = new BufferedReader(new FileReader(commandsFileName));\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                arglist.add(line);\n            } \n        } catch (IOException e) {\n            logger.fatal((\"Unable to read temporary commands file \" + commandsFileName) + \".\");\n            logger.info(e);\n        } finally {\n            if (bufferedReader != null) {\n                try {\n                    bufferedReader.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        args = ((String[]) (arglist.toArray(new String[arglist.size()])));\n    }\n    main.parseArguments(args);\n    long stopTime = System.currentTimeMillis();\n    System.out.println((\"Instrument time: \" + (stopTime - startTime)) + \"ms\");\n}"}], [{"methodBefore": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        LOGGER.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classPackageName + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowsForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(generateHtmlizedJavaSource(sourceFileData));\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFile(SourceFileData sourceFileData) throws IOException {\n    if (!sourceFileData.containsInstrumentationInfo()) {\n        LOGGER.info((((\"Data file does not contain instrumentation \" + \"information for the file \") + sourceFileData.getName()) + \".  Ensure this class was instrumented, and this \") + \"data file contains the instrumentation information.\");\n    }\n    String filename = sourceFileData.getNormalizedName() + \".html\";\n    File file = new File(destinationDir, filename);\n    PrintWriter out = null;\n    try {\n        out = IOUtil.getPrintWriter(file);\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        String classPackageName = sourceFileData.getPackageName();\n        if ((classPackageName != null) && (classPackageName.length() > 0)) {\n            out.print(classPackageName + \".\");\n        }\n        out.print(sourceFileData.getBaseName());\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\">\");\n        out.println(generateTableHeader(\"Classes in this File\", false));\n        out.println(generateTableRowsForSourceFile(sourceFileData));\n        out.println(\"</table>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(generateHtmlizedJavaSource(sourceFileData));\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateSourceFileList(PackageData packageData) throws IOException {\n    String filename;\n    Collection sourceFiles;\n    if (packageData == null) {\n        filename = \"frame-sourcefiles.html\";\n        sourceFiles = projectData.getSourceFiles();\n    } else {\n        filename = (\"frame-sourcefiles-\" + packageData.getName()) + \".html\";\n        sourceFiles = packageData.getSourceFiles();\n    }\n    Vector sortedSourceFiles = new Vector();\n    sortedSourceFiles.addAll(sourceFiles);\n    Collections.sort(sortedSourceFiles, new SourceFileDataBaseNameComparator());\n    File file = new File(destinationDir, filename);\n    PrintWriter out = null;\n    try {\n        out = IOUtil.getPrintWriter(file);\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report Classes</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.println(\"<h5>\");\n        out.println(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<h5>Classes</h5>\");\n        if (!sortedSourceFiles.isEmpty()) {\n            out.println(\"<table width=\\\"100%\\\">\");\n            out.println(\"<tbody>\");\n            for (Iterator iter = sortedSourceFiles.iterator(); iter.hasNext();) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(\"<tr>\");\n                String percentCovered;\n                if (sourceFileData.getNumberOfValidLines() > 0) {\n                    percentCovered = getPercentValue(sourceFileData.getLineCoverageRate());\n                } else {\n                    percentCovered = \"N/A\";\n                }\n                out.println((((((\"<td nowrap=\\\"nowrap\\\"><a target=\\\"summary\\\" href=\\\"\" + sourceFileData.getNormalizedName()) + \".html\\\">\") + sourceFileData.getBaseName()) + \"</a> <i>(\") + percentCovered) + \")</i></td>\");\n                out.println(\"</tr>\");\n            }\n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}, {"methodBefore": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintStream out = null;\n    try {\n        out = new PrintStream(new FileOutputStream(file), false, \"UTF-8\");\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}", "methodAfter": "private void generateOverview(PackageData packageData) throws IOException {\n    Iterator iter;\n    String filename;\n    if (packageData == null) {\n        filename = \"frame-summary.html\";\n    } else {\n        filename = (\"frame-summary-\" + packageData.getName()) + \".html\";\n    }\n    File file = new File(destinationDir, filename);\n    PrintWriter out = null;\n    try {\n        out = IOUtil.getPrintWriter(file);\n        out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\");\n        out.println(\"           \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\");\n        out.println(\"<html>\");\n        out.println(\"<head>\");\n        out.println(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"/>\");\n        out.println(\"<title>Coverage Report</title>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/main.css\\\"/>\");\n        out.println(\"<link title=\\\"Style\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" href=\\\"css/sortabletable.css\\\"/>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/popup.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/sortabletable.js\\\"></script>\");\n        out.println(\"<script type=\\\"text/javascript\\\" src=\\\"js/customsorttypes.js\\\"></script>\");\n        out.println(\"</head>\");\n        out.println(\"<body>\");\n        out.print(\"<h5>Coverage Report - \");\n        out.print(packageData == null ? \"All Packages\" : generatePackageName(packageData));\n        out.println(\"</h5>\");\n        out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n        out.println(\"<table class=\\\"report\\\" id=\\\"packageResults\\\">\");\n        out.println(generateTableHeader(\"Package\", true));\n        out.println(\"<tbody>\");\n        SortedSet packages;\n        if (packageData == null) {\n            out.println(generateTableRowForTotal());\n            packages = projectData.getPackages();\n        } else {\n            packages = projectData.getSubPackages(packageData.getName());\n        }\n        iter = packages.iterator();\n        while (iter.hasNext()) {\n            PackageData subPackageData = ((PackageData) (iter.next()));\n            out.println(generateTableRowForPackage(subPackageData));\n        } \n        out.println(\"</tbody>\");\n        out.println(\"</table>\");\n        out.println(\"<script type=\\\"text/javascript\\\">\");\n        out.println(\"var packageTable = new SortableTable(document.getElementById(\\\"packageResults\\\"),\");\n        out.println(\"    [\\\"String\\\", \\\"Number\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n        out.println(\"packageTable.sort(0);\");\n        out.println(\"</script>\");\n        Collection sourceFiles;\n        if (packageData == null) {\n            PackageData defaultPackage = ((PackageData) (projectData.getChild(\"\")));\n            if (defaultPackage != null) {\n                sourceFiles = defaultPackage.getSourceFiles();\n            } else {\n                sourceFiles = new TreeSet();\n            }\n        } else {\n            sourceFiles = packageData.getSourceFiles();\n        }\n        if (sourceFiles.size() > 0) {\n            out.println(\"<div class=\\\"separator\\\">&nbsp;</div>\");\n            out.println(\"<table class=\\\"report\\\" id=\\\"classResults\\\">\");\n            out.println(generateTableHeader(\"Classes in this Package\", false));\n            out.println(\"<tbody>\");\n            iter = sourceFiles.iterator();\n            while (iter.hasNext()) {\n                SourceFileData sourceFileData = ((SourceFileData) (iter.next()));\n                out.println(generateTableRowsForSourceFile(sourceFileData));\n            } \n            out.println(\"</tbody>\");\n            out.println(\"</table>\");\n            out.println(\"<script type=\\\"text/javascript\\\">\");\n            out.println(\"var classTable = new SortableTable(document.getElementById(\\\"classResults\\\"),\");\n            out.println(\"    [\\\"String\\\", \\\"Percentage\\\", \\\"Percentage\\\", \\\"FormattedNumber\\\"]);\");\n            out.println(\"classTable.sort(0);\");\n            out.println(\"</script>\");\n        }\n        out.println(generateFooter());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n}"}], [{"methodBefore": "private boolean jj_3R_169() {\n    if (jj_3R_103()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_116() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_169() {\n    if (jj_3R_103()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_116() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_166() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_168() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_166() {\n    if (jj_3R_141()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_168() {\n    if (jj_3R_144()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "public final void PrimaryPrefix() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case FALSE :\n        case NULL :\n        case TRUE :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n            Literal();\n            break;\n        case THIS :\n            jj_consume_token(THIS);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case DOT :\n                    jj_consume_token(DOT);\n                    break;\n                default :\n                    jj_la1[119] = jj_gen;\n            }\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSERT :\n                case IDENTIFIER :\n                    Identifier();\n                    break;\n                default :\n                    jj_la1[120] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[123] = jj_gen;\n            if (jj_2_34(2)) {\n                jj_consume_token(SUPER);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case DOT :\n                        jj_consume_token(DOT);\n                        break;\n                    default :\n                        jj_la1[121] = jj_gen;\n                }\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case IDENTIFIER :\n                        Identifier();\n                        break;\n                    default :\n                        jj_la1[122] = jj_gen;\n                }\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LPAREN :\n                        jj_consume_token(LPAREN);\n                        Expression();\n                        jj_consume_token(RPAREN);\n                        break;\n                    case NEW :\n                        AllocationExpression();\n                        break;\n                    default :\n                        jj_la1[124] = jj_gen;\n                        if (jj_2_35(2147483647)) {\n                            ResultType();\n                            jj_consume_token(DOT);\n                            jj_consume_token(CLASS);\n                        } else {\n                            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                                case ASSERT :\n                                case ENUM :\n                                case IDENTIFIER :\n                                    Name();\n                                    if (jj_2_33(3)) {\n                                        jj_consume_token(DOT);\n                                        jj_consume_token(SUPER);\n                                        jj_consume_token(DOT);\n                                        Identifier();\n                                    } else {\n                                    }\n                                    break;\n                                default :\n                                    jj_la1[125] = jj_gen;\n                                    jj_consume_token(-1);\n                                    throw new ParseException();\n                            }\n                        }\n                }\n            }\n    }\n}", "methodAfter": "public final void PrimaryPrefix() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case FALSE :\n        case NULL :\n        case TRUE :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n            Literal();\n            break;\n        case THIS :\n            jj_consume_token(THIS);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case DOT :\n                    jj_consume_token(DOT);\n                    break;\n                default :\n                    jj_la1[119] = jj_gen;\n            }\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case NEW :\n                    jj_consume_token(NEW);\n                    break;\n                default :\n                    jj_la1[120] = jj_gen;\n            }\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSERT :\n                case IDENTIFIER :\n                    Identifier();\n                    break;\n                default :\n                    jj_la1[121] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[124] = jj_gen;\n            if (jj_2_33(2)) {\n                jj_consume_token(SUPER);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case DOT :\n                        jj_consume_token(DOT);\n                        break;\n                    default :\n                        jj_la1[122] = jj_gen;\n                }\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case IDENTIFIER :\n                        Identifier();\n                        break;\n                    default :\n                        jj_la1[123] = jj_gen;\n                }\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LPAREN :\n                        jj_consume_token(LPAREN);\n                        Expression();\n                        jj_consume_token(RPAREN);\n                        break;\n                    case NEW :\n                        AllocationExpression();\n                        break;\n                    default :\n                        jj_la1[125] = jj_gen;\n                        if (jj_2_34(2147483647)) {\n                            ResultType();\n                            jj_consume_token(DOT);\n                            jj_consume_token(CLASS);\n                        } else {\n                            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                                case ASSERT :\n                                case ENUM :\n                                case IDENTIFIER :\n                                    Name();\n                                    if (jj_2_32(3)) {\n                                        jj_consume_token(DOT);\n                                        jj_consume_token(SUPER);\n                                        jj_consume_token(DOT);\n                                        Identifier();\n                                    } else {\n                                    }\n                                    break;\n                                default :\n                                    jj_la1[126] = jj_gen;\n                                    jj_consume_token(-1);\n                                    throw new ParseException();\n                            }\n                        }\n                }\n            }\n    }\n}"}, {"methodBefore": "public final void PrimaryPrefix() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case FALSE :\n        case NULL :\n        case TRUE :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n            Literal();\n            break;\n        case THIS :\n            jj_consume_token(THIS);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case DOT :\n                    jj_consume_token(DOT);\n                    break;\n                default :\n                    jj_la1[119] = jj_gen;\n            }\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSERT :\n                case IDENTIFIER :\n                    Identifier();\n                    break;\n                default :\n                    jj_la1[120] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[123] = jj_gen;\n            if (jj_2_34(2)) {\n                jj_consume_token(SUPER);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case DOT :\n                        jj_consume_token(DOT);\n                        break;\n                    default :\n                        jj_la1[121] = jj_gen;\n                }\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case IDENTIFIER :\n                        Identifier();\n                        break;\n                    default :\n                        jj_la1[122] = jj_gen;\n                }\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LPAREN :\n                        jj_consume_token(LPAREN);\n                        Expression();\n                        jj_consume_token(RPAREN);\n                        break;\n                    case NEW :\n                        AllocationExpression();\n                        break;\n                    default :\n                        jj_la1[124] = jj_gen;\n                        if (jj_2_35(2147483647)) {\n                            ResultType();\n                            jj_consume_token(DOT);\n                            jj_consume_token(CLASS);\n                        } else {\n                            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                                case ASSERT :\n                                case ENUM :\n                                case IDENTIFIER :\n                                    Name();\n                                    if (jj_2_33(3)) {\n                                        jj_consume_token(DOT);\n                                        jj_consume_token(SUPER);\n                                        jj_consume_token(DOT);\n                                        Identifier();\n                                    } else {\n                                    }\n                                    break;\n                                default :\n                                    jj_la1[125] = jj_gen;\n                                    jj_consume_token(-1);\n                                    throw new ParseException();\n                            }\n                        }\n                }\n            }\n    }\n}", "methodAfter": "public final void PrimaryPrefix() throws ParseException {\n    switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n        case FALSE :\n        case NULL :\n        case TRUE :\n        case INTEGER_LITERAL :\n        case FLOATING_POINT_LITERAL :\n        case CHARACTER_LITERAL :\n        case STRING_LITERAL :\n            Literal();\n            break;\n        case THIS :\n            jj_consume_token(THIS);\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case DOT :\n                    jj_consume_token(DOT);\n                    break;\n                default :\n                    jj_la1[119] = jj_gen;\n            }\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case NEW :\n                    jj_consume_token(NEW);\n                    break;\n                default :\n                    jj_la1[120] = jj_gen;\n            }\n            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                case ASSERT :\n                case IDENTIFIER :\n                    Identifier();\n                    break;\n                default :\n                    jj_la1[121] = jj_gen;\n            }\n            break;\n        default :\n            jj_la1[124] = jj_gen;\n            if (jj_2_33(2)) {\n                jj_consume_token(SUPER);\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case DOT :\n                        jj_consume_token(DOT);\n                        break;\n                    default :\n                        jj_la1[122] = jj_gen;\n                }\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT :\n                    case IDENTIFIER :\n                        Identifier();\n                        break;\n                    default :\n                        jj_la1[123] = jj_gen;\n                }\n            } else {\n                switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                    case LPAREN :\n                        jj_consume_token(LPAREN);\n                        Expression();\n                        jj_consume_token(RPAREN);\n                        break;\n                    case NEW :\n                        AllocationExpression();\n                        break;\n                    default :\n                        jj_la1[125] = jj_gen;\n                        if (jj_2_34(2147483647)) {\n                            ResultType();\n                            jj_consume_token(DOT);\n                            jj_consume_token(CLASS);\n                        } else {\n                            switch (jj_ntk == (-1) ? jj_ntk() : jj_ntk) {\n                                case ASSERT :\n                                case ENUM :\n                                case IDENTIFIER :\n                                    Name();\n                                    if (jj_2_32(3)) {\n                                        jj_consume_token(DOT);\n                                        jj_consume_token(SUPER);\n                                        jj_consume_token(DOT);\n                                        Identifier();\n                                    } else {\n                                    }\n                                    break;\n                                default :\n                                    jj_la1[126] = jj_gen;\n                                    jj_consume_token(-1);\n                                    throw new ParseException();\n                            }\n                        }\n                }\n            }\n    }\n}"}], [{"methodBefore": "private boolean jj_3_60() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_59() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3_60() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_140()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3_59() {\n    if (jj_scan_token(COMMA)) {\n        return true;\n    }\n    if (jj_3R_143()) {\n        return true;\n    }\n    return false;\n}"}], [{"methodBefore": "private boolean jj_3R_190() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_3R_106()) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_190() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}, {"methodBefore": "private boolean jj_3R_190() {\n    if (jj_3R_102()) {\n        return true;\n    }\n    if (jj_3R_106()) {\n        return true;\n    }\n    if (jj_3R_117()) {\n        return true;\n    }\n    return false;\n}", "methodAfter": "private boolean jj_3R_190() {\n    if (jj_3R_109()) {\n        return true;\n    }\n    return false;\n}"}]]